<?xml version="1.0" encoding="UTF-8"?>
<!-- Current changes labelled at="F" (2010-06-19) -->
<fos:functions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://www.w3.org/xpath-functions/spec/namespace fos.xsd"
 xmlns:fos="http://www.w3.org/xpath-functions/spec/namespace">
   <fos:global-variables>
      <fos:variable name="po" as="element()">&lt;PurchaseOrder&gt;
  &lt;line-item&gt;
    &lt;description&gt;Large widget&lt;/description&gt;
    &lt;price&gt;8.95&lt;/price&gt;
    &lt;quantity&gt;5.0&lt;/quantity&gt;
  &lt;/line-item&gt;
  &lt;line-item&gt;
    &lt;description&gt;Small widget&lt;/description&gt;
    &lt;price&gt;3.99&lt;/price&gt;
    &lt;quantity&gt;2.0&lt;/quantity&gt;
  &lt;/line-item&gt;
  &lt;line-item&gt;
    &lt;description&gt;Tiny widget&lt;/description&gt;
    &lt;price&gt;1.49&lt;/price&gt;
    &lt;quantity&gt;805&lt;/quantity&gt;
  &lt;/line-item&gt;
&lt;/PurchaseOrder&gt;</fos:variable>
      <fos:variable name="item1" select="$po/line-item[1]"/>
      <fos:variable name="item2" select="$po/line-item[2]"/>
      <fos:variable name="item3" select="$po/line-item[3]"/>
   </fos:global-variables>
   <fos:function name="node-name">
      <fos:signatures>
         <fos:proto  diff="add" at="F" name="node-name" return-type="xs:QName?"/>
         <fos:proto name="node-name" return-type="xs:QName?">
            <fos:arg name="arg" type="node()?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the name of a node, as an <code>xs:QName</code>.</p>
      </fos:summary>
      <fos:rules>
         <p diff="add" at="F">If the argument is omitted, it defaults to the context item (<code>.</code>).
            The behavior of the function if the argument is omitted is exactly the same as if the context 
            item had been passed as the argument.</p>
         <p>If <code>$arg</code> is the empty sequence, the empty sequence is returned.</p>
         <p>Otherwise, the function returns the result of the <code>dm:node-name</code> accessor
			as defined in <bibref ref="xpath-datamodel-11"/> (see <xspecref spec="DM" ref="dm-node-name"/>).</p>
      </fos:rules>
      <fos:notes>
         <p>For element and attribute nodes, the name of the node is returned as an <code>xs:QName</code>,
			retaining the prefix, namespace URI, and local part.</p>
         <p>For processing instructions, the name of the node is returned as an <code>xs:QName</code>
			in which the prefix and namespace URI are absent.</p>
         <p>For a namespace node, the function returns an empty sequence if the node represents the default
			namespace; otherwise it returns an <code>xs:QName</code>
			in which prefix and namespace URI are absent and the local part is the the namespace prefix being bound).</p>
         <p>For all other kinds of node, the function returns the empty sequence.</p>
      </fos:notes>
   </fos:function>
   <fos:function name="nilled">
      <fos:signatures>
         <fos:proto name="nilled" return-type="xs:boolean?">
            <fos:arg name="arg" type="node()?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns true for an element that is <term>nilled</term>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise the function returns the result of the <code>dm:nilled</code> accessor
			as defined in <bibref ref="xpath-datamodel-11"/> (see <xspecref spec="DM" ref="dm-nilled"/>).</p>
      </fos:rules>
      <fos:notes>
         <p>If <code>$arg</code> is not an element node, the function returns the empty sequence.</p>
         <p>If <code>$arg</code> is an untyped element node, the function returns false.</p>
         <p>In practice, the function returns <code>true</code> only for an element node that has the attribute <code>xsi:nil="true"</code>
            and that is successfully validated against a schema that defines the element to be nillable; the detailed rules, however,
			are defined in <bibref ref="xpath-datamodel-11"/>.</p>
      </fos:notes>
   </fos:function>
   <fos:function name="string">
      <fos:signatures>
         <fos:proto name="string" return-type="xs:string"/>
         <fos:proto name="string" return-type="xs:string">
            <fos:arg name="arg" type="item()?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the value of <code>$arg</code> represented as an <code>xs:string</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>In the zero-argument version of the function, <code>$arg</code> defaults to the context item. That is, calling
			<code>fn:string()</code> is equivalent to calling <code>fn:string(.)</code>.</p>
         <p>If <code>$arg</code> is the empty sequence, the function returns the zero-length string.</p>
         <p>If <code>$arg</code> is a node, the function returns the string-value of the
                    node, as obtained using the <code>dm:string-value</code> accessor defined in <bibref ref="xpath-datamodel-11"/> 
					(see <xspecref spec="DM" ref="dm-string-value"/>).</p>
         <p>If <code>$arg</code> is an atomic value, the function returns the result of the expression 
                    <code>$arg cast as xs:string</code> (see <specref ref="casting"/>).</p>
      </fos:rules>
      <fos:errors>
         <p>In the zero-argument version of the function,  
            if the context item is undefined, error <xerrorref spec="XP" class="DY" code="0002" type="dynamic"/> is raised.
         </p>
         <p>If <code>$arg</code> is a function item, error 
            <errorref class="TY" code="0014" type="dynamic"/> is raised.
         </p>
      </fos:errors>
   </fos:function>
   <fos:function name="data">
      <fos:signatures>
         <fos:proto diff="add" at="F" name="data" return-type="xs:anyAtomicType*"/>
         <fos:proto name="data" return-type="xs:anyAtomicType*">
            <fos:arg name="arg" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the result of atomizing a sequence, that is, replacing all nodes in the sequence
			by their typed values.</p>
      </fos:summary>
      <fos:rules>
         <p diff="add" at="F">If the argument is omitted, it defaults to the context item (<code>.</code>).
            The behavior of the function if the argument is omitted is exactly the same as if the context 
            item had been passed as the argument.</p>
         <p> The result of <code>fn:data</code> is the sequence of atomic values produced by
                    applying the following rules to each item in <code>$arg</code>:</p>
         <ulist>
            <item>
               <p>If the item is an atomic value, it is appended to the result sequence.</p>
            </item>
            <item>
               <p> If the item is a node, the typed value of the node is appended to the result sequence. 
		The typed value is a sequence of zero or more atomic values: specifically,
		the result of the <code>dm:typed-value</code> accessor as defined in <bibref ref="xpath-datamodel-11"/>
		(See <xspecref spec="DM" ref="dm-typed-value"/>).</p>
            </item>
         </ulist>
      </fos:rules>
      <fos:errors>
         <p>If an item in the sequence <code>$arg</code> is a node that does not have a typed value then an error is
            raised  <errorref class="TY" code="0012" type="dynamic"/>. </p>
         <p diff="add" at="B">If an item in the sequence <code>$arg</code> is a function item then an error is
            raised  <errorref class="TY" code="0013" type="dynamic"/>. </p>
      </fos:errors>
      <fos:notes>
         <p>The process of applying the <code>fn:data</code> function to a sequence is referred to as <code>atomization</code>.
				In many cases an explicit call on <code>fn:data</code> is not required, because atomization is invoked implicitly
				when a node or sequence of nodes is supplied in a context where an atomic value or sequence of atomic values is required.</p>
      </fos:notes>
   </fos:function>
   <fos:function name="base-uri">
      <fos:signatures>
         <fos:proto name="base-uri" return-type="xs:anyURI?"/>
         <fos:proto name="base-uri" return-type="xs:anyURI?">
            <fos:arg name="arg" type="node()?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the base URI of a node.</p>
      </fos:summary>
      <fos:rules>
         <!-- see bug 6340 -->
         <p diff="new" at="B">The zero-argument version of the function returns the base URI of the context
            node: it is equivalent to calling <code>fn:base-uri(.)</code>. This may result in an error
            being raised: if the context item is undefined <xerrorref spec="XP" class="DY" code="0002" type="type"/>;
            if the context item is not a node <xerrorref spec="XP" class="TY" code="0004" type="type"/>.            
         </p>
         <p diff="new" at="B">The single-argument version of the function behaves as follows:</p>
            <olist>
            <item>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</item>
            
            <item>Otherwise, the function returns the value of the <code>dm:base-uri</code> accessor
            applied to the node <code>$arg</code>. This accessor is defined, for each kind of node, in
               the XDM specification (See <xspecref spec="DM" ref="dm-base-uri"/>).</item>
            </olist>
            <note>As explained in XDM, document, element and processing-instruction nodes
               have a base-uri property which may be empty. The base-uri property for all
               other node kinds is the empty sequence. The dm:base-uri accessor returns the
               base-uri property of a node if it exists and is non-empty; otherwise it returns
               the result of applying the dm:base-uri accessor to its parent, recursively. If
               the node does not have a parent, or if the recursive ascent up the ancestor
               chain encounters a parentless node whose base-uri property is empty, the empty
               sequence is returned. In the case of namespace nodes, however, the result is
               always an empty sequence -- it does not depend on the base URI of the parent
               element.</note>
         
         
         <p>See also <code>fn:static-base-uri</code>.</p>
      </fos:rules>
      <fos:errors>
         <p>If <code>$arg</code> is not specified, the following errors may be raised:  if the context item is undefined <xerrorref spec="XP" class="DY" code="0002" type="type"/>; if the context item is not a node 
            <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>
      </fos:errors>
   </fos:function>
   <fos:function name="document-uri">
      <fos:signatures>
         <fos:proto diff="add" at="F" name="document-uri" return-type="xs:anyURI?"/>
         <fos:proto name="document-uri" return-type="xs:anyURI?">
            <fos:arg name="arg" type="node()?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the URI of a resource where a document can be found, if available.</p>
      </fos:summary>
      <fos:rules>
         <p diff="add" at="F">If the argument is omitted, it defaults to the context item (<code>.</code>).
            The behavior of the function if the argument is omitted is exactly the same as if the context 
            item had been passed as the argument.</p>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>If <code>$arg</code> is not a document node, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns the value of the <code>document-uri</code> accessor applied to <code>$arg</code>, as
                    defined in <bibref ref="xpath-datamodel-11"/> (See <xspecref spec="DM" ref="DocumentNodeAccessors"/>).</p>
      </fos:rules>
      <fos:notes>
         <p>In the case of a document node <code>$D</code> returned by the <code>fn:doc</code> function, 
				or a document node at the root of a tree containing a node returned by the <code>fn:collection</code> function, 
				it will always be true that either <code>fn:document-uri($D)</code> returns the empty sequence, 
				or that the following expression is true: <code>fn:doc(fn:document-uri($D))</code> is <code>$D</code>. 
				It is implementation-defined whether this guarantee also holds for document nodes obtained by other means, 
				for example a document node passed as the initial context node of a query or transformation.</p>
      </fos:notes>
   </fos:function>
   <fos:function name="error">
      <fos:signatures>
         <fos:proto name="error" return-type="none"/>
         <fos:proto name="error" return-type="none">
            <fos:arg name="code" type="xs:QName"/>
         </fos:proto>
         <fos:proto name="error" return-type="none">
            <fos:arg name="code" type="xs:QName?"/>
            <fos:arg name="description" type="xs:string"/>
         </fos:proto>
         <fos:proto name="error" return-type="none">
            <fos:arg name="code" type="xs:QName?"/>
            <fos:arg name="description" type="xs:string"/>
            <fos:arg name="error-object" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Calling the <code>fn:error</code> function raises an application-defined error.</p>
      </fos:summary>
      <fos:rules>
         <p>This function never returns a value. Instead it always raises an error. The effect of the error
		 is identical to the effect of dynamic errors raised implicitly, for example when an incorrect argument
		 is supplied to a function.</p>
         <p>The parameters to the <code>fn:error</code> function supply information that is associated with the
		 error condition and that is made available to a caller that asks for information about the error. The error may be
		 caught either by the host language (using a try/catch construct in XSLT or XQuery, for example), or
		 by the calling application or external processing environment. The way in which error information is
         returned to the external processing environment is <termref def="implementation-dependent"/></p>
         <p>If <code>fn:error</code> is called with no arguments, then its behavior is the same
                as the function call: </p>
         <eg xml:space="preserve"> fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000')) </eg>
         <p>If <code>$code</code> is the empty sequence then the effective value is
                the <code>xs:QName</code> constructed by:</p>
         <eg xml:space="preserve"> fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000')</eg>
         <p>There are three pieces of information that may be associated with an error:</p>
         <ulist>
            <item>
               <p>The <code>$code</code> is an error code that distinguishes this error from others. It is an <code>xs:QName</code>;
		 the namespace URI conventionally identifies the component, subsystem, or authority responsible for defining the meaning of the
		 error code, while the local part identifies the specific error condition. The namespace URI 
		 <code>http://www.w3.org/2005/xqt-errors</code> is used for errors defined in this specification; other namespace URIs may
		 be used for errors defined by the application.</p>
               <p>If the external processing environment expects the error code to be returned as a URI or a string rather than as an
		 <code>xs:QName</code>, then an error code with namespace URI <code>NS</code> and local part <code>LP</code> 
		 will be returned in the form <code>NS#LP</code>. The namespace URI part of the error code should therefore not include
		 a fragment identifier.</p>
            </item>
            <item>
               <p>The <code>$description</code> is a natural-language description of the error condition.</p>
            </item>
            <item>
               <p>The <code>$error-object</code> is an arbitrary value used to convey additional information about the error,
		 and may be used in any way the application chooses.</p>
            </item>
         </ulist>
      </fos:rules>
      <fos:errors>
         <p>This function always raises an error.</p>
      </fos:errors>
      <fos:notes>
         <p>The value of the <code>$description</code> parameter may need to be localized.</p>
         <p>The type <quote>none</quote> is a special type defined in <bibref ref="xquery-semantics"/> and is not available to the user. It indicates that the
                function never returns and ensures that it has the correct static type.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <p>
                            <code>fn:error()</code> returns
                            <code>http://www.w3.org/2005/xqt-errors#FOER0000</code> (or the corresponding <code>xs:QName</code>) to the
                            external processing environment, unless the error is caught using a try/catch construct in the host language.</p>
         </fos:example>
         <fos:example>
            <p>
                            <code>fn:error(fn:QName('http://www.example.com/HR', 'myerr:toohighsal'),
                                'Does not apply because salary is too high')</code> returns
                            <code>http://www.example.com/HR#toohighsal</code> and the <code>xs:string</code>
                            <code>"Does not apply because salary is too high"</code> (or the corresponding <code>xs:QName</code>) to the external
                            processing environment, unless the error is caught using a try/catch construct in the host language.</p>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="trace">
      <fos:signatures>
         <fos:proto name="trace" return-type="item()*">
            <fos:arg name="value" type="item()*"/>
            <fos:arg name="label" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary:  Provides an execution trace intended to be used in debugging 
            queries.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the value of <code>$value</code>, unchanged.</p>
         <p>In addition, the values of <code>$value</code>, converted to an <code>xs:string</code>,
                and <code>$label</code> <rfc2119>may</rfc2119> be directed to a trace data set. The destination of the
                trace output is <termref def="implementation-defined"/>. The format of the trace
                output is <termref def="implementation-dependent"/>. The ordering of output from
                calls of the <code>fn:trace</code> function is <termref def="implementation-dependent"/>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <p>Consider a situation in which a user wants to investigate the actual
                            value passed to a function. Assume that in a particular execution,
                            <code>$v</code> is an <code>xs:decimal</code> with value
                            <code>124.84</code>. Writing <code>fn:trace($v, 'the value of $v
                            is:')</code> will put the strings <code>"124.84"</code> and <code>"the
                                value of $v is:"</code> in the trace data set in implementation
                            dependent order.</p>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="numeric-add">
      <fos:signatures>
         <fos:proto name="numeric-add" return-type="numeric">
            <fos:arg name="arg1" type="numeric"/>
            <fos:arg name="arg2" type="numeric"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="+" types="numeric">Defines the semantics of the "+" operator applied to numeric values</fos:opermap>
      <fos:summary>
         <p>Summary: Returns the arithmetic sum of its
                        operands: (<code>$arg1 + $arg2</code>).</p>
      </fos:summary>
      <fos:rules>
         <p>General rules: see <specref ref="op.numeric"/>.</p>
      </fos:rules>
      <fos:notes>
         <p> For <code>xs:float</code> or <code>xs:double</code> values, if one of
                            the operands is a zero or a finite number and the other
                            is <code>INF</code> or <code>-INF</code>, <code>INF</code> or
                            <code>-INF</code> is returned. If both operands are <code>INF</code>,
                            <code>INF</code> is returned. If both operands are <code>-INF</code>,
                            <code>-INF</code> is returned. If one of the operands is
                            <code>INF</code> and the other is <code>-INF</code>, <code>NaN</code> is returned.</p>
      </fos:notes>
   </fos:function>
   <fos:function name="numeric-subtract">
      <fos:signatures>
         <fos:proto name="numeric-subtract" return-type="numeric">
            <fos:arg name="arg1" type="numeric"/>
            <fos:arg name="arg2" type="numeric"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="-" types="numeric">Defines the semantics of the "-" operator applied to numeric values. </fos:opermap>
      <fos:summary>
         <p>Summary: Returns the arithmetic difference of
                        its operands: (<code>$arg1 - $arg2</code>).</p>
      </fos:summary>
      <fos:rules>
         <p>General rules: see <specref ref="op.numeric"/>.</p>
      </fos:rules>
      <fos:notes>
         <p> For <code>xs:float</code> or <code>xs:double</code> values, if one of
                            the operands is a zero or a finite number and the other
                            is <code>INF</code> or <code>-INF</code>, an infinity of the appropriate
                            sign is returned. If both operands are <code>INF</code> or
                            <code>-INF</code>, <code>NaN</code> is returned. If one of the operands
                            is <code>INF</code> and the other is <code>-INF</code>, an infinity of
                            the appropriate sign is returned.</p>
      </fos:notes>
   </fos:function>
   <fos:function name="numeric-multiply">
      <fos:signatures>
         <fos:proto name="numeric-multiply" return-type="numeric">
            <fos:arg name="arg1" type="numeric"/>
            <fos:arg name="arg2" type="numeric"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="*" types="numeric">Defines the semantics of the "*" operator applied to numeric values.</fos:opermap>
      <fos:summary>
         <p>Summary:  Returns the arithmetic product of its
                        operands: (<code>$arg1 * $arg2</code>).</p>
      </fos:summary>
      <fos:rules>
         <p>General rules: see <specref ref="op.numeric"/>.</p>
      </fos:rules>
      <fos:notes>
         <p> For <code>xs:float</code> or <code>xs:double</code> values, if one of
                            the operands is a zero and the other is an infinity, <code>NaN</code> is
                            returned. If one of the operands is a non-zero number and the other
                            is an infinity, an infinity with the appropriate sign is returned.</p>
      </fos:notes>
   </fos:function>
   <fos:function name="numeric-divide">
      <fos:signatures>
         <fos:proto name="numeric-divide" return-type="numeric">
            <fos:arg name="arg1" type="numeric"/>
            <fos:arg name="arg2" type="numeric"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="div" types="numeric">Defines the semantics of the "div" operator applied to numeric values.</fos:opermap>
      <fos:summary>
         <p>Summary:  Returns the arithmetic quotient of
                        its operands: (<code>$arg1 div $arg2</code>).</p>
      </fos:summary>
      <fos:rules>
         <p>General rules: see <specref ref="op.numeric"/>.</p>
         <p>As a special case, if the types of both <code>$arg1</code> and
                        <code>$arg2</code> are <code>xs:integer</code>, then the return type is <code>xs:decimal</code>.</p>
         
      </fos:rules>
      <fos:errors>
         <p>For <code>xs:decimal</code> and <code>xs:integer</code> operands, if the
            divisor is (positive or negative) zero, an error is raised <errorref class="AR" code="0001"/>.</p>
      </fos:errors>
      <fos:notes>
         <p>For <code>xs:float</code> and <code>xs:double</code> operands, floating point
            division is performed as specified in <bibref ref="ieee754"/>. A positive
                number divided by positive zero returns <code>INF</code>. A negative number
                divided by positive zero returns <code>-INF</code>. Division by negative zero
                returns <code>-INF</code> and <code>INF</code>, respectively. Positive or negative zero
                divided by  positive or negative zero returns <code>NaN</code>.  Also, <code>INF</code> or <code>-INF</code> divided
                by <code>INF</code> or <code>-INF</code> returns <code>NaN</code>.</p>
      </fos:notes>
      
   </fos:function>
   <fos:function name="numeric-integer-divide">
      <fos:signatures>
         <fos:proto name="numeric-integer-divide" return-type="xs:integer">
            <fos:arg name="arg1" type="numeric"/>
            <fos:arg name="arg2" type="numeric"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="idiv" types="numeric">Defines the semantics of the "idiv" operator applied to numeric values.</fos:opermap>
      <fos:summary>
         <p diff="chg" at="A-E30">Summary: Performs an integer division.</p>
      </fos:summary>
      <fos:rules>
         <p>General rules: see <specref ref="op.numeric"/>.</p>
         
         <p>If $arg2 is INF or -INF, and $arg1 is not INF or -INF, then the result is zero.</p>
         
         <p diff="chg" at="A-E30">Otherwise, subject to limits of precision and overflow/underflow conditions,
         the result is the largest (furthest from zero) <code>xs:integer</code> value <code>$N</code> such that
         <code>fn:abs($N * $arg2) le fn:abs($arg1) and fn:compare($N * $arg2, 0) eq
         fn:compare($arg1, 0)</code>.</p>
         <note diff="chg" at="A-E30">
            <p>The second term in this condition ensures that the result has the correct sign.</p>
         </note>
         <p diff="chg" at="A-E30">The implementation may adopt a different algorithm provided that it is
         equivalent to this formulation in all cases where <termref def="implementation-dependent">implementation-dependent</termref> or
         <termref def="implementation-defined">implementation-defined</termref> behavior does not affect the outcome, for example, the
         implementation-defined precision of the result of <code>xs:decimal</code> division.</p>
      </fos:rules>
      <fos:errors>
         <p diff="chg" at="A-E30">If the divisor is (positive or negative) zero, then an error is raised 
		<errorref class="AR" code="0001"/>.</p>
         <p>If either operand is <code>NaN</code> or 
		if <code>$arg1</code> is <code>INF</code> or <code>-INF</code> then
                     an error is raised <errorref class="AR" code="0002"/>.</p>
      </fos:errors>
      <fos:notes>
         <p>Except in situations involving errors, loss of precision, or
         overflow/underflow, the result of <code>$a idiv $b</code> is the same as <code>($a div $b) cast
         as xs:integer</code>.</p>
         <p>The semantics of this function are different from integer division as
                            defined in programming languages such as Java and C++.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:numeric-integer-divide(10,3)</fos:expression>
               <fos:result>3</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:numeric-integer-divide(3,-2)</fos:expression>
               <fos:result>-1</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:numeric-integer-divide(-3,2)</fos:expression>
               <fos:result>-1</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:numeric-integer-divide(-3,-2)</fos:expression>
               <fos:result>1</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:numeric-integer-divide(9.0,3)</fos:expression>
               <fos:result>3</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:numeric-integer-divide(-3.5,3)</fos:expression>
               <fos:result>-1</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:numeric-integer-divide(3.0,4)</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:numeric-integer-divide(3.1E1,6)</fos:expression>
               <fos:result>5</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:numeric-integer-divide(3.1E1,7)</fos:expression>
               <fos:result>4</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="numeric-mod">
      <fos:signatures>
         <fos:proto name="numeric-mod" return-type="numeric">
            <fos:arg name="arg1" type="numeric"/>
            <fos:arg name="arg2" type="numeric"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="mod" types="numeric">Defines the semantics of the "mod" operator applied to numeric values.</fos:opermap>
      <fos:summary>
         <p>Summary:  Returns the
                        remainder resulting from dividing <code>$arg1</code>, the dividend, by
                        <code>$arg2</code>, the divisor. </p>
      </fos:summary>
      <fos:rules>
         <p>General rules: see <specref ref="op.numeric"/>.</p>
         <p>The operation <code>a mod b</code> for
                        operands that are <code>xs:integer</code> or <code>xs:decimal</code>, or
                        types derived from them, produces a result such that <code>(a idiv b)*b+(a
                            mod b)</code> is equal to <code>a</code> and the magnitude of the result
                        is always less than the magnitude of <code>b</code>. This identity holds
                        even in the special case that the dividend is the negative integer of
                        largest possible magnitude for its type and the divisor is -1 (the remainder
                        is 0). It follows from this rule that the sign of the result is the sign of
                        the dividend.</p>
         
         <p> For <code>xs:float</code> and <code>xs:double</code> operands the following
                        rules apply:</p>
         <ulist>
            <item>
               <p>If either operand is <code>NaN</code>, the result is <code>NaN</code>.</p>
            </item>
            <item>
               <p>If the dividend is positive or negative infinity, or the divisor is
                                positive or negative zero (0), or both, the result is <code>NaN</code>.</p>
            </item>
            <item>
               <p>If the dividend is finite and the divisor is an infinity, the result
                                equals the dividend.</p>
            </item>
            <item>
               <p>If the dividend is positive or negative zero and the divisor is
                                finite, the result is the same as the dividend.</p>
            </item>
            <item>
               <p>In the remaining cases, where neither positive or negative infinity,
                                nor positive or negative zero, nor <code>NaN</code> is involved, the
                                result obeys <code>(a idiv b)*b+(a mod b)</code> = <code>a</code>.

                                <!--float or double remainder r from a dividend n and a divisor d is defined by the mathematical relation r = n-(d * q) where q is an integer that is negative only if n/d is negative and positive only if n/d is positive, and whose magnitude is as large as possible without exceeding the magnitude of the true mathematical quotient of n and d.  -->
                                Division is truncating division, analogous to integer division,
                                    not <bibref ref="ieee754"/> rounding division i.e. additional
                                digits are truncated, not rounded to the required precision.</p>
            </item>
         </ulist>
      </fos:rules>
      <fos:errors>
         <p>For <code>xs:integer</code> and <code>xs:decimal</code> operands, if
            <code>$arg2</code> is zero, then an error is raised <errorref class="AR" code="0001"/>.</p>
      </fos:errors>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:numeric-mod(10,3)</fos:expression>
               <fos:result>1</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:numeric-mod(6,-2)</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:numeric-mod(4.5,1.2)</fos:expression>
               <fos:result>0.9</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:numeric-mod(1.23E2, 0.6E1)</fos:expression>
               <fos:result>3.0E0</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="numeric-unary-plus">
      <fos:signatures>
         <fos:proto name="numeric-unary-plus" return-type="numeric">
            <fos:arg name="arg" type="numeric"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="+" types="numeric">Defines the semantics of the unary "+" operator applied to numeric values.</fos:opermap>
      <fos:summary>
         <p diff="chg" at="A-E23">Summary: 
			    Returns its operand with the sign unchanged: (<code>+ $arg</code>).</p>
      </fos:summary>
      <fos:rules>
         <p>General rules: see <specref ref="op.numeric"/>.</p>
         <p diff="chg" at="A-E23">The returned value is equal to <code>$arg</code>, and is an instance of
		 <code>xs:integer</code>, <code>xs:decimal</code>, <code>xs:double</code>, or <code>xs:float</code>
		 depending on the type of <code>$arg</code>.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="numeric-unary-minus">
      <fos:signatures>
         <fos:proto name="numeric-unary-minus" return-type="numeric">
            <fos:arg name="arg" type="numeric"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="-" types="numeric">Defines the semantics of the unary "-" operator applied to numeric values.</fos:opermap>
      <fos:summary>
         <p diff="chg" at="A-E23">Summary: 
			   Returns its operand with the sign reversed: (<code>- $arg</code>).</p>
      </fos:summary>
      <fos:rules>
         <p>General rules: see <specref ref="op.numeric"/>.</p>
         <p diff="chg" at="A-E23">The returned value is an instance of
		 <code>xs:integer</code>, <code>xs:decimal</code>, <code>xs:double</code>, or <code>xs:float</code>
		 depending on the type of <code>$arg</code>.</p>
         <p>For <code>xs:integer</code> and <code>xs:decimal</code> arguments,
                        <code>0</code> and <code>0.0</code> return <code>0</code> and
                        <code>0.0</code>, respectively. For <code>xs:float</code> and
                        <code>xs:double</code> arguments, <code>NaN</code> returns <code>NaN</code>,
                        <code>0.0E0</code> returns <code>-0.0E0</code> and vice versa.
                        <code>INF</code> returns <code>-INF</code>. <code>-INF</code> returns <code>INF</code>.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="numeric-equal">
      <fos:signatures>
         <fos:proto name="numeric-equal" return-type="xs:boolean">
            <fos:arg name="arg1" type="numeric"/>
            <fos:arg name="arg2" type="numeric"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="eq" types="numeric" other-operators="ne le ge">Defines the semantics of the "eq" operator on numeric values, and is also used in defining
			   the semantics of "ne", "le" and "ge".</fos:opermap>
      <fos:summary>
         <p>Summary: 
			   Returns true if and only if the value of <code>$arg1</code> is equal
                        to the value of <code>$arg2</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>General rules: see <specref ref="op.numeric"/> and <specref ref="comp.numeric"/>.</p>
         <p> For <code>xs:float</code> and
                        <code>xs:double</code> values, positive zero and negative zero compare
                        equal. <code>INF</code> equals <code>INF</code>, and <code>-INF</code> equals
                        <code>-INF</code>. <code>NaN</code> does not equal itself.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="numeric-less-than">
      <fos:signatures>
         <fos:proto name="numeric-less-than" return-type="xs:boolean">
            <fos:arg name="arg1" type="numeric"/>
            <fos:arg name="arg2" type="numeric"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="lt" types="numeric" other-operators="le">Defines the semantics of the "lt" operator on numeric values, and is also used in defining
			   the semantics of "le".</fos:opermap>
      <fos:summary>
         <p>Summary: 
			   Returns <code>true</code> if and only if <code>$arg1</code> is numerically less
                        than <code>$arg2</code>. </p>
      </fos:summary>
      <fos:rules>
         <p>General rules: see <specref ref="op.numeric"/> and <specref ref="comp.numeric"/>.</p>
         <p>For <code>xs:float</code> and
                        <code>xs:double</code> values, positive infinity is greater than all other
                        non-<code>NaN</code> values; negative infinity is less than all other
                        non-<code>NaN</code> values. If <code>$arg1</code> or <code>$arg2</code> is
                        <code>NaN</code>, the function returns <code>false</code>.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="numeric-greater-than">
      <fos:signatures>
         <fos:proto name="numeric-greater-than" return-type="xs:boolean">
            <fos:arg name="arg1" type="numeric"/>
            <fos:arg name="arg2" type="numeric"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="gt" types="numeric" other-operators="ge">Defines the semantics of the "gt" operator on numeric values, and is also used in defining
			   the semantics of "ge".</fos:opermap>
      <fos:summary>
         <p>Summary: 
			   Returns <code>true</code> if and only if <code>$arg1</code> is
                        numerically greater than <code>$arg2</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>The function call <code>op:numeric-greater-than($A, $B)</code> is defined to return
			   the same result as <code>op:numeric-less-than($B, $A)</code></p>
      </fos:rules>
   </fos:function>
   <fos:function name="abs">
      <fos:signatures>
         <fos:proto name="abs" return-type="numeric?">
            <fos:arg name="arg" type="numeric?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the absolute value of <code>$arg</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>General rules: see <specref ref="numeric-value-functions"/>.</p>
         <p>If <code>$arg</code> is negative the function returns <code>-$arg</code>, otherwise it returns
                        <code>$arg</code>.</p>
         <p>If the type of <code>$arg</code> is one of the four numeric
                        types <code>xs:float</code>, <code>xs:double</code>, <code>xs:decimal</code>
                        or <code>xs:integer</code> the type of the result is the same as the type of
                        <code>$arg</code>. If the type of <code>$arg</code> is a type derived from
                        one of the numeric types, the result is an instance of the base numeric type.</p>
         <p>For <code>xs:float</code> and <code>xs:double</code> arguments, if the
                        argument is positive zero or negative zero, then positive zero
                        is returned. If the argument is positive or negative infinity, positive
                        infinity is returned.</p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:abs(10.5)</fos:expression>
               <fos:result>10.5</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:abs(-10.5)</fos:expression>
               <fos:result>10.5</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="ceiling">
      <fos:signatures>
         <fos:proto name="ceiling" return-type="numeric?">
            <fos:arg name="arg" type="numeric?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Rounds <code>$arg</code> upwards to a whole number.</p>
      </fos:summary>
      <fos:rules>
         <p>General rules: see <specref ref="numeric-value-functions"/>.</p>
         <p>The function returns the smallest (closest to negative infinity) number with no
                        fractional part that is not less than the value of <code>$arg</code>.</p>
         <p>If the type of <code>$arg</code> is one of the four numeric types
                        <code>xs:float</code>, <code>xs:double</code>, <code>xs:decimal</code> or
                        <code>xs:integer</code> the type of the result is the same as the type of
                        <code>$arg</code>. If the type of <code>$arg</code> is a type derived from
                        one of the numeric types, the result is an instance of the base numeric type.</p>
         <p>For <code>xs:float</code> and <code>xs:double</code> arguments, if the
                        argument is positive zero, then positive zero is returned. If the
                        argument is negative zero, then negative zero is returned. If the
                        argument is less than zero and greater than -1, negative zero is returned.</p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:ceiling(10.5)</fos:expression>
               <fos:result>11</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:ceiling(-10.5)</fos:expression>
               <fos:result>-10</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="floor">
      <fos:signatures>
         <fos:proto name="floor" return-type="numeric?">
            <fos:arg name="arg" type="numeric?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Rounds <code>$arg</code> downwards to a whole number.</p>
      </fos:summary>
      <fos:rules>
         <p>General rules: see <specref ref="numeric-value-functions"/>.</p>
         <p>The function returns the largest (closest to positive infinity) number with no
                        fractional part that is not greater than the value of <code>$arg</code>.</p>
         <p>If the type of <code>$arg</code> is one of the four numeric types
                        <code>xs:float</code>, <code>xs:double</code>, <code>xs:decimal</code> or
                        <code>xs:integer</code> the type of the result is the same as the type of
                        <code>$arg</code>. If the type of <code>$arg</code> is a type derived from
                        one of the numeric types, the result is an instance of the base numeric type.</p>
         <p>For <code>xs:float</code> and <code>xs:double</code> arguments, if the argument is
                        positive zero, then positive zero is returned. If the argument is
                        negative zero, then negative zero is returned.</p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:floor(10.5)</fos:expression>
               <fos:result>10</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:floor(-10.5)</fos:expression>
               <fos:result>-11</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="round">
      <fos:signatures>
         <fos:proto name="round" return-type="numeric?">
            <fos:arg name="arg" type="numeric?"/>
         </fos:proto>
         <fos:proto name="round" return-type="numeric?">
            <fos:arg name="arg" type="numeric?"/>
            <fos:arg name="precision" type="xs:integer"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Rounds a value to a specified number of decimal places, rounding upwards if two
			   such values are equally near.</p>
      </fos:summary>
      <fos:rules>
         <p>General rules: see <specref ref="numeric-value-functions"/>.</p>
         <p>The function returns the nearest (that is, numerically closest) value
to <code>$arg</code> that is a multiple of ten to the power of minus <code>$precision</code>. If two such
values are equally near (for example, if the fractional part in <code>$arg</code> is exactly
.5), the function returns the one that is closest to positive infinity.</p>
         <p>If the type of <code>$arg</code> is one of the four numeric types <code>xs:float</code>, <code>xs:double</code>,
<code>xs:decimal</code> or <code>xs:integer</code> the type of the result is the same as the type of
<code>$arg</code>. If the type of <code>$arg</code> is a type derived from one of the numeric types, the
result is an instance of the base numeric type.</p>
         <p>The single-argument version of this function produces the same result as the two-argument version
 with <code>$precision=0</code> (that is, it rounds to a whole number).</p>
         <p>When <code>$arg</code> is of type <code>xs:float</code> and <code>xs:double</code>:</p>
         <olist>
            <item>
               <p>If <code>$arg</code> is NaN, positive
or negative zero, or positive or negative infinity, then the result is the same
as the argument.</p>
            </item>
            <item>
               <p>For other values, the argument is cast to <code>xs:decimal</code> using an
implementation of <code>xs:decimal</code> that imposes no limits on the number of digits
that can be represented. The function is applied to this <code>xs:decimal</code> value, and
the resulting <code>xs:decimal</code> is cast back to <code>xs:float</code> or <code>xs:double</code> as appropriate
to form the function result. If the resulting <code>xs:decimal</code> value is zero, then
positive or negative zero is returned according to the sign of <code>$arg</code>.</p>
            </item>
         </olist>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:notes>
         <p>This function is typically used with a non-zero <code>$precision</code> in financial
applications where the argument is of type <code>xs:decimal</code>. For arguments of type
<code>xs:float</code> and <code>xs:double</code> the results may be counter-intuitive. For example,
consider <code>round(35.425e0, 2)</code>. The result is not 35.43, as might be expected, but
35.42. This is because the conversion of 35.425e0 to <code>xs:decimal</code> produces the decimal
value 35.42499999999..., which is closer to 35.42 than to 35.43.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:round(2.5)</fos:expression>
               <fos:result>3.0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:round(2.4999)</fos:expression>
               <fos:result>2.0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:round(-2.5)</fos:expression>
               <fos:result>-2.0</fos:result>
               <fos:postamble>Not the possible alternative, <code>-3</code></fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test xslt-version="2.1">
               <fos:expression>fn:round(1.125, 2)</fos:expression>
               <fos:result>1.13</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test xslt-version="2.1">
               <fos:expression>fn:round(8452, -2)</fos:expression>
               <fos:result>8500</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test xslt-version="2.1">
               <fos:expression>fn:round(3.1415e0, 2)</fos:expression>
               <fos:result>3.14e0</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="round-half-to-even">
      <fos:signatures>
         <fos:proto name="round-half-to-even" return-type="numeric?">
            <fos:arg name="arg" type="numeric?"/>
         </fos:proto>
         <fos:proto name="round-half-to-even" return-type="numeric?">
            <fos:arg name="arg" type="numeric?"/>
            <fos:arg name="precision" type="xs:integer"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Rounds a value to a specified number of decimal places, rounding to make the last digit even if two
			   such values are equally near.</p>
      </fos:summary>
      <fos:rules>
         <p>General rules: see <specref ref="numeric-value-functions"/>.</p>
         <p>The function returns the nearest (that is, numerically closest)
                        value to <code>$arg</code> that is a multiple of ten to the power of minus
                        <code>$precision</code>. If two such values are equally near (e.g. if the
                        fractional part in <code>$arg</code> is exactly .500...), the function returns the one
                        whose least significant digit is even.</p>
         <p>If the type of <code>$arg</code> is one
                        of the four numeric types <code>xs:float</code>, <code>xs:double</code>,
                        <code>xs:decimal</code> or <code>xs:integer</code> the type of the result is
                        the same as the type of <code>$arg</code>. If the type of <code>$arg</code>
                        is a type derived from one of the numeric types, the result is an instance
                        of the base numeric type.</p>
         <p> The first signature of this function produces the same result as the second
                        signature with <code>$precision=0</code>.</p>
         <p>For arguments of type <code>xs:float</code> and <code>xs:double</code>:</p>
         <olist>
            <item>
               <p>If the argument is <code>NaN</code>,
			    positive or negative zero, or positive or negative infinity, then the result is the same as the argument.</p>
            </item>
            <item>
               <p>In all other cases, the argument is cast to <code>xs:decimal</code>
				 <phrase diff="add" at="A">using an implementation of xs:decimal that imposes no 
				 limits on the number of digits that can be represented.</phrase>
                  The function is applied to this
				  <code>xs:decimal</code> value, and the resulting <code>xs:decimal</code> is cast back to 
				  <code>xs:float</code> or <code>xs:double</code> as appropriate to form the function result.
				   If the resulting <code>xs:decimal</code> value is zero, then positive or negative zero is
				    returned according to the sign of the original argument.</p>
            </item>
         </olist>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:notes>
         <p diff="chg" at="A">This function is typically used in financial applications where the argument is of type <code>xs:decimal</code>.
            For arguments of type <code>xs:float</code> and <code>xs:double</code> the results may be counter-intuitive.
	 For example, consider <code>round-half-to-even(xs:float(150.015), 2)</code>.
	 The result is not 150.02 as might be expected, but 150.01. This is because the conversion
	 of the <code>xs:float</code> value represented by the literal 150.015 to an <code>xs:decimal</code> 
            produces the <code>xs:decimal</code> value 150.014999389..., which is closer to 150.01 than to 150.02.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:round-half-to-even(0.5)</fos:expression>
               <fos:result>0.0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:round-half-to-even(1.5)</fos:expression>
               <fos:result>2.0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:round-half-to-even(2.5)</fos:expression>
               <fos:result>2.0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:round-half-to-even(3.567812e+3, 2)</fos:expression>
               <fos:result>3567.81e0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:round-half-to-even(4.7564e-3, 2)</fos:expression>
               <fos:result>0.0e0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:round-half-to-even(35612.25, -2)</fos:expression>
               <fos:result>35600</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="format-integer">
      <fos:signatures>
         <fos:proto name="format-integer" return-type="xs:string">
            <fos:arg name="value" type="xs:integer?"/>
            <fos:arg name="picture" type="xs:string"/>
         </fos:proto>
         <fos:proto name="format-integer" return-type="xs:string">
            <fos:arg name="value" type="xs:integer?"/>
            <fos:arg name="picture" type="xs:string"/>
            <fos:arg name="language" type="xs:language"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: formats an integer according to a given picture string, using the conventions of a given natural language if specified.</p>
      </fos:summary>
      <fos:rules>
          <p>If <code>$value</code> is an empty sequence, the function returns a zero-length string.</p>
         <p>In all other cases, the <code>$picture</code> argument describes the format in which <code>$value</code> is output.</p>
         <p>The rules that follow describe how non-negative numbers are output. If the value of <code>$value</code> is negative, the
		rules below are applied to the absolute value of <code>$value</code>, and the result is prepended with a minus sign.</p>
         <p>A picture consists of a primary format token, followed by an optional format modifier.</p>
         <p>The primary format token is one of the following:</p>
         <ulist>
            <item diff="chg" at="D">
               <p>A <var>decimal-digit-pattern</var> made up of <var>optional-digit-signs</var>, <var>mandatory-digit-signs</var>,
                  and <var>grouping-separator-signs</var>.</p>
               
               <ulist>
                  <item>
                     <p>an <var>optional-digit-sign</var> is the character "#".</p>
                  </item>
                  <item>
                     <p>a <var>mandatory-digit-sign</var> is a Unicode character in category Nd. All
                  <var>mandatory-digit-signs</var> within the format token must be from the same digit
                  family, where a digit family is a sequence of ten consecutive Unicode
                  characters in category Nd, having digit values 0 through 9. Within the format
                  token, these digits are interchangeable: a three-digit number may thus be
                  indicated equivalently by <code>000</code>, <code>001</code>, or <code>999</code>.</p>
                  </item>
                  <item>
                     <p>a <var>grouping-separator-sign</var> is a non-alphanumeric character, that is a
                  character whose Unicode category is other than Nd, Nl, No, Lu, Ll, Lt, Lm or
                  Lo.</p>
                  </item>
               </ulist>

                  
                  <p>There must be at least one <var>mandatory-digit-sign</var>. There may be zero or more
                  <var>optional-digit-signs</var>, and (if present) these must precede all
                  <var>mandatory-digit-signs</var>. There may be zero or more <var>grouping-separator-signs</var>. A
                  <var>grouping-separator-sign</var> must not appear at the start or end of the
                  <var>decimal-digit-pattern</var>, nor adjacent to another <var>grouping-separator-sign</var>.</p>
                  
                  <p>The corresponding output format is a decimal number, using this digit family,
                  with at least as many digits as there are <var>mandatory-digit-signs</var> in the format
                  token. Thus, a format token <code>1</code> generates the sequence <code>0 1 2 ... 10 11 12 ...</code>,
                  and a format token <code>01</code> (or equivalently, <code>00</code> or <code>99</code>) 
                     generates the sequence <code>00 01
                        02 ... 09 10 11 12 ... 99 100 101</code>. A format token of <code>&amp;#x661;</code> 
                     (Arabic-Indic digit one) generates the sequence <code>١</code> then <code>٢</code> then <code>٣</code> ...</p>
                  
                  <p>The <var>grouping-separator-signs</var> are handled as follows. The position of grouping
                  separators within the format token, counting backwards from the last digit,
                  indicates the position of grouping separators to appear within the formatted
                  number, and the character used as the <var>grouping-separator-sign</var> within the format
                  token indicates the character to be used as the corresponding grouping
                  separator in the formatted number. If <var>grouping-separator-signs</var> appear at
                  regular intervals within the format token, that is if the same grouping
                  separator appears at positions forming a sequence <var>N</var>, 2<var>N</var>, 3<var>N</var>, ... for some
                  integer value <var>N</var> (including the case where there is only one number in the
                  list), then the sequence is extrapolated to the left, so grouping separators
                  will be used in the formatted number at every multiple of <var>N</var>. For example, if
                  the format token is <code>0'000</code> then the number one million will be formatted as
                  <code>1'000'000</code>, while the number fifteen will be formatted as <code>0'015</code>.</p>
                  
                  <p>The only purpose of <var>optional-digit-signs</var> is to mark the position of
                  <var>grouping-separator-signs</var>. For example, if the format token is <code>#'##0</code> then the
                  number one million will be formatted as <code>1'000'000</code>, while the number fifteen
                  will be formatted as <code>15</code>. A grouping separator is included in the formatted
                  number only if there is a digit to its left, which will only be the case if
                  either (a) the number is large enough to require that digit, or (b) the number
                  of <var>mandatory-digit-signs</var> in the format token requires insignificant leading
                  zeros to be present.</p>
                  
                  <note><p>Numbers will never be truncated. Given the <var>decimal-digit-pattern</var> <code>01</code>, the
                  number three hundred will be output as <code>300</code>, despite the absence of any
                  <var>optional-digit-sign</var>.</p></note>
            </item>
            
            
            

            <item>
               <p>A format token <code>A</code> generates the sequence <code>A
B C ... Z AA AB AC...</code>.</p>
            </item>
            <item>
               <p>A format token <code>a</code> generates the sequence <code>a
b c ... z aa ab ac...</code>.</p>
            </item>
            <item>
               <p>A format token <code>i</code> generates the sequence <code>i
ii iii iv v vi vii viii ix x ...</code>.</p>
            </item>
            <item>
               <p>A format token <code>I</code> generates the sequence <code>I
II III IV V VI VII VIII IX X ...</code>.</p>
            </item>
            <item>
               <p>A format token <code>w</code> generates numbers written as lower-case words, for
					example in English, <code>one two three four ...</code>
                  </p>
            </item>
            <item>
               <p>A format token <code>W</code> generates numbers written as upper-case words, for
					example in English, <code>ONE TWO THREE FOUR ...</code>
                  </p>
            </item>
            <item>
               <p>A format token <code>Ww</code> generates numbers written as title-case words, for
					example in English, <code>One Two Three Four ...</code>
                  </p>
            </item>
            <item>
               <p>Any other format token indicates a
						numbering sequence in which that token 
            represents the number 1 (one) (but see the note below).
						<!-- Where possible (given the constraint that format tokens
						must be alphanumeric, and that they must be distinct) the format token
						used to represent a numbering sequence should be the same as the representation
						of the number 1 (one) in that sequence.-->
						It is <termref def="implementation-defined">implementation-defined</termref> which
						numbering sequences, additional to those listed above, are supported.
If an implementation does not support a
numbering sequence represented by the given token, it <rfc2119>must</rfc2119> use a format
token of <code>1</code>.</p>
               <note>
                  <p>In some traditional numbering sequences additional signs are
added to denote that the letters should be interpreted as numbers;
these are not included in the format token. An example, see also
the example below, is classical Greek where a <emph>dexia keraia</emph>
and sometimes an <emph>aristeri keraia</emph> is added.</p>
               </note>
            </item>
         </ulist>
         <p>For all format tokens other than the first kind above
(one that consists of decimal digits), there <rfc2119>may</rfc2119> be 
<termref def="implementation-defined">implementation-defined</termref>
lower and upper bounds on the range of numbers that 
can be formatted using this format
token; indeed, for some numbering sequences there may be 
intrinsic limits. For example, the format token <code>&amp;#x2460;</code>
 (circled digit one, ①) has a range of 1 to 20 imposed by the Unicode character repertoire.

For the numbering sequences described above 
 any upper bound imposed by the implementation <rfc2119>must not</rfc2119> be
less than 1000 (one thousand) and any lower bound must not be greater than 1. 
Numbers that fall outside this range
<rfc2119>must</rfc2119> be formatted using the format token <code>1</code>.</p>
         <p>The above expansions of numbering sequences for format tokens such as <code>a</code> and
<code>i</code> are indicative but not prescriptive. There are various conventions in use for
how alphabetic sequences continue when the alphabet is exhausted, and differing conventions for how
roman numerals are written (for example, <code>IV</code> versus <code>IIII</code> as the
representation of the number 4). Sometimes alphabetic sequences are used that omit
letters such as <code>i</code> and <code>o</code>. This 
specification does not prescribe the detail of any sequence other than 
those sequences consisting entirely of decimal digits.</p>
         <p>Many numbering sequences are language-sensitive.
This applies especially to the sequence selected by the tokens <code>w</code>, 
<code>W</code> and <code>Ww</code>.
It also applies to other sequences,
for example different languages using the Cyrillic alphabet use different
sequences of characters, each starting with the letter #x410 (Cyrillic
capital letter A). In such cases, the <code>$language</code>
argument specifies which language's conventions are to be used; it has
the same range of values as <code>xml:lang</code>
					(see <bibref ref="REC-xml"/>).
If no <code>$language</code> argument is specified, the language that is used is
<termref def="implementation-defined">implementation-defined</termref>.
  The set of languages for which numbering is supported is 
<termref def="implementation-defined">implementation-defined</termref>. 
If a language is requested that is not supported, 
the processor uses the language that it
would use if the <code>$language</code> argument were omitted.</p>
         <p>The format modifier, if present, is one of:</p>
         <ulist>
            <item>
               <p><code>o</code>, optionally followed by a sequence of characters enclosed
between parentheses, to indicate ordinal numbering</p>
            </item>
            <item>
               <p><code>t</code> to indicate traditional numbering</p>
            </item>
         </ulist>
         <p>If the <code>o</code> modifier is present, this indicates a request to output ordinal numbers rather than cardinal
numbers. For example, in English, when used with
the format token <code>1</code>, this outputs the sequence
 <code>1st 2nd 3rd 4th ...</code>, and when used with the format token <code>w</code> outputs the sequence
 <code>first second third fourth ...</code>.</p>
         <p>In some languages, ordinal numbers vary depending on the grammatical context, for example they
may have different genders and may decline with the noun that they qualify. In such cases the string appearing
in parentheses after the letter <code>o</code>  may
be used to indicate the variation of the ordinal number required.
The way in which the variation is indicated
will depend on the conventions of the language. For inflected languages that vary 
the ending of the word,
the preferred approach is to indicate the required ending, preceded by a hyphen: for example in German,
 appropriate values are <code>o(-e)</code>, <code>o(-er)</code>, <code>o(-es)</code>, <code>o(-en)</code>. </p>
         <p>It is <termref def="implementation-defined">implementation-defined</termref>
 what combinations of values of the format token, the language, and the 
<code>ordinal</code> attribute are supported. 
 If ordinal numbering
is not supported for the combination of the format token, the language, and the string appearing in parentheses, 
the request is ignored and cardinal numbers are generated instead.</p>
         <example>
            <head>Ordinal Numbering in Italian</head>
            <p>The specification <code>"1o(-º)"</code> with <code>$language</code> equal to <code>it</code>, if supported, should
 produce the sequence:</p>
            <eg xml:space="preserve">1º 2º 3º 4º ...</eg>
            <p>The specification <code>"Wwo"</code> with <code>$language</code> equal to <code>it</code>, if supported, should
produce the sequence:</p>
            <eg xml:space="preserve">Primo Secondo Terzo Quarto Quinto ...</eg>
         </example>
         <p>The <code>t</code> modifier disambiguates between
numbering sequences that use letters.  In many languages there are two
commonly used numbering sequences that use letters.  One numbering
sequence assigns numeric values to letters in alphabetic sequence, and
the other assigns numeric values to each letter in some other manner
traditional in that language.  In English, these would correspond to
the numbering sequences specified by the format tokens <code>a</code>
and <code>i</code>.  In some languages, the first member of each
sequence is the same, and so the format token alone would be
ambiguous.  By default the
alphabetic sequence is used; the <code>t</code> modifier requests the
other sequence.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test xslt-version="2.1">
               <fos:expression>format-integer(123, '0000')</fos:expression>
               <fos:result>"0123"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <p><code>format-integer(123, 'w')</code> might return <code>"one hundred and twenty-three"</code></p>
         </fos:example>
         <fos:example>
            <fos:test xslt-version="2.1">
               <fos:expression>format-integer(21, '1o', 'en')</fos:expression>
               <fos:result>"21st"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <p><code>format-integer(14, 'Wwo(-e)', 'de')</code> might return <code>"Vierzehnte"</code></p>
         </fos:example>
         <fos:example>
            <fos:test xslt-version="2.1">
               <fos:expression>format-integer(7, 'a')</fos:expression>
               <fos:result>"g"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test xslt-version="2.1">
               <fos:expression>format-integer(57, 'I')</fos:expression>
               <fos:result>"LVII"</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="format-number">
      <fos:signatures>
         <fos:proto name="format-number" return-type="xs:string">
            <fos:arg name="value" type="numeric?"/>
            <fos:arg name="picture" type="xs:string"/>
         </fos:proto>
         <fos:proto name="format-number" return-type="xs:string">
            <fos:arg name="value" type="numeric?"/>
            <fos:arg name="picture" type="xs:string"/>
            <fos:arg name="decimal-format-name" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns a string containing a number formatted according to a given picture string, 
            taking account of decimal formats specified in the static context.</p>
      </fos:summary>
      <fos:rules>
         <p>The function formats
            <code>$value</code> as a string using the <termref def="dt-picture-string">picture string</termref>
             specified by the
            <code>$picture</code> argument and the decimal-format named by the <code>$decimal-format-name</code> argument, or
            the default decimal-format, if there is no <code>$decimal-format-name</code> argument.
            The syntax of the picture string is described in 
            <specref ref="syntax-of-picture-string"/>.</p>
         <p>The <code>$value</code> argument may be of any numeric data type (<code>xs:double</code>,
            <code>xs:float</code>, <code>xs:decimal</code>, or their subtypes including <code>xs:integer</code>).
            Note that if an <code>xs:decimal</code> is supplied, it is not automatically promoted to an <code>xs:double</code>,
            as such promotion can involve a loss of precision.</p>
         <p>If the supplied value of the <code>$value</code> argument is an empty sequence, the function
            behaves as if the supplied value were the <code>xs:double</code> value <code>NaN</code>.</p>
         <p>The value of <code>$decimal-format-name</code> 
             <rfc2119>must</rfc2119> be a lexical QName, which is expanded using
	   the in-scope namespaces from the static context. 
	   The default namespace is not used (no prefix means no namespace).</p>
         <p>The evaluation of the <function>format-number</function> function
               takes place in two phases, an analysis phase described in <specref ref="analysing-picture-string"/>
               and a formatting phase described in <specref ref="formatting-the-number"/>.</p>
            
         <p>The analysis phase takes as its inputs the <termref def="dt-picture-string">picture string</termref>
               and the variables derived from the relevant decimal format in the static context,
               and produces as its output a number of variables with defined values.
               The formatting phase takes as its inputs the number to be formatted
               and the variables produced by the analysis phase, and produces as
               its output a string containing a formatted representation of the number.</p>
            
         <p>The result of the function is the formatted string
               representation of the supplied number.</p>
         
      </fos:rules>
      <fos:errors>
         <p>An error is raised <errorref class="DF" code="1280"/> 
            if the name specified as the
            <code>$decimal-format-name</code> argument
            is not a valid  lexical QName, or if its prefix has not been declared in an in-scope namespace declaration, or
            if the static context does not contain a declaration of a decimal-format with a matching 
            expanded QName.
            If the processor is able to detect the error statically (for example, when the argument is
            supplied as a string literal), then the processor <rfc2119>may</rfc2119> optionally signal this 
            as a static error.</p>
      </fos:errors>
      <fos:notes>       
         <p>Numbers will always be formatted with the most significant
                  digit on the left.</p>
      </fos:notes>
   </fos:function>
   <fos:function name="pi" prefix="math">
      <fos:signatures>
         <fos:proto name="pi" return-type="xs:double"/>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns an approximation to the mathematical constant <var>π</var>.</p>
      </fos:summary>
      <fos:rules>
         <p>This function returns the <code>xs:double</code> value whose lexical representation is
			   3.141592653589793e0</p>
	  </fos:rules>
	  <fos:examples>
	     <fos:example>
            <fos:test xslt-version="2.1">
               <fos:expression>2*math:pi()</fos:expression>
               <fos:result>6.283185307179586e0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <p>The expression <code>60 * (math:pi() div 180)</code> converts an angle of 60 degrees to radians. </p>
         </fos:example>         
      </fos:examples>
   </fos:function>
   <fos:function name="sqrt" prefix="math">
      <fos:signatures>
         <fos:proto name="sqrt" return-type="xs:double?">
            <fos:arg name="arg" type="xs:double?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the non-negative square root of the argument.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>If <code>$arg</code> is less than zero, the result is <code>NaN</code>.</p>
         <p>If <code>$arg</code> is positive or negative zero, positive infinity, or <code>NaN</code>, then 
			   the result is <code>$arg</code>.</p>
         <p>Otherwise the result is the <code>xs:double</code> value <termref def="either-side-of">either side of</termref> the mathematical
			   square root of <code>$arg</code>.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="sin" prefix="math">
      <fos:signatures>
         <fos:proto name="sin" return-type="xs:double?">
            <fos:arg name="θ" type="xs:double?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the sine of the argument, expressed in radians.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$</code><var>θ</var> is the empty sequence, the function returns the empty sequence.</p>
         <p>If <code>$</code><var>θ</var> is positive or negative zero, the result is <code>$</code><var>θ</var>.</p>
         <p>If <code>$</code><var>θ</var> is positive or negative infinity, or <code>NaN</code>, then 
			   the result is <code>NaN</code>.</p>
         <p>Otherwise the result is the sine of <code>$</code><var>θ</var>, treated as an angle in radians.
            If <code>$</code><var>θ</var> is in the range -2<var>π</var><code> &lt; $</code><var>θ</var><code> &lt; +2</code><var>π</var> 
            then the result is the <code>xs:double</code> value 
	   <termref def="either-side-of">either side of</termref> the 
	   mathematical sine of the angle; if it is outside this range, then the precision of the result is 
	   <termref def="implementation-dependent">implementation-dependent</termref>.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="cos" prefix="math">
      <fos:signatures>
         <fos:proto name="cos" return-type="xs:double?">
            <fos:arg name="θ" type="xs:double?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the cosine of the argument, expressed in radians.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$</code><var>θ</var> is the empty sequence, the function returns the empty sequence.</p>
         <p>If <code>$</code><var>θ</var> is positive or negative infinity, or <code>NaN</code>, then 
			   the result is <code>NaN</code>.</p>
         <p>Otherwise the result is the cosine of <code>$</code><var>θ</var>, treated as an angle in radians.
            If <code>$</code><var>θ</var> is in the range -2<var>π</var><code> &lt; $</code><var>θ</var><code> &lt; +2</code><var>π</var>
            then the result is the <code>xs:double</code> 
            value <termref def="either-side-of">either side of</termref> the 
	   mathematical cosine of the angle; if it is outside this range, then the precision of the result is 
	   <termref def="implementation-dependent">implementation-dependent</termref>.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="tan" prefix="math">
      <fos:signatures>
         <fos:proto name="tan" return-type="xs:double?">
            <fos:arg name="θ" type="xs:double?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the tangent of the argument, expressed in radians.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$</code><var>θ</var> is the empty sequence, the function returns the empty sequence.</p>
         <p>If <code>$</code><var>θ</var> is positive or negative infinity, or <code>NaN</code>, then 
			   the result is <code>NaN</code>.</p>
         <p>Otherwise the result is the tangent of <code>$</code><var>θ</var>, treated as an angle in radians.
            If <code>$</code><var>θ</var> is in the range -2<var>π</var><code> &lt; $</code><var>θ</var><code> &lt; +2</code><var>π</var>
            then the result is the <code>xs:double</code> 
            value <termref def="either-side-of">either side of</termref> the 
           mathematical tangent of the angle; if it is outside this range, then the precision of the result is 
           <termref def="implementation-dependent">implementation-dependent</termref>.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="asin" prefix="math">
      <fos:signatures>
         <fos:proto name="asin" return-type="xs:double?">
            <fos:arg name="arg" type="xs:double?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the arc sine of the argument, the result being in the range -<var>π</var>/2 to +<var>π</var>/2 radians.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>If <code>$arg</code> is positive or negative zero, the result is <code>$arg</code>.</p>
         <p>If <code>$arg</code> is <code>NaN</code>, or if its absolute value is greater than one, then 
			   the result is <code>NaN</code>.</p>
         <p>Otherwise the result is the <code>xs:double</code> value <termref def="either-side-of">either side of</termref>
            the mathematical arc sine of the argument <code>$arg</code>, this being an angle 
            <var>θ</var> in radians in the range 
            -<var>π</var><code>/2 &lt;= $</code><var>θ</var><code> &lt;= +</code><var>π</var><code>/2</code>.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="acos" prefix="math">
      <fos:signatures>
         <fos:proto name="acos" return-type="xs:double?">
            <fos:arg name="arg" type="xs:double?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the arc cosine of the argument, the result being in the range zero to +<var>π</var> radians.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>If <code>$arg</code> is <code>NaN</code>, or if its absolute value is greater than one, then 
			   the result is <code>NaN</code>.</p>
         <p>Otherwise the result is the <code>xs:double</code> value <termref def="either-side-of">either side of</termref>
            the mathematical arc cosine of <code>$arg</code>, this being an angle in radians in the range
            <code>0 &lt;= $</code><var>θ</var><code> &lt;= +</code><var>π</var>.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="atan" prefix="math">
      <fos:signatures>
         <fos:proto name="atan" return-type="xs:double?">
            <fos:arg name="arg" type="xs:double?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the arc tangent of the argument, the result being in the range -<var>π</var>/2 to +<var>π</var>/2 radians.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>If <code>$arg</code> is positive or negative zero, the result is <code>$arg</code>.</p>
         <p>If <code>$arg</code> is <code>NaN</code> then 
			   the result is <code>NaN</code>.</p>
         <p>If <code>$arg</code> is negative infinity then the result is the <code>xs:double</code> value
            <termref def="either-side-of">either side of</termref> -<var>π</var><code>/2</code>.</p>
         <p>If <code>$arg</code> is positive infinity then the result is the <code>xs:double</code> value
            <termref def="either-side-of">either side of</termref> +<var>π</var><code>/2</code>.</p>
         <p>Otherwise the result is the <code>xs:double</code> value <termref def="either-side-of">either side of</termref>
            the mathematical arc tangent of <code>$arg</code>, this being an angle in radians in the range 
            -<var>π</var><code>/2 &lt;= $</code><var>θ</var><code> &lt;= +</code><var>π</var><code>/2</code>.</p>
       </fos:rules>
   </fos:function>
   <fos:function name="codepoints-to-string">
      <fos:signatures>
         <fos:proto name="codepoints-to-string" return-type="xs:string">
            <fos:arg name="arg" type="xs:integer*"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Creates an <code>xs:string</code> from a sequence of <bibref ref="Unicode4"/> codepoints.</p>
      </fos:summary>
      <fos:rules>         
         <p>The function returns the string made up from the characters whose Unicode codepoints are
			   supplied in <code>$arg</code>. This will be the
               zero-length string if <code>$arg</code> is the empty sequence. </p>
         
      </fos:rules>
      <fos:errors>
         <p>If any of the codepoints in <code>$arg</code> is not a legal XML character, an error is
                        raised <errorref class="CH" code="0001"/>.</p>
      </fos:errors>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:codepoints-to-string((2309, 2358, 2378, 2325))</fos:expression>
               <fos:result>"अशॊक"</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="string-to-codepoints">
      <fos:signatures>
         <fos:proto name="string-to-codepoints" return-type="xs:integer*">
            <fos:arg name="arg" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the sequence of <bibref ref="Unicode4"/>           
                    codepoints that constitute an
                        <code>xs:string</code> value. 
						</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns a sequence of integers, each integer being the Unicode
				codepoint of the corresponding character in <code>$arg</code>.</p>
         <p>If <code>$arg</code> is a zero-length string or the
                        empty sequence, the function returns the empty sequence.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:string-to-codepoints("Thérèse")</fos:expression>
               <fos:result>(84, 104, 233, 114, 232, 115, 101)</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="compare">
      <fos:signatures>
         <fos:proto name="compare" return-type="xs:integer?">
            <fos:arg name="comparand1" type="xs:string?"/>
            <fos:arg name="comparand2" type="xs:string?"/>
         </fos:proto>
         <fos:proto name="compare" return-type="xs:integer?">
            <fos:arg name="comparand1" type="xs:string?"/>
            <fos:arg name="comparand2" type="xs:string?"/>
            <fos:arg name="collation" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns -1, 0, or 1, depending on whether <code>$comparand1</code>
			   collates before, equal to, or after <code>$comparand2</code> according to the
			   rules of a selected collation.</p>
      </fos:summary>
      <fos:rules>
         <p>Returns -1, 0, or 1, depending on whether the value of the
                        <code>$comparand1</code> is respectively less than, equal to, or greater
                        than the value of <code>$comparand2</code>, according to the rules of the
                        collation that is used. </p>
         <p>The collation used by this function is determined according
                        to the rules in <specref ref="choosing-a-collation"/>. </p>
         <p>If either <code>$comparand1</code> or <code>$comparand2</code> is the empty sequence, 
			      the function returns the empty sequence.</p>
         <p>This function, called with the first signature, defines the semantics of the "eq", "ne",
                        "gt", "lt", "le" and "ge" operators on <code>xs:string</code> values.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:compare('abc', 'abc')</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test default-collation="http://example.com/deutsch">
               <fos:expression>fn:compare('Strasse', 'Straße')</fos:expression>
               <fos:result>0</fos:result>
               <fos:postamble>Assuming the default collation includes provisions that
                    equate <quote>ss</quote> and the (German) character
                    <quote>ß</quote> (<quote>sharp-s</quote>). Otherwise,
                    the returned value depends on the semantics of the default collation.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
           <fos:test>
               <fos:expression>fn:compare('Strasse', 'Straße', 'http://example.com/deutsch')</fos:expression>
               <fos:result>0</fos:result>
               <fos:postamble>Assuming the collation identified by the URI
                    <code>http://example.com/deutsch</code> includes provisions that equate
                    <quote>ss</quote> and the (German) character
                    <quote>ß</quote> (<quote>sharp-s</quote>). Otherwise,
                    the returned value depends on the semantics of that collation.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test default-collation="http://example.com/deutsch">
               <fos:expression>fn:compare('Strassen', 'Straße')</fos:expression>
               <fos:result>1</fos:result>
               <fos:postamble>Assuming the default collation includes provisions that treat
                  differences between <quote>ss</quote> and the (German) character
                  <quote>ß</quote> (<quote>sharp-s</quote>) with less
                  strength than the differences between the base characters, such
                  as the final <quote>n</quote>.
               </fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="codepoint-equal">
      <fos:signatures>
         <fos:proto name="codepoint-equal" return-type="xs:boolean?">
            <fos:arg name="comparand1" type="xs:string?"/>
            <fos:arg name="comparand2" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns true if two strings are equal, considered codepoint-by-codepoint.</p>
      </fos:summary>
      <fos:rules>
         <p>If either argument is the empty sequence, the function returns the empty sequence. </p>
         <p>Otherwise, the function returns <code>true</code> or <code>false</code> depending on whether
            the value of <code>$comparand1</code> is equal to the value of
            <code>$comparand2</code>, according to the Unicode codepoint collation
	 (<code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>).</p>
         
      </fos:rules>
      <fos:notes>
         <p>This function allows <code>xs:anyURI</code> values to be compared without having to specify the Unicode codepoint collation.</p>
      </fos:notes>
   </fos:function>
   <fos:function name="concat">
      <fos:signatures>
         <fos:proto name="concat" return-type="xs:string">
            <fos:arg name="arg1" type="xs:anyAtomicType?"/>
            <fos:arg name="arg2" type="xs:anyAtomicType?"/>
            <fos:arg name="..." type="xs:anyAtomicType?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the concatenation of the string values of the arguments.</p>
      </fos:summary>
      <fos:rules>
         <p>This function accepts two or more <code>xs:anyAtomicType</code> arguments and
                        casts each one to <code>xs:string</code>. The function returns the <code>xs:string</code>
                        that is the concatenation of the values of its arguments after conversion.
                        If any argument is the empty sequence, that argument is treated as
                        the zero-length string.</p>
         <p diff="chg" at="A-E19">The <code>fn:concat</code> function is specified to allow two or more
                        arguments, which are concatenated together. This is the only function
                        specified in this document that allows a variable number of arguments. This
                        capability is retained for compatibility with <bibref ref="xpath"/>. </p>
      </fos:rules>
      <fos:notes>
         <p>As mentioned in <specref ref="string-types"/> Unicode normalization is not
automatically applied to the result of <code>fn:concat</code>.  If a normalized result is required, <code>fn:normalize-unicode</code> 
can be applied to the <code>xs:string</code> returned by <code>fn:concat</code>.  The following XQuery:</p>
         <eg xml:space="preserve">
let $v1 := "I plan to go to Mu"
let $v2 := "?nchen in September"
return concat($v1, $v2)</eg>
         <p>where the "?" represents either the actual Unicode character COMBINING DIARESIS (Unicode codepoint U+0308) or "&amp;#x0308;", will return:</p>
         <p>"I plan to go to Mu?nchen in September"</p>
         <p>where the "?" represents either the actual Unicode character COMBINING DIARESIS (Unicode codepoint U+0308) or "&amp;#x0308;". It is worth noting that the returned value is not normalized in NFC; however, it is normalized in NFD.
.</p>
         <p>
However, the following XQuery:</p>
         <eg xml:space="preserve">
let $v1 := "I plan to go to Mu"
let $v2 := "?nchen in September"
return normalize-unicode(concat($v1, $v2))</eg>
         <p>where the "?" represents either the actual Unicode character COMBINING DIARESIS (Unicode codepoint U+0308) or "&amp;#x0308;", will return:</p>
         <p>
"I plan to go to München in September"</p>
         <p>This returned result is normalized in NFC.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:concat('un', 'grateful')</fos:expression>
               <fos:result>"ungrateful"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:concat('Thy ', (), 'old ', "groans", "", ' ring', ' yet', ' in', ' my', ' ancient',' ears.')</fos:expression>
               <fos:result>"Thy old groans ring yet in my ancient ears."</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:concat('Ciao!',())</fos:expression>
               <fos:result>"Ciao!"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:concat('Ingratitude, ', 'thou ', 'marble-hearted', ' fiend!')</fos:expression>
               <fos:result>"Ingratitude, thou marble-hearted fiend!"</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="string-join">
      <fos:signatures>
         <fos:proto name="string-join" return-type="xs:string" diff="add" at="B">
            <fos:arg name="arg1" type="xs:string*"/>
         </fos:proto>
         <fos:proto name="string-join" return-type="xs:string">
            <fos:arg name="arg1" type="xs:string*"/>
            <fos:arg name="arg2" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns a string created by concatenating the items in a sequence, with 
	   a defined separator between adjacent items.</p>
      </fos:summary>
      <fos:rules>
         <p diff="add" at="B">The effect of calling the single-argument version of this function is the same as calling
         the two-argument version with <code>$arg2</code> set to a zero-length string.</p>
         <p>The function returns an <code>xs:string</code> created by concatenating the
            items in the sequence <code>$arg1</code>, in order, using the value of <code>$arg2</code> as a
            separator between adjacent items. If the value of <code>$arg2</code> is the zero-length string,
            then the members of <code>$arg1</code> are concatenated without a separator.</p>
         
      </fos:rules>
      <fos:notes>
         <p>If the value of <code>$arg1</code> is the empty sequence, the function returns the zero-length
            string.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:string-join(('Now', 'is', 'the', 'time', '...'), ' ')</fos:expression>
               <fos:result>"Now is the time ..."</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:string-join(('Blow, ', 'blow, ', 'thou ', 'winter ', 'wind!'), '')</fos:expression>
               <fos:result>"Blow, blow, thou winter wind!"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:string-join((), 'separator')</fos:expression>
               <fos:result>""</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <p>Assume a document:</p>
            <eg xml:space="preserve">&lt;doc&gt;
  &lt;chap&gt;
    &lt;section/&gt;
  &lt;/chap&gt;
&lt;/doc&gt;</eg>
            <p>with the <code>&lt;section&gt;</code> element as the context node,
                                    the <bibref ref="xpath20"/> expression: </p>
            <p><code>fn:string-join(ancestor-or-self::*/name(), '/')</code></p>
            <p> returns <code>"doc/chap/section"</code></p>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="substring">
      <fos:signatures>
         <fos:proto name="substring" return-type="xs:string">
            <fos:arg name="sourceString" type="xs:string?"/>
            <fos:arg name="start" type="xs:double"/>
         </fos:proto>
         <fos:proto name="substring" return-type="xs:string">
            <fos:arg name="sourceString" type="xs:string?"/>
            <fos:arg name="start" type="xs:double"/>
            <fos:arg name="length" type="xs:double"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the portion of the value of <code>$sourceString</code>
                        beginning at the position indicated by the value of
                        <code>$start</code> and continuing for the number of characters
                        indicated by the value of <code>$length</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If the value of <code>$sourceString</code> is the empty sequence, the
                        function returns the zero-length string. </p>
         <p>Otherwise, the function returns a string comprising those characters of <code>$sourceString</code> whose index
			   position (counting from one) is greater than or equal to the value of <code>$start</code> (rounded to an integer),
               and (if <code>$length</code> is specified) less than the sum of 
			   <code>$start</code> and <code>$length</code> (both rounded to integers).</p>
         <p>The characters returned do
                        not extend beyond <code>$sourceString</code>. If <code>$start</code>
                        is zero or negative, only those characters in positions greater than zero
                        are returned.</p>
         <p>More specifically, the three argument version of the function returns the
                        characters in <code>$sourceString</code> whose position <code>$p</code> satisfies:</p>
         <p><code>fn:round($start) &lt;= $p &lt; fn:round($start) + fn:round($length)</code>
                    </p>
         <p>The two argument version of the function assumes that <code>$length</code> is
                        infinite and thus returns the characters in <code>$sourceString</code> whose
                        position <code>$p</code> satisfies:</p>
         <p><code>fn:round($start) &lt;= $p</code></p>
         <p>In the above computations, the rules for <code>op:numeric-less-than</code>
                        and <code>op:numeric-greater-than</code> apply.</p>
      </fos:rules>
      <fos:notes>
         <p>The first character of a string is located at position 1, not position 0.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring("motor car", 6)</fos:expression>
               <fos:result>" car"</fos:result>
               <fos:postamble>Characters starting at position 6 to the end of
                                    <code>$sourceString</code> are selected.</fos:postamble>
            </fos:test>
            <p></p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring("metadata", 4, 3)</fos:expression>
               <fos:result>"ada"</fos:result>
               <fos:postamble>Characters at positions greater than or equal to 4 and less than
                                    7 are selected.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring("12345", 1.5, 2.6)</fos:expression>
               <fos:result>"234"</fos:result>
               <fos:postamble>Characters at positions greater than or equal to 2 and less than
                                    5 are selected.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring("12345", 0, 3)</fos:expression>
               <fos:result>"12"</fos:result>
               <fos:postamble>Characters at positions greater than or equal to 0 and less than
                                    3 are selected. Since the first position is 1, these are the
                                    characters at positions 1 and 2.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring("12345", 5, -3)</fos:expression>
               <fos:result>""</fos:result>
               <fos:postamble>Characters at positions greater than or equal to 5 and less than
                                    2 are selected.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring("12345", -3, 5)</fos:expression>
               <fos:result>"1"</fos:result>
               <fos:postamble>Characters at positions greater than or equal to -3 and less than
                                    2 are selected. Since the first position is 1, this is the
                                    character at position 1.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring("12345", 0 div 0E0, 3)</fos:expression>
               <fos:result>""</fos:result>
               <fos:postamble>Since <code>0 div 0E0</code> returns <code>NaN</code>, and
                                    <code>NaN</code> compared to any other number returns
                                    <code>false</code>, no characters are selected.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring("12345", 1, 0 div 0E0)</fos:expression>
               <fos:result>""</fos:result>
               <fos:postamble>As above.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring((), 1, 3)</fos:expression>
               <fos:result>""</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring("12345", -42, 1 div 0E0)</fos:expression>
               <fos:result>"12345"</fos:result>
               <fos:postamble>Characters at positions greater than or equal to -42 and less
                                    than INF are selected.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring("12345", -1 div 0E0, 1 div 0E0)</fos:expression>
               <fos:result>""</fos:result>
               <fos:postamble>Since the value of <code>-INF + INF</code> is <code>NaN</code>, no
                                    characters are selected.</fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="string-length">
      <fos:signatures>
         <fos:proto name="string-length" return-type="xs:integer"/>
         <fos:proto name="string-length" return-type="xs:integer">
            <fos:arg name="arg" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the number of characters in a string.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns an <code>xs:integer</code> equal to the length in characters
                        of the value of <code>$arg</code>.</p>
         <p>Calling the zero-argument version of the function is equivalent to calling 
                        <code>fn:string-length(fn:string(.))</code>.</p>
         <p>If the value of <code>$arg</code> is the empty sequence, the function returns the 
                        <code>xs:integer</code> value zero (0).</p>
      </fos:rules>
      <fos:errors>
         <p>If <code>$arg</code> is not specified and the context item is undefined, an error is raised:
            <xerrorref spec="XP" class="DY" code="0002" type="type"/>.</p>
      </fos:errors>
      <fos:notes>
         <p>Unlike some programming languages, a codepoint greater than 65535 counts as one character, not two.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:string-length("Harp not on that string, madam; that is
                                    past.")</fos:expression>
               <fos:result>45</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:string-length(())</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="normalize-space">
      <fos:signatures>
         <fos:proto name="normalize-space" return-type="xs:string"/>
         <fos:proto name="normalize-space" return-type="xs:string">
            <fos:arg name="arg" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the value of <code>$arg</code> with leading and trailing whitespace
			   removed, and sequences of internal whitespace reduced to a single space character.</p>
      </fos:summary>
      <fos:rules>
         <p>If the value of
               <code>$arg</code> is the empty sequence, the function returns the zero-length string.</p>
         <p>The function returns a string constructed by stripping leading and trailing whitespace
			   from the value of <code>$arg</code>, and replacing sequences of one or
                        more adjacent whitespace characters with a single space, <code>#x20</code>.</p>
         <p>The whitespace characters are defined in the metasymbol S (Production 3)                    
                    of <bibref ref="REC-xml"/>.</p>
         
         <p diff="chg" at="A-E14">If no argument is supplied, then <code>$arg</code> defaults to the string value
                        (calculated using <code>fn:string</code>) of the context item
                        (<code>.</code>). </p>
      </fos:rules>
      <fos:errors>
         <p>If no argument is supplied and the context item is
        undefined then an error is raised: <xerrorref spec="XP" class="DY" code="0002" type="type"/>.</p>
      </fos:errors>
      <fos:notes>
         <p>The definition of whitespace is unchanged in <bibref ref="xml11"/>. </p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression xml:space="preserve">fn:normalize-space(" The    wealthy curled darlings
                                        of    our    nation. ")</fos:expression>
               <fos:result>"The wealthy curled darlings of our nation."</fos:result>
            </fos:test>
         </fos:example>         
         <fos:example>
            <fos:test>
               <fos:expression>fn:normalize-space(())</fos:expression>
               <fos:result>""</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="normalize-unicode">
      <fos:signatures>
         <fos:proto name="normalize-unicode" return-type="xs:string">
            <fos:arg name="arg" type="xs:string?"/>
         </fos:proto>
         <fos:proto name="normalize-unicode" return-type="xs:string">
            <fos:arg name="arg" type="xs:string?"/>
            <fos:arg name="normalizationForm" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the value of <code>$arg</code> after applying Unicode normalization.</p>
      </fos:summary>
      <fos:rules>
         <p>If the value of <code>$arg</code> is the empty sequence, the function returns the zero-length string.</p>
         <p>If the single-argument version of the function is used, the result is the same as calling
			   the two-argument version with <code>$normalizationForm</code> set to the string "NFC".</p>
         <p>Otherwise, the function returns the value of <code>$arg</code> normalized according to the
                        rules of the normalization form identified by the value of
                        <code>$normalizationForm</code>.</p>
         <p>The effective value of <code>$normalizationForm</code> is the value of the
			   expression <code>fn:upper-case(fn:normalize-space($normalizationForm))</code>.</p>
         <p diff="del" at="D">See <bibref ref="charmod-normalization"/> for a description of the normalization forms.</p>
         
         <ulist>
            <item>
               <p>If the effective value of <code>$normalizationForm</code> is
                                <quote>NFC</quote>, then the function returns the
                                value of <code>$arg</code> converted to Unicode Normalization Form C (NFC).</p>
            </item>
            <item>
               <p>If the effective value of <code>$normalizationForm</code> is
                                <quote>NFD</quote>, then the function returns the
                                value of <code>$arg</code> converted to Unicode Normalization Form D (NFD).</p>
            </item>
            <item>
               <p>If the effective value of <code>$normalizationForm</code> is
                                <quote>NFKC</quote>, then the function returns the
                                value of <code>$arg</code> in Unicode Normalization Form KC (NFKC).</p>
            </item>
            <item>
               <p>If the effective value of <code>$normalizationForm</code> is
                                <quote>NFKD</quote>, then the function returns the
                                value of <code>$arg</code> converted to Unicode Normalization Form KD (NFKD).</p>
            </item>
            <item>
               <p>If the effective value of <code>$normalizationForm</code> is
                                <quote>FULLY-NORMALIZED</quote>, then the function returns the
                                value of <code>$arg</code> converted to fully normalized form.
                            </p>
            </item>
            <item>
               <p>If the effective value of <code>$normalizationForm</code> is the
                                zero-length string, no normalization is performed and
                                <code>$arg</code> is returned.</p>
            </item>
         </ulist>
         <p diff="add" at="D">Normalization forms NFC, NFD, NFKC, and NFKD, and the algorithms to be used for converting a string
            to each of these forms, are defined in <bibref ref="Unicode-Normalization"/>.</p>
         <p diff="add" at="D">The motivation for normalization form FULLY-NORMALIZED is explained
            in <bibref ref="charmod-normalization"/>. However, as that specification did not progress beyond
            working draft status, the normative specification is as follows:</p>
         <ulist diff="add" at="D">
            <item>
               <p>A string is <term>fully-normalized</term> if (a) it is in normalization form NFC as defined
                  in <bibref ref="Unicode-Normalization"/>, and (b) it does not start with a composing character.</p>
            </item>
            <item>
               <p>A composing character is a character that is one or both of the following:</p>
               <ulist>
                  <item>
                     <p>the second character in the canonical decomposition mapping of some character that is
                        not listed in the Composition Exclusion Table defined in <bibref ref="Unicode-Normalization"/>;</p>
                  </item>
                  <item>
                     <p>of non-zero canonical combining class (as defined in <bibref ref="Unicode4"/>).</p>
                  </item>
               
               </ulist>
            </item>
            <item><p>A string is converted to FULLY-NORMALIZED form as follows:</p>
               <ulist>
                  <item>
                     <p>if the first character in the string is a composing character, prepend a single space (x20);</p>
                  </item>
                  <item>
                     <p>convert the resulting string to normalization form NFC.</p>
                  </item>                 
               </ulist>
            </item>
         </ulist>
            
         <p>Conforming implementations <termref def="must"/> support normalization form
                        "NFC" and <termref def="may"/> support normalization forms "NFD", "NFKC",
                        "NFKD", and "FULLY-NORMALIZED". They <termref def="may"/> also support other
                        normalization forms with <termref def="implementation-defined"/> semantics.
                        </p>
      </fos:rules>
      <fos:errors>
         <p>If the effective value of the <code>$normalizationForm</code> argument is not
                        one of the values supported by the implementation, then an error is raised
                            <errorref class="CH" code="0003"/>.</p>
      </fos:errors>
   </fos:function>
   <fos:function name="upper-case">
      <fos:signatures>
         <fos:proto name="upper-case" return-type="xs:string">
            <fos:arg name="arg" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Converts a string to upper case.</p>
      </fos:summary>
      <fos:rules>
         <p>If the value of <code>$arg</code> is the empty sequence, the zero-length
                        string is returned.</p>
         <p>Otherwise, the function returns the value of <code>$arg</code> after translating every character to 
					its upper-case correspondent as defined in the appropriate case 
					mappings section in the Unicode standard <bibref ref="Unicode4"/>. 
					For versions of Unicode beginning with the 2.1.8 update, only 
					locale-insensitive case mappings should be applied.  Beginning with 
					version 3.2.0 (and likely future versions) of Unicode, precise mappings 
					are described in default case operations, which are full case mappings
					in the absence of tailoring for particular languages and environments.
					Every lower-case character that does not have an upper-case correspondent, 
					as well as every upper-case character, is included in the returned value 
					in its original form. 
					</p>
      </fos:rules>
      <fos:notes>
         <p>Case mappings may change the length of a string. In general, the <code>fn:upper-case</code>
				  and <code>fn:lower-case</code> functions are not inverses of each other:
                            <code>fn:lower-case(fn:upper-case($arg))</code> is not guaranteed to
                            return <code>$arg</code>, nor
                            is <code>fn:upper-case(fn:lower-case($arg))</code>. The Latin small
                            letter dotless i (as used in Turkish) is perhaps the most prominent
                            lower-case letter which will not round-trip. The Latin capital letter i
                            with dot above is the most prominent upper-case letter which will not
                            round trip; there are others, such as Latin capital letter Sharp S (#1E9E) which is
							introduced in Unicode 5.1.</p>
         <p> These functions may not always be linguistically appropriate (e.g.
                            Turkish i without dot) or appropriate for the application (e.g.
                            titlecase). In cases such as Turkish, a simple translation should be
                            used first.</p>
         <p> Because the function is not sensitive to locale, results will not always match 
            user expectations. In Quebec, for example, the
                            standard uppercase equivalent of "è" is "È", while
                            in metropolitan France it is more commonly "E"; only one of these is
                            supported by the functions as defined.</p>
         <p> Many characters of class Ll lack uppercase equivalents in the Unicode
                            case mapping tables; many characters of class Lu lack lowercase equivalents.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:upper-case("abCd0")</fos:expression>
               <fos:result>"ABCD0"</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="lower-case">
      <fos:signatures>
         <fos:proto name="lower-case" return-type="xs:string">
            <fos:arg name="arg" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Converts a string to lower case.</p>
      </fos:summary>
      <fos:rules>
         <p>If the value of <code>$arg</code> is the empty sequence, the zero-length
                        string is returned.</p>
         <p>Otherwise, the function returns the value of <code>$arg</code> after translating every character to 
				its lower-case correspondent as defined in the appropriate case 
				mappings section in the Unicode standard <bibref ref="Unicode4"/>. 
				For versions of Unicode beginning with the 2.1.8 update, only 
				locale-insensitive case mappings should be applied.  Beginning with 
				version 3.2.0 (and likely future versions) of Unicode, precise mappings 
				are described in default case operations, which are full case mappings
				in the absence of tailoring for particular languages and environments.
				Every upper-case character that does not have a lower-case correspondent, 
				as well as every lower-case character, is included in the returned value 
				in its original form. 
				</p>
      </fos:rules>
      <fos:notes>
         <p>Case mappings may change the length of a string. In general, the <code>fn:upper-case</code>
				  and <code>fn:lower-case</code> functions are not inverses of each other:
                            <code>fn:lower-case(fn:upper-case($arg))</code> is not guaranteed to
                            return <code>$arg</code>, nor
                            is <code>fn:upper-case(fn:lower-case($arg))</code>. The Latin small
                            letter dotless i (as used in Turkish) is perhaps the most prominent
                            lower-case letter which will not round-trip. The Latin capital letter i
                            with dot above is the most prominent upper-case letter which will not
                            round trip; there are others, such as Latin capital letter Sharp S (#1E9E) which is
							introduced in Unicode 5.1.</p>
         <p> These functions may not always be linguistically appropriate (e.g.
                            Turkish i without dot) or appropriate for the application (e.g.
                            titlecase). In cases such as Turkish, a simple translation should be
                            used first.</p>
         <p> Because the function is not sensitive to locale, results will not always match 
            user expectations. In Quebec, for example, the
            standard uppercase equivalent of "è" is "È", while
            in metropolitan France it is more commonly "E"; only one of these is
            supported by the functions as defined.</p>
         <p> Many characters of class Ll lack uppercase equivalents in the Unicode
                            case mapping tables; many characters of class Lu lack lowercase equivalents.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:lower-case("ABc!D")</fos:expression>
               <fos:result>"abc!d"</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="translate">
      <fos:signatures>
         <fos:proto name="translate" return-type="xs:string">
            <fos:arg name="arg" type="xs:string?"/>
            <fos:arg name="mapString" type="xs:string"/>
            <fos:arg name="transString" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the value of <code>$arg</code> modified by replacing or removing
			   individual characters. </p>
      </fos:summary>
      <fos:rules>
         <p>If the value of <code>$arg</code> is the empty sequence, the function returns the zero-length
                        string.</p>
         <p>Otherwise, the function returns a result string constructed by processing each character in the
			   value of <code>$arg</code>, in order, according to the following rules:</p>
         <olist>
            <item>
               <p>If the character does not appear in the
                        value of <code>$mapString</code> then it is added to the result string unchanged.</p>
            </item>
            <item>
               <p>If the character first appears in the value of <code>$mapString</code>
			   			at some position <emph>M</emph>, where the
                        value of <code>$transString</code> is <emph>M</emph> or more characters in
                        length, then the character at position <emph>M</emph> in <code>$transString</code>
						is added to the result string.</p>
            </item>
            <item>
               <p>If the character first appears in the value of <code>$mapString</code>
			   			at some position <emph>M</emph>, where the
                        value of <code>$transString</code> is less than <emph>M</emph> characters in
                        length, then the character is omitted from the result string.</p>
            </item>
         </olist>
      </fos:rules>
      <fos:notes>
         <p>If <code>$mapString</code> is
                        the zero-length string then the function returns <code>$arg</code> unchanged.</p>
         <p>If a character occurs more than once in <code>$mapString</code>, then the
                        first occurrence determines the action taken.</p>
         <p>If <code>$transString</code> is longer than <code>$mapString</code>, the excess
                        characters are ignored.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:translate("bar","abc","ABC")</fos:expression>
               <fos:result>"BAr"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:translate("--aaa--","abc-","ABC")</fos:expression>
               <fos:result>"AAA"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:translate("abcdabc", "abc", "AB")</fos:expression>
               <fos:result>"ABdAB"</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="encode-for-uri">
      <fos:signatures>
         <fos:proto name="encode-for-uri" return-type="xs:string">
            <fos:arg name="uri-part" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Encodes reserved characters in a string that is 
			   intended to be used in the path segment of a URI.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$uri-part</code> is the empty sequence, the function returns the zero-length string.</p>
         <p>This function applies the URI escaping rules defined in section 2 of <bibref ref="rfc3986"/> to the 
			   <code>xs:string</code> supplied as <code>$uri-part</code>. The effect of the function is to escape reserved characters. 
			   Each such character in the string is replaced with its percent-encoded form as described in <bibref ref="rfc3986"/>.</p>
         <p>Since <bibref ref="rfc3986"/> recommends that, for consistency, URI producers and normalizers should use uppercase 
			   hexadecimal digits for all percent-encodings, this function must always generate hexadecimal values using the upper-case letters A-F.</p>
      </fos:rules>
      <fos:notes>
         <p>All characters are escaped except those identified as "unreserved" by <bibref ref="rfc3986"/>, 
			   that is the upper- and lower-case letters A-Z, the digits 0-9, HYPHEN-MINUS ("-"), LOW LINE ("_"), FULL STOP ".", and TILDE "~".</p>
         <p>This function escapes URI delimiters and therefore cannot be used indiscriminately to encode 
			   "invalid" characters in a path segment.</p>
         <p>This function is invertible but not idempotent. This is because a string containing a percent character
			   will be modified by applying the function: for example <code>100%</code> becomes <code>100%25</code>, 
			   while <code>100%25</code> becomes <code>100%2525</code>.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:encode-for-uri("http://www.example.com/00/Weather/CA/Los%20Angeles#ocean")</fos:expression>
               <fos:result>"http%3A%2F%2Fwww.example.com%2F00%2FWeather%2FCA%2FLos%2520Angeles%23ocean"</fos:result>
               <fos:postamble>This is probably not what the user intended because all of the delimiters
      have been encoded.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>concat("http://www.example.com/", encode-for-uri("~bébé"))</fos:expression>
               <fos:result>"http://www.example.com/~b%C3%A9b%C3%A9"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>concat("http://www.example.com/", encode-for-uri("100% organic"))</fos:expression>
               <fos:result>"http://www.example.com/100%25%20organic"</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="iri-to-uri">
      <fos:signatures>
         <fos:proto name="iri-to-uri" return-type="xs:string">
            <fos:arg name="iri" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Converts a string containing an IRI into a URI according
			    to the rules of <bibref ref="rfc3987"/>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$iri</code> is the empty sequence, the function returns the zero-length string.</p>
         <p>Otherwise, the function converts the value of <code>$iri</code> into a URI according
			    to the rules given in Section 3.1 of <bibref ref="rfc3987"/> by percent-encoding characters that are allowed
				in an IRI but not in a URI. If <code>$iri</code> contains a character that is invalid in an IRI, such as the space character (see note below), the invalid character is 
                replaced by its percent-encoded form as described in <bibref ref="rfc3986"/> before the conversion is performed.</p>
         <p>Since <bibref ref="rfc3986"/> recommends that, for consistency, URI producers and normalizers should use uppercase
				 hexadecimal digits for all percent-encodings, this function must always generate hexadecimal values using the upper-case
				 letters A-F.</p>
	  </fos:rules>			 
      <fos:notes>
            <p>The function is idempotent but not invertible. Both the inputs <code>My Documents</code> and <code>My%20Documents</code> 
				  will be converted to the output <code>My%20Documents</code>.</p>
            <p>This function does not check whether <code>$iri</code> is a legal IRI.  
				  It treats it as an <code>xs:string</code> and operates on the characters in the <code>xs:string</code>.</p>
            <!--Text replaced by erratum E8 change 1"--><p>
		The following printable ASCII characters are invalid in an IRI:
		"&lt;", "&gt;", <quote> " </quote> (double quote), space, "{", "}",
		 "|", "\", "^", and "`".  Since these characters should not appear
		  in an IRI, if they do appear in <code>$iri</code> they will be 
		  percent-encoded. In addition, characters outside the range x20-<phrase diff="chg" at="A-E8">x7E</phrase> 
		  will be percent-encoded because they are invalid in a URI.
		</p>
            <!--End of text replaced by erratum E8--><p>
  Since this function does not escape the PERCENT SIGN "%" and this
  character is not allowed in data within a URI, users wishing to
  convert character strings (such as file names) that include "%" to a
  URI should manually escape "%" by replacing it with "%25".
</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:iri-to-uri
                                        ("http://www.example.com/00/Weather/CA/Los%20Angeles#ocean")</fos:expression>
               <fos:result>"http://www.example.com/00/Weather/CA/Los%20Angeles#ocean"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:iri-to-uri
                                        ("http://www.example.com/~bébé")</fos:expression>
               <fos:result>"http://www.example.com/~b%C3%A9b%C3%A9"</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="escape-html-uri">
      <fos:signatures>
         <fos:proto name="escape-html-uri" return-type="xs:string">
            <fos:arg name="uri" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary:  Escapes a URI in the 
			   same way that HTML user agents handle attribute values expected to contain URIs.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$uri</code> is the empty sequence, the function returns the zero-length string.</p>
         <p>Otherwise, the function escapes all characters except printable characters of the US-ASCII coded character set, 
			   specifically the codepoints between 32 and 126 (decimal) inclusive. Each character in <code>$uri</code> to be 
			   escaped is replaced by an escape sequence, which is formed by encoding the character as a sequence of octets 
			   in UTF-8, and then representing each of these octets in the form %HH, where HH is the hexadecimal representation
			   of the octet.  This function must always generate hexadecimal values using the upper-case letters A-F.</p>
      </fos:rules>
      <fos:notes>
         <p>The behavior of this function corresponds to the recommended handling 
                 of non-ASCII characters in URI attribute values as described in <bibref ref="HTML40"/> Appendix B.2.1.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:escape-html-uri
                                ("http://www.example.com/00/Weather/CA/Los Angeles#ocean")</fos:expression>
               <fos:result>"http://www.example.com/00/Weather/CA/Los Angeles#ocean"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:escape-html-uri
                                ("javascript:if (navigator.browserLanguage == 'fr') window.open('http://www.example.com/~bébé');")</fos:expression>
               <fos:result>"javascript:if (navigator.browserLanguage == 'fr') window.open('http://www.example.com/~b%C3%A9b%C3%A9');"</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="contains">
      <fos:signatures>
         <fos:proto name="contains" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:string?"/>
            <fos:arg name="arg2" type="xs:string?"/>
         </fos:proto>
         <fos:proto name="contains" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:string?"/>
            <fos:arg name="arg2" type="xs:string?"/>
            <fos:arg name="collation" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns true if the string <code>$arg1</code> contains <code>$arg2</code>
			   as a substring, taking collations into account.</p>
      </fos:summary>
      <fos:rules>
         <p>If the value of <code>$arg1</code> or <code>$arg2</code> is the empty
                        sequence, or contains only ignorable collation units, it is interpreted as the zero-length string.</p>
         <p>If the value of <code>$arg2</code> is the zero-length string, then the
                        function returns <code>true</code>.</p>
         <p>If the value of <code>$arg1</code> is the zero-length string, the function
                        returns <code>false</code>.</p>
         <p>The collation used by this function is determined according
                        to the rules in <specref ref="choosing-a-collation"/>.</p>
         <p>The function returns an <code>xs:boolean</code> indicating whether or not the
                        value of <code>$arg1</code> contains (at the beginning, at the end, or
                        anywhere within) at least one sequence of collation units that provides a
                        <term>minimal match</term> to the collation units in the value of <code>$arg2</code>,
                        according to the collation that is used.</p>
         <note>
            <p><term>Minimal match</term> is defined in <bibref ref="Unicode-Collations"/>. </p>
         </note>
         
      </fos:rules>
      <fos:errors>
         <p>If the specified collation does not support collation units an error 
            <termref def="may"/> be raised <errorref class="CH" code="0004"/>.</p>
      </fos:errors>
      <fos:examples>
         <fos:example>
            <p>The collation used in these examples, <code>http://example.com/CollationA</code> 
				  is a collation in which both "-" and
                            "*" are ignorable collation units.</p>
            <p>"Ignorable collation unit" is equivalent to "ignorable collation
                                element" in <bibref ref="Unicode-Collations"/>.</p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:contains ( "tattoo", "t")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:contains ( "tattoo", "ttt")</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:contains ( "", ())</fos:expression>
               <fos:result>true()</fos:result>
               <fos:postamble>The first rule is applied, followed by the second rule.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:contains ( "abcdefghi", "-d-e-f-", "http://example.com/CollationA")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:contains ( "a*b*c*d*e*f*g*h*i*", "d-ef-",
                                    "http://example.com/CollationA")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:contains ( "abcd***e---f*--*ghi", "def",
                                    "http://example.com/CollationA")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:contains ( (), "--***-*---", "http://example.com/CollationA")</fos:expression>
               <fos:result>true()</fos:result>
               <fos:postamble>The second argument contains only
                                    ignorable collation units and is equivalent to the zero-length string.</fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="starts-with">
      <fos:signatures>
         <fos:proto name="starts-with" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:string?"/>
            <fos:arg name="arg2" type="xs:string?"/>
         </fos:proto>
         <fos:proto name="starts-with" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:string?"/>
            <fos:arg name="arg2" type="xs:string?"/>
            <fos:arg name="collation" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns true if the string <code>$arg1</code> contains <code>$arg2</code>
			   as a leading substring, taking collations into account.</p>
      </fos:summary>
      <fos:rules>
         <p>If the value of <code>$arg1</code> or <code>$arg2</code> is the empty
                        sequence, or contains only ignorable collation units, it is interpreted as the zero-length string.</p>
         <p>If the value of <code>$arg2</code> is the zero-length string, then the
                        function returns <code>true</code>. If the value of <code>$arg1</code> is
                        the zero-length string and the value of <code>$arg2</code> is not the
                        zero-length string, then the function returns <code>false</code>.</p>
         <p>The collation used by this function is determined according
                        to the rules in <specref ref="choosing-a-collation"/>.</p>
         <p>The function returns an <code>xs:boolean</code> indicating whether or not the
                        value of <code>$arg1</code> starts with a sequence of collation units that
                        provides a <term>match</term> to the collation units of <code>$arg2</code>
                        according to the collation that is used.</p>
         <note>
            <p><term>Match</term> is defined in <bibref ref="Unicode-Collations"/>.</p>
         </note>
         
      </fos:rules>
      <fos:errors>
         <p>If the specified collation does not support collation units an error 
            <termref def="may"/> be raised <errorref class="CH" code="0004"/>.</p>
      </fos:errors>
      <fos:examples>
         <fos:example>
            <p>The collation used in these examples, <code>http://example.com/CollationA</code> 
				  is a collation in which both "-" and
                            "*" are ignorable collation units.</p>
            <p>"Ignorable collation unit" is equivalent to "ignorable collation
                                element" in <bibref ref="Unicode-Collations"/>.</p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:starts-with("tattoo", "tat")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:starts-with ( "tattoo", "att")</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:starts-with ((), ())</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:starts-with ( "abcdefghi", "-a-b-c-",
                                    "http://example.com/CollationA")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:starts-with ( "a*b*c*d*e*f*g*h*i*", "a-bc-",
                                    "http://example.com/CollationA")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:starts-with ( "abcd***e---f*--*ghi", "abcdef",
                                    "http://example.com/CollationA")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:starts-with ( (), "--***-*---", "http://example.com/CollationA")</fos:expression>
               <fos:result>true()</fos:result>
               <fos:postamble>The second argument contains only
                                    ignorable collation units and is equivalent to the zero-length string.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:starts-with ( "-abcdefghi", "-abc", "http://example.com/CollationA")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="ends-with">
      <fos:signatures>
         <fos:proto name="ends-with" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:string?"/>
            <fos:arg name="arg2" type="xs:string?"/>
         </fos:proto>
         <fos:proto name="ends-with" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:string?"/>
            <fos:arg name="arg2" type="xs:string?"/>
            <fos:arg name="collation" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns true if the string <code>$arg1</code> contains <code>$arg2</code>
			   as a trailing substring, taking collations into account.</p>
      </fos:summary>
      <fos:rules>
         <p>If the value of <code>$arg1</code> or <code>$arg2</code> is the empty
                        sequence, or contains only ignorable collation units, it is interpreted as the zero-length string.</p>
         <p>If the value of <code>$arg2</code> is the zero-length string, then the
                        function returns <code>true</code>. If the value of <code>$arg1</code> is
                        the zero-length string and the value of <code>$arg2</code> is not the
                        zero-length string, then the function returns <code>false</code>.</p>
         <p>The collation used by this function is determined according
                        to the rules in <specref ref="choosing-a-collation"/>.</p>
         <p>The function returns an <code>xs:boolean</code> indicating whether or not the
                        value of <code>$arg1</code> starts with a sequence of collation units that
                        provides a <term>match</term> to the collation units of <code>$arg2</code>
                        according to the collation that is used.</p>
         <note>
            <p>
                     <term>Match</term> is defined in <bibref ref="Unicode-Collations"/>. </p>
         </note>
         
      </fos:rules>
      <fos:errors>
         <p>If the specified collation does not support collation units an error 
            <termref def="may"/> be raised <errorref class="CH" code="0004"/>.</p>
      </fos:errors>
      <fos:examples>
         <fos:example>
            <p>The collation used in these examples, <code>http://example.com/CollationA</code> 
				  is a collation in which both "-" and
                            "*" are ignorable collation units.</p>
            <p>"Ignorable collation unit" is equivalent to "ignorable collation
                                element" in <bibref ref="Unicode-Collations"/>.</p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:ends-with ( "tattoo", "tattoo")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:ends-with ( "tattoo", "atto")</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:ends-with ((), ())</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:ends-with ( "abcdefghi", "-g-h-i-",
                                    "http://example.com/CollationA")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:ends-with ( "abcd***e---f*--*ghi", "defghi",
                                    "http://example.com/CollationA")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:ends-with ( "abcd***e---f*--*ghi", "defghi",
                                    "http://example.com/CollationA")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:ends-with ( (), "--***-*---", "http://example.com/CollationA")</fos:expression>
               <fos:result>true()</fos:result>
               <fos:postamble>The second argument contains only
                                    ignorable collation units and is equivalent to the zero-length string.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:ends-with ( "abcdefghi", "ghi-", "http://example.com/CollationA")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="substring-before">
      <fos:signatures>
         <fos:proto name="substring-before" return-type="xs:string">
            <fos:arg name="arg1" type="xs:string?"/>
            <fos:arg name="arg2" type="xs:string?"/>
         </fos:proto>
         <fos:proto name="substring-before" return-type="xs:string">
            <fos:arg name="arg1" type="xs:string?"/>
            <fos:arg name="arg2" type="xs:string?"/>
            <fos:arg name="collation" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the part of <code>$arg1</code> that precedes the first
			   occurrence of <code>$arg2</code>, taking collations into account.</p>
      </fos:summary>
      <fos:rules>
         <p> If the value of <code>$arg1</code> or <code>$arg2</code> is the empty
                        sequence, or contains only ignorable collation units, it is interpreted as the zero-length string.</p>
         <p>If the value of <code>$arg2</code> is the zero-length string, then the
                        function returns the zero-length string. </p>
         <p>If the value of <code>$arg1</code> does not contain a string that is equal to
                        the value of <code>$arg2</code>, then the function returns the zero-length
                        string. </p>
         <p>The collation used by this function is determined according
                        to the rules in <specref ref="choosing-a-collation"/>.</p>
         <p>The function returns the substring of the value of <code>$arg1</code> that
                        precedes in the value of <code>$arg1</code> the first occurrence of a
                        sequence of collation units that provides a <term>minimal match</term> to the collation
                        units of <code>$arg2</code> according to the collation that is used.</p>
         <note>
            <p><term>Minimal match</term> is defined in <bibref ref="Unicode-Collations"/>. </p>
         </note>
         
      </fos:rules>
      <fos:errors>
         <p>If the specified collation does not support collation units an error 
            <termref def="may"/> be raised <errorref class="CH" code="0004"/>.</p>
      </fos:errors>
      <fos:examples>
         <fos:example>
            <p>The collation used in these examples, <code>http://example.com/CollationA</code> 
				  is a collation in which both "-" and
                            "*" are ignorable collation units.</p>
            <p>"Ignorable collation unit" is equivalent to "ignorable collation
                                element" in <bibref ref="Unicode-Collations"/>.</p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring-before ( "tattoo", "attoo")</fos:expression>
               <fos:result>"t"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring-before ( "tattoo", "tatto")</fos:expression>
               <fos:result>""</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring-before ((), ())</fos:expression>
               <fos:result>""</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring-before ( "abcdefghi", "--d-e-",
                                    "http://example.com/CollationA")</fos:expression>
               <fos:result>"abc"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring-before ( "abc--d-e-fghi", "--d-e-",
                                    "http://example.com/CollationA")</fos:expression>
               <fos:result>"abc--"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring-before ( "a*b*c*d*e*f*g*h*i*", "***cde",
                                    "http://example.com/CollationA")</fos:expression>
               <fos:result>"a*b*"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring-before ( "Eureka!", "--***-*---",
                                    "http://example.com/CollationA")</fos:expression>
               <fos:result>""</fos:result>
               <fos:postamble>The second argument
                                    contains only ignorable collation units and is equivalent to the
                                    zero-length string.</fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="substring-after">
      <fos:signatures>
         <fos:proto name="substring-after" return-type="xs:string">
            <fos:arg name="arg1" type="xs:string?"/>
            <fos:arg name="arg2" type="xs:string?"/>
         </fos:proto>
         <fos:proto name="substring-after" return-type="xs:string">
            <fos:arg name="arg1" type="xs:string?"/>
            <fos:arg name="arg2" type="xs:string?"/>
            <fos:arg name="collation" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the part of <code>$arg1</code> that follows the first
			   occurrence of <code>$arg2</code>, taking collations into account.</p>
      </fos:summary>
      <fos:rules>
         <p>If the value of <code>$arg1</code> or <code>$arg2</code> is the empty
                        sequence, or contains only ignorable collation units, it is interpreted as the zero-length string.</p>
         <p>If the value of <code>$arg2</code> is the zero-length string, then the
                        function returns the value of <code>$arg1</code>.</p>
         <p>If the value of <code>$arg1</code> does not contain a string that is equal to
                        the value of <code>$arg2</code>, then the function returns the zero-length
                        string. </p>
         <p>The collation used by this function is determined according
                        to the rules in <specref ref="choosing-a-collation"/>.</p>
         <p>The function returns the substring of the value of <code>$arg1</code> that
                        follows in the value of <code>$arg1</code> the first occurrence of a
                        sequence of collation units that provides a <term>minimal match</term> to the collation
                        units of <code>$arg2</code> according to the collation that is used. </p>
         <note>
            <p><term>Minimal match</term> is defined in <bibref ref="Unicode-Collations"/>. </p>
         </note>
         
      </fos:rules>
      <fos:errors>
         <p>If the specified collation does not support collation units an error 
            <termref def="may"/> be raised <errorref class="CH" code="0004"/>.</p>
      </fos:errors><fos:examples>
         <fos:example>
            <p>The collation used in these examples, <code>http://example.com/CollationA</code> 
				  is a collation in which both "-" and
                            "*" are ignorable collation units.</p>
            <p>"Ignorable collation unit" is equivalent to "ignorable collation
                                element" in <bibref ref="Unicode-Collations"/>.</p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring-after("tattoo", "tat")</fos:expression>
               <fos:result>"too"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring-after("tattoo", "tattoo")</fos:expression>
               <fos:result>""</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring-after((), ())</fos:expression>
               <fos:result>""</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression> fn:substring-after("abcdefghi", "--d-e-",
                                    "http://example.com/CollationA")</fos:expression>
               <fos:result>"fghi"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring-after("abc--d-e-fghi", "--d-e-",
                                    "http://example.com/CollationA")</fos:expression>
               <fos:result>"-fghi"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring-after ( "a*b*c*d*e*f*g*h*i*", "***cde***",
                                    "http://example.com/CollationA")</fos:expression>
               <fos:result>"*f*g*h*i*"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring-after ( "Eureka!", "--***-*---",
                                    "http://example.com/CollationA")</fos:expression>
               <fos:result>"Eureka!"</fos:result>
               <fos:postamble>The second argument contains only ignorable collation
                                    units and is equivalent to the zero-length string.</fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="matches">
      <fos:signatures>
         <fos:proto name="matches" return-type="xs:boolean">
            <fos:arg name="input" type="xs:string?"/>
            <fos:arg name="pattern" type="xs:string"/>
         </fos:proto>
         <fos:proto name="matches" return-type="xs:boolean">
            <fos:arg name="input" type="xs:string?"/>
            <fos:arg name="pattern" type="xs:string"/>
            <fos:arg name="flags" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns true if the supplied string matches a given regular expression.</p>
      </fos:summary>
      <fos:rules>
         <p>The effect of calling the first version of this function (omitting the
                        argument <code>$flags</code>) is the same as the effect of calling the
                        second version with the <code>$flags</code> argument set to a zero-length
                        string. Flags are defined in <specref ref="flags"/>.</p>
         <p>If <code>$input</code> is the empty sequence, it is interpreted as the
                        zero-length string.</p>
         <p>The function returns <code>true</code> if <code>$input</code> or some substring of <code>$input</code>
                        matches the regular expression supplied as <code>$pattern</code>. Otherwise, the function
                        returns <code>false</code>. The matching rules are
                        influenced by the value of <code>$flags</code> if present. </p>
         
      </fos:rules>
      <fos:errors>
         <p>An error is raised <errorref class="RX" code="0002"/> if the value of
            <code>$pattern</code> is invalid according to the rules described in 
            <specref ref="regex-syntax"/>. </p>
         <p>An error is raised <errorref class="RX" code="0001"/> if the value of
            <code>$flags</code> is invalid according to the rules described in 
            <specref ref="flags"/>. </p>
      </fos:errors>
      <fos:notes>
         <p>Unless the metacharacters <code>^</code> and <code>$</code> are used as
                        anchors, the string is considered to match the pattern if any substring
                        matches the pattern. But if anchors are used, the anchors must match the
                        start/end of the string (in string mode), or the start/end of a line (in
                        multiline mode). </p>
         <p>This is different from the behavior of patterns in <bibref ref="xmlschema-2"/>, 
				  where regular expressions are <emph>implicitly</emph> anchored.</p>
         <p>Regular expression matching is defined on the basis of Unicode code
                                points; it takes no account of collations.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:matches("abracadabra", "bra")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:matches("abracadabra", "^a.*a$")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:matches("abracadabra", "^bra")</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example><p>Given the source document:</p></fos:example>
         <fos:variable name="poem" as="element()">&lt;poem author="Wilhelm Busch"&gt; 
Kaum hat dies der Hahn gesehen,
Fängt er auch schon an zu krähen:
Kikeriki! Kikikerikih!!
Tak, tak, tak! - da kommen sie.
&lt;/poem&gt;</fos:variable>
         <fos:example><p>the following function calls produce the following results, with the
                            <code>poem</code> element as the context node:</p></fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:matches($poem, "Kaum.*krähen")</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:matches($poem, "Kaum.*krähen", "s")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:matches($poem, "^Kaum.*gesehen,$", "m")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:matches($poem, "^Kaum.*gesehen,$")</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:matches($poem, "kiki", "i")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="replace">
      <fos:signatures>
         <fos:proto name="replace" return-type="xs:string">
            <fos:arg name="input" type="xs:string?"/>
            <fos:arg name="pattern" type="xs:string"/>
            <fos:arg name="replacement" type="xs:string"/>
         </fos:proto>
         <fos:proto name="replace" return-type="xs:string">
            <fos:arg name="input" type="xs:string?"/>
            <fos:arg name="pattern" type="xs:string"/>
            <fos:arg name="replacement" type="xs:string"/>
            <fos:arg name="flags" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns a string produced from the input string by replacing any substrings
			   that match a given regular expression with a supplied replacement string.</p>
      </fos:summary>
      <fos:rules>
         <p>The effect of calling the first version of this function (omitting the
                        argument <code>$flags</code>) is the same as the effect of calling the
                        second version with the <code>$flags</code> argument set to a zero-length
                        string. Flags are defined in <specref ref="flags"/>.</p>
         <p>The <code>$flags</code> argument is interpreted in the same manner as for the
                        <code>fn:matches</code> function. </p>
         <p>If <code>$input</code> is the empty sequence, it is interpreted as the
                        zero-length string.</p>
         <p>The function returns the <code>xs:string</code> that is obtained by
                        replacing each non-overlapping substring of <code>$input</code> that matches
                        the given <code>$pattern</code> with an occurrence of the
                        <code>$replacement</code> string.</p>
         <p>If two overlapping substrings of <code>$input</code> both match the
                        <code>$pattern</code>, then only the first one (that is, the one whose first
                        character comes first in the <code>$input</code> string) is replaced.</p>
         <p diff="add" at="B">If the <code>q</code> flag is present, the replacement string is used 
            <emph>as is</emph>.</p>
         <p><phrase diff="add" at="B">Otherwise,</phrase> within the <code>$replacement</code> string, 
            a variable <code>$N</code> may be used to refer 
	   to the substring captured by the Nth parenthesized sub-expression in the regular expression. 
	   For each match of the pattern, these variables are assigned the value of the content matched 
	   by the relevant sub-expression, and the modified replacement string is then substituted for 
	   the characters in <code>$input</code> that matched the pattern.  <code>$0</code> refers 
	   to the substring captured by the regular expression as a whole.</p>
         <p>More specifically, the rules are as follows, where <code>S</code> is the number of parenthesized 
	   sub-expressions in the regular expression, and <code>N</code> is the decimal number formed by taking 
	   all the digits that consecutively follow the <code>$</code> character:</p>
         
         <olist><item><p>If <code>N</code>=<code>0</code>, then the variable is replaced by the substring 
		matched by the regular expression as a whole.</p>
               </item>
               <item>
                  <p>If <code>1</code>&lt;=<code>N</code>&lt;=<code>S</code>, then the variable is 
		replaced by the substring captured by the Nth parenthesized sub-expression. If the 
		<code>Nth</code> parenthesized sub-expression was not matched, then the variable 
		is replaced by the zero-length string.</p>
               </item>
               <item>
                  <p>If <code>S</code>&lt;<code>N</code>&lt;=<code>9</code>, then the variable is 
		replaced by the zero-length string.</p>
               </item>
               <item>
                  <p>Otherwise (if <code>N</code>&gt;<code>S</code> and <code>N</code>&gt;<code>9</code>), 
		the last digit of <code>N</code> is taken to be a literal character to be included 
		"as is" in the replacement string, and the rules are reapplied using the number 
		<code>N</code> formed by stripping off this last digit.</p>
               </item>
         </olist>
            
         <p>For example, if the replacement string is <quote>
                     <code>$23</code>
                  </quote> and there are 5 substrings, the result contains the value of the substring that matches the second sub-expression, followed by the digit <quote>
                     <code>3</code>
                  </quote>.</p>
         <p diff="chg" at="B">Unless the <code>q</code> flag is used, a literal <code>$</code> character 
            within the replacement string must be written as
         <code>\$</code>, and a literal <code>\</code> character must be written as <code>\\</code>.</p>
         
         <p> If two alternatives within the pattern both match at the same position in
                        the <code>$input</code>, then the match that is chosen is the one matched by
                        the first alternative. For example:</p>
         <eg xml:space="preserve"> fn:replace("abcd", "(ab)|(a)", "[1=$1][2=$2]") returns "[1=ab][2=]cd"</eg>
         
      </fos:rules>
      <fos:errors>
         <p>An error is raised <errorref class="RX" code="0002"/> if the value of
            <code>$pattern</code> is invalid according to the rules described in section
            <specref ref="regex-syntax"/>. </p>
         <p>An error is raised <errorref class="RX" code="0001"/> if the value of
            <code>$flags</code> is invalid according to the rules described in section
            <specref ref="regex-syntax"/>. </p>
         <p>An error is raised <errorref class="RX" code="0003"/> if the pattern matches
            a zero-length string, that is, if the expression <code>fn:matches("",
               $pattern, $flags)</code> returns <code>true</code>. It is not an error,
            however, if a captured substring is zero-length.</p>
         <p>An error is raised <errorref class="RX" code="0004"/> if the value of
            <code>$replacement</code> contains a "<code>$</code>" character that is not
            immediately followed by a digit <code>0-9</code> and not immediately
            preceded by a "\".</p>
         <p>An error is raised <errorref class="RX" code="0004"/> if the value of
            <code>$replacement</code> contains a "<code>\</code>" character that is not
            part of a "<code>\\</code>" pair, unless it is immediately followed by a
            "<code>$</code>" character.</p>         
      </fos:errors>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>replace("abracadabra", "bra", "*")</fos:expression>
               <fos:result>"a*cada*"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>replace("abracadabra", "a.*a", "*")</fos:expression>
               <fos:result>"*"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>replace("abracadabra", "a.*?a", "*")</fos:expression>
               <fos:result>"*c*bra"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>replace("abracadabra", "a", "")</fos:expression>
               <fos:result>"brcdbr"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>replace("abracadabra", "a(.)", "a$1$1")</fos:expression>
               <fos:result>"abbraccaddabbra"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <p>The expression <code>replace("abracadabra", ".*?", "$1")</code> raises an
                    error, because the pattern matches the zero-length string </p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>replace("AAAA", "A+", "b")</fos:expression>
               <fos:result>"b"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>replace("AAAA", "A+?", "b")</fos:expression>
               <fos:result>"bbbb"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>replace("darted", "^(.*?)d(.*)$", "$1c$2")</fos:expression>
               <fos:result>"carted"</fos:result>
               <fos:postamble>The first <code>d</code> is replaced.</fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="tokenize">
      <fos:signatures>
         <fos:proto name="tokenize" return-type="xs:string*">
            <fos:arg name="input" type="xs:string?"/>
            <fos:arg name="pattern" type="xs:string"/>
         </fos:proto>
         <fos:proto name="tokenize" return-type="xs:string*">
            <fos:arg name="input" type="xs:string?"/>
            <fos:arg name="pattern" type="xs:string"/>
            <fos:arg name="flags" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns a sequence of strings constructed by splitting the input
			     wherever a separator is found; the separator is any substring that matches
				 a given regular expression.</p>
      </fos:summary>
      <fos:rules>
         <p>The effect of calling the first version of this function (omitting the
                        argument <code>$flags</code>) is the same as the effect of calling the
                        second version with the <code>$flags</code> argument set to a zero-length
                        string. Flags are defined in <specref ref="flags"/>.</p>
         <p>The <code>$flags</code> argument is interpreted in the same way as for the
                        <code>fn:matches</code> function.</p>
         <p>If <code>$input</code> is the empty sequence, or if <code>$input</code> is the zero-length string, 
			   the function returns the empty sequence.</p>
         
         <p>The function returns a sequence of strings formed by breaking the <code>$input</code> string into a sequence
                        of strings, treating any substring that matches <code>$pattern</code> as a
                        separator. The separators themselves are not returned.</p>
         <p>If a separator occurs at the start of the <code>$input</code> string, the
                        result sequence will start with a zero-length string. Zero-length strings
                        will also occur in the result sequence if a separator occurs at the end of
                        the <code>$input</code> string, or if two adjacent substrings match the
                        supplied <code>$pattern</code>.</p>
         <p> If two alternatives within the supplied <code>$pattern</code> both match at
                        the same position in the <code>$input</code> string, then the match that is
                        chosen is the first. For example:</p>
         <eg xml:space="preserve"> fn:tokenize("abracadabra", "(ab)|(a)") returns ("", "r", "c", "d", "r", "")</eg>
         
      </fos:rules>
      <fos:errors>
         <p> An error is raised <errorref class="RX" code="0002"/> if the value of
            <code>$pattern</code> is invalid according to the rules described in section
            <specref ref="regex-syntax"/>.</p>
         <p> An error is raised <errorref class="RX" code="0001"/> if the value of
            <code>$flags</code> is invalid according to the rules described in section
            <specref ref="regex-syntax"/>.</p>
         <p>If the supplied <code>$pattern</code> matches a zero-length string, that is,
                        if <code>fn:matches("", $pattern, $flags)</code> returns <code>true</code>,
                        then an error is raised: <errorref class="RX" code="0003"/>. </p>
         
      </fos:errors>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:tokenize("The cat sat on the mat", "\s+")</fos:expression>
               <fos:result>("The", "cat", "sat", "on", "the", "mat")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:tokenize("1, 15, 24, 50", ",\s*")</fos:expression>
               <fos:result>("1", "15", "24", "50")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:tokenize("1,15,,24,50,", ",")</fos:expression>
               <fos:result>("1", "15", "", "24", "50", "")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <p><code>fn:tokenize("abba", ".?")</code> raises the error
                                        <errorref class="RX" code="0003"/>.</p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:tokenize("Some unparsed &lt;br&gt; HTML
                                        &lt;BR&gt; text", "\s*&lt;br&gt;\s*", "i")</fos:expression>
               <fos:result>("Some unparsed", "HTML", "text")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="analyze-string" diff="add" at="B">
      <fos:signatures>
         <fos:proto name="analyze-string" return-type="element(fn:analyze-string-result)">
            <fos:arg name="input" type="xs:string?"/>
            <fos:arg name="pattern" type="xs:string"/>
         </fos:proto>
         <fos:proto name="analyze-string" return-type="element(fn:analyze-string-result)">
            <fos:arg name="input" type="xs:string?"/>
            <fos:arg name="pattern" type="xs:string"/>
            <fos:arg name="flags" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Analyzes a string using a regular expression, returning an XML structure that
            identifies which parts of the input string matched or failed to match the regular expression,
            and in the case of matched substrings, which substrings matched each capturing group in the
            regular expression.</p>        
      </fos:summary>
      <fos:rules>
         <p>The effect of calling the first version of this function (omitting the
            argument <code>$flags</code>) is the same as the effect of calling the
            second version with the <code>$flags</code> argument set to a zero-length
            string. Flags are defined in <specref ref="flags"/>.</p>
         <p>The <code>$flags</code> argument is interpreted in the same way as for the
            <code>fn:matches</code> function.</p>
         <p>If <code>$input</code> is the empty sequence the function behaves as if <code>$input</code>
            were the zero-length string. In this situation the result will be an element node with no
            children.</p>       
         <p>The function returns an element node whose local name is <code>analyze-string-result</code>.
            This element and all its descendant elements have the namespace URI 
            <code>http://www.w3.org/2005/xpath-functions</code>. The namespace
            prefix is <termref def="implementation-dependent"/>. 
            The children of this element are a sequence of
            <code>fn:match</code> and <code>fn:non-match</code> elements. 
            This sequence is formed by breaking the <code>$input</code> string into a sequence
            of strings, returning any substring that matches <code>$pattern</code> as the content of
            a <code>match</code> element, and any intervening substring as the content of a <code>non-match</code>
            element.</p>
         <p>More specifically, the function starts at the beginning of the input string and attempts to find
            the first substring that matches the regular expression. If there are several matches, the first
            match is defined to be the one whose starting position comes first in the string. If several
            alternatives within the regular expression both match at the same position in the input string,
            then the match that is chosen is the first alternative that matches. For example, if the input
            string is <code>The quick brown fox jumps</code> and the regular expression is 
            <code>jump|jumps</code>, then the match that is chosen is <code>jump</code>.</p>
         
         <p>Having found the first match, the instruction proceeds to find the second and subsequent
            matches by repeating the search, starting at the first character that was not included
            in the previous match.</p>
         
         <p>The input string is thus partitioned into a sequence of substrings, some of which match
            the regular expression, others which do not match it. Each substring will contain at least
            one character. This sequence is represented in the result by the sequence of <code>fn:match</code>
            and <code>fn:non-match</code> children of the returned element node; the string value
            of the <code>fn:match</code> or <code>fn:non-match</code> element will be the corresponding
            substring of <code>$input</code>, and the string value of the returned element node will
            therefore be the same as <code>$input</code>.</p>
         
         <p>The content of an <code>fn:non-match</code> element is always a single text node.</p>
         
         <p>The content of a <code>fn:match</code> element, however, is in general a sequence of text nodes
            and <code>fn:group</code> element children. An <code>fn:group</code> element with a <code>nr</code>
            attribute having the integer value <var>N</var> identifies the substring captured by the
            <var>Nth</var> parenthesized sub-expression in the regular expression. For each capturing
            subexpression there will be at most one corresponding <code>fn:group</code> element in each 
            <code>fn:match</code> element in the result.</p>
         
         <p>If the function is called twice with the same arguments, it is <termref def="implementation-dependent"/>
         whether the two calls return the same element node or distinct (but deep equal) element nodes.</p>
         
         <p>A schema is defined for the structure of the returned element, containing the definitions below. The
         returned element and its descendants will have type annotations obtained by validating the returned element
         against this schema, unless the function is used in an environment where type annotations are not supported
         (for example, a Basic XSLT Processor), in which case the elements will all be annotated as <code>xs:untyped</code>
         and the attributes as <code>xs:untypedAtomic</code>.</p>
         
         <p><eg><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
    targetNamespace="http://www.w3.org/2005/xpath-functions"
    xmlns:fn="http://www.w3.org/2005/xpath-functions"
    elementFormDefault="qualified"> 

    <xs:element name="analyze-string-result" type="fn:analyze-string-result-type"/>
    <xs:element name="match" type="fn:match-type"/>
    <xs:element name="non-match" type="xs:string"/>
    <xs:element name="group" type="fn:group-type"/>
    
    <xs:complexType name="analyze-string-result-type" mixed="true">
        <xs:choice minOccurs="0" maxOccurs="unbounded">
            <xs:element ref="fn:match"/>
            <xs:element ref="fn:non-match"/>
        </xs:choice>
    </xs:complexType>
        
    <xs:complexType name="match-type" mixed="true">
        <xs:sequence>
            <xs:element ref="fn:group" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    
    <xs:complexType name="group-type" mixed="true">
        <xs:sequence>
            <xs:element ref="fn:group" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="nr" type="xs:positiveInteger"/>
    </xs:complexType>    
 
</xs:schema>
]]></eg></p>
      </fos:rules>
      <fos:errors>
         <p> An error is raised <errorref class="RX" code="0002"/> if the value of
            <code>$pattern</code> is invalid according to the rules described in section
            <specref ref="regex-syntax"/>.</p>
         <p> An error is raised <errorref class="RX" code="0001"/> if the value of
            <code>$flags</code> is invalid according to the rules described in section
            <specref ref="regex-syntax"/>.</p>
         <p>If the supplied <code>$pattern</code> matches a zero-length string, that is,
            if <code>fn:matches("", $pattern, $flags)</code> returns <code>true</code>,
            then an error is raised: <errorref class="RX" code="0003"/>. </p>         
      </fos:errors>
      <fos:examples>
         <fos:example>
            <p>In the following examples, the result document is shown in serialized form, with whitespace between
            the element nodes. This whitespace is not actually present in the result.</p>
         </fos:example>  
         <fos:example>
            <fos:test>
               <fos:expression>fn:analyze-string("The cat sat on the mat.", "\w+")</fos:expression>
               <fos:result><![CDATA[
<analyze-string-result xmlns="http://www.w3.org/2005/xpath-functions">
  <match>The</match>
  <non-match> </non-match>
  <match>cat</match>
  <non-match> </non-match>
  <match>sat</match>
  <non-match> </non-match>
  <match>on</match>
  <non-match> </non-match>
  <match>the</match>
  <non-match> </non-match>
  <match>mat</match>
  <non-match>.</non-match>
</analyze-string-result>]]></fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:analyze-string("2008-12-03", "^(\d+)\-(\d+)\-(\d+)$")</fos:expression>
               <fos:result><![CDATA[
<analyze-string-result xmlns="http://www.w3.org/2005/xpath-functions">
  <match><group nr="1">2008</group>-<group nr="2">12</group>-<group nr="3">03</group></match>
</analyze-string-result>]]></fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:analyze-string("A1,C15,,D24, X50,", "([A-Z])([0-9]+)")</fos:expression>
               <fos:result><![CDATA[
<analyze-string-result xmlns="http://www.w3.org/2005/xpath-functions">                  
  <match><group nr="1">A</group><group nr="2">1</group></match>
  <non-match>,</non-match>
  <match><group nr="1">C</group><group nr="2">15</group></match>
  <non-match>,,</non-match>
  <match><group nr="1">D</group><group nr="2">24</group></match>
  <non-match>, </non-match>
  <match><group nr="1">X</group><group nr="2">50</group></match>
  <non-match>,</non-match>
</analyze-string-result>]]></fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>   
   <fos:function name="resolve-uri" diff="chg" at="F">
      <fos:signatures>
         <fos:proto name="resolve-uri" return-type="xs:anyURI?">
            <fos:arg name="relative" type="xs:string?"/>
         </fos:proto>
         <fos:proto name="resolve-uri" return-type="xs:anyURI?">
            <fos:arg name="relative" type="xs:string?"/>
            <fos:arg name="base" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Resolves a relative IRI reference against an absolute IRI.</p>
      </fos:summary>
      <fos:rules>
         <p>If the second argument is absent, the effect is the same as calling the two-argument function
         with the value of <code>fn:static-base-uri()</code> as the second argument.</p>
         
         <p>The function is defined to operate on IRI references as defined in <bibref ref="rfc3987"/>,
         and the implementation <rfc2119>must</rfc2119> permit all arguments that are legal according to that specification.
         In addition, the implementation <rfc2119>may</rfc2119> accept some or all strings that conform to the rules for (absolute
         or relative) Legacy Extended IRI references as defined in <bibref ref="LEIRI"/>. For the purposes of this section, the terms
         IRI and IRI reference include these extensions, insofar as the implementation chooses to support them.</p>
                         
         <p>If <code>$relative</code> is the empty sequence, the function returns the empty sequence.</p>
         
         <p>If <code>$relative</code> is an absolute IRI (as defined above), then it is returned unchanged.</p>

         <p>Otherwise, the function resolves the relative IRI reference <code>$relative</code> against the base IRI <code>$base</code> using the
         algorithm defined in <bibref ref="rfc3986"/>, adapted by treating any character that would not be legal in
         an RFC3986 URI or relative reference in the same way that RFC3986 treats unreserved characters. 
         No percent-encoding takes place.</p>
         
        
         
      </fos:rules>
      <fos:errors>
         <p>The first form of
            this function resolves <code>$relative</code> against the value of the base-uri property from the
            static context. If the base-uri property is not initialized in the static
            context an error is raised <errorref class="NS" code="0005"/>. </p>
         <p>
            If <code>$relative</code> is not a valid IRI according to the rules of RFC3987,
            extended with an implementation-defined subset of the extensions permitted in LEIRI, or if it is not a suitable relative reference to use 
               as input to the RFC3986 resolution algorithm extended to handle additional unreserved characters, then an error is raised 
               <errorref class="RG" code="0002"/>.
         </p>
         <p>
            If <code>$base</code> is not a valid IRI according to the rules of RFC3987,
            extended with an implementation-defined subset of the extensions permitted in LEIRI, or if it is not a suitable IRI to use as input 
               to the chosen resolution algorithm (for example, if it is a relative IRI reference, 
               if it is a non-hierarchic URI, or if it contains a fragment identifier), 
               then an error is raised <errorref class="RG" code="0002"/>.
         </p>
         <p>
            If the chosen resolution algorithm fails for any other reason then an error is
               raised <errorref class="RG" code="0009"/>.
         </p>         
      </fos:errors>
      <fos:notes>
         <p>Resolving a URI does not dereference it. This is merely a syntactic operation
                        on two character strings.</p>
         <p>The algorithms in the cited RFCs include some variations that are optional or
              recommended rather than mandatory; they also describe some common practices
              that are not recommended, but which are permitted for backwards compatibility.
              Where the cited RFCs permit variations in behavior, so does this specification.
         </p>
         <p>Throughout this family of specifications, the phrase "resolving a relative URI (or IRI) reference" should be understood as using the
         rules of this function, unless otherwise stated.</p>
      </fos:notes>
   </fos:function>
   <fos:function name="true">
      <fos:signatures>
         <fos:proto name="true" return-type="xs:boolean"/>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the <code>xs:boolean</code> value <code>true</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>The result is equivalent to <code>xs:boolean("1")</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:true()</fos:expression>
               <fos:result>xs:boolean(1)</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="false">
      <fos:signatures>
         <fos:proto name="false" return-type="xs:boolean"/>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the <code>xs:boolean</code> value <code>false</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>The result is equivalent to <code>xs:boolean("0")</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:false()</fos:expression>
               <fos:result>xs:boolean(0)</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="boolean-equal">
      <fos:signatures>
         <fos:proto name="boolean-equal" return-type="xs:boolean">
            <fos:arg name="value1" type="xs:boolean"/>
            <fos:arg name="value2" type="xs:boolean"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="eq" types="xs:boolean numeric">Defines the semantics of the "eq" operator on <code>xs:boolean</code> values.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns <code>true</code> if the two arguments are the same boolean value.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns <code>true</code> if both arguments are <code>true</code> or
                        if both arguments are <code>false</code>. It returns <code>false</code> if one
                        of the arguments is <code>true</code> and the other argument is
                        <code>false</code>. </p>
      </fos:rules>
   </fos:function>
   <fos:function name="boolean-less-than">
      <fos:signatures>
         <fos:proto name="boolean-less-than" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:boolean"/>
            <fos:arg name="arg2" type="xs:boolean"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="lt" types="xs:boolean numeric" other-operators="ge">Defines the semantics of the "lt" operator on <code>xs:boolean</code>
                        values. Also used in the definition of the "ge" operator.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns true if the first argument is false and the second is true.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns <code>true</code> if <code>$arg1</code> is
                        <code>false</code> and <code>$arg2</code> is <code>true</code>. Otherwise,
                        it returns <code>false</code>.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="boolean-greater-than">
      <fos:signatures>
         <fos:proto name="boolean-greater-than" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:boolean"/>
            <fos:arg name="arg2" type="xs:boolean"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="gt" types="xs:boolean numeric" other-operators="le">Defines the semantics of the "gt" operator on <code>xs:boolean</code>
                        values. Also used in the definition of the "le" operator.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns true if the first argument is true and the second is false.</p>
      </fos:summary>
      <fos:rules>
         <p>The function call <code>op:boolean-greater-than($A, $B)</code> is defined to return
			   the same result as <code>op:boolean-less-than($B, $A)</code></p>
      </fos:rules>
   </fos:function>
   <fos:function name="boolean">
      <fos:signatures>
         <fos:proto name="boolean" return-type="xs:boolean">
            <fos:arg name="arg" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Computes the effective boolean value of the sequence
                        <code>$arg</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>The function computes the effective boolean value of a sequence, defined according to the
            following rules. See also <xspecref spec="XP" ref="id-ebv"/>.</p>
         <ulist>
            <item>
               <p>If <code>$arg</code> is the empty sequence, <code>fn:boolean</code> returns <code>false</code>.</p>
            </item>
            <item>
               <p>If <code>$arg</code> is a sequence whose first item is a node, <code>fn:boolean</code> returns <code>true</code>.</p>
            </item>
            <item>
               <p>If <code>$arg</code> is a singleton value of type <code>xs:boolean</code> or a derived from <code>xs:boolean</code>, <code>fn:boolean</code> returns <code>$arg</code>.</p>
            </item>
            <item>
               <p>If <code>$arg</code> is a singleton value of type <code>xs:string</code> or a type derived from <code>xs:string</code>, <code>xs:anyURI</code> or a type derived
					  from <code>xs:anyURI</code> or <code>xs:untypedAtomic</code>, <code>fn:boolean</code> returns <code>false</code> if the operand value has zero length; otherwise it returns <code>true</code>.</p>
            </item>
            <item>
               <p>If <code>$arg</code> is a singleton value of any numeric type or a type derived from a numeric type,
					  <code>fn:boolean</code> returns <code>false</code> if the operand value is <code>NaN</code> or is 
					  numerically equal to zero; otherwise it returns <code>true</code>.</p>
            </item>
            <item>
               <p>In all other cases, <code>fn:boolean</code> raises a type error <errorref class="RG" code="0006"/>.</p>
            </item>
         </ulist>
         <p diff="del" at="F">The static semantics of this function are described in [Formal Semantics].</p>
      </fos:rules>
      <fos:notes>
         <p>The result of this function is not necessarily the same as 
             <code>$arg cast as xs:boolean</code>. For example, <code>fn:boolean("false")</code> returns the
             value <code>true</code> whereas <code>"false"cast as
             xs:boolean</code> (which can also be written <code>xs:boolean("false")</code>) returns <code>false</code>.</p>
      </fos:notes>
      <fos:examples>
         <fos:variable name="abc" select="(&quot;a&quot;, &quot;b&quot;, &quot;&quot;)"/>
         <fos:example>
            <p><code>fn:boolean($abc)</code> raises a type error <errorref class="RG" code="0006"/>.</p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:boolean($abc[1])</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:boolean($abc[0])</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:boolean($abc[3])</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="not">
      <fos:signatures>
         <fos:proto name="not" return-type="xs:boolean">
            <fos:arg name="arg" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns <code>true</code> if the effective boolean value of <code>$arg</code>
			   is <code>false</code>, or <code>false</code> if it is <code>true</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>The value of <code>$arg</code> is first reduced to an effective boolean value by
                        applying the <code>fn:boolean()</code> function. The function returns <code>true</code>
                        if the effective boolean value is <code>false</code>, or <code>false</code>
                        if the effective boolean value is <code>true</code>. </p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:not(fn:true())</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:not("false")</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="yearMonthDuration-less-than">
      <fos:signatures>
         <fos:proto name="yearMonthDuration-less-than" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:yearMonthDuration"/>
            <fos:arg name="arg2" type="xs:yearMonthDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="lt" types="xs:yearMonthDuration numeric" other-operators="ge">Defines the semantics of the "lt" operator on
                        <code>xs:yearMonthDuration</code> values. Also used in the definition of the "ge" operator.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns true if <code>$arg1</code> is a shorter duration than <code>$arg2</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If the number of months in the value of <code>$arg1</code> is numerically less
                        than the number of months in the value of <code>$arg2</code>, the function returns true.</p>
         <p>Otherwise, the function returns false.</p>
      </fos:rules>
      <fos:notes>
         <p>Either or both durations may be negative</p>
      </fos:notes>
   </fos:function>
   <fos:function name="yearMonthDuration-greater-than">
      <fos:signatures>
         <fos:proto name="yearMonthDuration-greater-than" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:yearMonthDuration"/>
            <fos:arg name="arg2" type="xs:yearMonthDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="gt" types="xs:yearMonthDuration numeric" other-operators="le">Defines the semantics of the "gt" operator on
                        <code>xs:yearMonthDuration</code> values. Also used in the definition of the "le" operator.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns true if <code>$arg1</code> is a longer duration than <code>$arg2</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>The function call <code>op:yearMonthDuration-greater-than($A, $B)</code> is defined to return
			   the same result as <code>op:yearMonthDuration-less-than($B, $A)</code></p>
      </fos:rules>
   </fos:function>
   <fos:function name="dayTimeDuration-less-than">
      <fos:signatures>
         <fos:proto name="dayTimeDuration-less-than" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:dayTimeDuration"/>
            <fos:arg name="arg2" type="xs:dayTimeDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="lt" types="xs:dayTimeDuration numeric" other-operators="ge">Defines the semantics of the "lt" operator on
                        <code>xs:dayTimeDuration</code> values. Also used in the definition of the "ge" operator.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns true if <code>$arg1</code> is a shorter duration than <code>$arg2</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If the number of seconds in the value of <code>$arg1</code> is numerically less
                        than the number of seconds in the value of <code>$arg2</code>, the function returns true.</p>
         <p>Otherwise, the function returns false.</p>
      </fos:rules>
      <fos:notes>
         <p>Either or both durations may be negative</p>
      </fos:notes>
   </fos:function>
   <fos:function name="dayTimeDuration-greater-than">
      <fos:signatures>
         <fos:proto name="dayTimeDuration-greater-than" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:dayTimeDuration"/>
            <fos:arg name="arg2" type="xs:dayTimeDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="gt" types="xs:dayTimeDuration numeric" other-operators="le">Defines the semantics of the "gt" operator on
                        <code>xs:dayTimeDuration</code> values. Also used in the definition of the "le" operator.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns true if <code>$arg1</code> is a longer duration than <code>$arg2</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>The function call <code>op:dayTimeDuration-greater-than($A, $B)</code> is defined to return
			   the same result as <code>op:dayTimeDuration-less-than($B, $A)</code></p>
      </fos:rules>
   </fos:function>
   <fos:function name="duration-equal">
      <fos:signatures>
         <fos:proto name="duration-equal" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:duration"/>
            <fos:arg name="arg2" type="xs:duration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="eq" types="xs:duration numeric" other-operators="ne">Defines the semantics of the "eq" operators on
                        <code>xs:duration</code> values. Also used in the definition of the "ne" operator.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns true if <code>$arg1</code> and <code>$arg2</code> are durations of the same length.</p>
      </fos:summary>
      <fos:rules>
         <p>If the <code>xs:yearMonthDuration</code> components of <code>$arg1</code> and <code>$arg2</code> are equal 
				and the <code>xs:dayTimeDuration</code> 
				components of <code>$arg1</code> and <code>$arg2</code> are equal, the function returns <code>true</code>.</p>
         <p>Otherwise, the function returns false.</p>
         <p>The semantics of this function are:</p>
         <eg xml:space="preserve">
xs:yearMonthDuration($arg1) div xs:yearMonthDuration('P1M')  eq
xs:yearMonthDuration($arg2) div xs:yearMonthDuration('P1M')
    and
xs:dayTimeDuration($arg1) div xs:dayTimeDuration('PT1S')  eq
xs:dayTimeDuration($arg2) div xs:dayTimeDuration('PT1S')
</eg>
         <p>that is, the function returns <code>true</code> if the months and seconds values of the two durations are equal.</p>
      </fos:rules>
      <fos:notes>
         <p>Note that this function, like any other, may be applied to arguments that are derived from the types given 
			   in the function signature, including the two subtypes <code>xs:dayTimeDuration</code> and <code>xs:yearMonthDuration</code>. 
			   With the exception of the zero-length duration, no instance of <code>xs:dayTimeDuration</code> can ever be equal to 
			   an instance of <code>xs:yearMonthDuration</code>.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:duration-equal(xs:duration("P1Y"), xs:duration("P12M"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:duration-equal(xs:duration("PT24H"), xs:duration("P1D"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:duration-equal(xs:duration("P1Y"), xs:duration("P365D"))</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:duration-equal(xs:yearMonthDuration("P0Y"), xs:dayTimeDuration("P0D"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:duration-equal(xs:yearMonthDuration("P1Y"), xs:dayTimeDuration("P365D"))</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:duration-equal(xs:yearMonthDuration("P2Y"), xs:yearMonthDuration("P24M"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:duration-equal(xs:dayTimeDuration("P10D"), xs:dayTimeDuration("PT240H"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:duration-equal(xs:duration("P2Y0M0DT0H0M0S"), xs:yearMonthDuration("P24M"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:duration-equal(xs:duration("P0Y0M10D"), xs:dayTimeDuration("PT240H"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="years-from-duration">
      <fos:signatures>
         <fos:proto name="years-from-duration" return-type="xs:integer?">
            <fos:arg name="arg" type="xs:duration?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the number of years in a duration.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:integer</code> representing the years component
                        in the value of <code>$arg</code>.  The result is obtained by casting <code>$arg</code> 
						to an <code>xs:yearMonthDuration</code> (see <specref ref="casting-to-durations"/>) 
						and then computing the years component as described in <specref ref="canonical-yearMonthDuration"/>.</p>
         <p>If <code>$arg</code> is a negative duration then the result will be negative..</p>
         <p>If <code>$arg</code> is an <code>xs:dayTimeDuration</code> the function returns 0.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:years-from-duration(xs:yearMonthDuration("P20Y15M"))</fos:expression>
               <fos:result>21</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:years-from-duration(xs:yearMonthDuration("-P15M"))</fos:expression>
               <fos:result>-1</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:years-from-duration(xs:dayTimeDuration("-P2DT15H"))</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="months-from-duration">
      <fos:signatures>
         <fos:proto name="months-from-duration" return-type="xs:integer?">
            <fos:arg name="arg" type="xs:duration?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the number of months in a duration.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:integer</code> representing the months component
                        in the value of <code>$arg</code>.  The result is obtained by casting <code>$arg</code>
						to an <code>xs:yearMonthDuration</code> (see <specref ref="casting-to-durations"/>) 
						and then computing the months component as described in <specref ref="canonical-yearMonthDuration"/>.</p>
         <p>If <code>$arg</code> is a negative duration then the result will be negative..</p>
         <p>If <code>$arg</code> is an <code>xs:dayTimeDuration</code> the function returns 0.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:months-from-duration(xs:yearMonthDuration("P20Y15M"))</fos:expression>
               <fos:result>3</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:months-from-duration(xs:yearMonthDuration("-P20Y18M"))</fos:expression>
               <fos:result>-6</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:months-from-duration(xs:dayTimeDuration("-P2DT15H0M0S"))</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="days-from-duration">
      <fos:signatures>
         <fos:proto name="days-from-duration" return-type="xs:integer?">
            <fos:arg name="arg" type="xs:duration?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the number of days in a duration.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:integer</code> representing the days component
                in the value of <code>$arg</code>.  The result is obtained by casting
				 <code>$arg</code> to an <code>xs:dayTimeDuration</code> (see <specref ref="casting-to-durations"/>)
				  and then computing the days component as described in <specref ref="canonical-dayTimeDuration"/>.</p>
         <p>If <code>$arg</code> is a negative duration then the result will be negative..</p>
         <p>If <code>$arg</code> is an <code>xs:yearMonthDuration</code> the function returns 0.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:days-from-duration(xs:dayTimeDuration("P3DT10H"))</fos:expression>
               <fos:result>3</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:days-from-duration(xs:dayTimeDuration("P3DT55H"))</fos:expression>
               <fos:result>5</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:days-from-duration(xs:yearMonthDuration("P3Y5M"))</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="hours-from-duration">
      <fos:signatures>
         <fos:proto name="hours-from-duration" return-type="xs:integer?">
            <fos:arg name="arg" type="xs:duration?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the number of hours in a duration.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:integer</code> representing the hours component
                        in the value of <code>$arg</code>.  The result is obtained by casting
						 <code>$arg</code> to an <code>xs:dayTimeDuration</code> 
						 (see <specref ref="casting-to-durations"/>) and then computing the hours 
						 component as described in <specref ref="canonical-dayTimeDuration"/>.</p>
         <p>If <code>$arg</code> is a negative duration then the result will be negative..</p>
         <p>If <code>$arg</code> is an <code>xs:yearMonthDuration</code> the function returns 0.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:hours-from-duration(xs:dayTimeDuration("P3DT10H"))</fos:expression>
               <fos:result>10</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:hours-from-duration(xs:dayTimeDuration("P3DT12H32M12S"))</fos:expression>
               <fos:result>12</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:hours-from-duration(xs:dayTimeDuration("PT123H"))</fos:expression>
               <fos:result>3</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:hours-from-duration(xs:dayTimeDuration("-P3DT10H"))</fos:expression>
               <fos:result>-10</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="minutes-from-duration">
      <fos:signatures>
         <fos:proto name="minutes-from-duration" return-type="xs:integer?">
            <fos:arg name="arg" type="xs:duration?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the number of minutes in a duration.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:integer</code> representing the minutes component
                        in the value of <code>$arg</code>.  The result is obtained by casting
						 <code>$arg</code> to an <code>xs:dayTimeDuration</code> 
						 (see <specref ref="casting-to-durations"/>) and then computing the minutes 
						 component as described in <specref ref="canonical-dayTimeDuration"/>.</p>
         <p>If <code>$arg</code> is a negative duration then the result will be negative..</p>
         <p>If <code>$arg</code> is an <code>xs:yearMonthDuration</code> the function returns 0.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:minutes-from-duration(xs:dayTimeDuration("P3DT10H"))</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:minutes-from-duration(xs:dayTimeDuration("-P5DT12H30M"))</fos:expression>
               <fos:result>-30</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="seconds-from-duration">
      <fos:signatures>
         <fos:proto name="seconds-from-duration" return-type="xs:decimal?">
            <fos:arg name="arg" type="xs:duration?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the number of seconds in a duration.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:decimal</code> representing the seconds component
                        in the value of <code>$arg</code>.  The result is obtained by casting
						 <code>$arg</code> to an <code>xs:dayTimeDuration</code>
						  (see <specref ref="casting-to-durations"/>) and then computing
						   the seconds component as described in <specref ref="canonical-dayTimeDuration"/>.</p>
         <p>If <code>$arg</code> is a negative duration then the result will be negative..</p>
         <p>If <code>$arg</code> is an <code>xs:yearMonthDuration</code> the function returns 0.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:seconds-from-duration(xs:dayTimeDuration("P3DT10H12.5S"))</fos:expression>
               <fos:result>12.5</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:seconds-from-duration(xs:dayTimeDuration("-PT256S"))</fos:expression>
               <fos:result>-16.0</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="add-yearMonthDurations">
      <fos:signatures>
         <fos:proto name="add-yearMonthDurations" return-type="xs:yearMonthDuration">
            <fos:arg name="arg1" type="xs:yearMonthDuration"/>
            <fos:arg name="arg2" type="xs:yearMonthDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="+" types="xs:yearMonthDuration numeric">Defines the semantics of the "+" operator on
                        <code>xs:yearMonthDuration</code> values.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns the result of adding two <code>xs:yearMonthDuration</code> values. </p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the result of adding the value of <code>$arg1</code> to the
                        value of <code>$arg2</code>. The result will be an <code>xs:yearMonthDuration</code> whose length in months is
						equal to the length in months of <code>$arg1</code> plus the length in months of <code>$arg2</code>.</p>
         <p>For handling of overflow, see <specref ref="duration-limits"/>.</p>
      </fos:rules>
      <fos:notes>
         <p>Either duration (and therefore the result) may be negative.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:add-yearMonthDurations(xs:yearMonthDuration("P2Y11M"),
                                    xs:yearMonthDuration("P3Y3M"))</fos:expression>
               <fos:result>xs:yearMonthDuration("P6Y2M")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="subtract-yearMonthDurations">
      <fos:signatures>
         <fos:proto name="subtract-yearMonthDurations" return-type="xs:yearMonthDuration">
            <fos:arg name="arg1" type="xs:yearMonthDuration"/>
            <fos:arg name="arg2" type="xs:yearMonthDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="-" types="xs:yearMonthDuration numeric">Defines the semantics of the "-" operator on
                        <code>xs:yearMonthDuration</code> values.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns the result of subtracting one <code>xs:yearMonthDuration</code> value from another. </p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the result of subtracting the value of <code>$arg2</code> from the
                        value of <code>$arg1</code>. The result will be an <code>xs:yearMonthDuration</code> whose length in months is
						equal to the length in months of <code>$arg1</code> minus the length in months of <code>$arg2</code>.</p>
         <p>For handling of overflow, see <specref ref="duration-limits"/>.</p>
      </fos:rules>
      <fos:notes>
         <p>Either duration (and therefore the result) may be negative.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:subtract-yearMonthDurations(xs:yearMonthDuration("P2Y11M"),
                                    xs:yearMonthDuration("P3Y3M"))</fos:expression>
               <fos:result>xs:yearMonthDuration("-P4M")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="multiply-yearMonthDuration">
      <fos:signatures>
         <fos:proto name="multiply-yearMonthDuration" return-type="xs:yearMonthDuration">
            <fos:arg name="arg1" type="xs:yearMonthDuration"/>
            <fos:arg name="arg2" type="xs:double"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="*" types="xs:yearMonthDuration numeric">Defines the semantics of the "*" operator on <code>xs:yearMonthDuration</code> values.</fos:opermap>
      <fos:summary>
         <p diff="chg" at="A-E12">Summary: Returns the result of multiplying the value of <code>$arg1</code> by
                        <code>$arg2</code>. The result is rounded to the nearest month.</p>
      </fos:summary>
      <fos:rules>
         <p diff="chg" at="A-E12">The result is the <code>xs:yearMonthDuration</code> whose length in months is equal
	  to the result of applying the <code>fn:round</code> function to the value obtained by multiplying
	  the length in months of <code>$arg1</code> by the value of <code>$arg2</code>.</p>
         <p>If <code>$arg2</code> is positive or negative zero, the result is a
                        zero-length duration. If <code>$arg2</code> is positive or negative
                        infinity, the result overflows and is handled as discussed in <specref ref="duration-limits"/>. 
                    </p>
         <p>For handling of overflow and underflow, see <specref ref="duration-limits"/>.</p>
      </fos:rules>
      <fos:errors>
         <p>If <code>$arg2</code> is
            <code>NaN</code> an error is raised <errorref class="CA" code="0005"/>.</p>
      </fos:errors>
      <fos:notes>
         <p>Either duration (and therefore the result) may be negative.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test> 
               <fos:expression>op:multiply-yearMonthDuration(xs:yearMonthDuration("P2Y11M"),
               2.3)</fos:expression>
               <fos:result>xs:yearMonthDuration("P6Y9M")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="divide-yearMonthDuration">
      <fos:signatures>
         <fos:proto name="divide-yearMonthDuration" return-type="xs:yearMonthDuration">
            <fos:arg name="arg1" type="xs:yearMonthDuration"/>
            <fos:arg name="arg2" type="xs:double"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="div" types="xs:yearMonthDuration numeric">Defines the semantics of the "div" operator on <code>xs:yearMonthDuration</code> and numeric values.</fos:opermap>
      <fos:summary>
         <p diff="chg" at="A-E12">Summary: Returns the result of dividing the value of <code>$arg1</code> by
                        <code>$arg2</code>. The result is rounded to the nearest month.</p>
      </fos:summary>
      <fos:rules>
         <p diff="chg" at="A-E12">The result is the <code>xs:yearMonthDuration</code> whose length in months is equal
	  to the result of applying the <code>fn:round</code> function to the value obtained by dividing
	  the length in months of <code>$arg1</code> by the value of <code>$arg2</code>.</p>
         <p>If <code>$arg2</code> is positive or negative infinity, the result is a
                        zero-length duration. If <code>$arg2</code> is positive or negative zero,
                        the result overflows and is handled as discussed in <specref ref="duration-limits"/>. 
                    </p>
         <p>For handling of overflow and underflow, see <specref ref="duration-limits"/>.</p>
      </fos:rules>
      <fos:errors>
         <p>If <code>$arg2</code> is
            <code>NaN</code> an error is raised <errorref class="CA" code="0005"/>.</p>
      </fos:errors>
      <fos:notes>
         <p>Either operand (and therefore the result) may be negative.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:divide-yearMonthDuration(xs:yearMonthDuration("P2Y11M"),
                  1.5)</fos:expression>
               <fos:result>xs:yearMonthDuration("P1Y11M")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="divide-yearMonthDuration-by-yearMonthDuration">
      <fos:signatures>
         <fos:proto name="divide-yearMonthDuration-by-yearMonthDuration" return-type="xs:decimal">
            <fos:arg name="arg1" type="xs:yearMonthDuration"/>
            <fos:arg name="arg2" type="xs:yearMonthDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="div" types="xs:yearMonthDuration numeric">Defines the semantics of the "div" operator on <code>xs:yearMonthDuration</code> values.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns the ratio of two <code>xs:yearMonthDuration</code> values.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the result of dividing the length in months of <code>$arg1</code>
                        by the length in months of <code>$arg2</code>, according to the rules of the
						<code>op:numeric-divide</code> function for integer operands.</p>
         <p>For handling of overflow and underflow, see <specref ref="duration-limits"/>.</p>
      </fos:rules>
      <fos:notes>
         <p>Either duration (and therefore the result) may be negative.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:divide-yearMonthDuration-by-yearMonthDuration(xs:yearMonthDuration("P3Y4M"),
                                    xs:yearMonthDuration("-P1Y4M"))</fos:expression>
               <fos:result>-2.5</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <p>The following example demonstrates how to calculate the length of an
               <code>xs:yearMonthDuration</code> value in months:</p>
            <fos:test>
               <fos:expression>op:divide-yearMonthDuration-by-yearMonthDuration(xs:yearMonthDuration("P3Y4M"),
                                    xs:yearMonthDuration("P1M"))</fos:expression>
               <fos:result>40</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="add-dayTimeDurations">
      <fos:signatures>
         <fos:proto name="add-dayTimeDurations" return-type="xs:dayTimeDuration">
            <fos:arg name="arg1" type="xs:dayTimeDuration"/>
            <fos:arg name="arg2" type="xs:dayTimeDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="+" types="xs:dayTimeDuration numeric">Defines the semantics of the "+" operator on
                        <code>xs:dayTimeDuration</code> values.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns the sum of two <code>xs:dayTimeDuration</code> values.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the result of adding the value of <code>$arg1</code> to the
                        value of <code>$arg2</code>. The result is the <code>xs:dayTimeDuration</code> whose
						length in seconds is equal to the sum of the length in seconds of the two input durations.</p>
         <p>For handling of overflow, see <specref ref="duration-limits"/>.</p>
      </fos:rules>
      <fos:notes>
         <p>Either duration (and therefore the result) may be negative.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:add-dayTimeDurations(xs:dayTimeDuration("P2DT12H5M"),
                  xs:dayTimeDuration("P5DT12H"))</fos:expression>
               <fos:result>xs:dayTimeDuration('P8DT5M')</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="subtract-dayTimeDurations">
      <fos:signatures>
         <fos:proto name="subtract-dayTimeDurations" return-type="xs:dayTimeDuration">
            <fos:arg name="arg1" type="xs:dayTimeDuration"/>
            <fos:arg name="arg2" type="xs:dayTimeDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="-" types="xs:dayTimeDuration numeric">Defines the semantics of the "-" operator on
                        <code>xs:dayTimeDuration</code> values.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns the result of subtracting one <code>xs:dayTimeDuration</code> from another.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the result of subtracting the value of <code>$arg2</code>
                        from the value of <code>$arg1</code>. The result is the <code>xs:dayTimeDuration</code> whose
						length in seconds is equal to the length in seconds of <code>$arg1</code> minus the length in seconds
						of <code>$arg2</code>.</p>
         <p>For handling of overflow, see <specref ref="duration-limits"/>.</p>
      </fos:rules>
      <fos:notes>
         <p>Either duration (and therefore the result) may be negative.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:subtract-dayTimeDurations(xs:dayTimeDuration("P2DT12H"),
                  xs:dayTimeDuration("P1DT10H30M"))</fos:expression>
               <fos:result>xs:dayTimeDuration('P1DT1H30M')</fos:result>
            </fos:test>            
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="multiply-dayTimeDuration">
      <fos:signatures>
         <fos:proto name="multiply-dayTimeDuration" return-type="xs:dayTimeDuration">
            <fos:arg name="arg1" type="xs:dayTimeDuration"/>
            <fos:arg name="arg2" type="xs:double"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="*" types="xs:dayTimeDuration numeric">Defines the semantics of the "*" operator on <code>xs:dayTimeDuration</code> and numeric values.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns the result of multiplying a <code>xs:dayTimeDuration</code> by a number.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the result of multiplying the value of <code>$arg1</code> by <code>$arg2</code>. The result
			   is the <code>xs:dayTimeDuration</code> whose length in seconds is equal to the length in seconds of <code>$arg1</code>
			   multiplied by the numeric value <code>$arg2</code>.</p>
         <ednote>
            <edtext>We ought to say whether the calculation is performed using double or decimal arithmetic.</edtext>
         </ednote>
         <p>If <code>$arg2</code> is positive or negative zero, the result is a
                        zero-length duration. If <code>$arg2</code> is positive or negative
                        infinity, the result overflows and is handled as discussed in <specref ref="date-time-duration-conformance"/>. 
                    </p>
         <p>For handling of overflow and underflow, see <specref ref="duration-limits"/>.</p>
      </fos:rules>
      <fos:errors>
         <p>If <code>$arg2</code> is
            <code>NaN</code> an error is raised <errorref class="CA" code="0005"/>.</p>
      </fos:errors>
      <fos:notes>
         <p>Either operand (and therefore the result) may be negative.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:multiply-dayTimeDuration(xs:dayTimeDuration("PT2H10M"),
                  2.1)</fos:expression>
               <fos:result>xs:dayTimeDuration('PT4H33M')</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="divide-dayTimeDuration">
      <fos:signatures>
         <fos:proto name="divide-dayTimeDuration" return-type="xs:dayTimeDuration">
            <fos:arg name="arg1" type="xs:dayTimeDuration"/>
            <fos:arg name="arg2" type="xs:double"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="div" types="xs:dayTimeDuration numeric">Defines the semantics of the "div" operator on <code>xs:dayTimeDuration</code> values.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns the result of multiplying a <code>xs:dayTimeDuration</code> by a number.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the result of dividing the value of <code>$arg1</code> by <code>$arg2</code>. The result
			   is the <code>xs:dayTimeDuration</code> whose length in seconds is equal to the length in seconds of <code>$arg1</code>
			   divided by the numeric value <code>$arg2</code>.</p>
         <p>If <code>$arg2</code> is positive or negative infinity, the result is a
                        zero-length duration. If <code>$arg2</code> is positive or negative zero,
                        the result overflows and is handled as discussed in <specref ref="date-time-duration-conformance"/>. 
                    </p>
         <ednote>
            <edtext>We ought to say whether the calculation is performed using double or decimal arithmetic.</edtext>
         </ednote>
         <p>For handling of overflow and underflow, see <specref ref="duration-limits"/>.</p>
      </fos:rules>
      <fos:errors>
         <p>If <code>$arg2</code> is
            <code>NaN</code> an error is raised <errorref class="CA" code="0005"/></p>
      </fos:errors>
      <fos:notes>
         <p>Either operand (and therefore the result) may be negative.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:divide-dayTimeDuration(xs:dayTimeDuration("P1DT2H30M10.5S"), 1.5)</fos:expression>
               <fos:result>xs:duration("PT17H40M7S")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="divide-dayTimeDuration-by-dayTimeDuration">
      <fos:signatures>
         <fos:proto name="divide-dayTimeDuration-by-dayTimeDuration" return-type="xs:decimal">
            <fos:arg name="arg1" type="xs:dayTimeDuration"/>
            <fos:arg name="arg2" type="xs:dayTimeDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="div" types="xs:dayTimeDuration numeric">Defines the semantics of the "div" operator on <code>xs:dayTimeDuration</code> values.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns the ratio of two <code>xs:dayTimeDuration</code> values, as a decimal number.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the result of dividing the value of <code>$arg1</code>
          by <code>$arg2</code>. The result is the <code>xs:dayTimeDuration</code> whose length in seconds 
	is equal to the length in seconds of <code>$arg1</code>
	divided by the length in seconds of <code>$arg2</code>.
	The calculation is performed by applying <code>op:numeric-divide</code> to the two
           <code>xs:decimal</code> operands.</p>
         <p>For handling of overflow and underflow, see <specref ref="duration-limits"/>.</p>
      </fos:rules>
      <fos:notes>
         <p>Either operand (and therefore the result) may be negative.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:round-half-to-even(
                         op:divide-dayTimeDuration-by-dayTimeDuration(
                                    xs:dayTimeDuration("P2DT53M11S"),
                                    xs:dayTimeDuration("P1DT10H")), 4)</fos:expression>
               <fos:result>1.4378</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <p>This examples shows how to determine the number of seconds in a duration.</p>
            <fos:test>
               <fos:expression>op:divide-dayTimeDuration-by-dayTimeDuration(xs:dayTimeDuration("P2DT53M11S"),
                                    xs:dayTimeDuration("PT1S"))</fos:expression>
               <fos:result>175991.0</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="dateTime">
      <fos:signatures>
         <fos:proto name="dateTime" return-type="xs:dateTime?">
            <fos:arg name="arg1" type="xs:date?"/>
            <fos:arg name="arg2" type="xs:time?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns an <code>xs:dateTime</code> value created by combining an <code>xs:date</code>
			and an <code>xs:time</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If either <code>$arg1</code> or <code>$arg2</code> is the empty sequence the function
			returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:dateTime</code> whose date component is equal to
                    <code>$arg1</code> and whose time component is equal
                    to <code>$arg2</code>.</p>
         <p>The timezone of the result is computed as follows:</p>
         <ulist>
            <item>
               <p>If neither argument has a timezone, the result has no timezone.</p>
            </item>
            <item>
               <p>If exactly one of the arguments has a timezone, or if both arguments have
                            the same timezone, the result has this timezone.</p>
            </item>
         </ulist>
      </fos:rules>
      <fos:errors>
         <p>If the two arguments both have timezones and the timezones are different, an error is
            raised: <errorref class="RG" code="0008"/>
         </p>
      </fos:errors>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:dateTime(xs:date("1999-12-31"), xs:time("12:00:00"))</fos:expression>
               <fos:result>xs:dateTime("1999-12-31T12:00:00")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:dateTime(xs:date("1999-12-31"), xs:time("24:00:00"))</fos:expression>
               <fos:result>xs:dateTime("1999-12-31T00:00:00")</fos:result>
               <fos:postamble>This is because <code>"24:00:00"</code> is an alternate lexical form for <code>"00:00:00"</code></fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="dateTime-equal">
      <fos:signatures>
         <fos:proto name="dateTime-equal" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:dateTime"/>
            <fos:arg name="arg2" type="xs:dateTime"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="eq" types="xs:dateTime numeric" other-operators="ne le ge">Defines the semantics of the "eq" operator on
                        <code>xs:dateTime</code> values. Also used in the definition of the "ne", "le" and "ge" operators.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns true if the two supplied <code>xs:dateTime</code> values refer to the same instant in time.</p>
      </fos:summary>
      <fos:rules>
         <p>If either <code>$arg1</code> or <code>$arg2</code> has no timezone component, the effective value of the
			   argument is obtained by substituting the implicit timezone from the dynamic evaluation context.</p>
         <p>The function then returns <code>true</code> if and only if the effective value of
                        <code>$arg1</code> is equal to the effective value of <code>$arg2</code> according to the algorithm defined 
						in section 3.2.7.4 of <bibref ref="xmlschema-2"/> 
                  <quote>Order relation on dateTime</quote> for <code>xs:dateTime</code> values with timezones.
                        Otherwise the function returns <code>false</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example><p>Assume that the dynamic context provides an implicit timezone value of <code>-05:00</code></p></fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:dateTime-equal(xs:dateTime("2002-04-02T12:00:00-01:00"),
                                    xs:dateTime("2002-04-02T17:00:00+04:00"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test implicit-timezone="-PT5H">
               <fos:expression>op:dateTime-equal(xs:dateTime("2002-04-02T12:00:00"),
                                    xs:dateTime("2002-04-02T23:00:00+06:00"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:dateTime-equal(xs:dateTime("2002-04-02T12:00:00"),
                                    xs:dateTime("2002-04-02T17:00:00"))</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:dateTime-equal(xs:dateTime("2002-04-02T12:00:00"),
                                    xs:dateTime("2002-04-02T12:00:00"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:dateTime-equal(xs:dateTime("2002-04-02T23:00:00-04:00"),
                                    xs:dateTime("2002-04-03T02:00:00-01:00"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:dateTime-equal(xs:dateTime("1999-12-31T24:00:00"),
xs:dateTime("2000-01-01T00:00:00"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:dateTime-equal(xs:dateTime("2005-04-04T24:00:00"),
xs:dateTime("2005-04-04T00:00:00"))</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="dateTime-less-than">
      <fos:signatures>
         <fos:proto name="dateTime-less-than" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:dateTime"/>
            <fos:arg name="arg2" type="xs:dateTime"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="lt" types="xs:dateTime numeric" other-operators="le">Defines the semantics of the "lt" operator on
                        <code>xs:dateTime</code> values. Also used in the definition of the "le" operator.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns <code>true</code> if the first argument represents an earlier instant in time than the second argument.</p>
      </fos:summary>
      <fos:rules>
         <p>If either <code>$arg1</code> or <code>$arg2</code> has no timezone component, the effective value of the
			   argument is obtained by substituting the implicit timezone from the dynamic evaluation context.</p>
         <p>The function then returns <code>true</code> if and only if the effective value of
                        <code>$arg1</code> is less than the effective value of <code>$arg2</code> according to the 
						algorithm defined in section 3.2.7.4 of <bibref ref="xmlschema-2"/> 
                  <quote>Order relation on dateTime</quote> for <code>xs:dateTime</code> values with timezones.

                        Otherwise the function returns <code>false</code>.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="dateTime-greater-than">
      <fos:signatures>
         <fos:proto name="dateTime-greater-than" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:dateTime"/>
            <fos:arg name="arg2" type="xs:dateTime"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="gt" types="xs:dateTime numeric" other-operators="ge">Defines the semantics of the "gt" operator on
                        <code>xs:dateTime</code> values. Also used in the definition of the "ge" operator.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns <code>true</code> if the first argument represents a later instant in time than the second argument.</p>
      </fos:summary>
      <fos:rules>
         <p>The function call <code>op:dateTime-greater-than($A, $B)</code> is defined to return
			   the same result as <code>op:dateTime-less-than($B, $A)</code></p>
      </fos:rules>
   </fos:function>
   <fos:function name="date-equal">
      <fos:signatures>
         <fos:proto name="date-equal" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:date"/>
            <fos:arg name="arg2" type="xs:date"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="eq" types="xs:date numeric" other-operators="ne le ge">Defines the semantics of the "eq" operator on <code>xs:date</code> values. 
			   Also used in the definition of the "ne", "le" and "ge" operators.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns <code>true</code> if and only if the starting instants of
                        the two supplied <code>xs:date</code> values are the same.</p>
      </fos:summary>
      <fos:rules>
         <p>The starting instant of an <code>xs:date</code> is the <code>xs:dateTime</code> at time <code>00:00:00</code> on that date.</p>
         <p>The function returns the result of the expression:</p>
         <eg xml:space="preserve">op:dateTime-equal(xs:dateTime($arg1), xs:dateTime($arg2))</eg>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:date-equal(xs:date("2004-12-25Z"),
                  xs:date("2004-12-25+07:00"))</fos:expression>
               <fos:result>false()</fos:result>
               <fos:postamble>The starting instants are <code>xs:dateTime("2004-12-25T00:00:00Z")</code> and
                  <code>xs:dateTime("2004-12-25T00:00:00+07:00")</code>. 
                  These are normalized to <code>xs:dateTime("2004-12-25T00:00:00Z")</code> 
                  and <code>xs:dateTime("2004-12-24T17:00:00Z")</code>.
               </fos:postamble>
            </fos:test>
         </fos:example><fos:example>
            <fos:test>
               <fos:expression>op:date-equal(xs:date("2004-12-25-12:00"),
                                    xs:date("2004-12-26+12:00"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="date-less-than">
      <fos:signatures>
         <fos:proto name="date-less-than" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:date"/>
            <fos:arg name="arg2" type="xs:date"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="lt" types="xs:date numeric" other-operators="le">Defines the semantics of the "lt" operator on <code>xs:date</code> values.
			   Also used in the definition of the "le" operator.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns <code>true</code> if and only if the starting instant of 
                        <code>$arg1</code> is less than the starting instant of <code>$arg2</code>.
                        Returns <code>false</code> otherwise.</p>
      </fos:summary>
      <fos:rules>
         <p>The starting instant of an <code>xs:date</code> is the <code>xs:dateTime</code> at time <code>00:00:00</code> on that date.</p>
         <p>The function returns the result of the expression:</p>
         <eg xml:space="preserve">op:dateTime-less-than(xs:dateTime($arg1), xs:dateTime($arg2))</eg>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:date-less-than(xs:date("2004-12-25Z"),
                                    xs:date("2004-12-25-05:00"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:date-less-than(xs:date("2004-12-25-12:00"),
                                    xs:date("2004-12-26+12:00"))</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="date-greater-than">
      <fos:signatures>
         <fos:proto name="date-greater-than" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:date"/>
            <fos:arg name="arg2" type="xs:date"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="gt" types="xs:date numeric" other-operators="ge">Defines the semantics of the "gt" operator on <code>xs:date</code> values.
			   Also used in the definition of the "ge" operator.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns <code>true</code> if and only if the starting instant of
                        <code>$arg1</code> is greater than the starting instant of <code>$arg2</code>. Returns <code>false</code> otherwise.</p>
      </fos:summary>
      <fos:rules>
         <p>The function call <code>op:date-greater-than($A, $B)</code> is defined to return
			   the same result as <code>op:date-less-than($B, $A)</code></p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:date-greater-than(xs:date("2004-12-25Z"),
                                    xs:date("2004-12-25+07:00"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:date-greater-than(xs:date("2004-12-25-12:00"),
                                    xs:date("2004-12-26+12:00"))</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="time-equal">
      <fos:signatures>
         <fos:proto name="time-equal" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:time"/>
            <fos:arg name="arg2" type="xs:time"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="eq" types="xs:time numeric" other-operators="ne le ge">Defines the semantics of the "eq" operator on <code>xs:time</code> values.
			   Also used in the definition of the "ne", "le" and "ge" operators.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns <code>true</code> if the two <code>xs:time</code> values represent the same
			   instant in time, when treated as being times on the same date, before adjusting the timezone.</p>
      </fos:summary>
      <fos:rules>
         <p>Each of the supplied <code>xs:time</code> values is expanded to an <code>xs:dateTime</code>
			   value by associating the time with an arbitrary date. The function returns the result of comparing
			   these two <code>xs:dateTime</code> values using <code>op:dateTime-equal</code>.</p>
         <p>The result of the function is thus the same as the value of the expression:</p>
         <eg xml:space="preserve">op:dateTime-equal(
        fn:dateTime(xs:date('1972-12-31'), $arg1), 
        fn:dateTime(xs:date('1972-12-31'), $arg2))</eg>
      </fos:rules>
      <fos:examples>
         <fos:example><p>Assume that the date components from the reference <code>xs:dateTime</code> 
            correspond to <code>1972-12-31</code>.</p></fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:time-equal(xs:time("08:00:00+09:00"),
                  xs:time("17:00:00-06:00"))</fos:expression>
               <fos:result>false()</fos:result>
               <fos:postamble>The <code>xs:dateTime</code>s calculated using the reference date components 
                  are <code>1972-12-31T08:00:00+09:00</code> and <code>1972-12-31T17:00:00-06:00</code>.
                  These normalize to <code>1972-12-30T23:00:00Z</code> and <code>1972-12-31T23:00:00</code>.
               </fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:time-equal(xs:time("21:30:00+10:30"),
                                    xs:time("06:00:00-05:00"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:time-equal(xs:time("24:00:00+01:00"), xs:time("00:00:00+01:00"))</fos:expression>
               <fos:result>true()</fos:result>
               <fos:postamble>This not the result one might expect. For <code>xs:dateTime</code> values, a time of 
                  <code>24:00:00</code> is equivalent to <code>00:00:00</code> on the following day. 
                  For <code>xs:time</code>, the normalization from <code>24:00:00</code> to <code>00:00:00</code> 
                  happens before the <code>xs:time</code> is converted into an <code>xs:dateTime</code> for the purpose 
                  of the equality comparison. For <code>xs:time</code>, any operation on <code>24:00:00</code> produces 
                  the same result as the same operation on <code>00:00:00</code> because these are two different lexical 
                  representations of the same value.
               </fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="time-less-than">
      <fos:signatures>
         <fos:proto name="time-less-than" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:time"/>
            <fos:arg name="arg2" type="xs:time"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="lt" types="xs:time numeric" other-operators="le">Defines the semantics of the "lt" operator on <code>xs:time</code> values.
			   Also used in the definition of the "le" operator.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns <code>true</code> if the first <code>xs:time</code> value represents an earlier 
			   instant in time than the second, when both are treated as being times on the same date, before adjusting the timezone.</p>
      </fos:summary>
      <fos:rules>
         <p>Each of the supplied <code>xs:time</code> values is expanded to an <code>xs:dateTime</code>
			   value by associating the time with an arbitrary date. The function returns the result of comparing
			   these two <code>xs:dateTime</code> values using <code>op:dateTime-less-than</code>.</p>
         <p>The result of the function is thus the same as the value of the expression:</p>
         <eg xml:space="preserve">op:dateTime-less-than(
        fn:dateTime(xs:date('1972-12-31'), $arg1), 
        fn:dateTime(xs:date('1972-12-31'), $arg2))</eg>
      </fos:rules>
      <fos:examples>
         <fos:example>
             <p>Assume that the dynamic context provides an implicit timezone value of <code>-05:00</code>.</p>
         </fos:example>
         <fos:example>
            <fos:test implicit-timezone="-PT5H">
               <fos:expression>op:time-less-than(xs:time("12:00:00"),
                                    xs:time("23:00:00+06:00"))</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:time-less-than(xs:time("11:00:00"),
                                    xs:time("17:00:00Z"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:time-less-than(xs:time("23:59:59"), xs:time("24:00:00"))</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="time-greater-than">
      <fos:signatures>
         <fos:proto name="time-greater-than" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:time"/>
            <fos:arg name="arg2" type="xs:time"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="gt" types="xs:time numeric" other-operators="ge">Defines the semantics of the "gt" operator on <code>xs:time</code> values.
			   Also used in the definition of the "ge" operator.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns <code>true</code> if the first <code>xs:time</code> value represents a later
			   instant in time than the second, when both are treated as being times on the same date, before adjusting the timezone.</p>
      </fos:summary>
      <fos:rules>
         <p>The function call <code>op:time-greater-than($A, $B)</code> is defined to return
			   the same result as <code>op:time-less-than($B, $A)</code></p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:time-greater-than(xs:time("08:00:00+09:00"),
                                    xs:time("17:00:00-06:00"))</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="gYearMonth-equal">
      <fos:signatures>
         <fos:proto name="gYearMonth-equal" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:gYearMonth"/>
            <fos:arg name="arg2" type="xs:gYearMonth"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="eq" types="xs:gYearMonth numeric" other-operators="ne">Defines the semantics of the "eq" operator on <code>xs:gYearMonth</code> values.
			   Also used in the definition of the "ne" operator.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns true if the two <code>xs:gYearMonth</code> values have the same starting instant.</p>
      </fos:summary>
      <fos:rules>
         <p>The starting instants of <code>$arg1</code> 
			   and <code>$arg2</code> are calculated by supplying the missing components of <code>$arg1</code> and <code>$arg2</code> 
			   from the <code>xs:dateTime</code> template <code>xxxx-xx-01T00:00:00</code>. 
			   The function returns the result of comparing these two starting instants using <code>op:dateTime-equal</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
             <p>Assume that the dynamic context provides an implicit timezone value of <code>-05:00</code>.</p>
         </fos:example>
         <fos:example>
            <p><code>op:gYearMonth-equal(xs:gYearMonth("1986-02"),
                                    xs:gYearMonth("1986-03"))</code> returns <code>false()</code>.  
   	The starting instants are <code>1986-02-01T00:00:00-05:00</code> and 
   	<code>1986-03-01T00:00:00</code>, respectively.</p>
         </fos:example>
         <fos:example>
            <p><code>op:gYearMonth-equal(xs:gYearMonth("1978-03"),
                                    xs:gYearMonth("1986-03Z"))</code> returns <code>false()</code>.
	      The starting instants are <code>1986-03-01T00:00:00-05:00</code> and 
      	      <code>1986-03-01T00:00:00Z</code>, respectively.</p>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="gYear-equal">
      <fos:signatures>
         <fos:proto name="gYear-equal" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:gYear"/>
            <fos:arg name="arg2" type="xs:gYear"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="eq" types="xs:gYear numeric" other-operators="ne">Defines the semantics of the "eq" operator on <code>xs:gYear</code> values.
			   Also used in the definition of the "ne" operator.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns true if the two <code>xs:gYear</code> values have the same starting instant.</p>
      </fos:summary>
      <fos:rules>
         <p>The starting instants of <code>$arg1</code> 
	   and <code>$arg2</code> are calculated by supplying the missing components of <code>$arg1</code> and <code>$arg2</code> 
	   from the <code>xs:dateTime</code> template <code>xxxx-01-01T00:00:00</code>. 
	   The function returns the result of comparing these two starting instants using <code>op:dateTime-equal</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <p>Assume that the dynamic context provides an implicit timezone value of <code>-05:00</code>.
              Assume, also, that the <code>xs:dateTime</code> template is <code>xxxx-01-01T00:00:00</code>.
            </p>
         </fos:example>
         <fos:example>
            <p><code>op:gYear-equal(xs:gYear("2005-12:00"),
                                    xs:gYear("2005+12:00"))</code> returns <code>false()</code>.  
            	The starting instants are <code>2005-01-01T00:00:00-12:00</code> 
            	and <code>2005-01-01T00:00:00+12:00</code>, respectively, and 
            	normalize to <code>2005-01-01T12:00:00Z</code> and <code>2004-12-31T12:00:00Z</code>.</p>
         </fos:example>
         <fos:example>
            <fos:test implicit-timezone="-PT5H">
               <fos:expression>op:gYear-equal(xs:gYear("1976-05:00"),
                                    xs:gYear("1976"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="gMonthDay-equal">
      <fos:signatures>
         <fos:proto name="gMonthDay-equal" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:gMonthDay"/>
            <fos:arg name="arg2" type="xs:gMonthDay"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="eq" types="xs:gMonthDay numeric" other-operators="ne">Defines the semantics of the "eq" operator on <code>xs:gMonthDay</code> values.
			   Also used in the definition of the "ne" operator.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns true if the two <code>xs:gMonthDay</code> values have the same 
            starting instant, when considered as days in the same year.</p>
      </fos:summary>
      <fos:rules>
         <p>The starting instants of <code>$arg1</code> 
	   and <code>$arg2</code> are calculated by supplying the missing components of <code>$arg1</code> and <code>$arg2</code> 
	   from the <code>xs:dateTime</code> template <code>1972-xx-xxT00:00:00</code> or an equivalent. 
	   The function returns the result of comparing these two starting instants using <code>op:dateTime-equal</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <p>Assume that the dynamic context provides an implicit timezone value of <code>-05:00</code>.  
	  Assume for the purposes of illustration that the <code>xs:dateTime</code> template used is <code>1972-xx-xxT00:00:00</code>
	  (this does not affect the result).
	  </p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:gMonthDay-equal(xs:gMonthDay("--12-25-14:00"),
                  xs:gMonthDay("--12-26+10:00"))</fos:expression>
               <fos:result>true()</fos:result>
               <fos:postamble>	The starting instants are <code>1972-12-25T00:00:00-14:00</code> and 
                  <code>1972-12-26T00:00:00+10:00</code>, respectively, and normalize to 
                  <code>1972-12-25T14:00:00Z</code> and <code>1972-12-25T14:00:00Z</code>.
               </fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:gMonthDay-equal(xs:gMonthDay("--12-25"),
                                    xs:gMonthDay("--12-26Z"))</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="gMonth-equal">
      <fos:signatures>
         <fos:proto name="gMonth-equal" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:gMonth"/>
            <fos:arg name="arg2" type="xs:gMonth"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="eq" types="xs:gMonth numeric" other-operators="ne">Defines the semantics of the "eq" operator on <code>xs:gMonth</code> values.
			   Also used in the definition of the "ne" operator.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns true if the two <code>xs:gMonth</code> values have the same starting instant, 
            when considered as months in the same year.</p>
      </fos:summary>
      <fos:rules>
         <p>The starting instants of <code>$arg1</code> 
      and <code>$arg2</code> are calculated by supplying the missing components of <code>$arg1</code> and <code>$arg2</code> 
      from the <code>xs:dateTime</code> template <code>1972-xx-01T00:00:00</code> or an equivalent. 
      The function returns the result of comparing these two starting instants using <code>op:dateTime-equal</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <p>Assume that the dynamic context provides an implicit timezone value of <code>-05:00</code>.  
	     Assume, also, that the <code>xs:dateTime</code> template chosen is <code>1972-xx-01T00:00:00</code>.
	  </p>
	 </fos:example>
         <fos:example>
            <fos:test implicit-timezone="-PT5H">
               <fos:expression>op:gMonth-equal(xs:gMonth("--12-14:00"),
                  xs:gMonth("--12+10:00"))</fos:expression>
               <fos:result>false()</fos:result>
               <fos:postamble>	The starting instants are <code>1972-12-01T00:00:00-14:00</code> 
                  and <code>1972-12-01T00:00:00+10:00</code>, respectively, and 
                  normalize to <code>1972-11-30T14:00:00Z</code> and <code>1972-12-01T14:00:00Z</code>.
               </fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test implicit-timezone="-PT5H">
               <fos:expression>op:gMonth-equal(xs:gMonth("--12"),
                                    xs:gMonth("--12Z"))</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="gDay-equal">
      <fos:signatures>
         <fos:proto name="gDay-equal" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:gDay"/>
            <fos:arg name="arg2" type="xs:gDay"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="eq" types="xs:gDay numeric" other-operators="ne">Defines the semantics of the "eq" operator on <code>xs:gDay</code> values.
	   Also used in the definition of the "ne" operator.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns true if the two <code>xs:gDay</code> values have the same starting instant, when considered as days in the same
		   month of the same year.</p>
      </fos:summary>
      <fos:rules>
         <p>The starting instants of <code>$arg1</code> 
	   and <code>$arg2</code> are calculated by supplying the missing components of <code>$arg1</code> and <code>$arg2</code> 
	   from the <code>xs:dateTime</code> template <code>1972-12-xxT00:00:00</code> or an equivalent. 
	   The function returns the result of comparing these two starting instants using <code>op:dateTime-equal</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <p>Assume that the dynamic context provides an implicit timezone value of <code>-05:00</code>.  
	     Assume, also, that the <code>xs:dateTime</code> template is <code>1972-12-xxT00:00:00</code>.
            </p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:gDay-equal(xs:gDay("---25-14:00"), xs:gDay("---25+10:00"))</fos:expression>
               <fos:result>false()</fos:result>
               <fos:postamble>	The starting instants are <code>1972-12-25T00:00:00-14:00</code> 
                  and <code>1972-12-25T00:00:00+10:00</code>, respectively, and normalize 
                  to <code>1972-12-25T14:00:00Z</code> and <code>1972-12-24T14:00:00Z</code>.
               </fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test implicit-timezone="-PT5H">
               <fos:expression>op:gDay-equal(xs:gDay("---12"),
                                    xs:gDay("---12Z"))</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="year-from-dateTime">
      <fos:signatures>
         <fos:proto name="year-from-dateTime" return-type="xs:integer?">
            <fos:arg name="arg" type="xs:dateTime?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the year component of an <code>xs:dateTime</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:integer</code> representing the year component
                        in the local value of <code>$arg</code>. The result may be negative.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:year-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))</fos:expression>
               <fos:result>1999</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:year-from-dateTime(xs:dateTime("1999-05-31T21:30:00-05:00"))</fos:expression>
               <fos:result>1999</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:year-from-dateTime(xs:dateTime("1999-12-31T19:20:00"))</fos:expression>
               <fos:result>1999</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:year-from-dateTime(xs:dateTime("1999-12-31T24:00:00"))</fos:expression>
               <fos:result>2000</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="month-from-dateTime">
      <fos:signatures>
         <fos:proto name="month-from-dateTime" return-type="xs:integer?">
            <fos:arg name="arg" type="xs:dateTime?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the month component of an <code>xs:dateTime</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:integer</code> between 1 and 12, both inclusive,
                        representing the month component in the local value of <code>$arg</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:month-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))</fos:expression>
               <fos:result>5</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:month-from-dateTime(xs:dateTime("1999-12-31T19:20:00-05:00"))</fos:expression>
               <fos:result>12</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:month-from-dateTime(fn:adjust-dateTime-to-timezone(xs:dateTime("1999-12-31T19:20:00-05:00"),
                                    xs:dayTimeDuration("PT0S")))</fos:expression>
               <fos:result>1</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="day-from-dateTime">
      <fos:signatures>
         <fos:proto name="day-from-dateTime" return-type="xs:integer?">
            <fos:arg name="arg" type="xs:dateTime?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the day component of an <code>xs:dateTime</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:integer</code> between 1 and 31, both inclusive,
                        representing the day component in the local value of <code>$arg</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:day-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))</fos:expression>
               <fos:result>31</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:day-from-dateTime(xs:dateTime("1999-12-31T20:00:00-05:00"))</fos:expression>
               <fos:result>31</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:day-from-dateTime(fn:adjust-dateTime-to-timezone(xs:dateTime("1999-12-31T19:20:00-05:00"),
                                    xs:dayTimeDuration("PT0S")))</fos:expression>
               <fos:result>1</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="hours-from-dateTime">
      <fos:signatures>
         <fos:proto name="hours-from-dateTime" return-type="xs:integer?">
            <fos:arg name="arg" type="xs:dateTime?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the hours component of an <code>xs:dateTime</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:integer</code> between 0 and 23, both inclusive,
                        representing the hours component in the local value of <code>$arg</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:hours-from-dateTime(xs:dateTime("1999-05-31T08:20:00-05:00"))</fos:expression>
               <fos:result>8</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:hours-from-dateTime(xs:dateTime("1999-12-31T21:20:00-05:00"))</fos:expression>
               <fos:result>21</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:hours-from-dateTime(fn:adjust-dateTime-to-timezone(xs:dateTime("1999-12-31T21:20:00-05:00"),
                                        xs:dayTimeDuration("PT0S")))</fos:expression>
               <fos:result>2</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:hours-from-dateTime(xs:dateTime("1999-12-31T12:00:00"))</fos:expression>
               <fos:result>12</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:hours-from-dateTime(xs:dateTime("1999-12-31T24:00:00"))</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="minutes-from-dateTime">
      <fos:signatures>
         <fos:proto name="minutes-from-dateTime" return-type="xs:integer?">
            <fos:arg name="arg" type="xs:dateTime?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the minute component of an <code>xs:dateTime</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:integer</code> value between 0 and 59, both
                        inclusive, representing the minute component in the local value of <code>$arg</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:minutes-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))</fos:expression>
               <fos:result>20</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:minutes-from-dateTime(xs:dateTime("1999-05-31T13:30:00+05:30"))</fos:expression>
               <fos:result>30</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="seconds-from-dateTime">
      <fos:signatures>
         <fos:proto name="seconds-from-dateTime" return-type="xs:decimal?">
            <fos:arg name="arg" type="xs:dateTime?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the seconds component of an <code>xs:dateTime</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:decimal</code> value greater than or equal to zero and less than 60,
                        representing the seconds and fractional seconds in the
                        local value of <code>$arg</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:seconds-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="timezone-from-dateTime">
      <fos:signatures>
         <fos:proto name="timezone-from-dateTime" return-type="xs:dayTimeDuration?">
            <fos:arg name="arg" type="xs:dateTime?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the timezone component of an <code>xs:dateTime</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns the timezone component of <code>$arg</code>, if any. If
                        <code>$arg</code> has a timezone component, then the result is
                        an <code>xs:dayTimeDuration</code> that indicates deviation from UTC; its
                        value may range from +14:00 to -14:00 hours, both inclusive. 
						If <code>$arg</code> has no timezone component, the
                        result is the empty sequence.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:timezone-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))</fos:expression>
               <fos:result>xs:dayTimeDuration("-PT5H")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:timezone-from-dateTime(xs:dateTime("2000-06-12T13:20:00Z"))</fos:expression>
               <fos:result>xs:dayTimeDuration("PT0S")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:timezone-from-dateTime(xs:dateTime("2004-08-27T00:00:00"))</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="year-from-date">
      <fos:signatures>
         <fos:proto name="year-from-date" return-type="xs:integer?">
            <fos:arg name="arg" type="xs:date?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the year component of an <code>xs:date</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:integer</code> representing the year in the
                        local value of <code>$arg</code>. The value may be negative. </p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:year-from-date(xs:date("1999-05-31"))</fos:expression>
               <fos:result>1999</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:year-from-date(xs:date("2000-01-01+05:00"))</fos:expression>
               <fos:result>2000</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="month-from-date">
      <fos:signatures>
         <fos:proto name="month-from-date" return-type="xs:integer?">
            <fos:arg name="arg" type="xs:date?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the month component of an <code>xs:date</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:integer</code> between 1 and 12, both inclusive,
                        representing the month component in the local value of
                        <code>$arg</code>. </p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:month-from-date(xs:date("1999-05-31-05:00"))</fos:expression>
               <fos:result>5</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:month-from-date(xs:date("2000-01-01+05:00"))</fos:expression>
               <fos:result>1</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="day-from-date">
      <fos:signatures>
         <fos:proto name="day-from-date" return-type="xs:integer?">
            <fos:arg name="arg" type="xs:date?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the day component of an <code>xs:date</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:integer</code> between 1 and 31, both inclusive,
                        representing the day component in the localized value of <code>$arg</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:day-from-date(xs:date("1999-05-31-05:00"))</fos:expression>
               <fos:result>31</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:day-from-date(xs:date("2000-01-01+05:00"))</fos:expression>
               <fos:result>1</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="timezone-from-date">
      <fos:signatures>
         <fos:proto name="timezone-from-date" return-type="xs:dayTimeDuration?">
            <fos:arg name="arg" type="xs:date?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the timezone component of an <code>xs:date</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns the timezone component of <code>$arg</code>, if any. If
                        <code>$arg</code> has a timezone component, then the result is
                        an <code>xs:dayTimeDuration</code> that indicates deviation from UTC; its
                        value may range from +14:00 to -14:00 hours, both inclusive. 
						If <code>$arg</code> has no timezone component, the
                        result is the empty sequence.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:timezone-from-date(xs:date("1999-05-31-05:00"))</fos:expression>
               <fos:result>xs:dayTimeDuration("-PT5H")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:timezone-from-date(xs:date("2000-06-12Z"))</fos:expression>
               <fos:result>xs:dayTimeDuration("PT0S")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="hours-from-time">
      <fos:signatures>
         <fos:proto name="hours-from-time" return-type="xs:integer?">
            <fos:arg name="arg" type="xs:time?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the hours component of an <code>xs:time</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:integer</code> between 0 and 23, both inclusive,
                        representing the value of the hours component in the local value of <code>$arg</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <p>Assume that the dynamic context provides an implicit timezone value of <code>-05:00</code>.
            </p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:hours-from-time(xs:time("11:23:00"))</fos:expression>
               <fos:result>11</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:hours-from-time(xs:time("21:23:00"))</fos:expression>
               <fos:result>21</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:hours-from-time(xs:time("01:23:00+05:00"))</fos:expression>
               <fos:result>1</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:hours-from-time(fn:adjust-time-to-timezone(xs:time("01:23:00+05:00"),
                                    xs:dayTimeDuration("PT0S")))</fos:expression>
               <fos:result>20</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:hours-from-time(xs:time("24:00:00"))</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="minutes-from-time">
      <fos:signatures>
         <fos:proto name="minutes-from-time" return-type="xs:integer?">
            <fos:arg name="arg" type="xs:time?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the minutes component of an <code>xs:time</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:integer</code> value between 0 and 59, both
                        inclusive, representing the value of the minutes component in the local
                        value of <code>$arg</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:minutes-from-time(xs:time("13:00:00Z"))</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="seconds-from-time">
      <fos:signatures>
         <fos:proto name="seconds-from-time" return-type="xs:decimal?">
            <fos:arg name="arg" type="xs:time?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the seconds component of an <code>xs:time</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:decimal</code> value greater than or equal to zero 
			   and less than 60, representing the seconds and fractional seconds in the
                        local value of <code>$arg</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:seconds-from-time(xs:time("13:20:10.5"))</fos:expression>
               <fos:result>10.5</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="timezone-from-time">
      <fos:signatures>
         <fos:proto name="timezone-from-time" return-type="xs:dayTimeDuration?">
            <fos:arg name="arg" type="xs:time?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the timezone component of an <code>xs:time</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns the timezone component of <code>$arg</code>, if any. If
                        <code>$arg</code> has a timezone component, then the result is
                        an <code>xs:dayTimeDuration</code> that indicates deviation from UTC; its
                        value may range from +14:00 to -14:00 hours, both inclusive. 
		If <code>$arg</code> has no timezone component, the
                        result is the empty sequence.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:timezone-from-time(xs:time("13:20:00-05:00"))</fos:expression>
               <fos:result>xs:dayTimeDuration("-PT5H")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:timezone-from-time(xs:time("13:20:00"))</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="adjust-dateTime-to-timezone">
      <fos:signatures>
         <fos:proto name="adjust-dateTime-to-timezone" return-type="xs:dateTime">
            <fos:arg name="arg" type="xs:dateTime?"/>
         </fos:proto>
         <fos:proto name="adjust-dateTime-to-timezone" return-type="xs:dateTime">
            <fos:arg name="arg" type="xs:dateTime?"/>
            <fos:arg name="timezone" type="xs:dayTimeDuration?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Adjusts an <code>xs:dateTime</code> value to a specific timezone, or
                        to no timezone at all.</p>
      </fos:summary>
      <fos:rules>
         <p> If <code>$timezone</code> is not specified, then the effective value of <code>$timezone</code> is
                        the value of the implicit timezone in the dynamic context.</p>
         <p> If <code>$arg</code> is the empty sequence, then the function returns the empty sequence.</p>         
         <p> If <code>$arg</code> does not have a timezone component and
                        <code>$timezone</code> is the empty sequence, then the result is <code>$arg</code>.</p>
         <p> If <code>$arg</code> does not have a timezone component and
                        <code>$timezone</code> is not the empty sequence, then the result is
                        <code>$arg</code> with <code>$timezone</code> as the timezone component.</p>
         <p> If <code>$arg</code> has a timezone component and <code>$timezone</code> is
                        the empty sequence, then the result is the local value of
                        <code>$arg</code> without its timezone component.</p>
         <p> If <code>$arg</code> has a timezone component and <code>$timezone</code> is
                        not the empty sequence, then the result is the <code>xs:dateTime</code> value
                        that is equal to <code>$arg</code> and that has a timezone component 
						equal to <code>$timezone</code>.</p>
      </fos:rules>
      <fos:errors>
         <p> A dynamic error is raised <errorref class="DT" code="0003"/> if
                        <code>$timezone</code> is less than <code>-PT14H</code> or greater than <code>PT14H</code> 
						or is not an integral number of minutes.</p>
      </fos:errors>
      <fos:examples>
         <fos:example>
              <p> Assume the dynamic context provides an implicit timezone of <code>-05:00 (-PT5H0M)</code>.</p>
         </fos:example>
         <fos:variable name="tz-10" select="xs:dayTimeDuration(&quot;-PT10H&quot;)"/>
         <fos:example>
            <fos:test implicit-timezone="-PT5H">
               <fos:expression>fn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T10:00:00'))</fos:expression>
               <fos:result>xs:dateTime('2002-03-07T10:00:00-05:00')</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T10:00:00-07:00'))</fos:expression>
               <fos:result>xs:dateTime('2002-03-07T12:00:00-05:00')</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T10:00:00'),
                                    $tz-10)</fos:expression>
               <fos:result>xs:dateTime('2002-03-07T10:00:00-10:00')</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T10:00:00-07:00'),
                                    $tz-10)</fos:expression>
               <fos:result>xs:dateTime('2002-03-07T07:00:00-10:00')</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T10:00:00-07:00'),
                                    xs:dayTimeDuration("PT10H"))</fos:expression>
               <fos:result>xs:dateTime('2002-03-08T03:00:00+10:00')</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T00:00:00+01:00'),
                                    xs:dayTimeDuration("-PT8H"))</fos:expression>
               <fos:result>xs:dateTime('2002-03-06T15:00:00-08:00')</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T10:00:00'),
                                    ())</fos:expression>
               <fos:result>xs:dateTime('2002-03-07T10:00:00')</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T10:00:00-07:00'),
                                    ())</fos:expression>
               <fos:result>xs:dateTime('2002-03-07T10:00:00')</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="adjust-date-to-timezone">
      <fos:signatures>
         <fos:proto name="adjust-date-to-timezone" return-type="xs:date?">
            <fos:arg name="arg" type="xs:date?"/>
         </fos:proto>
         <fos:proto name="adjust-date-to-timezone" return-type="xs:date?">
            <fos:arg name="arg" type="xs:date?"/>
            <fos:arg name="timezone" type="xs:dayTimeDuration?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Adjusts an <code>xs:date</code> value to a specific timezone, or to
                        no timezone at all; the result is the date in the target timezone that
						contains the starting instant of the supplied date.</p>
      </fos:summary>
      <fos:rules>
         <p> If <code>$timezone</code> is not specified, then the effective value of <code>$timezone</code> is
                        the value of the implicit timezone in the dynamic context.</p>
         <p> If <code>$arg</code> is the empty sequence, then the function returns the empty sequence.</p>
         <p> If <code>$arg</code> does not have a timezone component and
                        <code>$timezone</code> is the empty sequence, then the result is the value
                        of <code>$arg</code>.</p>
         <p> If <code>$arg</code> does not have a timezone component and
                        <code>$timezone</code> is not the empty sequence, then the result is
                        <code>$arg</code> with <code>$timezone</code> as the timezone component.</p>
         <p> If <code>$arg</code> has a timezone component and <code>$timezone</code> is
                        the empty sequence, then the result is the local value of
                        <code>$arg</code> without its timezone component.</p>
         <p> If <code>$arg</code> has a timezone component and <code>$timezone</code> is
                        not the empty sequence, then the function returns the value of the expression:</p>
         <ulist>
            <item>
               <p>Let <code>$dt</code> be the value of <code>fn:dateTime($arg, xs:time('00:00:00'))</code>.</p>
            </item>
            <item>
               <p>Let <code>$adt</code> be the value of
                                    <code>fn:adjust-dateTime-to-timezone($dt, $timezone)</code></p>
            </item>
            <item>
               <p>The function returns the value of <code>xs:date($adt)</code></p>
            </item>
         </ulist>
         <ednote>
            <edtext>I suspect this procedure actually gives the right result in all cases, so the whole
			   description can be simplified.</edtext>
         </ednote>
      </fos:rules>
      <fos:errors>
         <p> A dynamic error is raised <errorref class="DT" code="0003"/> if
            <code>$timezone</code> is less than <code>-PT14H</code> or greater than 
            <code>PT14H</code> or is not an integral number of minutes.</p>        
      </fos:errors>
      <fos:examples>
          <fos:example>
		   <p>Assume the dynamic context provides an implicit timezone of <code>-05:00 (-PT5H0M)</code>.</p>
		  </fos:example>
         <fos:variable name="tz-10" select="xs:dayTimeDuration(&quot;-PT10H&quot;)"/>
         <fos:example>
            <fos:test implicit-timezone="-PT5H">
               <fos:expression>fn:adjust-date-to-timezone(xs:date("2002-03-07"))</fos:expression>
               <fos:result>xs:date("2002-03-07-05:00")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-date-to-timezone(xs:date("2002-03-07-07:00"))</fos:expression>
               <fos:result>xs:date("2002-03-07-05:00")</fos:result>
               <fos:postamble><code>$arg</code> is
                            converted to <code>xs:dateTime("2002-03-07T00:00:00-07:00")</code>. 
                           This is adjusted to the
                            implicit timezone, giving <code>"2002-03-07T02:00:00-05:00"</code>.
               </fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-date-to-timezone(xs:date("2002-03-07"),
                                    $tz-10)</fos:expression>
               <fos:result>xs:date("2002-03-07-10:00")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-date-to-timezone(xs:date("2002-03-07-07:00"),
                  $tz-10)</fos:expression>
               <fos:result>xs:date("2002-03-06-10:00")</fos:result>
               <fos:postamble><code>$arg</code> is converted to the <code>xs:dateTime
                            "2002-03-07T00:00:00-07:00"</code>. This is adjusted to the
                            given timezone, giving <code>"2002-03-06T21:00:00-10:00"</code>.
               </fos:postamble>
            </fos:test>
         </fos:example>         
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-date-to-timezone(xs:date("2002-03-07"),
                                    ())</fos:expression>
               <fos:result>xs:date("2002-03-07")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-date-to-timezone(xs:date("2002-03-07-07:00"),
                            ())</fos:expression>
               <fos:result>xs:date("2002-03-07")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="adjust-time-to-timezone">
      <fos:signatures>
         <fos:proto name="adjust-time-to-timezone" return-type="xs:time?">
            <fos:arg name="arg" type="xs:time?"/>
         </fos:proto>
         <fos:proto name="adjust-time-to-timezone" return-type="xs:time?">
            <fos:arg name="arg" type="xs:time?"/>
            <fos:arg name="timezone" type="xs:dayTimeDuration?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Adjusts an <code>xs:time</code> value to a specific timezone, or to
                        no timezone at all.</p>
      </fos:summary>
      <fos:rules>       
         <p> If <code>$timezone</code> is not specified, then the effective value of <code>$timezone</code> is
                        the value of the implicit timezone in the dynamic context.</p>
         <p> If <code>$arg</code> is the empty sequence, then the function returns the empty sequence.</p>
         <p> If <code>$arg</code> does not have a timezone component and
                        <code>$timezone</code> is the empty sequence, then the result is <code>$arg</code>.</p>
         <p> If <code>$arg</code> does not have a timezone component and
                        <code>$timezone</code> is not the empty sequence, then the result is
                        <code>$arg</code> with <code>$timezone</code> as the timezone component.</p>
         <p> If <code>$arg</code> has a timezone component and <code>$timezone</code> is
                        the empty sequence, then the result is the localized value of
                        <code>$arg</code> without its timezone component.</p>
         <p> If <code>$arg</code> has a timezone component and <code>$timezone</code> is
                        not the empty sequence, then:</p>
         <ulist>
            <item>
               <p>Let <code>$dt</code> be the <code>xs:dateTime</code> value
					           <code>fn:dateTime(xs:date('1972-12-31'), $arg)</code>.</p>
            </item>
            <item>
               <p>Let <code>$adt</code> be the value of <code>fn:adjust-dateTime-to-timezone($dt, $timezone)</code>
                            </p>
            </item>
            <item>
               <p>The function returns the <code>xs:time</code> value <code>xs:time($adt)</code>.</p>
            </item>
         </ulist>
      </fos:rules>
      <fos:errors>
         <p> A dynamic error is raised <errorref class="DT" code="0003"/> if
            <code>$timezone</code> is less than <code>-PT14H</code> or greater than <code>PT14H</code> or if does not contain an integral number of minutes.</p>
      </fos:errors>
      <fos:examples>
         <fos:example>
            <p>Assume the dynamic context provides an implicit timezone of <code>-05:00 (-PT5H0M)</code>.</p>
         </fos:example>
         <fos:variable name="tz-10" select="xs:dayTimeDuration(&quot;-PT10H&quot;)"/>
         <fos:example>
            <fos:test implicit-timezone="-PT5H">
               <fos:expression>fn:adjust-time-to-timezone(xs:time("10:00:00"))</fos:expression>
               <fos:result>xs:time("10:00:00-05:00")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-time-to-timezone(xs:time("10:00:00-07:00"))</fos:expression>
               <fos:result>xs:time("12:00:00-05:00")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-time-to-timezone(xs:time("10:00:00"),
                                    $tz-10)</fos:expression>
               <fos:result>xs:time("10:00:00-10:00")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-time-to-timezone(xs:time("10:00:00-07:00"),
                                    $tz-10)</fos:expression>
               <fos:result>xs:time("07:00:00-10:00")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-time-to-timezone(xs:time("10:00:00"), ())</fos:expression>
               <fos:result>xs:time("10:00:00")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-time-to-timezone(xs:time("10:00:00-07:00"),
                                    ())</fos:expression>
               <fos:result>xs:time("10:00:00")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-time-to-timezone(xs:time("10:00:00-07:00"),
                                    xs:dayTimeDuration("PT10H"))</fos:expression>
               <fos:result>xs:time("03:00:00+10:00")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="subtract-dateTimes">
      <fos:signatures>
         <fos:proto name="subtract-dateTimes" return-type="xs:dayTimeDuration">
            <fos:arg name="arg1" type="xs:dateTime"/>
            <fos:arg name="arg2" type="xs:dateTime"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="-" types="xs:dateTime numeric">Defines the semantics of the "-" operator on <code>xs:dateTime</code> values.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns an <code>xs:dayTimeDuration</code> representing the amount of elapsed time
			   between the instants <code>arg2</code> and <code>arg1</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If either <code>$arg1</code>
                        or <code>$arg2</code> do not contain an explicit timezone then, for the
                        purpose of the operation, the implicit timezone provided by the dynamic
                        context (See <xspecref spec="XP" ref="id-xp-evaluation-context-components"/>.) is assumed to be present as
                        part of the value.</p>
         <p>The function returns the elapsed time between the date/time instant <code>arg2</code> 
			   and the date/time instant <code>arg1</code>, computed according to the algorithm given in Appendix E of <bibref ref="xmlschema-2"/>,
			   and expressed as a <code>xs:dayTimeDuration</code>.</p>
         <p>If the normalized value of <code>$arg1</code> precedes in time the normalized
                        value of <code>$arg2</code>, then the returned value is a negative duration.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <p>Assume that the dynamic context provides an implicit timezone value of <code>-05:00</code>.</p>
         </fos:example>
         <fos:example>
            <fos:test implicit-timezone="-PT5H">
               <fos:expression>op:subtract-dateTimes(xs:dateTime("2000-10-30T06:12:00"),
                                    xs:dateTime("1999-11-28T09:00:00Z"))</fos:expression>
               <fos:result>xs:dayTimeDuration("P337DT2H12M")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="subtract-dates">
      <fos:signatures>
         <fos:proto name="subtract-dates" return-type="xs:dayTimeDuration">
            <fos:arg name="arg1" type="xs:date"/>
            <fos:arg name="arg2" type="xs:date"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="-" types="xs:date numeric">Defines the semantics of the "-" operator on <code>xs:date</code> values.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns the <code>xs:dayTimeDuration</code> that corresponds to the
                        elapsed time between the starting instant of <code>$arg2</code> and the
                        the starting instant of <code>$arg2</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If either <code>$arg1</code>
                        or <code>$arg2</code> do not contain an explicit timezone then, for the
                        purpose of the operation, the implicit timezone provided by the dynamic
                        context (See <xspecref spec="XP" ref="id-xp-evaluation-context-components"/>.) is assumed to be present as
                        part of the value.</p>
         <p>The starting instant of an <code>xs:date</code> is the <code>xs:dateTime</code> at <code>00:00:00</code> on that date.
				</p>
         <p>The function returns the result of subtracting the two starting instants using
               <code>op:subtract-dateTimes</code>.</p>
         <p>If the starting instant of <code>$arg1</code> precedes in time the starting instant of 
			   <code>$arg2</code>, then the returned value is a negative duration.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <p>Assume that the dynamic context provides an implicit timezone value of <code>Z</code>. </p>
         </fos:example>
         <fos:example>
            <fos:test implicit-timezone="PT0S">
               <fos:expression>op:subtract-dates(xs:date("2000-10-30"), xs:date("1999-11-28"))</fos:expression>
               <fos:result>xs:dayTimeDuration("P337D")</fos:result>
               <fos:postamble>The normalized values of the two starting instants are <code>{2000, 10, 30, 0, 0, 0, PT0S}</code> 
                  and <code>{1999, 11, 28, 0, 0, 0, PT0S}</code>.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <p>Now assume that the dynamic context provides an implicit timezone value
                                    of <code>+05:00</code>.</p>
         </fos:example>
         <fos:example>
            <fos:test implicit-timezone="PT5H">
               <fos:expression>op:subtract-dates(xs:date("2000-10-30"),
                  xs:date("1999-11-28Z"))</fos:expression>
               <fos:result>xs:dayTimeDuration("P336DT19H")</fos:result>
               <fos:postamble>	The normalized values of the two starting instants are 
                  <code>{2000, 10, 29, 19, 0, 0, PT0S}</code> and <code>{1999, 11, 28, 0, 0, 0, PT0S}</code>.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:subtract-dates(xs:date("2000-10-15-05:00"),
                                    xs:date("2000-10-10+02:00"))</fos:expression>
               <fos:result>xs:dayTimeDuration("P5DT7H")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="subtract-times">
      <fos:signatures>
         <fos:proto name="subtract-times" return-type="xs:dayTimeDuration">
            <fos:arg name="arg1" type="xs:time"/>
            <fos:arg name="arg2" type="xs:time"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="-" types="xs:time numeric">Defines the semantics of the "-" operator on <code>xs:time</code> values.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns the <code>xs:dayTimeDuration</code> that corresponds to the
                        elapsed time between the values of <code>$arg2</code> and <code>$arg1</code>
						treated as times on the same date.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the result of the expression:</p>
         <eg xml:space="preserve">op-subtract-dateTimes(
        fn:dateTime(xs:date('1972-12-31'), $arg1),
        fn:dateTime(xs:date('1972-12-31'), $arg2))</eg>
      </fos:rules>
      <fos:notes>
         <p>Any other reference date would work equally well.</p>
      </fos:notes>
      <fos:examples>
         <fos:example><p>Assume that the dynamic context provides an implicit timezone value of <code>-05:00</code>.  
				  Assume, also, that the date components of the reference <code>xs:dateTime</code> correspond to <code>"1972-12-31"</code>.</p>
		</fos:example>
         <fos:example>
            <fos:test implicit-timezone="-PT5H">
               <fos:expression>op:subtract-times(xs:time("11:12:00Z"),
                                    xs:time("04:00:00"))</fos:expression>
               <fos:result>xs:dayTimeDuration("PT2H12M")</fos:result>
               <fos:postamble>This is obtained by subtracting from the <code>xs:dateTime</code> 
               value <code>{1972, 12, 31, 11, 12, 0, PT0S}</code> the <code>xs:dateTime</code> 
               value <code>{1972, 12, 31, 9, 0, 0, PT0S}</code>.</fos:postamble>
            </fos:test>
         </fos:example>   
         <fos:example>
            <fos:test>
               <fos:expression>op:subtract-times(xs:time("11:00:00-05:00"),
                                    xs:time("21:30:00+05:30"))</fos:expression>
               <fos:result>xs:dayTimeDuration("PT0S")</fos:result>
               <fos:postamble>The two <code>xs:dateTime</code> values are 
                  <code>{1972, 12, 31, 11, 0, 0, -PT5H}</code> and <code>{1972, 12, 31, 21, 30, 0, PT5H30M}</code>.
                  These normalize to  <code>{1972, 12, 31, 16, 0, 0, PT0S}</code> and <code>{1972, 12, 31, 16, 0, 0, PT0S}</code>.
               </fos:postamble>
            </fos:test>
         </fos:example>  
         <fos:example>
            <fos:test>
               <fos:expression>op:subtract-times(xs:time("17:00:00-06:00"),
                                    xs:time("08:00:00+09:00"))</fos:expression>
               <fos:result>xs:dayTimeDuration("P1D")</fos:result>
               <fos:postamble>The two normalized <code>xs:dateTime</code> values are 
            <code>{1972, 12, 31, 23, 0, 0, PT0S}</code> and <code>{1972, 12, 30, 23, 0, 0, PT0S}</code>.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:subtract-times(xs:time("24:00:00"), xs:time("23:59:59"))</fos:expression>
               <fos:result>xs:dayTimeDuration("-PT23H59M59S")</fos:result>
               <fos:postamble>The two normalized <code>xs:dateTime</code> values are <code>{1972, 12, 31, 0, 0, 0, ()}</code> 
               and <code>{1972, 12, 31, 23, 59, 59.0, ()}</code>.</fos:postamble>
            </fos:test>
         </fos:example>           
      </fos:examples>
   </fos:function>
   <fos:function name="add-yearMonthDuration-to-dateTime">
      <fos:signatures>
         <fos:proto name="add-yearMonthDuration-to-dateTime" return-type="xs:dateTime">
            <fos:arg name="arg1" type="xs:dateTime"/>
            <fos:arg name="arg2" type="xs:yearMonthDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="+" types="xs:dateTime xs:yearMonthDuration numeric">Defines the semantics of the "+" operator on <code>xs:dateTime</code> and
                        <code>xs:yearMonthDuration</code> values. </fos:opermap>
      <fos:summary>
         <p>Summary: Returns the <code>xs:dateTime</code> that is a given duration after a specified <code>xs:dateTime</code>
			   (or before, if the duration is negative).</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the result of adding
                        <code>$arg2</code> to the value of <code>$arg1</code> using the
                        algorithm described in Appendix E of <bibref ref="xmlschema-2"/>, disregarding the rule about leap seconds. If
                        <code>$arg2</code> is negative, then the result <code>xs:dateTime</code>
                        precedes <code>$arg1</code>.</p>
         <p>The result has the same timezone as <code>$arg1</code>. If <code>$arg1</code>
                        has no timezone, the result has no timezone. </p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:add-yearMonthDuration-to-dateTime(xs:dateTime("2000-10-30T11:12:00"),
                                    xs:yearMonthDuration("P1Y2M"))</fos:expression>
               <fos:result>xs:dateTime("2001-12-30T11:12:00")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="add-dayTimeDuration-to-dateTime">
      <fos:signatures>
         <fos:proto name="add-dayTimeDuration-to-dateTime" return-type="xs:dateTime">
            <fos:arg name="arg1" type="xs:dateTime"/>
            <fos:arg name="arg2" type="xs:dayTimeDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="+" types="xs:dateTime xs:dayTimeDuration numeric">Defines the semantics of the "+" operator on <code>xs:dateTime</code> and
                        <code>xs:dayTimeDuration</code> values. </fos:opermap>
      <fos:summary>
         <p>Summary: Returns the <code>xs:dateTime</code> that is a given duration after a specified <code>xs:dateTime</code>
			   (or before, if the duration is negative).</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the result of adding
                        <code>$arg2</code> to the value of <code>$arg1</code> using the
                        algorithm described in Appendix E of <bibref ref="xmlschema-2"/>, disregarding the rule about leap seconds. If
                        <code>$arg2</code> is negative, then the result <code>xs:dateTime</code>
                        precedes <code>$arg1</code>.</p>
         <p>The result has the same timezone as <code>$arg1</code>. If <code>$arg1</code>
                        has no timezone, the result has no timezone. </p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:add-dayTimeDuration-to-dateTime(xs:dateTime("2000-10-30T11:12:00"),
                                    xs:dayTimeDuration("P3DT1H15M"))</fos:expression>
               <fos:result>xs:dateTime("2000-11-02T12:27:00")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="subtract-yearMonthDuration-from-dateTime">
      <fos:signatures>
         <fos:proto name="subtract-yearMonthDuration-from-dateTime" return-type="xs:dateTime">
            <fos:arg name="arg1" type="xs:dateTime"/>
            <fos:arg name="arg2" type="xs:yearMonthDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="-" types="xs:dateTime xs:yearMonthDuration numeric">Defines the semantics of the "-" operator on <code>xs:dateTime</code> and
                        <code>xs:yearMonthDuration</code> values. </fos:opermap>
      <fos:summary>
         <p>Summary: Returns the <code>xs:dateTime</code> that is a given duration before a specified <code>xs:dateTime</code>
			   (or after, if the duration is negative).</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the <code>xs:dateTime</code> computed by negating
                        <code>$arg2</code> and adding the result to the value of
                        <code>$arg1</code> using the function <code>op:add-yearMonthDuration-to-dateTime</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:subtract-yearMonthDuration-from-dateTime(xs:dateTime("2000-10-30T11:12:00"),
                                    xs:yearMonthDuration("P1Y2M"))</fos:expression>
               <fos:result>xs:dateTime("1999-08-30T11:12:00")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="subtract-dayTimeDuration-from-dateTime">
      <fos:signatures>
         <fos:proto name="subtract-dayTimeDuration-from-dateTime" return-type="xs:dateTime">
            <fos:arg name="arg1" type="xs:dateTime"/>
            <fos:arg name="arg2" type="xs:dayTimeDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="-" types="xs:dateTime xs:dayTimeDuration numeric">Defines the semantics of the "-" operator on <code>xs:dateTime</code> and
                        <code>xs:dayTimeDuration</code> values.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns the <code>xs:dateTime</code> that is a given duration before a specified <code>xs:dateTime</code>
			   (or after, if the duration is negative).</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the <code>xs:dateTime</code> computed by negating
                        <code>$arg2</code> and adding the result to the value of
                        <code>$arg1</code> using the function <code>op:add-dayTimeDuration-to-dateTime</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:subtract-dayTimeDuration-from-dateTime(xs:dateTime("2000-10-30T11:12:00"),
                                    xs:dayTimeDuration("P3DT1H15M"))</fos:expression>
               <fos:result>xs:dateTime("2000-10-27T09:57:00")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="add-yearMonthDuration-to-date">
      <fos:signatures>
         <fos:proto name="add-yearMonthDuration-to-date" return-type="xs:date">
            <fos:arg name="arg1" type="xs:date"/>
            <fos:arg name="arg2" type="xs:yearMonthDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="+" types="xs:date xs:yearMonthDuration numeric">Defines the semantics of the "+" operator on <code>xs:date</code> and
                        <code>xs:yearMonthDuration</code> values. </fos:opermap>
      <fos:summary>
         <p>Summary: Returns the <code>xs:date</code> that is a given duration after a specified <code>xs:date</code>
			   (or before, if the duration is negative).</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the result of casting <code>$arg1</code> to an <code>xs:dateTime</code>, adding <code>$arg2</code>
			   using the function <code>op:add-yearMonthDuration-to-dateTime</code>, and casting the result back to an <code>xs:date</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:add-yearMonthDuration-to-date(xs:date("2000-10-30"),
                                    xs:yearMonthDuration("P1Y2M"))</fos:expression>
               <fos:result>xs:date("2001-12-30")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="add-dayTimeDuration-to-date">
      <fos:signatures>
         <fos:proto name="add-dayTimeDuration-to-date" return-type="xs:date">
            <fos:arg name="arg1" type="xs:date"/>
            <fos:arg name="arg2" type="xs:dayTimeDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="+" types="xs:date xs:dayTimeDuration numeric">Defines the semantics of the "+" operator on <code>xs:date</code> and
                        <code>xs:dayTimeDuration</code> values. </fos:opermap>
      <fos:summary>
         <p>Summary: Returns the <code>xs:date</code> that is a given duration after a specified <code>xs:date</code>
			   (or before, if the duration is negative).</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the result of casting <code>$arg1</code> to an <code>xs:dateTime</code>, adding <code>$arg2</code>
			   using the function <code>op:add-dayTimeDuration-to-dateTime</code>, and casting the result back to an <code>xs:date</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:add-dayTimeDuration-to-date(xs:date("2004-10-30Z"),
                  xs:dayTimeDuration("P2DT2H30M0S"))</fos:expression>
               <fos:result>xs:date("2004-11-01Z")</fos:result>
               <fos:postamble>	The starting instant of the first argument is the <code>xs:dateTime</code> 
               	value <code>{2004, 10, 30, 0, 0, 0, PT0S}</code>.  
               	Adding the second argument to this gives the <code>xs:dateTime</code> 
               	value <code>{2004, 11, 1, 2, 30, 0, PT0S}</code>.  
               	The time components are then discarded.
               </fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="subtract-yearMonthDuration-from-date">
      <fos:signatures>
         <fos:proto name="subtract-yearMonthDuration-from-date" return-type="xs:date">
            <fos:arg name="arg1" type="xs:date"/>
            <fos:arg name="arg2" type="xs:yearMonthDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="-" types="xs:date xs:yearMonthDuration numeric">Defines the semantics of the "-" operator on <code>xs:date</code> and
                        <code>xs:yearMonthDuration</code> values. 
      </fos:opermap>
      <fos:summary>
         <p>Summary: Returns the <code>xs:date</code> that is a given duration before a specified <code>xs:date</code>
			   (or after, if the duration is negative).</p>
      </fos:summary>
      <fos:rules>
         <p>Returns the <code>xs:date</code> computed by negating
                        <code>$arg2</code> and adding the result to 
                        <code>$arg1</code> using the function <code>op:add-yearMonthDuration-to-date</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:subtract-yearMonthDuration-from-date(xs:date("2000-10-30"),
                                    xs:yearMonthDuration("P1Y2M"))</fos:expression>
               <fos:result>xs:date("1999-08-30")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:subtract-yearMonthDuration-from-date(xs:date("2000-02-29Z"),
                                    xs:yearMonthDuration("P1Y"))</fos:expression>
               <fos:result>xs:date("1999-02-28Z")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:subtract-yearMonthDuration-from-date(xs:date("2000-10-31-05:00"),
                  xs:yearMonthDuration("P1Y1M"))</fos:expression>
               <fos:result>xs:date("1999-09-30-05:00")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="subtract-dayTimeDuration-from-date">
      <fos:signatures>
         <fos:proto name="subtract-dayTimeDuration-from-date" return-type="xs:date">
            <fos:arg name="arg1" type="xs:date"/>
            <fos:arg name="arg2" type="xs:dayTimeDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="-" types="xs:date xs:dayTimeDuration numeric">Defines the semantics of the "-" operator on <code>xs:date</code> and
                        <code>xs:dayTimeDuration</code> values. </fos:opermap>
      <fos:summary>
         <p>Summary: Returns the <code>xs:date</code> that is a given duration before a specified <code>xs:date</code>
			   (or after, if the duration is negative).</p>
      </fos:summary>
      <fos:rules>
         <p>Returns the <code>xs:date</code> computed by negating
                        <code>$arg2</code> and adding the result to 
                        <code>$arg1</code> using the function <code>op:add-dayTimeDuration-to-date</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:subtract-dayTimeDuration-from-date(xs:date("2000-10-30"),
                                    xs:dayTimeDuration("P3DT1H15M"))</fos:expression>
               <fos:result>xs:date("2000-10-26")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="add-dayTimeDuration-to-time">
      <fos:signatures>
         <fos:proto name="add-dayTimeDuration-to-time" return-type="xs:time">
            <fos:arg name="arg1" type="xs:time"/>
            <fos:arg name="arg2" type="xs:dayTimeDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="+" types="xs:time xs:dayTimeDuration numeric">Defines the semantics of the "+" operator on <code>xs:time</code> and
                        <code>xs:dayTimeDuration</code> values.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns the <code>xs:time</code> value that is a given duration after a specified <code>xs:time</code>
			   (or before, if the duration is negative or causes wrap-around past midnight)</p>
      </fos:summary>
      <fos:rules>
         <p>First, the days component in the canonical lexical representation of
                        <code>$arg2</code> is set to zero (0) and the value of the resulting
                        <code>xs:dayTimeDuration</code> is calculated. Alternatively, the value of <code>$arg2</code> 
                        modulus 86,400 is used as the second argument. This value is added to the value of
                        <code>$arg1</code> converted to an <code>xs:dateTime</code> using a reference date 
						such as <code>1972-12-31</code>, and the time component of the result is returned. Note that the
                        <code>xs:time</code> returned may occur in a following or preceding day and
                        may be less than <code>$arg1</code>.</p>
         <p>The result has the same timezone as <code>$arg1</code>. If <code>$arg1</code>
                        has no timezone, the result has no timezone.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:add-dayTimeDuration-to-time(xs:time("11:12:00"),
                                    xs:dayTimeDuration("P3DT1H15M"))</fos:expression>
               <fos:result>xs:time("12:27:00")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:add-dayTimeDuration-to-time(xs:time("23:12:00+03:00"),
                  xs:dayTimeDuration("P1DT3H15M"))</fos:expression>
               <fos:result>xs:time("02:27:00+03:00")</fos:result>
               <fos:postamble>That is, <code>{0, 0, 0, 2, 27, 0, PT3H}</code></fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="subtract-dayTimeDuration-from-time">
      <fos:signatures>
         <fos:proto name="subtract-dayTimeDuration-from-time" return-type="xs:time">
            <fos:arg name="arg1" type="xs:time"/>
            <fos:arg name="arg2" type="xs:dayTimeDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="-" types="xs:time xs:dayTimeDuration numeric">Defines the semantics of the "-" operator on <code>xs:time</code> and
                        <code>xs:dayTimeDuration</code> values. </fos:opermap>
      <fos:summary>
         <p>Summary: Returns the <code>xs:time</code> value that is a given duration before a specified <code>xs:time</code>
			   (or after, if the duration is negative or causes wrap-around past midnight)</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the result of negating <code>$arg2</code> and adding the result to <code>$arg1</code>
			   using the function <code>add-dayTimeDuration-to-time</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:subtract-dayTimeDuration-from-time(xs:time("11:12:00"),
                                    xs:dayTimeDuration("P3DT1H15M"))</fos:expression>
               <fos:result>xs:time("09:57:00")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:subtract-dayTimeDuration-from-time(xs:time("08:20:00-05:00"),
                                    xs:dayTimeDuration("P23DT10H10M"))</fos:expression>
               <fos:result>xs:time("22:10:00-05:00")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="format-dateTime">
      <fos:signatures>
         <fos:proto name="format-dateTime" return-type="xs:string?">
            <fos:arg name="value" type="xs:dateTime?"/>
            <fos:arg name="picture" type="xs:string"/>
            <fos:arg name="language" type="xs:string?"/>
            <fos:arg name="calendar" type="xs:string?"/>
            <fos:arg name="place" type="xs:string?"/>
         </fos:proto>
         <fos:proto name="format-dateTime" return-type="xs:string?">
            <fos:arg name="value" type="xs:dateTime?"/>
            <fos:arg name="picture" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Returns a string containing an <code>xs:dateTime</code> value formatted for display.</p>
      </fos:summary>
      <fos:rules>
         <p>See <specref ref="rules-for-datetime-formatting"/>.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="format-date">
      <fos:signatures>
         <fos:proto name="format-date" return-type="xs:string?">
            <fos:arg name="value" type="xs:date?"/>
            <fos:arg name="picture" type="xs:string"/>
            <fos:arg name="language" type="xs:string?"/>
            <fos:arg name="calendar" type="xs:string?"/>
            <fos:arg name="place" type="xs:string?"/>
         </fos:proto>
         <fos:proto name="format-date" return-type="xs:string?">
            <fos:arg name="value" type="xs:date?"/>
            <fos:arg name="picture" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Returns a string containing an <code>xs:date</code> value formatted for display.</p>
      </fos:summary>
      <fos:rules>
         <p>See <specref ref="rules-for-datetime-formatting"/>.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="format-time">
      <fos:signatures>
         <fos:proto name="format-time" return-type="xs:string?">
            <fos:arg name="value" type="xs:time?"/>
            <fos:arg name="picture" type="xs:string"/>
            <fos:arg name="language" type="xs:string?"/>
            <fos:arg name="calendar" type="xs:string?"/>
            <fos:arg name="place" type="xs:string?"/>
         </fos:proto>
         <fos:proto name="format-time" return-type="xs:string?">
            <fos:arg name="value" type="xs:time?"/>
            <fos:arg name="picture" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Returns a string containing an <code>xs:time</code> value formatted for display.</p>
      </fos:summary>
      <fos:rules>
         <p>See <specref ref="rules-for-datetime-formatting"/>.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="resolve-QName">
      <fos:signatures>
         <fos:proto name="resolve-QName" return-type="xs:QName?">
            <fos:arg name="qname" type="xs:string?"/>
            <fos:arg name="element" type="element()"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns an <code>xs:QName</code> value (that is, an expanded-QName)
                        by taking an <code>xs:string</code> that has the lexical form of an
                        <code>xs:QName</code> (a string in the form "prefix:local-name" or
                        "local-name") and resolving it using the in-scope namespaces for a given element.</p>
      </fos:summary>
      <fos:rules>
         
         <p>If <code>$qname</code> is the empty sequence, returns the empty sequence.</p>
         <p>More specifically, the function searches the namespace bindings of
                        <code>$element</code> for a binding whose name matches the prefix of
                        <code>$qname</code>, or the zero-length string if it has no prefix, and
                        constructs an expanded-QName whose local name is taken from the supplied
                        <code>$qname</code>, and whose namespace URI is taken from the string value
                        of the namespace binding.</p>
         <p>If the <code>$qname</code> has a prefix and if there is no namespace binding
                        for <code>$element</code> that matches this prefix, then an error is raised
                            <errorref class="NS" code="0004"/>.</p>
         <p>If the <code>$qname</code> has no prefix, and there is no namespace binding for
                        <code>$element</code> corresponding to the default (unnamed) namespace, then
                        the resulting expanded-QName has no namespace part.</p>
         <p>The prefix (or absence of a prefix) in the supplied <code>$qname</code>
                        argument is retained in the returned expanded-QName, as discussed in
                            <xspecref spec="DM" ref="terminology"/>.</p>
         
      </fos:rules>
      <fos:errors>
         <p>If <code>$qname</code> does not have the correct lexical form
            for <code>xs:QName</code> an error is raised <errorref class="CA" code="0002"/>.</p>
      </fos:errors>
      <fos:notes>
         <p>Sometimes the requirement is to construct an <code>xs:QName</code>
            without using the default namespace. This can be achieved by writing:</p>
         <eg xml:space="preserve"> if (contains($qname, ":")) then fn:resolve-QName($qname, $element) else
            fn:QName("", $qname)</eg>
         <p>If the requirement is to construct an <code>xs:QName</code> using the
            namespaces in the static context, then the <code>xs:QName</code>
            constructor should be used.</p>
      </fos:notes>
      <fos:examples>
         <fos:example><p>Assume that the element bound to <code>$element</code> has a single
                            namespace binding bound to the prefix <code>eg</code>.</p></fos:example>
         
         <fos:example>
            <p>
               <code>fn:resolve-QName("hello", $element)</code> returns a QName
               with local name "hello" that is in no namespace.</p>
         </fos:example>
         <fos:example>
            <p>
               <code>fn:resolve-QName("eg:myFunc", $element)</code> returns an
               <code>xs:QName</code> whose namespace URI is specified by the
               namespace binding corresponding to the prefix "eg" and whose local
               name is "myFunc".</p>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="QName">
      <fos:signatures>
         <fos:proto name="QName" return-type="xs:QName">
            <fos:arg name="paramURI" type="xs:string?"/>
            <fos:arg name="paramQName" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Constructs an <code>xs:QName</code> value given a namespace URI and a lexical QName.</p>
      </fos:summary>
      <fos:rules>
         <p>The namespace URI in the returned QName is taken from <code>$paramURI</code>.
            If <code>$paramURI</code> is the zero-length string or the
            empty sequence, it represents "no namespace".</p>
         <p>The prefix (or absence of a
            prefix) in <code>$paramQName</code> is retained in the returned
            <code>xs:QName</code> value.</p>
         <p>The local name in the result is taken from the
                        local part of <code>$paramQName</code>.</p>
      </fos:rules>
      <fos:errors>
         <p>If <code>$paramQName</code> does not have the correct lexical form
            for an <code>xs:QName</code> an error is raised <errorref class="CA" code="0002"/>.</p>
         <p>If <code>$paramURI</code> is the zero-length string or the
            empty sequence, and the value                        
            of <code>$paramQName</code> contains a colon (<code>:</code>),                        
            an error is raised <errorref class="CA" code="0002"/>.</p>
      </fos:errors>
      <fos:notes>
         <p diff="del" at="F">Note that unlike the <code>xs:QName</code> constructor, this function does not require
                        a string literal as the argument.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <p>
               <code>fn:QName("http://www.example.com/example",
                  "person")</code> returns an <code>xs:QName</code> with namespace
               URI = "http://www.example.com/example", local name = "person"
               and prefix = "".</p>
         </fos:example>
         <fos:example>
            <p>
               <code>fn:QName("http://www.example.com/example",
               "ht:person")</code> returns an <code>xs:QName</code> with
               namespace URI = "http://www.example.com/example", local name =
               "person" and prefix = "ht".</p>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="QName-equal">
      <fos:signatures>
         <fos:proto name="QName-equal" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:QName"/>
            <fos:arg name="arg2" type="xs:QName"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="eq" types="xs:QName numeric" other-operators="ne">Defines the semantics of the "eq" and "ne" operators on values of type <code>xs:QName</code>. </fos:opermap>
      <fos:summary>
         <p>Summary: Returns <code>true</code> if two supplied QNames have the same namespace URI and the same local part.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns <code>true</code> if the namespace URIs of
                        <code>$arg1</code> and <code>$arg2</code> are equal and the local names of
                        <code>$arg1</code> and <code>$arg2</code> are equal.</p>
         <p>Otherwise, the function returns <code>false</code>.</p>
         <p>The namespace URI parts are considered equal if they are both absent, or if they are both
            present and equal under the rules of the <code>fn:codepoint-equal</code> function.</p>
         <p>The local parts are also compared under the rules of the <code>fn:codepoint-equal</code> function.</p>          
      </fos:rules>
      <fos:notes>
         <p>The prefix parts of <code>$arg1</code> and <code>$arg2</code>, if any, are ignored.</p>
      </fos:notes>
   </fos:function>
   <fos:function name="prefix-from-QName">
      <fos:signatures>
         <fos:proto name="prefix-from-QName" return-type="xs:NCName?">
            <fos:arg name="arg" type="xs:QName?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the prefix component of the supplied QName.</p>
      </fos:summary>
      <fos:rules>
        <p>If <code>$arg</code> is the empty sequence the function returns the empty sequence.</p>
        <p>If <code>$arg</code> has no prefix component the function returns the empty sequence.</p>
        <p>Otherwise, the function returns an <code>xs:NCName</code> representing the prefix component of
                        <code>$arg</code>.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="local-name-from-QName">
      <fos:signatures>
         <fos:proto name="local-name-from-QName" return-type="xs:NCName?">
            <fos:arg name="arg" type="xs:QName?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the local part of the supplied QName.</p>
      </fos:summary>
      <fos:rules>
        <p>If <code>$arg</code> is the empty sequence the function returns the empty sequence.</p>
        <p>Otherwise, the function returns an <code>xs:NCName</code> representing the local part of
                        <code>$arg</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:local-name-from-QName(fn:QName("http://www.example.com/example",
                                    "person"))</fos:expression>
               <fos:result>"person"</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="namespace-uri-from-QName">
      <fos:signatures>
         <fos:proto name="namespace-uri-from-QName" return-type="xs:anyURI?">
            <fos:arg name="arg" type="xs:QName?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the namespace URI part of the supplied QName.</p>
      </fos:summary>
      <fos:rules>
        <p>If <code>$arg</code> is the empty sequence the function returns the empty sequence.</p>
        <p>Otherwise, the function returns an <code>xs:anyURI</code> representing the namespace URI part of
                        <code>$arg</code>.</p>
        <p>If <code>$arg</code> is in no namespace, the
                        function returns the zero-length <code>xs:anyURI</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:namespace-uri-from-QName(fn:QName("http://www.example.com/example",
                        "person"))</fos:expression>
               <fos:result>xs:anyURI("http://www.example.com/example")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="namespace-uri-for-prefix">
      <fos:signatures>
         <fos:proto name="namespace-uri-for-prefix" return-type="xs:anyURI?">
            <fos:arg name="prefix" type="xs:string?"/>
            <fos:arg name="element" type="element()"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the namespace URI of one of the in-scope namespaces for
                        <code>$element</code>, identified by its namespace prefix.</p>
      </fos:summary>
      <fos:rules>
         <p> If <code>$element</code> has an in-scope namespace whose namespace prefix is
                        equal to <code>$prefix</code>, it returns the namespace URI of that
                        namespace. If <code>$prefix</code> is the zero-length string or the empty sequence, it returns the
                        namespace URI of the default (unnamed) namespace. Otherwise, it returns the
                        empty sequence.</p>
         <p>Prefixes are equal only if their Unicode codepoints match exactly.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="in-scope-prefixes">
      <fos:signatures>
         <fos:proto name="in-scope-prefixes" return-type="xs:string*">
            <fos:arg name="element" type="element()"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the prefixes of the in-scope namespaces for
                        an element node.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns a sequence of strings representing the prefixes 
            of the in-scope namespaces for <code>$element</code>.</p> 
            
         <p>For namespace bindings that have a prefix, the function returns the
         prefix as an <code>xs:NCName</code>. For the default namespace, which has no
         prefix, it returns the zero-length string. </p>
         
         <p>The result sequence contains no duplicates.</p>
         
         <p>The ordering of the result sequence is <termref def="implementation-dependent">implementation-dependent</termref>.</p>
         
      </fos:rules>
   </fos:function>
   <fos:function name="hexBinary-equal">
      <fos:signatures>
         <fos:proto name="hexBinary-equal" return-type="xs:boolean">
            <fos:arg name="value1" type="xs:hexBinary"/>
            <fos:arg name="value2" type="xs:hexBinary"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="eq" types="xs:hexBinary numeric" other-operators="ne">Defines the semantics of the "eq" and "ne" operators on
                        <code>xs:hexBinary</code> values.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns true if two <code>xs:hexBinary</code> values contain the same
         octet sequence.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns <code>true</code> if <code>$value1</code> and
            <code>$value2</code> are of the same length, measured in binary octets, and
            contain the same octets in the same order. Otherwise, it returns
            <code>false</code>. </p>
      </fos:rules>
   </fos:function>
   <fos:function name="base64Binary-equal">
      <fos:signatures>
         <fos:proto name="base64Binary-equal" return-type="xs:boolean">
            <fos:arg name="value1" type="xs:base64Binary"/>
            <fos:arg name="value2" type="xs:base64Binary"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="eq" types="xs:base64Binary numeric" other-operators="ne">Defines the semantics of the "eq" and "ne" operators on
                        <code>xs:base64Binary</code> values.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns true if two <code>xs:base64Binary</code> values contain the same
            octet sequence.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns <code>true</code> if <code>$value1</code> and
            <code>$value2</code> are of the same length, measured in binary octets, and
            contain the same octets in the same order. Otherwise, it returns
            <code>false</code>. </p>
      </fos:rules>
   </fos:function>
   <fos:function name="NOTATION-equal">
      <fos:signatures>
         <fos:proto name="NOTATION-equal" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:NOTATION"/>
            <fos:arg name="arg2" type="xs:NOTATION"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="eq" types="xs:NOTATION numeric" other-operators="ne">Defines the semantics of the "eq" and "ne" operators on values of type <code>xs:NOTATION</code>. </fos:opermap>
      <fos:summary>
         <p>Summary: Returns <code>true</code> if the two <code>xs:NOTATION</code> values 
            have the same namespace URI and the same local part.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns <code>true</code> if the namespace URIs of
            <code>$arg1</code> and <code>$arg2</code> are equal and the local names of
            <code>$arg1</code> and <code>$arg2</code> are equal.</p>
         <p>Otherwise, the function returns <code>false</code>.</p>
         <p>The namespace URI parts are considered equal if they are both absent, or if they are both
            present and equal under the rules of the <code>fn:codepoint-equal</code> function.</p>
         <p>The local parts are also compared under the rules of the <code>fn:codepoint-equal</code> function.</p>          
      </fos:rules>
      <fos:notes>
         <p>The prefix parts of <code>$arg1</code> and <code>$arg2</code>, if any, are ignored.</p>
      </fos:notes>
   </fos:function>
   <fos:function name="name">
      <fos:signatures>
         <fos:proto name="name" return-type="xs:string"/>
         <fos:proto name="name" return-type="xs:string">
            <fos:arg name="arg" type="node()?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the name of a node, as an <code>xs:string</code> that is either
                    the zero-length string, or has the lexical form of an <code>xs:QName</code>. </p>
      </fos:summary>
      <fos:rules>
         <p>If the argument is omitted, it defaults to the context item (<code>.</code>).
            The behavior of the function if the argument is omitted is exactly the same as if the context 
            item had been passed as the argument.</p>
         <p>If the argument is supplied and is the empty sequence, the function returns the
                    zero-length string.</p>
         <p>If the node identified by <code>$arg</code> has no name (that is, if it is a document node, a comment, a
                    text node, or a namespace node having no name), the function returns the
                    zero-length string.</p>
         <p>Otherwise, the function returns the value of the expression
                    <code>fn:string(fn:node-name($arg))</code>.</p>
      </fos:rules>
      <fos:errors>
         <p>The following errors may be raised when <code>$arg</code> is omitted:  if the context item is undefined 
            <xerrorref spec="XP" class="DY" code="0002" type="type"/>; 
            if the context item is not a node <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>
         
      </fos:errors>
   </fos:function>
   <fos:function name="local-name">
      <fos:signatures>
         <fos:proto name="local-name" return-type="xs:string"/>
         <fos:proto name="local-name" return-type="xs:string">
            <fos:arg name="arg" type="node()?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the local part of the name of <code>$arg</code> as an
                    <code>xs:string</code> that is either the zero-length string, or has
                    the lexical form of an <code>xs:NCName</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If the argument is omitted, it defaults to the context item (<code>.</code>).
            The behavior of the function if the argument is omitted is exactly the same as if 
            the context item had been passed as the argument.</p>
         <p>If the argument is supplied and is the empty sequence, the function returns the zero-length string.</p>
         <p>If the node identified by <code>$arg</code> has no name (that is, if it is a document node, 
                    a comment, a text node, or a namespace node having no name), the function returns the 
                    zero-length string.</p>
         <p>Otherwise, the function returns the local part of the expanded-QName of the
            node identified by <code>$arg</code>, as determined by the <code>dm:node-name</code> accessor
            defined in <xspecref spec="DM" ref="dm-node-name"/>). 
	  This will be an <code>xs:string</code> whose lexical form is an <code>xs:NCName</code>.</p>
      </fos:rules>
      <fos:errors>
         <p>The following errors may be raised when <code>$arg</code> is omitted:  if the context item is undefined 
            <xerrorref spec="XP" class="DY" code="0002" type="type"/>; 
            if the context item is not a node <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>
         
      </fos:errors>
   </fos:function>
   <fos:function name="namespace-uri">
      <fos:signatures>
         <fos:proto name="namespace-uri" return-type="xs:anyURI"/>
         <fos:proto name="namespace-uri" return-type="xs:anyURI">
            <fos:arg name="arg" type="node()?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p diff="chg" at="A-E15">Summary: Returns the namespace URI part of the name of <code>$arg</code>, as an
	  <code>xs:anyURI</code> value.</p>
      </fos:summary>
      <fos:rules>
         <p>If the argument is omitted, it defaults to the context node (<code>.</code>). 
	The behavior of the function if the argument is omitted is exactly the same as if 
	the context item had been passed as the argument.</p>
         <p>If the node identified by <code>$arg</code> is neither an element nor an attribute node, 
            or if it is an element or attribute node whose expanded-QName (as determined by the
            <code>dm:node-name</code> accessor in the <xspecref spec="DM" ref="dm-node-name"/>) 
            is in no namespace, then the function returns the zero-length <code>xs:anyURI</code> value.</p>
         <p>Otherwise, the result will be the namespace URI part of the expanded-QName of the
            node identified by <code>$arg</code>, as determined by the <code>dm:node-name</code> accessor 
            defined in <xspecref spec="DM" ref="dm-node-name"/>), returned as an <code>xs:anyURI</code> value.</p>
      </fos:rules>
      <fos:errors>
         <p>The following errors may be raised when <code>$arg</code> is omitted:  if the context item is undefined 
            <xerrorref spec="XP" class="DY" code="0002" type="type"/>; 
            if the context item is not a node <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>         
      </fos:errors>
   </fos:function>
   <fos:function name="number">
      <fos:signatures>
         <fos:proto name="number" return-type="xs:double"/>
         <fos:proto name="number" return-type="xs:double">
            <fos:arg name="arg" type="xs:anyAtomicType?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the value indicated by <code>$arg</code> or, if
                    <code>$arg</code> is not specified, the context item after atomization,
                    converted to an <code>xs:double</code>.
            </p>
      </fos:summary>
      <fos:rules>
         <p>Calling the zero-argument version of the function is defined to give the same
                    result as calling the single-argument version with the context item (<code>.</code>). That is,
                    <code>fn:number()</code> is equivalent to <code>fn:number(.)</code>.</p>
         <p>If <code>$arg</code> is the empty
                    sequence or if <code>$arg</code> or the context item cannot be converted to an
                    <code>xs:double</code>, the <code>xs:double</code> value <code>NaN</code> is
                    returned. </p>
         <p>Otherwise, <code>$arg</code>, or the context item after atomization, is
                    converted to an <code>xs:double</code> following the rules of <specref ref="casting-to-double"/>. 
					If the conversion to <code>xs:double</code> fails,
                    the <code>xs:double</code> value <code>NaN</code> is returned.</p>
      </fos:rules>
      <fos:errors>
         <p>If <code>$arg</code> is omitted and the context item is undefined an error is raised: 
            <xerrorref spec="XP" class="DY" code="0002" type="type"/>.</p>         
      </fos:errors>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:number($item1/quantity)</fos:expression>
               <fos:result>5.0e0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:number($item2/description)</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <p>Assume that the context item is the <code>xs:string</code> value
                                "<code>15</code>".
               Then <code>fn:number()</code> returns <code>1.5e1</code>.</p>
         </fos:example>
      </fos:examples>

   </fos:function>
   <fos:function name="lang">
      <fos:signatures>
         <fos:proto name="lang" return-type="xs:boolean">
            <fos:arg name="testlang" type="xs:string?"/>
         </fos:proto>
         <fos:proto name="lang" return-type="xs:boolean">
            <fos:arg name="testlang" type="xs:string?"/>
            <fos:arg name="node" type="node()"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: This function tests whether the language of <code>$node</code>, or the
                    context item if the second argument is omitted, as specified by
                    <code>xml:lang</code> attributes is the same as, or is a sublanguage of, the
                    language specified by <code>$testlang</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>The behavior of the function if the second argument is omitted is exactly the same as if the 
			        context item  (<code>.</code>) had been passed as the second argument.</p>
         <p>The language of the argument <code>$node</code>,
                    or the context item if the second argument is omitted, is determined by the
                    value of the <code>xml:lang</code> attribute on the node, or, if the node has no
                    such attribute, by the value of the <code>xml:lang</code> attribute on the
                    nearest ancestor of the node that has an <code>xml:lang</code> attribute. If
                    there is no such ancestor, then the function returns <code>false</code>.
                </p>
         
         <p>If <code>$testlang</code> is the empty sequence it is interpreted as the
                    zero-length string.</p>
         <p>The relevant <code>xml:lang</code> attribute is determined by the value of the
                    XPath expression:</p>
         <eg xml:space="preserve">(ancestor-or-self::*/@xml:lang)[last()]</eg>
         <p>If this expression returns an empty sequence, the function returns
                    <code>false</code>. </p>
         <p>Otherwise, the function returns <code>true</code> if and only if, based on a caseless 
			default match as specified in section 3.13 of <bibref ref="Unicode4"/>, either:</p>
            <olist><item><p diff="chg" at="A-E16">
                        <code>$testlang</code> is equal to the string-value of the relevant
		       <code>xml:lang</code> attribute, or</p>
               </item>
               <item>
                  <p diff="chg" at="A-E16">
                        <code>$testlang</code> is equal to some substring of the string-value 
		  of the relevant <code>xml:lang</code> attribute that starts at the start of the 
		  string-value and ends immediately before a hyphen, "-" (the character "-" is
                    HYPHEN-MINUS, #x002D).</p>
               </item>
            </olist>
      </fos:rules>
      <fos:errors>
         <p>When <code>$arg</code> is omitted the following errors may be raised:  
            if the context item is undefined <xerrorref spec="XP" class="DY" code="0002" type="type"/>; 
            if the context item is not a node <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>
      </fos:errors>
      <fos:examples>
         <fos:example>
            <p>The expression <code>fn:lang("en")</code> would return
                                <code>true</code> if the context node were any of the following four elements:</p>
            <ulist>
               <item>
                  <p><code>&lt;para xml:lang="en"/&gt;</code>
                                    </p>
               </item>
               <item>
                  <p><code>&lt;div xml:lang="en"&gt;&lt;para&gt;And now,
                                            and forever!&lt;/para&gt;&lt;/div&gt;</code>
                                    </p>
               </item>
               <item>
                  <p><code>&lt;para xml:lang="EN"/&gt;</code>
                                    </p>
               </item>
               <item>
                  <p><code>&lt;para xml:lang="en-us"/&gt;</code>
                                    </p>
               </item>
            </ulist>
         </fos:example>
         <fos:example>
            <p>The expression <code>fn:lang("fr")</code> would return
                                <code>false</code> if the context node were <code>&lt;para xml:lang="EN"/&gt;</code>
                            </p>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="is-same-node">
      <fos:signatures>
         <fos:proto name="is-same-node" return-type="xs:boolean">
            <fos:arg name="arg1" type="node()"/>
            <fos:arg name="arg2" type="node()"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="is" types="numeric">Defines the semantics of the "is" operator on nodes.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns true if the two arguments refer to the same node.</p>
      </fos:summary>
      <fos:rules>
         <p>If the node identified by the value of <code>$arg1</code> is the
                    same node as the node identified by the value of <code>$arg2</code> (that
                    is, the two nodes have the same identity), then the function returns
                    <code>true</code>; otherwise, the function returns <code>false</code>. </p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:is-same-node($item1, $item1)</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:is-same-node($item1, $item2)</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="node-before">
      <fos:signatures>
         <fos:proto name="node-before" return-type="xs:boolean">
            <fos:arg name="arg1" type="node()"/>
            <fos:arg name="arg2" type="node()"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="&lt;&lt;" types="numeric">Defines the semantics of the "&lt;&lt;" operator.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns true if the node identified by the first argument precedes the node identified by the second argument
			in document order.</p>
      </fos:summary>
      <fos:rules>
         <p>If the node identified by the value of <code>$arg1</code> occurs
                    in document order before the node identified by the value of
                    <code>$arg2</code>, then the function returns <code>true</code>; otherwise, it
                    returns <code>false</code>.</p>
         <p>The rules determining the order of nodes within a
                    single document and in different documents can be found in 
                    <xspecref spec="DM" ref="document-order"/>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:node-before($item1, $item2)</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:node-before($item1, $item1)</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="node-after">
      <fos:signatures>
         <fos:proto name="node-after" return-type="xs:boolean">
            <fos:arg name="arg1" type="node()"/>
            <fos:arg name="arg2" type="node()"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator=">>" types="numeric">Defines the semantics of the "&gt;&gt;" operator.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns true if the node identified by the first argument follows the node identified by the second argument
			in document order.</p>
      </fos:summary>
      <fos:rules>
         <p>If the node identified by the value of <code>$arg1</code> occurs
                    in document order after the node identified by the value of
                    <code>$arg2</code>, the function returns <code>true</code>; otherwise, it
                    returns <code>false</code>.</p>
         <p>The rules determining the order of nodes within a
                    single document and in different documents can be found in 
                    <xspecref spec="DM" ref="document-order"/>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:node-after($item1, $item2)</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:node-after($item1, $item1)</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:node-after($item2, $item1)</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="root">
      <fos:signatures>
         <fos:proto name="root" return-type="node()"/>
         <fos:proto name="root" return-type="node()?">
            <fos:arg name="arg" type="node()?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the root of the tree to which <code>$arg</code> belongs. This
                    will usually, but not necessarily, be a document node.</p>
      </fos:summary>
      <fos:rules>
         <p>If the function is called without an argument, the context item (<code>.</code>) is used as the
                    default argument. The behavior of the function if the argument is omitted is exactly the same as if the 
					context item had been passed as the argument.</p>
         
         <p>The function returns the value of the expression <code>($arg/ancestor-or-self::node())[1]</code>.</p>
      </fos:rules>
      <fos:errors>
         <p>When <code>$arg</code> is omitted the following errors may be raised :  
            if the context item is undefined <xerrorref spec="XP" class="DY" code="0002" type="type"/>; 
            if the context item is not a node <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>
      </fos:errors>
      <fos:examples>
         <fos:example><p>These examples use some variables which could be defined in <bibref ref="xquery"/> as:</p></fos:example>
         <fos:example>
                        <eg xml:space="preserve">let $i := &lt;tool&gt;wrench&lt;/tool&gt;
let $o := &lt;order&gt; {$i} &lt;quantity&gt;5&lt;/quantity&gt; &lt;/order&gt;
let $odoc := document {$o}
let $newi := $o/tool</eg>
                    </fos:example>
         <fos:example><p>Or they could be defined in <bibref ref="xslt20"/> as:</p></fos:example>
         <fos:example>
                        <eg xml:space="preserve">&lt;xsl:variable name="i" as="element()"&gt;
  &lt;tool&gt;wrench&lt;/tool&gt;
&lt;/xsl:variable&gt;

&lt;xsl:variable name="o" as="element()"&gt;
  &lt;order&gt;
    &lt;xsl:copy-of select="$i"/&gt;
    &lt;quantity&gt;5&lt;/quantity&gt;
  &lt;/order&gt;
&lt;/xsl:variable&gt;

&lt;xsl:variable name="odoc"&gt;
  &lt;xsl:copy-of select="$o"/&gt;
&lt;/xsl:variable&gt;

&lt;xsl:variable name="newi" select="$o/tool"/&gt;</eg>
                    </fos:example>
         <fos:example>
            <p><code>fn:root($i)</code> returns the element node <code>$i</code>
                            </p>
         </fos:example>
         <fos:example>
            <p><code>fn:root($o/quantity)</code> returns the element node <code>$o</code>
                            </p>
         </fos:example>
         <fos:example>
            <p><code>fn:root($odoc//quantity)</code> returns the document node <code>$odoc</code>
                            </p>
         </fos:example>
         <fos:example>
            <p><code>fn:root($newi)</code> returns the element node <code>$o</code>
                            </p>
         </fos:example>
         <fos:example>
            <p>The final three examples could be made type-safe by wrapping their operands with <code>fn:exactly-one()</code>.</p>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="concatenate">
      <fos:signatures>
         <fos:proto name="concatenate" return-type="item()*">
            <fos:arg name="seq1" type="item()*"/>
            <fos:arg name="seq2" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="," types="numeric">Defines the semantics of the infix operator ",". </fos:opermap>
      <fos:summary>
         <p>Summary: Returns the concatenation of two sequences.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns a sequence consisting of all the items in <code>$seq1</code>
            followed by all the items in <code>$seq2</code>. </p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:notes>
         <p>If either sequence is the empty sequence, the other operand is returned.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:concatenate((1, 2, 3), (4, 5))</fos:expression>
               <fos:result>(1, 2, 3, 4, 5)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:concatenate((1, 2, 3), ())</fos:expression>
               <fos:result>(1, 2, 3)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:concatenate((), ())</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="index-of">
      <fos:signatures>
         <fos:proto name="index-of" return-type="xs:integer*">
            <fos:arg name="seq" type="xs:anyAtomicType*"/>
            <fos:arg name="search" type="xs:anyAtomicType"/>
         </fos:proto>
         <fos:proto name="index-of" return-type="xs:integer*">
            <fos:arg name="seq" type="xs:anyAtomicType*"/>
            <fos:arg name="search" type="xs:anyAtomicType"/>
            <fos:arg name="collation" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns a sequence of positive integers giving the positions within
                        the sequence <code>$seq</code> of items that are equal to <code>$search</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns a sequence of positive integers giving the positions within
            the sequence <code>$seq</code> of items that are equal to <code>$search</code>.</p>
         <p>The collation used by this function is determined according
               to the rules in <specref ref="choosing-a-collation"/>. This collation is used when
               string comparison is required.</p>
         <p>The items in the sequence <code>$seq</code> are compared with
               <code>$search</code> under the rules for the <code>eq</code> operator.  
               Values of type <code>xs:untypedAtomic</code> are
               compared as if they were of type <code>xs:string</code>.
               Values that cannot be compared, because the <code>eq</code> operator is not
               defined for their types, are considered to be distinct. If an item compares
               equal, then the position of that item in the sequence
               <code>$seq</code> is included in the result.</p>         
         <p>The first item in a sequence is at position 1, not position 0.</p>
         <p>The result sequence is in ascending numeric order.</p>
      </fos:rules>
      <fos:notes>
         <p>If the value of <code>$seq</code> is the empty sequence, or if no item
            in <code>$seq</code> matches <code>$search</code>, then the function returns the empty
            sequence.</p>
         <p diff="add" at="D">No error occurs if non-comparable values are encountered. So when comparing two
         atomic values, the effective boolean value of <code>fn:index-of($a, $b)</code> is true if <code>$a</code>
         and <code>$b</code> are equal, false if they are not equal or not comparable.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:index-of((10, 20, 30, 40), 35)</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:index-of((10, 20, 30, 30, 20, 10), 20)</fos:expression>
               <fos:result>(2, 5)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:index-of(("a", "sport", "and", "a", "pastime"), "a")</fos:expression>
               <fos:result>(1, 4)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:index-of(current-date(), 23)</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <p diff="chg" at="A-E41">If <code>@a</code> is an attribute of type <code>xs:NMTOKENS</code> whose
               string value is <code>"red green blue"</code>, and whose typed value is therefore
               <code>("red", "green", "blue")</code>, then 
               <code>fn:index-of(@a, "blue")</code> returns <code>3</code>.
              This is because the function calling mechanism atomizes the
              attribute node to produce a sequence of three <code>xs:NMTOKEN</code> values.</p>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="empty">
      <fos:signatures>
         <fos:proto name="empty" return-type="xs:boolean">
            <fos:arg name="arg" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns true if the argument is the empty sequence.</p>
      </fos:summary>
      <fos:rules>
         <p>If the value of <code>$arg</code> is the empty sequence, the
            function returns <code>true</code>; otherwise, the function returns
            <code>false</code>. </p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:empty((1,2,3)[10])</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:empty(fn:remove(("hello", "world"), 1))</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="exists">
      <fos:signatures>
         <fos:proto name="exists" return-type="xs:boolean">
            <fos:arg name="arg" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns true if the argument is a non-empty sequence.</p>
      </fos:summary>
      <fos:rules>
         <p>If the value of <code>$arg</code> is a non-empty sequence, the
            function returns <code>true</code>; otherwise, the function returns
            <code>false</code>. </p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:exists(fn:remove(("hello"), 1))</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:exists(fn:remove(("hello", "world"), 1))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="distinct-values">
      <fos:signatures>
         <fos:proto name="distinct-values" return-type="xs:anyAtomicType*">
            <fos:arg name="arg" type="xs:anyAtomicType*"/>
         </fos:proto>
         <fos:proto name="distinct-values" return-type="xs:anyAtomicType*">
            <fos:arg name="arg" type="xs:anyAtomicType*"/>
            <fos:arg name="collation" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Returns the values that appear in a sequence, with duplicates eliminated.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the sequence that results from removing
            from <code>$arg</code> all but one of a set of values that are equal to one another.
            Values are compared using the <code>eq</code> operator, subject to the caveats defined below.</p>
         <p>Values of type <code>xs:untypedAtomic</code> are compared as if they were of
            type <code>xs:string</code>.</p>
         <p>Values that cannot be compared, because the <code>eq</code>
            operator is not defined for their types, are considered to be distinct.</p>
         
         <p>The collation used by this function is determined according
            to the rules in <specref ref="choosing-a-collation"/>. 
            This collation is used when string comparison is required.</p>
         
         <p>For <code>xs:float</code> and <code>xs:double</code> values, positive zero
                        is equal to negative zero and, although <code>NaN</code> does not equal
                        itself, if <code>$arg</code> contains multiple <code>NaN</code> values a
                        single <code>NaN</code> is returned.</p>
         <p> If <code>xs:dateTime</code>, <code>xs:date</code> or <code>xs:time</code>
                        values do not have a timezone, they are considered to have the implicit timezone provided by the dynamic context for the purpose of comparison.  Note that
                        <code>xs:dateTime</code>, <code>xs:date</code> or <code>xs:time</code> values
                        can compare equal even if their timezones are different.</p>
         <p>The order in which the sequence of values is
            returned is <termref def="implementation-dependent"/>.</p>
         
         <p>Which value of a set of values that compare equal is returned is 
            <termref def="implementation-dependent"/>. </p>
         <p diff="del" at="F">The static type of the result is a sequence of prime types as defined in
            [Formal Semantics].</p>
         <change diff="add" at="A-E44">
         <p>If the input sequence contains values of different numeric types that differ from each other
            by small amounts, then the eq operator is not transitive, because of rounding effects occurring
            during type promotion. In the situation where the input contains three values <code>A</code>, 
            <code>B</code>, and <code>C</code> such
            that <code>A eq B</code>, <code>B eq C</code>, but <code>A ne C</code>, then the number of items 
            in the result of the function
            (as well as the choice of which items are returned) is <termref def="implementation-dependent"/>, subject only 
            to the constraints that (a) no two items in the result sequence compare equal to each other, 
            and (b) every input item that does not appear in the result sequence compares equal to some 
            item that does appear in the result sequence.</p>            
            
            <p>For example, this arises when computing:</p>
            
            <eg><![CDATA[    distinct-values(
            (xs:float('1.0'),
            xs:decimal('1.0000000000100000000001',
            xs:double( '1.00000000001'))]]></eg>
            
            <p>because the values of type <code>xs:float</code> and <code>xs:double</code> both compare equal to 
               the value of type <code>xs:decimal</code> but not equal to each other. </p>
         </change>
      </fos:rules>
      <fos:notes>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:distinct-values((1, 2.0, 3, 2))</fos:expression>
               <fos:result allow-permutation="true">(1, 3, 2.0)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:distinct-values((xs:untypedAtomic("cherry"),
                  xs:untypedAtomic("plum"),
                  xs:untypedAtomic("plum")))</fos:expression>
               <fos:result allow-permutation="true">(xs:untypedAtomic("cherry"),
                  xs:untypedAtomic("plum"))</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="insert-before">
      <fos:signatures>
         <fos:proto name="insert-before" return-type="item()*">
            <fos:arg name="target" type="item()*"/>
            <fos:arg name="position" type="xs:integer"/>
            <fos:arg name="inserts" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns a sequence constructed by inserting an item or a sequence of items
         at a given position within an existing sequence.</p>
      </fos:summary>
      <fos:rules>         
         <p>The value returned by the function consists of all items of
                        <code>$target</code> whose index is less than <code>$position</code>,
                        followed by all items of <code>$inserts</code>, followed by the remaining
                        elements of <code>$target</code>, in that order. </p>
         
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:notes>
         <p>If <code>$target</code> is the empty sequence, <code>$inserts</code> is
                        returned. If <code>$inserts</code> is the empty sequence,
                        <code>$target</code> is returned.</p>
         <p>If <code>$position</code> is less than one (1), the first position, the
                        effective value of <code>$position</code> is one (1). If
                        <code>$position</code> is greater than the number of items in
                        <code>$target</code>, then the effective value of <code>$position</code> is
                        equal to the number of items in <code>$target</code> plus 1. </p>
         <p>The value of <code>$target</code> is not affected by the sequence construction.</p>
      </fos:notes>
      <fos:examples>
         <fos:variable name="abc" select="(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)"/>
         <fos:example>
            <fos:test>
               <fos:expression>fn:insert-before($abc, 0, "z")</fos:expression>
               <fos:result>("z", "a", "b", "c")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:insert-before($abc, 1, "z")</fos:expression>
               <fos:result>("z", "a", "b", "c")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:insert-before($abc, 2, "z")</fos:expression>
               <fos:result>("a", "z", "b", "c")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:insert-before($abc, 3, "z")</fos:expression>
               <fos:result>("a", "b", "z", "c")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:insert-before($abc, 4, "z")</fos:expression>
               <fos:result>("a", "b", "c", "z")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="remove">
      <fos:signatures>
         <fos:proto name="remove" return-type="item()*">
            <fos:arg name="target" type="item()*"/>
            <fos:arg name="position" type="xs:integer"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns a new sequence containing all the items of
                        <code>$target</code> except the item at position
                        <code>$position</code>.</p>
      </fos:summary>
      <fos:rules>         
         <p>The function returns a sequence consisting of all items of <code>$target</code>
                        whose index is less than <code>$position</code>, followed by all items of
                        <code>$target</code> whose index is greater than <code>$position</code>. </p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:notes>
         <p>If <code>$position</code> is less than 1 or greater than the number of items
            in <code>$target</code>, <code>$target</code> is returned.</p>
         <p>If <code>$target</code> is the empty sequence, the empty sequence is returned.</p>
      </fos:notes>
      <fos:examples>
         <fos:variable name="abc" select="(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)"/>
         <fos:example>
            <fos:test>
               <fos:expression>fn:remove($abc, 0)</fos:expression>
               <fos:result>("a", "b", "c")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:remove($abc, 1)</fos:expression>
               <fos:result>("b", "c")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:remove($abc, 6)</fos:expression>
               <fos:result>("a", "b", "c")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:remove((), 3)</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="head" diff="add" at="E">
      <fos:signatures>
         <fos:proto name="head" return-type="item()?">
            <fos:arg name="arg" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the first item in a sequence. </p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the value of the expression <code>$arg[1]</code></p>
      </fos:rules>
      <fos:notes>
         <p>If <code>$arg</code> is the empty sequence, the empty sequence is returned. Otherwise the first
         item in the sequence is returned.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:head(1 to 5)</fos:expression>
               <fos:result>1</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:head(("a", "b", "c"))</fos:expression>
               <fos:result>"a"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:head(())</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="tail" diff="add" at="E">
      <fos:signatures>
         <fos:proto name="tail" return-type="item()*">
            <fos:arg name="arg" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns all but the first item in a sequence. </p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the value of the expression <code>subsequence($arg, 2)</code></p>
      </fos:rules>
      <fos:notes>
         <p>If <code>$arg</code> is the empty sequence, or a sequence containing a single item,
            then the empty sequence is returned. </p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:tail(1 to 5)</fos:expression>
               <fos:result>(2, 3, 4, 5)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:tail(("a", "b", "c"))</fos:expression>
               <fos:result>("b", "c")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:tail("a")</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:tail(())</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="reverse">
      <fos:signatures>
         <fos:proto name="reverse" return-type="item()*">
            <fos:arg name="arg" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Reverses the order of items in a sequence. </p>
      </fos:summary>
      <fos:rules>
         <p>The function returns a sequence containing the items in <code>$arg</code> in reverse order.</p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:notes>
         <p>If <code>$arg</code> is the empty sequence, the empty sequence is returned. </p>
      </fos:notes>
      <fos:examples>
         <fos:variable name="abc" select="(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)"/>
         <fos:example>
            <fos:test>
               <fos:expression>fn:reverse($abc)</fos:expression>
               <fos:result>("c", "b", "a")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:reverse(("hello"))</fos:expression>
               <fos:result>("hello")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:reverse(())</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="subsequence">
      <fos:signatures>
         <fos:proto name="subsequence" return-type="item()*">
            <fos:arg name="sourceSeq" type="item()*"/>
            <fos:arg name="startingLoc" type="xs:double"/>
         </fos:proto>
         <fos:proto name="subsequence" return-type="item()*">
            <fos:arg name="sourceSeq" type="item()*"/>
            <fos:arg name="startingLoc" type="xs:double"/>
            <fos:arg name="length" type="xs:double"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the contiguous sequence of items in the value of
                        <code>$sourceSeq</code> beginning at the position indicated by the value of
                        <code>$startingLoc</code> and continuing for the number of items indicated
                        by the value of <code>$length</code>. </p>
      </fos:summary>
      <fos:rules>
         <p>In the two-argument case, returns:</p>
         <eg diff="chg" at="A-E2" xml:space="preserve">$sourceSeq[fn:round($startingLoc) le position()]</eg>
         <p>In the three-argument case, returns:</p>
         <eg diff="chg" at="A-E2" xml:space="preserve">$sourceSeq[fn:round($startingLoc) le position() 
         and position() lt fn:round($startingLoc) + fn:round($length)]</eg>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:notes>
            <p>The first item of a sequence is located at position 1, not position 0.</p>
            <p>If <code>$sourceSeq</code> is the empty sequence, the empty sequence is returned.</p>
            <p>
If <code>$startingLoc</code> is zero or negative, the subsequence includes items from the
beginning of the <code>$sourceSeq</code>.</p>
            <p>
If <code>$length</code> is not specified, the subsequence includes items to the end of <code>$sourceSeq</code>.</p>
            <p>
If <code>$length</code> is greater than the number of items in the value of <code>$sourceSeq</code>
following <code>$startingLoc</code>, the subsequence includes items to the end of <code>$sourceSeq</code>.</p>
         <p diff="add" at="F">As an exception to the previous two notes, if <code>$startingLoc</code> is <code>-INF</code>
            and <code>$length</code> is <code>+INF</code>, then <code>fn:round($startingLoc) + fn:round($length)</code> is <code>NaN</code>;
            since <code>position() lt NaN</code> is always false, the result is an empty sequence.</p>         
            <p>The reason the function accepts arguments of type <code>xs:double</code> is that many computations on untyped data return an <code>xs:double</code> result; and the reason for the rounding rules is to compensate for any imprecision in these floating-point computations.</p>
      </fos:notes>
      
      <fos:examples>
         <fos:variable name="seq" select="(&quot;item1&quot;, &quot;item2&quot;, &quot;item3&quot;, &quot;item4&quot;, &quot;item5&quot;)"/>
         <fos:example>
            <fos:test>
               <fos:expression>fn:subsequence($seq, 4)</fos:expression>
               <fos:result>("item4", "item5")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:subsequence($seq, 3, 2)</fos:expression>
               <fos:result>("item3", "item4")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="unordered">
      <fos:signatures>
         <fos:proto name="unordered" return-type="item()*">
            <fos:arg name="sourceSeq" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the items of <code>$sourceSeq</code> in an 
            <termref def="implementation-dependent"/> order.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the items of <code>$sourceSeq</code> in an 
            <termref def="implementation-dependent"/> order.</p>
      </fos:rules>
      <fos:notes>
         <p>Query optimizers may be able to do a better job if the order of the
             output sequence is not specified. For example, when retrieving prices
             from a purchase order, if an index exists on prices, it may be more
             efficient to return the prices in index order rather than in document order.</p>
      </fos:notes>
	  <fos:examples>
	      <fos:example>
	         <fos:test>
	            <fos:expression>fn:unordered((1, 2, 3, 4, 5))</fos:expression>
	            <fos:result allow-permutation="true">(1, 2, 3, 4, 5)</fos:result>
	         </fos:test>
	      </fos:example>
	  </fos:examples>
   </fos:function>
   <fos:function name="zero-or-one">
      <fos:signatures>
         <fos:proto name="zero-or-one" return-type="item()?">
            <fos:arg name="arg" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns <code>$arg</code> if it contains zero or one items.
                        Otherwise, raises an error.</p>
      </fos:summary>
      <fos:rules>
         <p>Except in error cases, the function returns <code>$arg</code> unchanged.</p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:errors>
         <p>An error is raised <errorref class="RG" code="0003"/> if <code>$arg</code> contains
         more than one item.</p>
      </fos:errors>
   </fos:function>
   <fos:function name="one-or-more">
      <fos:signatures>
         <fos:proto name="one-or-more" return-type="item()+">
            <fos:arg name="arg" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns <code>$arg</code> if it contains one or more items.
                        Otherwise, raises an error. </p>
      </fos:summary>
      <fos:rules>
         <p>Except in error cases, the function returns <code>$arg</code> unchanged.</p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:errors>
         <p>An error is raised <errorref class="RG" code="0004"/> if <code>$arg</code> is an empty sequence.</p>
      </fos:errors>
   </fos:function>
   <fos:function name="exactly-one">
      <fos:signatures>
         <fos:proto name="exactly-one" return-type="item()">
            <fos:arg name="arg" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns <code>$arg</code> if it contains exactly one item. Otherwise,
                        raises an error. </p>
      </fos:summary>
      <fos:rules>
         <p>Except in error cases, the function returns <code>$arg</code> unchanged.</p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:errors>
         <p>An error is raised <errorref class="RG" code="0005"/> if <code>$arg</code> is an empty sequence
            or a sequence containing more than one item.</p>
      </fos:errors></fos:function>
   <fos:function name="deep-equal">
      <fos:signatures>
         <fos:proto name="deep-equal" return-type="xs:boolean">
            <fos:arg name="parameter1" type="item()*"/>
            <fos:arg name="parameter2" type="item()*"/>
         </fos:proto>
         <fos:proto name="deep-equal" return-type="xs:boolean">
            <fos:arg name="parameter1" type="item()*"/>
            <fos:arg name="parameter2" type="item()*"/>
            <fos:arg name="collation" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p> Summary: This function assesses whether two sequences are deep-equal to each
                        other. To be deep-equal, they must contain items that are pairwise
                        deep-equal; and for two items to be deep-equal, they must either be atomic
                        values that compare equal, or nodes of the same kind, with the same name,
                        whose children are deep-equal.</p>
      </fos:summary>
      <fos:rules>
         <p>The <code>$collation</code> argument identifies a collation which is used at all
            levels of recursion when strings are compared (but not when names are
            compared), according to the rules in <specref ref="choosing-a-collation"/>.</p>
         <p>If the two sequences are both empty, the function returns <code>true</code>.</p>
         <p>If the two sequences are of different lengths, the function returns <code>false</code>.</p>
         <p>If the two sequences are of the same length, the function returns
                        <code>true</code> if and only if every item in the sequence
                        <code>$parameter1</code> is deep-equal to the item at the same position in
                        the sequence <code>$parameter2</code>. The rules for deciding whether two
                        items are deep-equal follow.</p>
         
         <p>Call the two items <code>$i1</code> and <code>$i2</code> respectively.</p>
         <p>If <code>$i1</code> and <code>$i2</code> are both atomic values, they are
                deep-equal if and only if <code>($i1 eq $i2)</code> is <code>true</code>, 
                or if both values are <code>NaN</code>.

                      If the <code>eq</code> operator is not defined for <code>$i1</code> and
                        <code>$i2</code>, the function returns <code>false</code>.</p>
         <p> If one of the pair <code>$i1</code> or <code>$i2</code> is an atomic value
                        and the other is a node, the function returns <code>false</code>.</p>
         <p>If <code>$i1</code> and <code>$i2</code> are both nodes, they are compared as
         described below:</p>
         <olist>   
            <item><p>If the two nodes are of different kinds, the result is <code>false</code>.</p></item>
            <item><p>If the two nodes are both document nodes then they are deep-equal if and only
                           if the sequence <code>$i1/(*|text())</code> is deep-equal to the sequence <code>$i2/(*|text())</code>.</p></item>
            <item><p> If the two nodes are both element nodes then they are deep-equal if and only
            if all of the following conditions are satisfied:</p>
            <olist>
               <item>
                  <p>The two nodes have the same name, that is <code>(node-name($i1) eq node-name($i2))</code>.</p>
               </item>
               <item>
                  <p>The two nodes are both annotated as having simple content or both nodes are annotated as having complex content.</p>
               </item>
               <item>
                  <p>The two nodes have the same number of attributes, and for every
                                   attribute <code>$a1</code> in <code>$i1/@*</code> there exists an
                                   attribute <code>$a2</code> in <code>$i2/@*</code> such that
                                   <code>$a1</code> and <code>$a2</code> are deep-equal.</p>
               </item>
               <item>
                  <p> One of the following conditions holds:</p>
                  <ulist>
                     <item>
                        <p>Both element nodes have a type annotation that is simple content, and the
                                           typed value of <code>$i1</code> is deep-equal to the typed
                                           value of <code>$i2</code>.</p>
                     </item>
                     <item>
                        <p>Both element nodes have a type annotation that
                                           is complex content with elementOnly content, and each child element of <code>$i1</code> is deep-equal to the corresponding child element of <code>$i2</code>.</p>
                     </item>
                     <item>
                        <p>Both element nodes have a type annotation that
                                           is complex content with mixed content, and the sequence <code>$i1/(*|text())</code> is
                                           deep-equal to the sequence <code>$i2/(*|text())</code>.</p>
                     </item>
                     <item>
                        <p>Both element nodes have a type annotation that
                                           is complex content with empty content.</p>
                     </item>
                  </ulist>
               </item>
            </olist></item>
            <item><p> If the two nodes are both attribute nodes then they are deep-equal if and
                           only if both the following conditions are satisfied:</p>
            <olist>
               <item>
                  <p>The two nodes have the same name, that is <code>(node-name($i1) eq node-name($i2))</code>.</p>
               </item>
               <item>
                  <p>The typed value of <code>$i1</code> is deep-equal to the typed value of <code>$i2</code>.</p>
               </item>
            </olist></item>
            <item><p> If the two nodes are both processing instruction nodes <phrase diff="del" at="A-E42">or namespace bindings</phrase>,
                           then they are deep-equal if and only if both the following conditions are satisfied:</p>
            <olist>
               <item>
                  <p>The two nodes have the same name, that is <code>(node-name($i1) eq node-name($i2))</code>.</p>
               </item>
               <item>
                  <p>The string value of <code>$i1</code> is equal to the string value of <code>$i2</code>.</p>
               </item>
            </olist></item>
            <item diff="add" at="A-E42"><p> If the two nodes are both namespace nodes,
               then they are deep-equal if and only if both the following conditions are satisfied:</p>
               <olist>
                  <item>
                     <p>The two nodes either have the same name or are both nameless, 
                        that is <code>fn:deep-equal(node-name($i1), node-name($i2))</code>.</p>
                  </item>
                  <item>
                     <p>The string value of <code>$i1</code> is equal to the string value of <code>$i2</code>
                        when compared using the Unicode codepoint collation.</p>
                  </item>
               </olist>
            </item>
            <item><p>If the two nodes are both text nodes or comment nodes, then they are
                           deep-equal if and only if their string-values are equal.</p></item>
         </olist> 
      </fos:rules>
      <fos:errors>
         <p diff="add" at="B">If either input sequence contains a function item,
            the function raises an error <errorref class="TY" code="0015"/> </p>
      </fos:errors>
       <fos:notes>
            <p> The two nodes are not required to have the same type annotation, and
                            they are not required to have the same in-scope namespaces. They may
                            also differ in their parent, their base URI, and the values returned by the <code>is-id</code> and <code>is-idrefs</code> accessors (see <xspecref spec="DM" ref="dm-is-id"/> and <xspecref spec="DM" ref="dm-is-idrefs"/>). The order of
                            children is significant, but the order of attributes is insignificant. </p>
            <p> The contents of comments and processing instructions are significant
                            only if these nodes appear directly as items in the two sequences being
                            compared. The content of a comment or processing instruction that
                            appears as a descendant of an item in one of the sequences being
                            compared does not affect the result. However, the presence of a comment
                            or processing instruction, if it causes a text node to be split into two
                            text nodes, may affect the result.</p>
            <p> The result of <code>fn:deep-equal(1, current-dateTime())</code> is
                            <code>false</code>; it does not raise an error.</p>
      </fos:notes>
      <fos:examples>
         <fos:variable name="at" as="element()">&lt;attendees&gt; 
  &lt;name last='Parker' first='Peter'/&gt; 
  &lt;name last='Barker' first='Bob'/&gt; 
  &lt;name last='Parker' first='Peter'/&gt; 
&lt;/attendees&gt;</fos:variable>
         <fos:example>
            <fos:test>
               <fos:expression>fn:deep-equal($at, $at/*)</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:deep-equal($at/name[1], $at/name[2])</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:deep-equal($at/name[1], $at/name[3])</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:deep-equal($at/name[1], 'Peter Parker')</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="union">
      <fos:signatures>
         <fos:proto name="union" return-type="node()*">
            <fos:arg name="arg1" type="node()*"/>
            <fos:arg name="arg2" type="node()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="union" types="numeric" other-operators="|">Defines the semantics of the "union" or "|" operator.</fos:opermap>
      <fos:summary>
         <p>Summary: Constructs a sequence containing every node that occurs in the
                        values of either <code>$arg1</code> or <code>$arg2</code>,
                        eliminating duplicates and sorting the result in document order.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns a sequence containing every node that occurs in the
            values of either <code>$arg1</code> or <code>$arg2</code>,
            eliminating duplicate nodes. Nodes are returned in document order.</p>
         <p>Two nodes <code>$n1</code> and <code>$n2</code>
            are duplicates if they satisfy <code>op:is-same-node($n1, $n2)</code>.</p>
         
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:notes>
         <p>If either operand is the empty sequence, the result is a sequence containing
            the nodes in the other operand in document order after eliminating duplicates.</p>
      </fos:notes>
      <fos:examples>
         <fos:variable name="seq1" select="($item1, $item2)"/>
         <fos:variable name="seq2" select="($item2, $item2, $item1)"/>
         <fos:variable name="seq3" select="($item2, $item3)"/>
         <fos:example>
            <fos:test>
               <fos:expression>op:union($seq1, $seq1)</fos:expression>
               <fos:result>($item1, $item2)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:union($seq2, $seq3)</fos:expression>
               <fos:result>($item1, $item2, $item3)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:union($seq2, ())</fos:expression>
               <fos:result>($item1, $item2)</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="intersect">
      <fos:signatures>
         <fos:proto name="intersect" return-type="node()*">
            <fos:arg name="arg1" type="node()*"/>
            <fos:arg name="arg2" type="node()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="intersect" types="numeric">Defines the semantics of the "intersect" operator.</fos:opermap>
      <fos:summary>
         <p>Summary: Constructs a sequence containing every node that occurs in the
            values of both <code>$arg1</code> and <code>$arg2</code>,
            eliminating duplicates and sorting the result in document order.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns a sequence containing every node that occurs in the
            values of both <code>$arg1</code> and <code>$arg2</code>,
            eliminating duplicate nodes. Nodes are returned in document order.</p>
         <p>Two nodes <code>$n1</code> and <code>$n2</code>
            are duplicates if they satisfy <code>op:is-same-node($n1, $n2)</code>.</p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:notes>
         <p>If either operand is the empty sequence, the function returns the empty sequence.</p>
      </fos:notes>
      <fos:examples>
         <fos:variable name="seq1" select="($item1, $item2)"/>
         <fos:variable name="seq2" select="($item2, $item2, $item1)"/>
         <fos:variable name="seq3" select="($item2, $item3)"/>
         <fos:example>
            <fos:test>
               <fos:expression>op:intersect($seq1, $seq1)</fos:expression>
               <fos:result>($item1, $item2)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:intersect($seq2, $seq3)</fos:expression>
               <fos:result>($item2)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:intersect($seq2, ())</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:intersect($item1, $item3)</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="except">
      <fos:signatures>
         <fos:proto name="except" return-type="node()*">
            <fos:arg name="arg1" type="node()*"/>
            <fos:arg name="arg2" type="node()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="except" types="numeric">Defines the semantics of the "except" operator.</fos:opermap>
      <fos:summary>
         <p>Summary: Constructs a sequence containing every node that occurs in the
            value of <code>$arg1</code> but not in the value of <code>$arg2</code>,
            eliminating duplicates and sorting the result in document order.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns a sequence containing every node that occurs in the
            value of <code>$arg1</code> provided that it does not occur in the value of <code>$arg2</code>.
            Duplicate nodes are eliminated, and nodes are returned in document order.</p>
         <p>Two nodes <code>$n1</code> and <code>$n2</code>
            are duplicates if they satisfy <code>op:is-same-node($n1, $n2)</code>.</p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:notes>
         <p>If <code>$arg1</code> is the empty sequence, the empty sequence is
         returned.</p>
         <p>If <code>$arg2</code> is the empty sequence, a sequence is
                        returned containing the nodes in <code>$arg1</code> in document order
                        after eliminating duplicates.</p>
      </fos:notes>
      <fos:examples>
         <fos:variable name="seq1" select="($item1, $item2)"/>
         <fos:variable name="seq2" select="($item2, $item2, $item1)"/>
         <fos:variable name="seq3" select="($item2, $item3)"/>
         <fos:example>
            <fos:test>
               <fos:expression>op:except($seq1, $seq1)</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:except($seq2, $seq1)</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:except($seq2, $seq3)</fos:expression>
               <fos:result>($item1)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:except($seq2, ())</fos:expression>
               <fos:result>($item1, $item2)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:except($seq3, $seq2)</fos:expression>
               <fos:result>($item3)</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="count">
      <fos:signatures>
         <fos:proto name="count" return-type="xs:integer">
            <fos:arg name="arg" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the number of items in a sequence.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the number of items in the value of <code>$arg</code>.</p>
      </fos:rules>
      <fos:notes>
         <p>Returns 0 if <code>$arg</code> is the empty sequence.</p>
      </fos:notes>
      <fos:examples>
         <fos:variable name="seq1" select="($item1, $item2)"/>
         <fos:variable name="seq2" select="(98.5, 98.3, 98.9)"/>
         <fos:variable name="seq3" select="()"/>
         <fos:example>
            <fos:test>
               <fos:expression>fn:count($seq1)</fos:expression>
               <fos:result>2</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:count($seq3)</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:count($seq2)</fos:expression>
               <fos:result>3</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:count($seq2[. &gt; 100])</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="avg">
      <fos:signatures>
         <fos:proto name="avg" return-type="xs:anyAtomicType?">
            <fos:arg name="arg" type="xs:anyAtomicType*"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the average of the values in the input
                        sequence <code>$arg</code>, that is, the sum of the values divided by the
                        number of values.</p>
      </fos:summary>
      <fos:rules>
         
         <p>If <code>$arg</code> is the empty sequence, the empty sequence is returned.</p>
         <p>If <code>$arg</code> contains values of type <code>xs:untypedAtomic</code>
                        they are cast to <code>xs:double</code>. </p>
         <p>Duration values must either all be <code>xs:yearMonthDuration</code> values
                        or must all be <code>xs:dayTimeDuration</code> values. For numeric values,
                        the numeric promotion rules defined in <specref ref="op.numeric"/> are used
                        to promote all values to a single common type. After these operations,
                        <code>$arg</code> must contain items of a single type, which must be one of
                        the four numeric types, <code>xs:yearMonthDuration</code> or
                        <code>xs:dayTimeDuration</code> or one if its subtypes.</p>
         
         <p>The function returns the average of the values as <code>sum($arg) div count($arg)</code>; 
            but the implementation may use an otherwise equivalent algorithm that avoids arithmetic overflow.</p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:errors>
         <p>If the input sequence contains items of incompatible types, as described above, 
            then a type error is raised <errorref class="RG" code="0006"/>.</p>
      </fos:errors>
      <fos:examples>
         <fos:variable name="d1" select="xs:yearMonthDuration(&quot;P20Y&quot;)"/>
         <fos:variable name="d2" select="xs:yearMonthDuration(&quot;P10M&quot;)"/>
         <fos:variable name="seq3" select="(3, 4, 5)"/>
         <fos:example>
            <fos:test>
               <fos:expression>fn:avg($seq3)</fos:expression>
               <fos:result>4.0</fos:result>
               <fos:postamble>The result is of type <code>xs:decimal</code>.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:avg(($d1, $d2))</fos:expression>
               <fos:result>xs:yearMonthDuration("P10Y5M")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <p><code>fn:avg(($d1, $seq3))</code> raises a type error <errorref class="RG" code="0006"/>. </p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:avg(())</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:avg((xs:float('INF'), xs:float('-INF')))</fos:expression>
               <fos:result>xs:float('NaN')</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:avg(($seq3, xs:float('NaN')))</fos:expression>
               <fos:result>xs:float('NaN')</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="max">
      <fos:signatures>
         <fos:proto name="max" return-type="xs:anyAtomicType?">
            <fos:arg name="arg" type="xs:anyAtomicType*"/>
         </fos:proto>
         <fos:proto name="max" return-type="xs:anyAtomicType?">
            <fos:arg name="arg" type="xs:anyAtomicType*"/>
            <fos:arg name="collation" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns a value that is equal to the highest value appearing in the input sequence.</p>
      </fos:summary>
      <fos:rules>
         <p>The following rules are applied to the input sequence <code>$arg</code>:</p>
         <ulist>
            <item>
               <p>Values of type <code>xs:untypedAtomic</code> in <code>$arg</code> are cast to
                  <code>xs:double</code>.</p>
            </item>
            <item><!--Text replaced by erratum E27 change 1"--><p diff="chg" at="A-E27">Numeric and <code>xs:anyURI</code> values are converted to the 
		least common type reachable by a combination 
		of type promotion and subtype substitution. See <xspecref spec="XP" ref="promotion"/> and <xspecref spec="XP" ref="mapping"/>.</p>
               <!--End of text replaced by erratum E27--></item>
         </ulist>
         <p>The items in the resulting sequence may be reordered in an arbitrary order. 
            The resulting sequence is referred to below as the converted sequence. 
            The function returns an item from the converted sequence rather than the input sequence. </p>
         <p>If the converted sequence is empty, the function returns the empty sequence.</p>
         <p>All items in the <phrase diff="chg" at="A-E47">converted sequence must be derived</phrase> from a single base
            type for which the <code>le</code> operator is defined. In addition, the values in
            the sequence must have a total order. If date/time values do not have a
            timezone, they are considered to have the implicit timezone provided by the dynamic context for the purpose of comparison. Duration values
            must either all be <code>xs:yearMonthDuration</code> values or must all be
            <code>xs:dayTimeDuration</code> values.</p>
         <p>If the converted sequence contains the value <code>NaN</code>, the value
            <code>NaN</code> is returned.</p>
         <p>If the items in the <phrase diff="chg" at="A-E47">converted sequence</phrase> are of type
            <code>xs:string</code> or types derived by restriction from
            <code>xs:string</code>, then the determination of the item with the smallest
            value is made according to the collation that is used. If the type of the
            items in the <phrase diff="chg" at="A-E47">converted sequence</phrase> is not <code>xs:string</code> and
            <code>$collation</code> is specified, the collation is ignored.</p>
         <p>The collation used by this function is determined according
                        to the rules in <specref ref="choosing-a-collation"/>.</p>
         <p>The function returns the result of the expression:</p>
         <eg xml:space="preserve">
   if (every $v in $c satisfies $c[1] ge $v)
   then $c[1] 
   else fn:max(fn:subsequence($c, 2))</eg>
         <p>evaluated with <code>$collation</code> as the default collation if specified, 
            and with <code>$c</code> as the converted sequence.</p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:errors>
         <p>If the input sequence contains items of incompatible types, as described above, 
            then a type error is raised <errorref class="RG" code="0006"/>.</p>
      </fos:errors>
      <fos:notes>
         <p>Because the rules allow the sequence to be reordered, if there are two or items that are "equal highest",
            the specific item whose value is returned is <termref def="implementation-dependent"/>. This can
            arise for example if two different strings compare equal under the selected collation, or if two
            different <code>xs:dateTime</code> values compare equal despite being in different timezones.</p>
         <p>If the converted sequence contains exactly one value then that value is returned.</p>
         <p>The default type when the <code>fn:max</code> function is applied
             to <code>xs:untypedAtomic</code> values is <code>xs:double</code>. This
             differs from the default type for operators such as <code>gt</code>, and
             for sorting in XQuery and XSLT, which is <code>xs:string</code>.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:max((3,4,5))</fos:expression>
               <fos:result>5</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:max((xs:integer(5), xs:float(5.0), xs:double(0)))</fos:expression>
               <fos:result>xs:double(5.0e0)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <p><code>fn:max((3,4,"Zero"))</code> raises a type error <errorref class="RG" code="0006"/>. </p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:max((fn:current-date(), xs:date("2100-01-01")))</fos:expression>
               <fos:result>xs:date("2100-01-01")</fos:result>
               <fos:postamble>Assuming that the current date is during the 21st century.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:max(("a", "b", "c"))</fos:expression>
               <fos:result>"c"</fos:result>
               <fos:postamble>Assuming a typical default collation.</fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="min">
      <fos:signatures>
         <fos:proto name="min" return-type="xs:anyAtomicType?">
            <fos:arg name="arg" type="xs:anyAtomicType*"/>
         </fos:proto>
         <fos:proto name="min" return-type="xs:anyAtomicType?">
            <fos:arg name="arg" type="xs:anyAtomicType*"/>
            <fos:arg name="collation" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns a value that is equal to the lowest value appearing in the input sequence.</p>
      </fos:summary>
      <fos:rules>
         <p>The following rules are applied to the input sequence:</p>
         <ulist>
            <item>
               <p>Values of type <code>xs:untypedAtomic</code> in <code>$arg</code> are cast to
                  <code>xs:double</code>.</p>
            </item>
            <item><!--Text replaced by erratum E27 change 2"--><p diff="chg" at="A-E27">Numeric and 
               <code>xs:anyURI</code> values are converted to the 
		least common type reachable by a combination 
		of type promotion and subtype substitution. See <xspecref spec="XP" ref="promotion"/> and <xspecref spec="XP" ref="mapping"/>.</p>
               <!--End of text replaced by erratum E27--></item>
         </ulist>
         <p>The items in the
            resulting sequence may be reordered in an arbitrary order. The resulting
            sequence is referred to below as the converted sequence. 
            The function returns an item from the converted sequence rather than the input sequence. </p>
         <p>If the converted sequence is empty, the empty sequence is returned.</p>
         <p>All items in the <phrase diff="chg" at="A-E47">converted sequence must be derived</phrase> from a single base
            type for which the <code>le</code> operator is defined. In addition, the values in
            the sequence must have a total order. If date/time values do not have a
            timezone, they are considered to have the implicit timezone provided by the dynamic context for the purpose of comparison. Duration values
            must either all be <code>xs:yearMonthDuration</code> values or must all be
            <code>xs:dayTimeDuration</code> values.</p>
         <p>If the converted sequence contains the value <code>NaN</code>, the value
            <code>NaN</code> is returned.</p>
         <p>If the items in the <phrase diff="chg" at="A-E47">converted sequence</phrase> are of type
            <code>xs:string</code> or types derived by restriction from
            <code>xs:string</code>, then the determination of the item with the smallest
            value is made according to the collation that is used. If the type of the
            items in the <phrase diff="chg" at="A-E47">converted sequence</phrase> is not <code>xs:string</code> and
            <code>$collation</code> is specified, the collation is ignored.</p>
         <p>The collation used by this function is determined according
            to the rules in <specref ref="choosing-a-collation"/>.</p>
         <p>The function returns the result of the expression:</p>
         <eg xml:space="preserve">
   if (every $v in $c satisfies $c[1] le $v) 
   then $c[1] 
   else fn:min(fn:subsequence($c, 2))</eg>
         <p>evaluated with <code>$collation</code> as the default collation if specified, 
            and with <code>$c</code> as the converted sequence.</p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:errors>
         <p>If the input sequence contains items of incompatible types, as described above, 
            then a type error is raised <errorref class="RG" code="0006"/>.</p>
      </fos:errors>
      <fos:notes>
         <p>Because the rules allow the sequence to be reordered, if there are two or items that are "equal lowest",
            the specific item whose value is returned is <termref def="implementation-dependent"/>. This can
            arise for example if two different strings compare equal under the selected collation, or if two
            different <code>xs:dateTime</code> values compare equal despite being in different timezones.</p>
         <p>If the converted sequence contains exactly one value then that value is returned.</p>
         <p>The default type when the <code>fn:min</code> function is applied
            to <code>xs:untypedAtomic</code> values is <code>xs:double</code>. This
            differs from the default type for operators such as <code>lt</code>, and
            for sorting in XQuery and XSLT, which is <code>xs:string</code>.</p>
         
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:min((3,4,5))</fos:expression>
               <fos:result>3</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:min((xs:integer(5), xs:float(5), xs:double(10)))</fos:expression>
               <fos:result>xs:double(5.0e0)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <p><code>fn:min((3,4,"Zero"))</code> raises a type error <errorref class="RG" code="0006"/>. </p>
         </fos:example>
         <fos:example>
            <p><code>fn:min((xs:float(0.0E0), xs:float(-0.0E0)))</code> can return either positive or negative zero. 
               <phrase diff="chg" at="F">The two items are equal, so it is <termref def="implementation-dependent"/> which is returned.</phrase></p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:min((fn:current-date(), xs:date("1900-01-01")))</fos:expression>
               <fos:result>xs:date("1900-01-01")</fos:result>
               <fos:postamble>Assuming that the current date is set to a reasonable value.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:min(("a", "b", "c"))</fos:expression>
               <fos:result>"a"</fos:result>
               <fos:postamble>Assuming a typical default collation.</fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="sum">
      <fos:signatures>
         <fos:proto name="sum" return-type="xs:anyAtomicType">
            <fos:arg name="arg" type="xs:anyAtomicType*"/>
         </fos:proto>
         <fos:proto name="sum" return-type="xs:anyAtomicType?">
            <fos:arg name="arg" type="xs:anyAtomicType*"/>
            <fos:arg name="zero" type="xs:anyAtomicType?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns a value obtained by adding together the values
                        in <code>$arg</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>Any values of type <code>xs:untypedAtomic</code> in <code>$arg</code> are
                        cast to <code>xs:double</code>. The items in the resulting sequence may be
                        reordered in an arbitrary order. The resulting sequence is referred to below
                        as the converted sequence.</p>
         <p>If the converted sequence is empty, then the single-argument form of the
                        function returns the <code>xs:integer</code> value <code>0</code>; the
                        two-argument form returns the value of the argument <code>$zero</code>.</p>
         <p>If the converted sequence contains the value <code>NaN</code>,
                        <code>NaN</code> is returned.</p>
         <p>All items in <code>$arg</code> must be numeric or derived from a single base
                        type. In addition, the type must support addition. Duration values must
                        either all be <code>xs:yearMonthDuration</code> values or must all be
                        <code>xs:dayTimeDuration</code> values. For numeric values, the numeric
                        promotion rules defined in <specref ref="op.numeric"/> are used to promote
                        all values to a single common type. The sum of a sequence of integers will
                        therefore be an integer, while the sum of a numeric sequence that includes
                        at least one <code>xs:double</code> will be an <code>xs:double</code>. </p>
         <p>The result of the function, using the second signature, is the
                        result of the expression:</p>
         <eg xml:space="preserve">
if (fn:count($c) eq 0) then
    $zero
else if (fn:count($c) eq 1) then
    $c[1]
else
    $c[1] + fn:sum(subsequence($c, 2))</eg>
         <p>where <code>$c</code> is the converted sequence.</p>
         <p>The result of the function, using the first signature, is the result of the
                            expression: <code>fn:sum($arg, 0)</code>.</p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:errors>
         <p>If the input sequence contains items of incompatible types, as described above, 
            then a type error is raised <errorref class="RG" code="0006"/>.</p>
      </fos:errors>
      <fos:notes>
            <p>The second argument allows an appropriate value to be defined to
                            represent the sum of an empty sequence. For example, when summing a
                            sequence of durations it would be appropriate to return a zero-length
                            duration of the appropriate type. This argument is necessary because a
                            system that does dynamic typing cannot distinguish "an empty sequence of
                            integers", for example, from "an empty sequence of durations".</p>
            <p> If the converted sequence contains exactly one value then that value is returned.</p>
      </fos:notes>
      <fos:examples>
         <fos:variable name="d1" select="xs:yearMonthDuration(&quot;P20Y&quot;)"/>
         <fos:variable name="d2" select="xs:yearMonthDuration(&quot;P10M&quot;)"/>
         <fos:variable name="seq1" select="($d1, $d2)"/>
         <fos:variable name="seq3" select="(3, 4, 5)"/>
         <fos:example>
            <fos:test>
               <fos:expression>fn:sum(($d1, $d2))</fos:expression>
               <fos:result>xs:yearMonthDuration("P20Y10M")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:sum($seq1[. lt xs:yearMonthDuration('P3M')],
                  xs:yearMonthDuration('P0M'))</fos:expression>
               <fos:result>xs:yearMonthDuration("P0M")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:sum($seq3)</fos:expression>
               <fos:result>12</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:sum(())</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:sum((),())</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:sum((1 to 100)[. lt 0], 0) </fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <p><code>fn:sum(($d1, 9E1))</code> raises an error <errorref class="RG" code="0006"/>. </p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:sum(($d1, $d2), "ein Augenblick")</fos:expression>
               <fos:result>xs:yearMonthDuration("P20Y10M")</fos:result>
               <fos:postamble>There is no requirement that the <code>$zero</code> value should be
               the same type as the items in <code>$arg</code>, or even that it should belong
               to a type that supports addition.</fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="to">
      <fos:signatures>
         <fos:proto name="to" return-type="xs:integer*">
            <fos:arg name="firstval" type="xs:integer"/>
            <fos:arg name="lastval" type="xs:integer"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="to" types="numeric">Defines the semantics of the "to" operator.</fos:opermap>
      <fos:summary>
         <p>Summary: Returns a sequence of consecutive integers in a given range.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the sequence containing every <code>xs:integer</code> whose
            value is between the value of <code>$firstval</code> (inclusive) and the
            value of <code>$lastval</code> (inclusive), in monotonic increasing order.</p>
         <p>If the value
            of the first operand is greater than the value of the second, the function returns the empty
            sequence.</p>
         <p>If the values of the two operands are equal, the function returns a
            sequence containing a single <code>xs:integer</code> equal to that value.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>1 to 3</fos:expression>
               <fos:result>(1, 2, 3)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>3 to 1</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>5 to 5</fos:expression>
               <fos:result>5</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="id">
      <fos:signatures>
         <fos:proto name="id" return-type="element()*">
            <fos:arg name="arg" type="xs:string*"/>
         </fos:proto>
         <fos:proto name="id" return-type="element()*">
            <fos:arg name="arg" type="xs:string*"/>
            <fos:arg name="node" type="node()"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the sequence of element nodes that have an <code>ID</code>
                        value matching the value of one or more of the <code>IDREF</code> values
                        supplied in <code>$arg</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns a sequence, in document order with duplicates
            eliminated, containing every element node <code>E</code> that satisfies all
            the following conditions:</p>
         <olist>
            <item>
               <p>
                 <code>E</code> is in the target document. The target document is the
                 document containing <code>$node</code>, or the document containing
                 the context item (<code>.</code>) if the second argument is omitted.
                  The behavior of the function if <code>$node</code> is omitted is exactly the 
                  same as if the context item had been passed as <code>$node</code>.</p>
            </item>
            <item>
               <p><code>E</code> has an <code>ID</code> value equal to one of the
                    candidate <code>IDREF</code> values, where:</p>
               <ulist>
                  <item>
                     <p> An element has an <code>ID</code> value equal to
                         <code>V</code> if either or both of the following conditions
                         are true:</p>
                     <ulist>
                        <item>
                           <p>The <code>is-id</code> property (See <xspecref spec="DM" ref="dm-is-id"/>.) of the element node
                              is true, and the typed value of the element node is
                              equal to V under the rules of the <code>eq</code>
                              operator using the Unicode codepoint collation (<code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>).</p>
                        </item>
                        <item>
                           <p>The element has an attribute node whose
                              <code>is-id</code> property (See <xspecref spec="DM" ref="dm-is-id"/>.) is true and whose typed value is
                              equal to <code>V</code> under the rules of the
                              <code>eq</code> operator using the Unicode code
                              point collation (<code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>).</p>
                        </item>
                     </ulist>
                  </item>
                  <item>
                     <p> Each <code>xs:string</code> in <code>$arg</code> is parsed
                         as if it were of type <code>IDREFS</code>, that is, each
                         <code>xs:string</code> in <code>$arg</code> is treated as a
                         whitespace-separated sequence of tokens, each acting as an
                         <code>IDREF</code>. These tokens are then included in the
                         list of candidate <code>IDREF</code>s. If any of the tokens
                         is not a lexically valid <code>IDREF</code> (that is, if it
                         is not lexically an <code>xs:NCName</code>), it is ignored.
                         Formally, the candidate <code>IDREF</code> values are the
                         strings in the sequence given by the expression:</p>
<eg xml:space="preserve">for $s in $arg return 
    fn:tokenize(fn:normalize-space($s), ' ')[. castable as xs:IDREF]</eg>
                                    
                  </item>
               </ulist>
            </item>
            <item>
               <p>If several elements have the same <code>ID</code> value, then
                   <code>E</code> is the one that is first in document order.</p>
            </item>
         </olist>
      </fos:rules>
      <fos:errors>
         <p>If <code>$node</code>, or the context item if the second argument is
            omitted, is a node in a tree whose root is not a document node 
            <errorref class="DC" code="0001" type="dynamic"/> is raised.</p>  
            <p>If the second argument is the context item, or is omitted, the following errors 
            may be raised: if there is no context item,
            <xerrorref spec="XP" class="DY" code="0002" type="type"/>; if the context item is not a node 
            <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>
      </fos:errors>
      <fos:notes>
         <p diff="chg" at="A-E31">The effect of this function is anomalous
            in respect of element nodes with the <code>is-id</code> property. For legacy reasons, this function
            returns the element that has the <code>is-id</code> property, whereas it would be more appropriate to return
            its parent, that being the element that is uniquely identified by the ID. A new function
            <function>element-with-id</function> is being introduced with the desired behavior.</p>
         
         <p> If the data model is constructed from an Infoset, an attribute will have
             the <code>is-id</code> property if the corresponding attribute in the
             Infoset had an attribute type of <code>ID</code>: typically this means
             the attribute was declared as an <code>ID</code> in a DTD.</p>
         <!--Text replaced by erratum E13 change 1"--><p diff="chg" at="A-E13"> If the data model is constructed from a PSVI, an element or attribute
             will have the <code>is-id</code> property if its typed value is a single
      atomic value of type <code>xs:ID</code>
             or a type derived by restriction from <code>xs:ID</code>.</p>
         <!--End of text replaced by erratum E13--><p> No error is raised in respect of a candidate <code>IDREF</code> value
             that does not match the <code>ID</code> of any element in the document.
             If no candidate <code>IDREF</code> value matches the <code>ID</code>
             value of any element, the function returns the empty sequence.</p>
         <p> It is not necessary that the supplied argument should have type <code>xs:IDREF</code> or <code>xs:IDREFS</code>, or that it should be
             derived from a node with the <code>is-idrefs</code> property.</p>
         <p> An element may have more than one <code>ID</code> value. This can occur
             with synthetic data models or with data models constructed from a PSVI
             where the element and one of its attributes are both typed as <code>xs:ID</code>.</p>
         <p> If the source document is well-formed but not valid, it is possible for
             two or more elements to have the same <code>ID</code> value. In this
             situation, the function will select the first such element.</p>
         <p> It is also possible in a well-formed but invalid document to have an
             element or attribute that has the <code>is-id</code> property but whose value does
             not conform to the lexical rules for the <code>xs:ID</code> type. Such a
             node will never be selected by this function.</p>
      </fos:notes>
      <fos:examples>
         <fos:variable name="emp" as="element()"><![CDATA[
            <employee xml:id="ID21256">
               <empnr>E21256</empnr>
               <first>John</first>
               <last>Brown</last>
            </employee>]]>
         </fos:variable>
         <fos:example>
            <fos:test xslt-version="2.1">
               <fos:expression>id('ID21256')/name()</fos:expression>
               <fos:result>employee</fos:result>
               <fos:postamble>The <code>xml:id</code> attribute has the <code>is-id</code> property,
               so the employee element is selected.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test xslt-version="2.1">
               <fos:expression>id('E21256')/name()</fos:expression>
               <fos:result>empnr</fos:result>
               <fos:postamble>Assuming the <code>empnr</code> element is given the type <code>xs:ID</code>
               as a result of schema validation, the element will have the <code>is-id</code> property
               and is therefore selected. Note the difference from the behavior of
               <code>fn:element-with-id</code>.</fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="element-with-id">
      <fos:signatures>
         <fos:proto name="element-with-id" return-type="element()*">
            <fos:arg name="arg" type="xs:string*"/>
         </fos:proto>
         <fos:proto name="element-with-id" return-type="element()*">
            <fos:arg name="arg" type="xs:string*"/>
            <fos:arg name="node" type="node()"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p diff="add" at="A-E31"> Summary: Returns the sequence of element nodes that have an <code>ID</code>
                        value matching the value of one or more of the <code>IDREF</code> values
                        supplied in <code>$arg</code>.</p>
      </fos:summary>
      <fos:rules>
         <change  diff="add" at="A-E31">
          
         <note>
            <p>The effect of this function is identical to <function>fn:id</function> in respect
	   of elements that have an attribute with the <code>is-id</code> property. However, it behaves differently
	   in respect of element nodes with the <code>is-id</code> property. Whereas the <code>fn:id</code>, for legacy reasons,
	   returns the element that has the <code>is-id</code> property, this parent returns the element identified by the ID, which
               is the parent of the element having the <code>is-id</code> property.</p>
         </note>
         <p>The function returns a sequence, in document order with duplicates
            eliminated, containing every element node <code>E</code> that satisfies all
            the following conditions:</p>
         <olist>
            <item>
               <p>
                 <code>E</code> is in the target document. The target document is the
                 document containing <code>$node</code>, or the document containing
                 the context item (<code>.</code>) if the second argument is omitted. 
                  The behavior of the function if <code>$node</code> is omitted is exactly 
                  the same as if the context item had been passed as <code>$node</code>.</p>
            </item>
            <item>
               <p><code>E</code> has an <code>ID</code> value equal to one of the
                        candidate <code>IDREF</code> values, where:</p>
               <ulist>
                  <item>
                     <p> An element has an <code>ID</code> value equal to
                         <code>V</code> if either or both of the following conditions
                         are true:</p>
                     <ulist>
                        <item>
                           <p>The element has an child element node whose
                             <code>is-id</code> property (See <xspecref spec="DM" ref="dm-is-id"/>.) 
                             is true and whose typed value is
                             equal to <code>V</code> under the rules of the
                             <code>eq</code> operator using the Unicode code
                             point collation (<code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>).</p>
                        </item>
                        <item>
                           <p>The element has an attribute node whose
                                <code>is-id</code> property (See <xspecref spec="DM" ref="dm-is-id"/>.) is true and whose typed value is
                                equal to <code>V</code> under the rules of the
                                <code>eq</code> operator using the Unicode code
                                point collation (<code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>).</p>
                        </item>
                     </ulist>
                  </item>
                  <item>
                     <p>Each <code>xs:string</code> in <code>$arg</code> is parsed
                         as if it were of type <code>IDREFS</code>, that is, each
                         <code>xs:string</code> in <code>$arg</code> is treated as a
                         whitespace-separated sequence of tokens, each acting as an
                         <code>IDREF</code>. These tokens are then included in the
                         list of candidate <code>IDREF</code>s. If any of the tokens
                         is not a lexically valid <code>IDREF</code> (that is, if it
                         is not lexically an <code>xs:NCName</code>), it is ignored.
                         Formally, the candidate <code>IDREF</code> values are the
                         strings in the sequence given by the expression:</p>
<eg xml:space="preserve">for $s in $arg return 
   fn:tokenize(fn:normalize-space($s), ' ')[. castable as xs:IDREF]</eg>
                  </item>
               </ulist>
            </item>
            <item>
               <p> If several elements have the same <code>ID</code> value, then
                                <code>E</code> is the one that is first in document order.</p>
            </item>
         </olist>
         </change>
      </fos:rules>
      <fos:errors>
         <change diff="add" at="A-E31">
         <p>If <code>$node</code>, or the context item if the second argument is
            omitted, is a node in a tree whose root is not a document node 
            <errorref class="DC" code="0001" type="dynamic"/> is raised.</p> 
         <p>If the second argument is the context item, or is omitted, the following errors may be raised: if there is no context item,
            <xerrorref spec="XP" class="DY" code="0002" type="type"/>; if the context item is not a node 
            <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>
         </change>
      </fos:errors>
      <fos:notes>
            <p>This function is equivalent to the <code>fn:id</code> function except when
               dealing with ID-valued element nodes. Whereas the <code>fn:id</code> function
               selects the element containing the identifier, this function selects its parent.</p>
            <p>If the data model is constructed from an Infoset, an attribute will have
                the <code>is-id</code> property if the corresponding attribute in the
                Infoset had an attribute type of <code>ID</code>: typically this means
                the attribute was declared as an <code>ID</code> in a DTD.</p>
            <!--Text replaced by erratum E13 change 1"--><p diff="chg" at="A-E13"> If the data model is constructed from a PSVI, an element or attribute
                will have the <code>is-id</code> property if its typed value is a single
	      atomic value of type <code>xs:ID</code>
                or a type derived by restriction from <code>xs:ID</code>.</p>
            <!--End of text replaced by erratum E13--><p> No error is raised in respect of a candidate <code>IDREF</code> value
                that does not match the <code>ID</code> of any element in the document.
                If no candidate <code>IDREF</code> value matches the <code>ID</code>
                value of any element, the function returns the empty sequence.</p>
            <p> It is not necessary that the supplied argument should have type <code>xs:IDREF</code> or <code>xs:IDREFS</code>, or that it should be
                derived from a node with the <code>is-idrefs</code> property.</p>
            <p> An element may have more than one <code>ID</code> value. This can occur
                with synthetic data models or with data models constructed from a PSVI
                where the element and one of its attributes are both typed as <code>xs:ID</code>.</p>
            <p> If the source document is well-formed but not valid, it is possible for
                two or more elements to have the same <code>ID</code> value. In this
                situation, the function will select the first such element.</p>
            <p> It is also possible in a well-formed but invalid document to have an
                element or attribute that has the <code>is-id</code> property but whose value does
                not conform to the lexical rules for the <code>xs:ID</code> type. Such a
                node will never be selected by this function.</p>
       </fos:notes>
      <fos:examples>
         <fos:variable name="emp" as="element()"><![CDATA[
            <employee xml:id="ID21256">
               <empnr>E21256</empnr>
               <first>John</first>
               <last>Brown</last>
            </employee>]]>
         </fos:variable>
         <fos:example>
            <fos:test xslt-version="2.1">
               <fos:expression>id('ID21256')/name()</fos:expression>
               <fos:result>"employee"</fos:result>
               <fos:postamble>The <code>xml:id</code> attribute has the <code>is-id</code> property,
                  so the employee element is selected.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test xslt-version="2.1">
               <fos:expression>id('E21256')/name()</fos:expression>
               <fos:result>"employee"</fos:result>
               <fos:postamble>Assuming the <code>empnr</code> element is given the type <code>xs:ID</code>
                  as a result of schema validation, the element will have the <code>is-id</code> property
                  and is therefore its parent is selected. Note the difference from the behavior of
                  <code>fn:id</code>.</fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="idref">
      <fos:signatures>
         <fos:proto name="idref" return-type="node()*">
            <fos:arg name="arg" type="xs:string*"/>
         </fos:proto>
         <fos:proto name="idref" return-type="node()*">
            <fos:arg name="arg" type="xs:string*"/>
            <fos:arg name="node" type="node()"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the sequence of element or attribute nodes with an
                        <code>IDREF</code> value matching the value of one or more of
                        the <code>ID</code> values supplied in <code>$arg</code>.</p>

      </fos:summary>
      <fos:rules>
         <p> The function returns a sequence, in document order with duplicates
               eliminated, containing every element or attribute node <code>$N</code> that
               satisfies all the following conditions:</p>
         <olist>
            <item>
               <p><code>$N</code> is in the target document. 
                  The target document is the document containing <code>$node</code> or the 
                  document containing the context item (<code>.</code>) if the second argument is omitted. 
                  The behavior of the function if <code>$node</code> is omitted is exactly the same as if 
                  the context item had been passed as <code>$node</code>.</p>
            </item>
            <item>
               <p><code>$N</code> has an <code>IDREF</code> value equal to one of the
                   candidate <code>ID</code> values, where:</p>
               <ulist>
                  <item>
                     <p>A node <code>$N</code> has an <code>IDREF</code> value equal
                         to <code>V</code> if both of the following conditions are true:</p>
                     <ulist>
                        <item>
                           <p>The <code>is-idrefs</code> property (see <xspecref spec="DM" ref="dm-is-idrefs"/>) of
                              <code>$N</code> is <code>true</code>.</p>
                        </item>
                        <item>
                           <p>The sequence <!--Text replaced by erratum E29 change 1"--><eg diff="chg" at="A-E29" xml:space="preserve">fn:tokenize(fn:normalize-space(fn:string($N)), ' ')</eg>
                                    <!--End of text replaced by erratum E29--> contains a string that is equal to
                              <code>V</code> under the rules of the
                              <code>eq</code> operator using the Unicode code
                              point collation (<code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>).</p>
                        </item>
                     </ulist>
                  </item>
                  <item>
                     <p>Each <code>xs:string</code> in <code>$arg</code> is parsed
                         as if it were of lexically of type <code>xs:ID</code>. These
                         <code>xs:string</code>s are then included in the list of
                         candidate <code>xs:ID</code>s. If any of the strings in
                         <code>$arg</code> is not a lexically valid
                         <code>xs:ID</code> (that is, if it is not lexically an
                         <code>xs:NCName</code>), it is ignored. More formally, the
                         candidate <code>ID</code> values are the strings in the
                         sequence:</p>
                      <eg xml:space="preserve">$arg[. castable as xs:NCName]</eg>
                  </item> 
               </ulist>
            </item>
         </olist>
      </fos:rules> 
      <fos:errors>
         <p>If <code>$node</code>, or the context item if the second argument is
            omitted, is a node in a tree whose root is not a document node 
            <errorref class="DC" code="0001" type="dynamic"/> is raised. </p> 
         <p>If the second argument is the context item, or is omitted, the following errors may be raised: 
            if there is no context item <xerrorref spec="XP" class="DY" code="0002" type="type"/>; 
            if the context item is not a node 
            <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>
      </fos:errors>
       <fos:notes>
            <p> An element or attribute typically acquires the <code>is-idrefs</code>
                            property by being validated against the schema type
                            <code>xs:IDREF</code> or <code>xs:IDREFS</code>, or (for attributes only)
                            by being described as of type <code>IDREF</code> or <code>IDREFS</code>
                            in a DTD.</p>
            <p> No error is raised in respect of a candidate <code>ID</code> value that
                            does not match the <code>IDREF</code> value of any element or attribute
                            in the document. If no candidate <code>ID</code> value matches the
                            <code>IDREF</code> value of any element or attribute, the function
                            returns the empty sequence.</p>
            <p> It is possible for two or more nodes to have an <code>IDREF</code> value
                            that matches a given candidate <code>ID</code> value. In this situation,
                            the function will return all such nodes. However, each matching node
                            will be returned at most once, regardless how many candidate
                            <code>ID</code> values it matches.</p>
            <p> It is possible in a well-formed but invalid document to have a node
                            whose <code>is-idrefs</code> property is true but that does not conform
                            to the lexical rules for the <code>xs:IDREF</code> type. The effect of
                            the above rules is that ill-formed candidate <code>ID</code> values and
                            ill-formed <code>IDREF</code> values are ignored.</p>
            <!--Text inserted by erratum E13 change 2"--><p diff="add" at="A-E13">If the data model is constructed from a PSVI, the typed value of a node that
      has the <code>is-idrefs</code> property will contain at least one atomic value of type
      <code>xs:IDREF</code> (or a type derived by restriction from <code>xs:IDREF</code>). It may also contain
atomic values of other types. These atomic values are treated as candidate <code>ID</code> values
if their lexical form is valid as an <code>xs:NCName</code>, and they are ignored otherwise.</p>
            <!--End of text inserted by erratum E13-->
      </fos:notes>
   </fos:function>
   <fos:function name="doc">
      <fos:signatures>
         <fos:proto name="doc" return-type="document-node()?">
            <fos:arg name="uri" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p diff="chg" at="A-E26">Summary: Retrieves a document using a URI supplied as an <code>xs:string</code>,
		 and returns the corresponding document node.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$uri</code> is the empty sequence, the result is an empty sequence.</p>
         
         <p diff="add" at="A-E26">If <code>$uri</code> is a relative URI reference,
                        it is resolved relative to the value of the base URI property from the
                        static context. The resulting absolute URI is promoted to
                        an <code>xs:string</code>.</p>
         <p diff="add" at="A-E26">If the <term>Available documents</term> described
                        in <xspecref spec="XP" ref="eval_context"/> provides a mapping from this
                        string to a document node, the function returns that document node.</p>
         
         <p diff="add" at="A-E26">The URI may include a fragment identifier.</p>
         <p>By default, this function is <termref def="stable"/>. Two calls on this function return
                        the same document node if the same URI Reference (after resolution to an
                        absolute URI Reference) is supplied to both calls. Thus, the following
                        expression (if it does not raise an error) will always be true:</p>
         <eg xml:space="preserve">doc("foo.xml") is doc("foo.xml")</eg>
         <p>However, for performance reasons, implementations may provide a user option to
            evaluate the function without a guarantee of stability. The manner in which any
            such option is provided is implementation-defined. If the user has not selected
            such an option, a call of the function must either return a stable result or
            must raise an error: <errorref class="DC" code="0003"/>.</p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
         <note>
            <p>If <code>$uri</code> is read from a source document, it is generally
                            appropriate to resolve it relative to the base URI property of the
                            relevant node in the source document. This can be achieved by calling
                            the <code>fn:resolve-uri</code> function, and passing the resulting
                            absolute URI as an argument to the <code>fn:doc</code> function.</p>
         </note>
         <p>If two calls to this function supply different absolute URI References as
                        arguments, the same document node may be returned if the implementation can
                        determine that the two arguments refer to the same resource.</p>
         <p> By defining the semantics of this function in terms of a
                        string-to-document-node mapping in the dynamic context, the specification is
                        acknowledging that the results of this function are outside the purview of
                        the language specification itself, and depend entirely on the run-time
                        environment in which the expression is evaluated. This run-time environment
                        includes not only an unpredictable collection of resources ("the web"), but
                        configurable machinery for locating resources and turning their contents
                        into document nodes within the XPath data model. Both the set of resources
                        that are reachable, and the mechanisms by which those resources are parsed
                        and validated, are <termref def="implementation-dependent"/>.</p>
         <p> One possible processing model for this function is as follows. The resource
                        identified by the URI Reference is retrieved. If the resource cannot be
                        retrieved, an error is raised <errorref class="DC" code="0002"/>. The data
                        resulting from the retrieval action is then parsed as an XML document and a
                        tree is constructed in accordance with the <bibref ref="xpath-datamodel-11"/>. If the
                        top-level media type is known and is "text", the content is parsed in the
                        same way as if the media type were text/xml; otherwise, it is parsed in the
                        same way as if the media type were application/xml. If the contents cannot
                        be parsed successfully, an error is raised <errorref class="DC" code="0002"/>. Otherwise, the result of the
                        function is the document node at the root of the resulting tree. This tree
                        is then optionally validated against a schema.</p>
         <p>Various aspects of this processing are <termref def="implementation-defined"/>. Implementations may provide external
                        configuration options that allow any aspect of the processing to be
                        controlled by the user. In particular:</p>
         <ulist>
            <item>
               <p>The set of URI schemes that the implementation recognizes is
                                implementation-defined. Implementations may allow the mapping of
                                URIs to resources to be configured by the user, using mechanisms
                                such as catalogs or user-written URI handlers.</p>
            </item>
            <item>
               <p>The handling of non-XML media types is implementation-defined.
                                Implementations may allow instances of the data model to be
                                constructed from non-XML resources, under user control.</p>
            </item>
            <item>
               <p>It is <termref def="implementation-defined"/> whether DTD validation
                                and/or schema validation is applied to the source document.</p>
            </item>
            <item>
               <p>Implementations may provide user-defined error handling options that
                                allow processing to continue following an error in retrieving a
                                resource, or in parsing and validating its content. When errors have
                                been handled in this way, the function may return either an empty
                                sequence, or a fallback document provided by the error handler.</p>
            </item>
            <item>
               <p>Implementations may provide user options that relax the requirement for the
function to return stable results.</p>
            </item>
         </ulist>
      </fos:rules>
      <fos:errors>
         <p diff="add" at="A-E26">If <code>$uri</code> is not a valid URI, an error <rfc2119>may</rfc2119> be raised
            <errorref class="DC" code="0005"/>.</p>
         <p diff="add" at="A-E26">If the <term>Available documents</term> provides no mapping for the absolutized URI, 
            an error is raised <errorref class="DC" code="0005"/>.</p>
         <p>If the resource cannot be retrieved or cannot be parsed successfully as XML, an error is raised
            <errorref class="DC" code="0002"/></p>
         <p>If the implementation is not able to guarantee that the result of the function will be stable,
            and the user has not indicated that an unstable result is acceptable, an error is raised
            <errorref class="DC" code="0003"/>.</p>
      </fos:errors>
   </fos:function>
   <fos:function name="doc-available">
      <fos:signatures>
         <fos:proto name="doc-available" return-type="xs:boolean">
            <fos:arg name="uri" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p diff="chg" at="A-E26">Summary: The function returns true if and only if the function call <code>fn:doc($uri)</code> 
		          would return a document node.</p>
      </fos:summary>
      <fos:rules>
         <p diff="chg" at="A-E26">If <code>$uri</code> is an empty sequence, this function returns <code>false</code>.</p>
         <p diff="chg" at="A-E26">If a call on <code>fn:doc($uri)</code> would return a document node, this function returns 
		<code>true</code>.</p>
         <p diff="chg" at="A-E26">If <code>$uri</code> is not a valid URI according to the rules applied by the
		implementation of <code>fn:doc</code>, an error is raised <errorref class="DC" code="0005"/>.</p>
         <p diff="chg" at="A-E26">Otherwise, this function returns <code>false</code>.</p>
         <p>If this function returns <code>true</code>, then
                        calling <code>fn:doc($uri)</code> within the same <termref def="execution-scope"/> must return a document node. However, if
non-stable processing has been selected for the <code>fn:doc</code> function, this guarantee is lost.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="collection">
      <fos:signatures>
         <fos:proto name="collection" return-type="node()*"/>
         <fos:proto name="collection" return-type="node()*">
            <fos:arg name="arg" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns a sequence of nodes representing a collection of documents indentified
         by a collection URI; or a default collection if no URI is supplied.</p>
      </fos:summary>
      <fos:rules>

         <p>This function takes an <code>xs:string</code> as argument and
            returns a sequence of nodes obtained by interpreting <code>$arg</code> as an
            <code>xs:anyURI</code> and resolving it according to the mapping specified
            in <term>Available collections</term> described in 
            <xspecref spec="XP" ref="id-xp-evaluation-context-components"/>.</p>
         <p>If <term>Available
               collections</term> provides a mapping from this string to a sequence of
            nodes, the function returns that sequence. If <term>Available
               collections</term> maps the string to an empty sequence, then the function
            returns an empty sequence.</p>
         <p>If <code>$arg</code> is not specified, the function returns
            the sequence of the nodes in the default collection in the dynamic context.
            See <xspecref spec="XP" ref="id-xp-evaluation-context-components"/>. </p>
         <p>If the value of <code>$arg</code> is a relative <code>xs:anyURI</code>, it is resolved 
            against the value of the base-URI property from the static context. </p>
         <p>If <code>$arg</code> is the empty sequence, the function behaves as if it had
                        been called without an argument. See above.</p>
         <p>By default, this function is <termref def="stable"/>. This means that repeated calls on the function with the same argument will return the same result. However,
for performance reasons, implementations may provide a user option to evaluate
the function without a guarantee of stability. The manner in which any such
option is provided is <termref def="implementation-defined"/>. If the user has not selected such
an option, a call to this function must either return a stable result or must
raise an error: <errorref class="DC" code="0003"/>.</p>
        
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:errors>
         <p>If no URI is supplied and the
            value of the default collection is undefined, 
            an error is raised <errorref class="DC" code="0002"/>.</p>
         <p>If <term>Available collections</term> provides no
           mapping for the absolutized URI, an error is raised <errorref class="DC" code="0004"/></p>
         <p>If <code>$arg</code> 
            is not a valid <code>xs:anyURI</code>, an error is raised  <errorref class="DC" code="0004"/>.</p>
      </fos:errors>
      <fos:notes>
         <p> This function provides a facility for users to work with a collection of
             documents which may be contained in a directory or rows of a Relational
             table or other implementation-specific construct. An implementation may
             also use external variables to identify external resources, but
             <code>fn:collection</code> provides functionality not provided by
             external variables. Specifying resources using URIs is useful because
             URIs are dynamic, can be parameterized, and do not rely on an external environment.</p>
      </fos:notes>
   </fos:function>
   <fos:function name="uri-collection" diff="add" at="C">
      <fos:signatures>
         <fos:proto name="uri-collection" return-type="xs:anyURI*"/>
         <fos:proto name="uri-collection" return-type="xs:anyURI*">
            <fos:arg name="arg" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns a sequence of <code>xs:anyURI</code> values representing the document URIs of the
            documents in a collection.</p>
      </fos:summary>
      <fos:rules>
         <p>A collection, as returned by the <function>fn:collection</function> function, is in general a
         sequence of nodes. Some of these nodes may be document nodes, and some of
         these document nodes may have a non-empty document URI, accessible using the
         <function>fn:document-uri</function> function. The <function>fn:uri-collection</function> function returns a sequence
         of URIs, being the document URIs of those nodes in the collection that are
         document nodes and that have a document URI (other nodes in the collection
         are ignored). That is, in the absence of errors, <code>fn:uri-collection(X)</code>
         returns the same set of URIs as <code>fn:collection(X)/fn:document-uri()</code>, 
         though not necessarily in the same order. </p>
         
         <p>The purpose
         in providing the function, however, is to allow the URIs of the documents in
         a collection to be retrieved without incurring the cost (which might be
         significant in some implementations) of dereferencing the URIs to obtain the
         actual nodes. Where required, the returned URIs can then be dereferenced by
         calling the <function>fn:doc</function> function.</p>
         
         <p>The zero-argument form of the function returns the document URIs of the
         document nodes in the default collection.</p>
         
         <p>The single-argument form returns the document URIs of the document nodes in
         the collection with a given collection URI. If the value of the argument is
         an empty sequence, the action is as for the zero-argument form of the
         function. If the argument is a relative URI reference, it is resolved against the base
         URI property of the static context.</p>
      </fos:rules>
      <fos:errors>
         <p>If no URI is supplied and the
            value of the default collection is undefined, 
            an error is raised <errorref class="DC" code="0002"/>.</p>
         <p>If <term>Available collections</term> provides no
            mapping for the absolutized URI, an error is raised <errorref class="DC" code="0004"/></p>
         <p>If <code>$arg</code> 
            is not a valid <code>xs:anyURI</code>, an error is raised  <errorref class="DC" code="0004"/>.</p>
      </fos:errors>

      <fos:notes>
         <p>There are several reasons it might be appriopriate to retrieve the URIs of
         the documents in a collection without retrieving the documents themselves.
         For example:</p>
         
         <ulist>
            <item><p>In XSLT it allows the documents to be processed in streaming mode
         using the <code>xsl:stream</code> instruction.</p></item>
            <item><p>It allows recovery from failures to read, parse, or validate
         individual documents, by calling the <code>fn:doc</code> function within the scope of
         try/catch.</p></item>
            <item><p>It allows selection of which documents to read based on their URI, for
         example they can be filtered to select those whose URIs end in <code>.xml</code>.</p></item></ulist>
         
         <p>However, there may be collections that cannot be processed in this way:
         specifically, those that contain nodes other than document nodes, and those
         that contain document nodes having no document URI. </p>

      </fos:notes>
   </fos:function>
   <fos:function name="unparsed-text">
      <fos:signatures>
         <fos:proto name="unparsed-text" return-type="xs:string?">
            <fos:arg name="href" type="xs:string?"/>
         </fos:proto>
         <fos:proto name="unparsed-text" return-type="xs:string?">
            <fos:arg name="href" type="xs:string?"/>
            <fos:arg name="encoding" type="xs:string"/>
         </fos:proto>
       </fos:signatures>

      <fos:summary><p>The <code>fn:unparsed-text</code> function reads an external resource (for
      example, a file) and returns its contents as a string.</p></fos:summary>
      <fos:rules>
         <p>The <code>$href</code> argument <rfc2119>must</rfc2119> be a string in the form of
         a URI reference, which <rfc2119>must</rfc2119> contain no fragment identifier, and
         <rfc2119>must</rfc2119> identify a resource that can be read as text. If the
         URI is a relative URI reference, then it is resolved relative to the base URI from the
         static context.</p>
         <p>If the value of the <code>$href</code> argument is an empty sequence, the function
         returns an empty sequence.</p>
         <p>The <code>$encoding</code> argument, if present, is the name of an encoding. The
         values for this attribute follow the same rules as for the <code>encoding</code>
         attribute in an XML declaration. The only values which every <termref
            def="dt-implementation">implementation</termref> is <rfc2119>required</rfc2119>
         to recognize are <code>utf-8</code> and <code>utf-16</code>.</p>
         <p>The encoding of the external resource is determined as follows:</p>
         <olist>
            <item>
               <p>external encoding information is used if available, otherwise</p>
            </item>
            <item>
               <p>if the media type of the resource is <code>text/xml</code> or
                  <code>application/xml</code> (see <bibref ref="rfc2376"/>), or if it
                  matches the conventions <code>text/*+xml</code> or
                  <code>application/*+xml</code> (see <bibref ref="rfc3023"/> and/or its
                  successors), then the encoding is recognized as specified in <bibref
                     ref="REC-xml"/>, otherwise</p>
            </item>
            <item>
               <p>the value of the <code>$encoding</code> argument is used if present,
                  otherwise</p>
            </item>
            <item>
               <p>the processor <rfc2119>may</rfc2119> use <termref
                  def="dt-implementation-defined">implementation-defined</termref>
                  heuristics to determine the likely encoding, otherwise</p>
            </item>
            <item>
               <p>UTF-8 is assumed.</p>
            </item>
         </olist>
         <p>The result of the function is a string containing the text of the resource retrieved using the
            URI.</p>
      </fos:rules>
      <fos:errors>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="1170">
               <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                  error</termref> if a URI <error.extra>supplied in the first argument to
                     the <function>unparsed-text</function> function</error.extra> contains a
                  fragment identifier, or if it cannot be used to retrieve a resource
                  containing text.</p>
            </error>
         </p>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="1190">
               <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                  error</termref> if a resource <error.extra>retrieved using the
                     <function>unparsed-text</function> function</error.extra> contains
                  octets that cannot be decoded into Unicode characters using the specified
                  encoding, or if the resulting characters are not permitted XML characters.
                  This includes the case where the <termref def="dt-processor"
                     >processor</termref> does not support the requested encoding.</p>
            </error>
         </p>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="1200">
               <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                  error</termref> if the second argument of the
                  <function>unparsed-text</function> function is omitted and the <termref
                     def="dt-processor">processor</termref> cannot infer the encoding using
                  external information and the encoding is not UTF-8.</p>
            </error>
         </p>
      </fos:errors>
      <fos:notes>
         <p>If it is appropriate to use a base URI other than the static base URI (for example, when resolving a relative
            URI reference read from a source document) 
            then it is advisable to resolve 
            the relative URI reference using
            the <code>fn:resolve-uri</code> function before passing it to the
            <function>fn:unparsed-text</function> function.</p>
         <p>The rules for determining the encoding are chosen for consistency with <bibref ref="xinclude"/>. Files
            with an XML media type are treated specially because there are use cases for
            this function where the retrieved text is to be included as unparsed XML within
            a CDATA section of a containing document, and because processors are likely to
            be able to reuse the code that performs encoding detection for XML external
            entities.</p>
         <p>If the text file contains characters such as <code>&lt;</code> and
            <code>&amp;</code>, these will typically be output as <code>&amp;lt;</code>
            and <code>&amp;amp;</code> when the string serialized as XML
            or HTML. If these characters actually represent markup (for example, if the
            text file contains HTML), then an XSLT stylesheet can attempt to write them as
            markup to the output file using the <code>disable-output-escaping</code>
            attribute of the <code>xsl:value-of</code> instruction. 
            Note, however, that XSLT implementations are
            not required to support this feature.</p>
      </fos:notes>
      
      

      <!--
      <imp-def-feature>The set of encodings recognized by the
         <function>unparsed-text</function> function, other than <code>utf-8</code> and
         <code>utf-16</code>, is <termref def="dt-implementation-defined"
            >implementation-defined</termref>.</imp-def-feature>
      
      <imp-def-feature>If no encoding is specified on a call to the
         <function>unparsed-text</function> function, the processor
         <rfc2119>may</rfc2119> use <termref def="dt-implementation-defined"
            >implementation-defined</termref> heuristics to determine the likely
         encoding.</imp-def-feature>-->
 
      <fos:examples>
         <fos:example>
         <p>Copying Unparsed HTML Boilerplate</p>
         <p>This example attempts to read an HTML file and copy it, as HTML, to the
            serialized output file:</p>
         <eg xml:space="preserve"><![CDATA[<xsl:output method="html"/>

<xsl:template match="/">
  <xsl:value-of select="unparsed-text('header.html', 'iso-8859-1')"
                disable-output-escaping="yes"/>
  <xsl:apply-templates/>
  <xsl:value-of select="unparsed-text('footer.html', 'iso-8859-1')"
                disable-output-escaping="yes"/>
</xsl:template>
]]></eg></fos:example>
         <fos:example>
            <p>Splitting an Input File into a Sequence of Lines</p>
         <p>Often it is necessary to split a text file into a sequence of lines,
            representing each line as a string. This can be achieved by using the
            <function>unparsed-text</function> function in conjunction with the XPath
            <code>fn:tokenize</code> function. For example:</p>
         <eg xml:space="preserve"><![CDATA[<xsl:for-each select="tokenize(unparsed-text($in), '\r?\n')">
 ...
</xsl:for-each>]]></eg>
         <p>Note that the <function>unparsed-text</function> function does not normalize
            line endings. This example has been written to recognize both Unix and Windows
            conventions for end-of-line, namely a single newline (#x0A) character or a
            carriage return / line feed pair (#x0D #x0A). It
               differs from the <function>unparsed-text-lines</function> function
            introduced in XSLT 2.1, however,
               in that it does not recognize a carriage return on its own as a line ending,
               and it does not give special treatment to a newline appearing at the end of
               the file.
         </p>
         </fos:example>   
      </fos:examples>

   </fos:function>
   <fos:function name="unparsed-text-available">
      <fos:signatures>
         <fos:proto name="unparsed-text-available" return-type="xs:boolean">
            <fos:arg name="href" type="xs:string?"/>
         </fos:proto>
         <fos:proto name="unparsed-text-available" return-type="xs:boolean">
            <fos:arg name="href" type="xs:string?"/>
            <fos:arg name="encoding" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Because errors in evaluating the <function>fn:unparsed-text</function>
         function are non-recoverable, these two functions are provided to allow an application to
         determine whether a call with particular arguments would succeed.</p>
      </fos:summary>
      <fos:rules>
         <p>The <function>fn:unparsed-text-available</function> function determines whether a
            call on the <function>fn:unparsed-text</function> function with identical arguments
         would return a string.</p>
      <p>If the first argument is an empty sequence, the function returns false. If the
         second argument is an empty sequence, the function behaves as if the second
         argument were omitted.</p>
      <p>In other cases, the function returns true if a call on
         <function>fn:unparsed-text</function> with the same arguments would succeed, and
         false if a call on <function>fn:unparsed-text</function> with the same arguments
         would fail with a non-recoverable dynamic error.</p>
         <p>The functions <function>fn:unparsed-text</function> and <function>fn:unparsed-text-available</function> have the same
            requirement for <xtermref spec="FO" ref="stable">stability</xtermref> as the functions <code>fn:doc</code> and
            <code>fn:doc-available</code>. This means that unless the user has explicitly stated a requirement for a
         reduced level of stability, either of these functions if called twice with the
         same arguments during the course of a transformation <rfc2119>must</rfc2119>
         return the same results each time; moreover, the results of a call on
            <function>fn:unparsed-text-available</function>
         <rfc2119>must</rfc2119> be consistent with the results of a subsequent call on
         <function>unparsed-text</function>
          with the same arguments.</p>  
      </fos:rules>
      <fos:notes>
         <p>This requires that the <function>unparsed-text-available</function> function
            should actually attempt to read the resource identified by the URI, and check
            that it is correctly encoded and contains no characters that are invalid in
            XML. Implementations may avoid the cost of repeating these checks for example
            by caching the validated contents of the resource, to anticipate a subsequent
            call on the <function>unparsed-text</function>
            <phrase diff="add" at="A">or <function>unparsed-text-lines</function>
            </phrase> function. Alternatively, implementations may be able to rewrite an
            expression such as <code>if (unparsed-text-available(A)) then unparsed-text(A)
               else ...</code> to generate a single call internally.</p>
         
      </fos:notes>   
      
   </fos:function>
   
   <fos:function name="environment-variable">
      <fos:signatures>
         <fos:proto name="environment-variable" return-type="xs:string?">
            <fos:arg name="name" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Returns the value of a system environment variable, if it exists.</p>
      </fos:summary>
      <fos:rules>
         <p>The set of available environment variables is a set of (name, value) pairs forming
         part of the dynamic context, in which the name is unique within the set of pairs. The name
         and value are arbitrary strings.</p>
         <p>If the <code>$name</code> argument matches the name of one of these pairs, the function returns 
         the corresponding value.</p>
         <p>If there is no environment variable with a matching name, the function returns the empty sequence.</p>
         <p>The collation used for matching names is <termref def="implementation-dependent"/>, but must be
         the same as the collation used to ensure that the names of all environment variables are unique.</p>
      </fos:rules>
      <fos:notes>
         <p>On many platforms, the term "environment variable" has a natural meaning in terms of facilities
         provided by the operating system. This interpretation of the concept does not exclude 
         other interpretations, such as a mapping to a set of configuration parameters in a database system.</p>
         <p>Environment variable names are usually case sensitive.  Names are
            usually of the form <code>(letter|_) (letter|_|digit)*</code>, but this varies by platform.</p>
         <p>On some platforms, there may sometimes be multiple environment
            names with the same name; in this case, it is
            implementation-dependent as to which is returned; see for example
            <bibref ref="POSIX.1-2008"/> (Chapter 8, Environment Variables).</p>
         <p>Calls to external functions, or other external events, may result in changes to environment
            variables: both to the set of available variables and to their
            values.  Calling get-environment-variable() multiple times with
            the same name may or may not reflect such changes, depending on
            the implementation.</p>
         <p>Security advice: Queries from untrusted sources should not be permitted
            unrestricted access to environment variables. For example, the
            name of the account under which the query is running may be
            useful information to a would-be intruder. An implementation may
            therefore choose to restrict access to the environment, or may
            provide a facility to make <code>fn:get-environment-variable</code> always
            return the empty sequence.</p>
         </fos:notes>
   </fos:function>
   <fos:function name="available-environment-variables" diff="add" at="F">
      <fos:signatures>
         <fos:proto name="available-environment-variables" return-type="xs:string*"/>
      </fos:signatures>
      <fos:summary><p>Returns a list of environment variable names that are suitable for
         passing to <code>fn:get-environment-variable</code>, as a (possibly empty) sequence of
         strings.</p></fos:summary>
      <fos:rules>
         <p>The function returns a list of strings, containing no duplicates.</p>
         <p>It is intended that the strings in this list should be suitable for passing
            to <code>fn:get-environment-variable</code>. However, since external events
         can cause the set of available environment variables to change at any time, there
         is no guarantee that this represents precisely the environment variables available in the dynamic
         context at any point in time.</p>
      </fos:rules>   
      <fos:notes>
         <p>Calls to external functions may result in changes to the set of
         environment variables, including creating new variables
         or deleting existing ones, as well as changing values.</p>
         
         <p>See also the note on security under the definition of the
         <code>fn:get-environment-variable</code> function. If access to environment
         variables has been disabled, <code>fn:available-environment-variables</code>
         always returns the empty sequence.</p>
      </fos:notes>
   </fos:function>
   
   
   <fos:function name="generate-id">
      <fos:signatures>
         <fos:proto name="generate-id" return-type="xs:string"/>
         <fos:proto name="generate-id" return-type="xs:string">
            <fos:arg name="arg" type="node()?"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: This function returns a string that
            uniquely identifies a given node. </p>
      </fos:summary>
      <fos:rules>
         <p>If the argument is omitted, it defaults to the context item (<code>.</code>).
            The behavior of the function if the argument is omitted is exactly the same as if the context 
            item had been passed as the argument.</p>
         <p>If the argument is the empty sequence, the result is the zero-length string.</p>
         <p>In other cases, the function returns a string that
            uniquely identifies a given node.</p>
         
         <p>The returned identifier <rfc2119>must</rfc2119> consist of ASCII
            alphanumeric characters and <rfc2119>must</rfc2119> start with an alphabetic character.
            Thus, the string is syntactically an XML name.</p>
         <p>An implementation is
            free to generate an identifier in any convenient way provided that it
            always generates the same identifier for the same node and that
            different identifiers are always generated from different nodes. An
            implementation is under no obligation to generate the same identifiers
            each time a document is transformed or queried.</p>         
      </fos:rules>
      <fos:errors>
         <p>The following errors may be raised when <code>$arg</code> is omitted:  if the context item is undefined 
            <xerrorref spec="XP" class="DY" code="0002" type="type"/>; 
            if the context item is not a node <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>         
      </fos:errors>
      <fos:notes>
         <p>There is no guarantee that a
            generated unique identifier will be distinct from any unique IDs
            specified in the source document.</p>     
         <p>There is no inverse to this function; it is not directly possible to find the node
            with a given generated ID. Of course, it is possible to search a given sequence of nodes
            using an expression such as <code>$nodes[generate-id()=$id]</code>.</p>
         <p>It is advisable, but not required, for implementations to generate IDs that are distinct
            even when compared using a case-blind collation.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <p>The primary use case for this function is to generate hyperlinks. For example, when
            generating HTML, an anchor for a given section <code>$sect</code> can be generated by writing 
            (in either XSLT or XQuery):</p>
            <p><code><![CDATA[<a name="{generate-id($sect)}"/>]]></code></p>
            <p>and a link to that section can then be produced with code such as:</p>
            <p><code><![CDATA[see <a href="#{generate-id($sect)}">here</a>]]></code></p>
            <p>Note that anchors generated in this way will not necessarily be the same each time
            a document is republished.</p>
         </fos:example>
      </fos:examples>   
   </fos:function>
  
   <fos:function name="parse-xml">
      <fos:signatures>
         <fos:proto name="parse-xml" return-type="document-node(element(*, xs:untyped))">
            <fos:arg name="arg" type="xs:string"/>
         </fos:proto>
         <fos:proto name="parse-xml" return-type="document-node(element(*, xs:untyped))">
            <fos:arg name="arg" type="xs:string"/>
            <fos:arg name="baseURI" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: This function takes as input an XML document represented as a string, and
returns the document node at the root of an XDM tree representing the parsed
document.</p>
      </fos:summary>
      <fos:rules>    
         <p>Schema validation is <emph>not</emph> invoked, which means that the nodes in the returned
            document will all be untyped.</p>
         <p>The precise process used to construct the XDM instance is
            implementation-defined. In particular, it is implementation-defined whether
            DTD validation is invoked, and it is implementation-defined whether an XML 1.0 
            or XML 1.1 parser is used.</p>
         <p>If the second argument is present then it provides a URI which will be used
            as the base URI of the document. This serves both as the base URI used by
            the XML parser to resolve relative entity references within the document,
            and as the base URI of the document node that is returned. If the second
            argument is omitted, then the static base URI of the <code>fn:parse-xml</code> function
            call is used.</p>
         <p>The function is <emph>not</emph> <termref def="stable">stable</termref>: that is, if the function is called
            twice with the same arguments, it is <termref def="implementation-dependent">implementation-dependent</termref> whether the same
            node is returned on both occasions.</p>
      </fos:rules>
      <fos:errors>
         <p>A dynamic error <errorref class="DC" code="0006"/> is raised if the content of <code>$arg</code> is not a
            well-formed and namespace-well-formed XML document.</p>
         <p>A dynamic error <errorref class="DC" code="0007"/> is raised if the content of <code>$baseURI</code> is not a
            valid absolute URI.</p>
      </fos:errors>
      <fos:notes>
         <p>Since the XML document is presented to the parser as a string, rather than
            as a sequence of octets, the encoding specified within the XML declaration has no meaning. 
            If the XML parser accepts input only in the form of a sequence of octets, then the processor must ensure
            that the string is encoded as octets in a way that is consistent with rules used
            by the XML parser to detect the encoding.</p>     
         <p>The primary use case for this function is to handle input documents that
            contain nested XML documents embedded within CDATA sections. Since the
            content of the CDATA section are exposed as text, the receiving query or
            stylesheet may pass this text to the <code>fn:parse-xml</code> function to create a tree
            representation of the nested document.</p>
         <p>Similarly, nested XML within comments is sometimes encountered, and lexical
            XML is sometimes returned by extension functions, for example, functions
            that access web services or read from databases.</p>
         <p>A use case arises in XSLT where there is a need to preprocess an input
            document before parsing. For example, an application might wish to edit the
            document to remove its DOCTYPE declaration. This can be done by reading the
            raw text using the <code>fn:unparsed-text</code> function, editing the resulting string,
            and then passing it to the <code>fn:parse-xml</code> function.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <p>The expression <code>fn:parse-xml("&lt;alpha>abcd&lt;/alpha>")</code> returns a newly created document node,
            having an <code>alpha</code> element as its only child; the <code>alpha</code> element in turn
            is the parent of a text node whose string value is <code>"abcd"</code>.</p>
         </fos:example>
      </fos:examples>   
   </fos:function>
   <fos:function name="serialize">
      <fos:signatures>
         <fos:proto name="serialize" return-type="xs:string">
            <fos:arg name="arg" type="node()"/>
         </fos:proto>
         <fos:proto name="serialize" return-type="xs:string">
            <fos:arg name="arg" type="node()"/>
            <fos:arg name="params" type="node()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: This function serializes the supplied node <code>$arg</code>
            as described in <bibref ref="xslt-xquery-serialization-11"/>, returning the serialized node as a string.</p>
      </fos:summary>
      <fos:rules>
         <p>The node <code>$arg</code> acts as the (singleton) input sequence to the serialization
            process.</p>
         
         <p>The single-argument version of this function has the same effect as the two-argument
            version called with <code>$params</code> set to an empty sequence.</p>
         <p>The <code>$params</code> argument is used to identify a set of
            serialization parameters. These are supplied in the form of a sequence of nodes, typically element
            or attribute nodes. Each node represents one serialization parameter. The parameters
            are interpreted as follows:</p>
         <olist>
            <item>
               <p>The name of the node is used for the name of the serialization parameter.</p>
            </item>
            <item>
               <p>The string value of the node is used for the value of the parameter.</p>
            </item>
            <item>
               <p>If more than one node in the sequence has the same name,
                  then the one that appears last in the sequence is used.</p>
            </item>
            <item>
               <p>If any node in the sequence has a name that is not
                  recognized as the name of a serialization parameter, then the node is ignored.</p>
            </item>
            <item>
               <p>Where a serialization parameter is a list of values (for example, <code>cdata-section-elements</code>)
                  its value is supplied as a whitespace-separated list.</p>
            </item>
            <item>
               <p>Where the value of a serialization
                  parameter includes an expanded-QName (for example, <code>method</code> or <code>cdata-section-elements</code>),
                  the value is supplied as a lexical QName, which is resolved with respect to the in-scope namespaces for the node in which the parameter value is
                  supplied, excluding any default namespace (so a name with no prefix is in no namespace).</p>
            </item>
            <item>
               <p>The <code>use-character-maps</code> property is not available, and any attempt to specify a value for this property 
                  is a dynamic error [SEPM0016].</p>
            </item>
            <item>
               <p>Any serialization parameter for which no value is supplied takes an implementation-defined default value.
                  However, the default for the <code>method</code> parameter is always <code>xml</code>.</p>
            </item>
         </olist>
         <p><ednote><edtext>A different format for defining serialization parameters as an XML document is expected
         to be introduced as an outcome of bug 9302. This will include the ability to specify a character map.
         For details see http://www.w3.org/Bugs/Public/show_bug.cgi?id=9302</edtext></ednote></p>
         <p>The final stage of serialization, that is, encoding, is skipped. If the
            serializer does not allow this phase to be skipped, then the sequence of
            octets returned by the serializer is decoded into a string by reversing the
            character encoding performed in the final stage.</p>       
      </fos:rules>
      <fos:errors>
         <p>The serialization process will raise an error if <code>$arg</code> is an attribute
            or namespace node.</p>
         <p>If any serialization error occurs, including the detection of an invalid value
            for a serialization parameter, this results in the <code>fn:serialize</code> call failing
            with a dynamic error.</p>
      </fos:errors>
      <fos:notes>
            <p>One use case for this function arises when there is a need to construct an XML document
               containing nested XML documents within a CDATA section (or on occasions
               within a comment). See <code>fn:parse-xml</code> for further details.</p>
            <p>Another use case arises when there is a need to call an extension function that expects a lexical
               XML document as input.</p>
            <p>There are also use cases where the application wants to post-process the
               output of a query or transformation, for example by adding an internal DTD subset,
               or by inserting proprietary markup delimiters such as the <code>&lt;% ... %&gt;</code> used by some templating
               languages.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <ednote>
               <edtext>Add some examples!</edtext>
            </ednote>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="position">
      <fos:signatures>
         <fos:proto name="position" return-type="xs:integer"/>
      </fos:signatures>
      <fos:summary>
         <p>Summary:  Returns the context position from the dynamic context.</p>
      </fos:summary>
      <fos:rules>
         <p>Returns the context position from the dynamic context.
            (See <xspecref spec="XP" ref="id-xp-evaluation-context-components"/>.)</p>
      </fos:rules>
      <fos:errors>
         <p>If the
            context item is undefined, an error is raised: <xerrorref spec="XP" class="DY" code="0002" type="type"/>.</p>
      </fos:errors>
   </fos:function>
   <fos:function name="last">
      <fos:signatures>
         <fos:proto name="last" return-type="xs:integer"/>
      </fos:signatures>
      <fos:summary>
         <p>Summary:  Returns the context size from the dynamic context.</p>
      </fos:summary>
      <fos:rules>
         <p>Returns the context size from the dynamic context.
            (See <xspecref spec="XP" ref="id-xp-evaluation-context-components"/>.)</p>
      </fos:rules>
      <fos:errors>
         <p>If the
            context item is undefined, an error is raised: <xerrorref spec="XP" class="DY" code="0002" type="type"/>.</p>
      </fos:errors>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>(1 to 20)[fn:last() - 1]</fos:expression>
               <fos:result>19</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="current-dateTime">
      <fos:signatures>
         <fos:proto name="current-dateTime" return-type="xs:dateTimeStamp"/>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the current date and time (with timezone).</p>
      </fos:summary>
      <fos:rules>
         <p>Returns the current dateTime (with timezone) from the dynamic context.
            (See <xspecref spec="XP" ref="id-xp-evaluation-context-components"/>.) This
            is an <code>xs:dateTime</code> that is current at some time during the
            evaluation of a query or transformation in
            which <code>fn:current-dateTime</code> is executed.</p> 
         <p>This function is <termref def="stable"/>. The precise instant during the query or transformation
            represented by the value of <code>fn:current-dateTime()</code> is <termref def="implementation-dependent"/>.</p>
         <p diff="chg" at="A">If the implementation supports data types from XSD 1.1 then the returned value will be an instance
            of <code>xs:dateTimeStamp</code>. Otherwise, the only guarantees are that it will be an instance of
            <code>xs:dateTime</code> and will have a timezone component.</p>
      </fos:rules>
      <fos:notes>
         <p>The returned <code>xs:dateTime</code> will always have an associated timezone, which will always be the
            same as the implicit timezone in the dynamic context</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <p><code>fn:current-dateTime()</code> returns an
                 <code>xs:dateTimeStamp</code> corresponding to the current date and time.
                 For example, a call of <code>fn:current-dateTime()</code>
                 might return <code>2004-05-12T18:17:15.125Z</code> corresponding to
                 the current time on May 12, 2004 in timezone <code>Z</code>. </p>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="current-date">
      <fos:signatures>
         <fos:proto name="current-date" return-type="xs:date"/>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the current date.</p>
      </fos:summary>
      <fos:rules>
         <p>Returns <code>xs:date(fn:current-dateTime())</code>. This is an
            <code>xs:date</code> (with timezone) that is current at some time during the
            evaluation of a query or transformation in which <code>fn:current-date</code>
            is executed.</p>
         <p>This function is <termref def="stable"/>. The precise instant
            during the query or transformation represented by the value of
            <code>fn:current-date</code> is <termref def="implementation-dependent"/>.</p>
      </fos:rules>
      <fos:notes>
         <p>The returned date will always have an associated timezone, which will always be the
         same as the implicit timezone in the dynamic context</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <p><code>fn:current-date()</code> returns an <code>xs:date</code>
              corresponding to the current date. For example, a
              call of <code>fn:current-date()</code> might return
              <code>2004-05-12+01:00</code>. </p>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="current-time">
      <fos:signatures>
         <fos:proto name="current-time" return-type="xs:time"/>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the current time.</p>
      </fos:summary>
      <fos:rules>
         <p>Returns <code>xs:time(fn:current-dateTime())</code>. This is an
            <code>xs:time</code> (with timezone) that is current at some time during the
            evaluation of a query or transformation in which <code>fn:current-time</code>
            is executed.</p>
         <p>This function is <termref def="stable"/>. The precise instant
            during the query or transformation represented by the value of
            <code>fn:current-time()</code> is <termref def="implementation-dependent"/>.</p>
      </fos:rules>
      <fos:notes>
         <p>The returned time will always have an associated timezone, which will always be the
            same as the implicit timezone in the dynamic context</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <p><code>fn:current-time()</code> returns an <code>xs:time</code>
              corresponding to the current time. For example, a
              call of <code>fn:current-time()</code> might return
              <code>23:17:00.000-05:00</code>. </p>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="implicit-timezone">
      <fos:signatures>
         <fos:proto name="implicit-timezone" return-type="xs:dayTimeDuration"/>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the value of the implicit timezone property from the dynamic
                    context. </p>
      </fos:summary>
      <fos:rules>
         <p>Returns the value of the implicit timezone property from the dynamic
            context. Components of the dynamic context are discussed in 
            <xspecref spec="XP" ref="id-xp-evaluation-context-components"/>.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="default-collation">
      <fos:signatures>
         <fos:proto name="default-collation" return-type="xs:string"/>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the value of the default collation property from the static context. </p>
      </fos:summary>
      <fos:rules>
         <p>Returns the value of the default collation property from the static
            context. Components of the static context are discussed in <xspecref spec="XP" ref="id-xp-static-context-components"/>.</p>
      </fos:rules>
      <fos:notes>
         <p>The default collation property can never be undefined. If it is not
            explicitly defined, a system defined default can be invoked. If this is not
            provided, the Unicode codepoint collation
            (<code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>)
            is used. </p>
      </fos:notes>
   </fos:function>
   <fos:function name="static-base-uri">
      <fos:signatures>
         <fos:proto name="static-base-uri" return-type="xs:anyURI?"/>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the value of the Base URI property from the static context.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the value of the Base URI property from the static context. If
         the Base URI property is undefined, the empty sequence is returned.</p>
         <p>Components
            of the static context are discussed in <xspecref spec="XP" ref="id-xp-static-context-components"/> .</p>
      </fos:rules>
   </fos:function>
   <fos:function name="function-name" diff="chg" at="C">
      <fos:signatures>
         <fos:proto name="function-name" return-type="xs:QName?">
            <fos:arg name="func" type="function(*)"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the name of the function identified by a function item.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$func</code> refers to a named function, <code>fn:function-name($func)</code> 
            returns the name of that function.</p>
         <p>Otherwise (<code>$func</code> refers to an anonymous function), <code>fn:function-name($func)</code> 
            returns an empty sequence.</p>
         <p>The prefix part of the returned QName is <termref def="implementation-dependent"/>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:function-name(fn:contains#2)</fos:expression>
               <fos:result>fn:QName("http://www.w3.org/2005/xpath-functions", "fn:contains")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:function-name(function($node){count($node/*})</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
         
      </fos:examples>
   </fos:function>
   <fos:function name="function-arity" diff="chg" at="C">
      <fos:signatures>
         <fos:proto name="function-arity" return-type="xs:integer">
            <fos:arg name="func" type="function(*)"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns the arity of the function identified by a function item.</p>
      </fos:summary>
      <fos:rules>
         <p>The <code>fn:function-arity</code> function
            returns the arity (number of arguments) of the function identified by <code>$func</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:function-arity(fn:contains#2)</fos:expression>
               <fos:result>2</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:function-arity(function($node){name($node})</fos:expression>
               <fos:result>1</fos:result>
            </fos:test>
         </fos:example>         
      </fos:examples>
   </fos:function>   
   <fos:function name="map" diff="add" at="C">
      <fos:signatures>
         <fos:proto name="map" return-type="item()*">
            <fos:arg name="f" type="function(item()) as item()*"/>
            <fos:arg name="seq" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Applies the function item <var>$f</var> to every item from the sequence 
            <var>$seq</var> in turn, returning the concatenation of the resulting sequences in order.</p>
      </fos:summary>
      <fos:rules>
         <p>The effect of the function is equivalent to the following implementation in XQuery:</p>
         <eg><![CDATA[
declare function fn:map($f, $seq) {
  if (fn:empty($seq))
  then ()
  else $f(fn:head($seq)), fn:map($f, fn:tail($seq))
};]]></eg>
         <p>or its equivalent in XSLT:</p>
         <eg><![CDATA[
<xsl:function name="fn:map">
  <xsl:param name="f"/>
  <xsl:param name="seq/>
  <xsl:if test="fn:exists($seq)">
    <xsl:sequence select="$f(fn:head($seq)), fn:map($f, fn:tail($seq))"/>
  </xsl:if>
</xsl:function>]]>
         </eg>
      </fos:rules>
      <fos:notes>
         <p>The function call <code>fn:map($F, $SEQ)</code> is equivalent to the expression
            <code>for $i in $SEQ return $F($i)</code>.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:map(function($a) { $a * $a }, 1 to 5)</fos:expression>
               <fos:result>(1, 4, 9, 16, 25)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:map(fn:string-to-codepoints#1, ("john", "jane"))</fos:expression>
               <fos:result>(106, 111, 104, 110, 106, 97, 110, 101)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:map(xs:int#1, ("23", "29"))</fos:expression>
               <fos:result>(23, 29)</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>  
   <fos:function name="filter" diff="add" at="D">
      <fos:signatures>
         <fos:proto name="filter" return-type="item()*">
            <fos:arg name="f" type="function(item()) as xs:boolean"/>
            <fos:arg name="seq" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Returns those items from the sequence 
            <var>$seq</var> for which the supplied function <var>$f</var> returns true.</p>
      </fos:summary>
      <fos:rules>
         <p>Except in error cases, the effect of the function is equivalent to the following implementation in XQuery:</p>
         <eg><![CDATA[
declare function fn:filter($f, $seq) {
  if (fn:empty($seq))
  then ()
  else ( fn:head($seq)[$f(.) eq fn:true()], 
         fn:filter($f, fn:tail($seq))
       )
};]]></eg>
         <p>or its equivalent in XSLT:</p>
         <eg><![CDATA[
<xsl:function name="fn:filter">
  <xsl:param name="f"/>
  <xsl:param name="seq/>
  <xsl:if test="fn:exists($seq)">
    <xsl:sequence select="fn:head($seq)[$f(.) eq fn:true()], fn:filter($f, fn:tail($seq))"/>
  </xsl:if>
</xsl:function>]]>
         </eg>
      </fos:rules>
      <fos:errors>
         <p>A type error occurs if the supplied function <var>$f</var> returns anything other than a single <code>xs:boolean</code> item; there is no
         conversion to an effective boolean value.</p>
      </fos:errors>
      <fos:notes>
         <p>The function call <code>fn:filter($F, $SEQ)</code> has a very similar effect to the expression
            <code>$SEQ[$F(.)]</code>. There are some differences, however. In the case of <code>fn:filter</code>,
            the function <code>$F</code> is required to return a boolean; there is no special treatment for
            numeric predicate values, and no conversion to an effective boolean value. Also, with a filter expression 
            <code>$SEQ[$F(.)]</code>, the focus within the predicate is different from that outside; this means that the use of
            of a context-sensitive function such as <code>fn:lang#1</code> will give different results in the two cases.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:filter(function($a) {$a mod 2 = 0}, 1 to 10)</fos:expression>
               <fos:result>(2, 4, 6, 8, 10)</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>     
   <fos:function name="fold-left" diff="add" at="D">
      <fos:signatures>
         <fos:proto name="fold-left" return-type="item()*">
            <fos:arg name="f" type="function(item()*, item()) as item()*"/>
            <fos:arg name="zero" type="item()*"/>
            <fos:arg name="seq" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Processes the supplied sequence from left to right, applying the supplied function
            repeatedly to each item in turn, together with an accumulated result value.</p>
      </fos:summary>
      <fos:rules>
         <p>The effect of the function is equivalent to the following implementation in XQuery:</p>
         <eg><![CDATA[
declare function fn:fold-left($f, $zero, $seq) {
  if (fn:empty($seq))
  then $zero
  else fn:fold-left($f, $f($zero, fn:head($seq)), fn:tail($seq))
};]]></eg>
         <p>or its equivalent in XSLT:</p>
         <eg><![CDATA[
<xsl:function name="fn:fold-left">
  <xsl:param name="f"/>
  <xsl:param name="zero"/>
  <xsl:param name="seq/>
  <xsl:choose>
    <xsl:when test="fn:empty($seq)">
      <xsl:sequence select="$zero"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:sequence select="fn:fold-left($f, $f($zero, fn:head($seq)), fn:tail($seq))"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:function>]]>
        </eg>
      </fos:rules>
      <fos:errors>
         <p>A type error occurs if the supplied function <var>$f</var> cannot be applied to two arguments,
         where the first argument is either the value of <var>$zero</var> or the result of a previous application
            of <var>$f</var>, and the second is <var>$seq</var> or any trailing subsequence of <var>$seq</var>.</p>
      </fos:errors>
      <fos:notes>
         <p>This operation is often referred to in the functional programming literature as "folding" or "reducing"
         a sequence. It takes a function that operates on a pair of values, and applies it repeatedly, with an
         accumulated result as the first argument, and the next item in the sequence as the second argument. The accumulated
         result is initially set to the value of the <var>$zero</var> argument, which is conventionally a value (such as zero
         in the case of addition, one in the case of multiplication, or a zero-length string in the case of string
         concatenation) that causes the function to return the value of the other argument unchanged.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:fold-left(function($a, $b) { $a + $b }, 0, 1 to 5)</fos:expression>
               <fos:result>15</fos:result>
               <fos:postamble>This returns the sum of the items in the sequence</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:fold-left(function($a, $b) { $a * $b }, 1, (2,3,5,7))</fos:expression>
               <fos:result>210</fos:result>
               <fos:postamble>This returns the product of the items in the sequence</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:fold-left(function($a, $b) { $a or $b }, false(), (true(), false(), false()))</fos:expression>
               <fos:result>true()</fos:result>
               <fos:postamble>This returns true if any item in the sequence has an effective boolean value of true</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:fold-left(function($a, $b) { $a and $b }, false(), (true(), false(), false()))</fos:expression>
               <fos:result>false()</fos:result>
               <fos:postamble>This returns true only if every item in the sequence has an effective boolean value of true</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:fold-left(function($a, $b) {($b, $a)}, (), 1 to 5)</fos:expression>
               <fos:result>"(5,4,3,2,1)"</fos:result>
               <fos:postamble>This reverses the order of the items in a sequence</fos:postamble>
            </fos:test>
         </fos:example> 
         <fos:example>
            <fos:test>
               <fos:expression>fn:fold-left(fn:concat(?, ".", ?), "", 1 to 5)</fos:expression>
               <fos:result>".1.2.3.4.5"</fos:result>
            </fos:test>
         </fos:example>   
         <fos:example>
            <fos:test>
               <fos:expression>fn:fold-left(fn:concat("$f(", ?, ", ", ?, ")"), "$zero", 1 to 5)</fos:expression>
               <fos:result>"$f($f($f($f($f($zero, 1), 2), 3), 4), 5)"</fos:result>
            </fos:test>
         </fos:example>         
      </fos:examples>
   </fos:function>   
   <fos:function name="fold-right" diff="add" at="D">
      <fos:signatures>
         <fos:proto name="fold-right" return-type="item()*">
            <fos:arg name="f" type="function(item(), item()*) as item()*"/>
            <fos:arg name="zero" type="item()*"/>
            <fos:arg name="seq" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Processes the supplied sequence from right to left, applying the supplied function
            repeatedly to each item in turn, together with an accumulated result value.</p>
      </fos:summary>
      <fos:rules>
         <p>The effect of the function is equivalent to the following implementation in XQuery:</p>
         <eg><![CDATA[
declare function fn:fold-right($f, $zero, $seq) {
  if (fn:empty($seq))
  then $zero
  else $f(fn:head($seq), fn:fold-right($f, $zero, fn:tail($seq)))
};]]></eg>
         <p>or its equivalent in XSLT:</p>
         <eg><![CDATA[
<xsl:function name="fn:fold-right">
  <xsl:param name="f"/>
  <xsl:param name="zero"/>
  <xsl:param name="seq/>
  <xsl:choose>
    <xsl:when test="fn:empty($seq)">
      <xsl:sequence select="$zero"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:sequence select="$f(fn:head($seq), fn:fold-right($f, $zero, fn:tail($seq))"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:function>]]>
         </eg>
      </fos:rules>
      <fos:errors>
         <p>A type error occurs if the supplied function <var>$f</var> cannot be applied to two arguments,
            where the first argument is any item in the sequence <var>$seq</var>, and the second is
            either the value of <var>$zero</var> or the result of a previous application
            of <var>$f</var>.</p>
      </fos:errors>
      <fos:notes>
         <p>This operation is often referred to in the functional programming literature as "folding" or "reducing"
            a sequence. It takes a function that operates on a pair of values, and applies it repeatedly, with 
            the next item in the sequence as the first argument, and the result of processing the remainder
            of the sequence as the second argument. The accumulated
            result is initially set to the value of the <var>$zero</var> argument, which is conventionally a value (such as zero
            in the case of addition, one in the case of multiplication, or a zero-length string in the case of string
            concatenation) that causes the function to return the value of the other argument unchanged.</p>
         <p>In cases where the function performs an associative operation on its two arguments (such as addition or
         multiplication), <code>fn:fold-right</code> produces the same result as <code>fn:fold-left</code>.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:fold-right(function($a, $b) { $a + $b }, 0, 1 to 5)</fos:expression>
               <fos:result>15</fos:result>
               <fos:postamble>This returns the sum of the items in the sequence</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:fold-right(fn:concat(?, ".", ?), "", 1 to 5)</fos:expression>
               <fos:result>"1.2.3.4.5."</fos:result>
            </fos:test>
         </fos:example> 
         <fos:example>
            <fos:test>
               <fos:expression>fn:fold-right(concat("$f(", ?, ", ", ?, ")"), "$zero", 1 to 5)</fos:expression>
               <fos:result>"$f(1, $f(2, $f(3, $f(4, $f(5, $zero)))))"</fos:result>
            </fos:test>
         </fos:example>         
      </fos:examples>
   </fos:function>
   <fos:function name="map-pairs" diff="add" at="D">
      <fos:signatures>
         <fos:proto name="map-pairs" return-type="item()*">
            <fos:arg name="f" type="function(item(), item()) as item()*"/>
            <fos:arg name="seq1" type="item()*"/>
            <fos:arg name="seq2" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Summary: Applies the function item <var>$f</var> to successive pairs of items taken one from
            <var>$seq1</var> and one from <var>$seq2</var>, returning the concatenation of the resulting sequences in order.</p>
      </fos:summary>
      <fos:rules>
         <p>The effect of the function is equivalent to the following implementation in XQuery:</p>
         <eg><![CDATA[
declare function fn:map-pairs($f, $seq1, $seq2)
{
   if(fn:exists($seq1) and fn:exists($seq2)) 
   then (
     $f(fn:head($seq1), fn:head($seq2)),
     fn:map-pairs($f, fn:tail($seq1), fn:tail($seq2))
   )
   else ()
};]]></eg>
         <p>or its equivalent in XSLT:</p>
         <eg><![CDATA[
<xsl:function name="fn:map-pairs">
  <xsl:param name="f"/>
  <xsl:param name="seq1/>
  <xsl:param name="seq2/>
  <xsl:if test="fn:exists($seq1) and fn:exists($seq2">
    <xsl:sequence select="$f(fn:head($seq1), fn:head($seq2))"/>
    <xsl:sequence select="fn:map-pairs($f, fn:tail($seq1), fn:tail($seq2))"/>
  </xsl:if>
</xsl:function>]]>
         </eg>
      </fos:rules>
       <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:map-pairs(concat#2, ("a", "b", "c"), ("x", "y", "z"))</fos:expression>
               <fos:result>("ax", "by", "cz")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression><![CDATA[fn:map-pairs(function($a, $b){<e a="{$a}" b="{$b}"/>}, (1 to 3), ("x", "y", "z"))]]></fos:expression>
               <fos:result><![CDATA[(<e a="1" b="x"/>, <e a="2" b="y"/>, <e a="3" b="z"/>)]]></fos:result>
               <fos:postamble>This example uses XQuery syntax</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:map-pairs(function($a, $b){10*$a + $b}, 1 to 5, 1 to 5)</fos:expression>
               <fos:result>(11, 22, 33, 44, 55)</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>     
</fos:functions>