<?xml version="1.0" encoding="utf-8"?>

<!-- 
   Draft A. xsl:if, xsl:when/xsl:otherwise, xsl:switch
--><spec xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax" xmlns:t="http://www.w3.org/2008/XSL/Spec/TreeDiagram" xmlns:g="http://www.martin-loetzsch.de/DOTML" w3c-doctype="rec" status="int-review"><!--role="editors-copy"--> 
 
   <header>
      <title>XSL Transformations (XSLT)</title>
      <version>Version 4.0</version>
      <w3c-designation>REC-xslt-40</w3c-designation>
      <w3c-doctype>W3C Editor's Draft</w3c-doctype>
      <pubdate>
         <!-- The value from the build.xml file is used in preference -->
         <day>8</day>
         <month>June</month>
         <year>2017</year>
      </pubdate> 
      <publoc>
         <loc href="https://qt4cg.org/specifications/xslt-40/"
              >https://qt4cg.org/specifications/xslt-40/</loc>
      </publoc>
      <altlocs>
         <loc href="Overview.html">Normative specification in HTML format</loc>
         <loc href="Overview-diff.html">HTML with revision markings (non-normative)</loc>
         <loc href="schema-for-xslt40.xsd">XSD 1.1 Schema for XSLT 4.0 Stylesheets (non-normative)</loc>
         <loc href="schema-for-xslt40.rnc">Relax-NG Schema for XSLT 4.0 Stylesheets (non-normative)</loc>
         <loc href="schema-for-json.xsd">XSD 1.0 Schema for the XML representation of JSON used by
            fn:json-to-xml (non-normative)</loc>
         <loc href="xml-to-json.xsl">Stylesheet for XML-to-JSON conversion (non-normative)</loc>
      </altlocs>
      <latestloc>
         <loc href="https://qt4cg.org/specifications/xslt-40/"/>
      </latestloc>
      <!--<prevlocs>
         <loc href="https://www.w3.org/TR/2017/PR-xslt-30-20170418/">https://www.w3.org/TR/2017/PR-xslt-30-20170418/</loc>
      </prevlocs>-->

  <prevrec doc="XSL Transformations (XSLT)">
    <loc href="https://www.w3.org/TR/xslt-30/">https://www.w3.org/TR/xslt-30/</loc>
  </prevrec>

      <authlist>
         <author>
            <name>Michael Kay</name>
            <affiliation>Saxonica</affiliation>
            <email href="http://www.saxonica.com/">http://www.saxonica.com/</email>
         </author>
      </authlist>
      <!--<errataloc href="http://www.w3.org/XML/2017/qt-errata/xslt-30-errata.html"/>
      <translationloc href="https://www.w3.org/2003/03/Translations/byTechnology?technology=xslt-30"/>-->
      <status>
         <p><emph>This section describes the status of this document at the time of its publication.
               Other documents may supersede this document. A list of current W3C publications and
               the latest revision of this technical report can be found in the <loc href="https://www.w3.org/TR/">W3C technical reports index at
                  https://www.w3.org/TR/.</loc></emph></p>
         
         <p>This document has no official standing. It is produced by the editor as a proposal for community review.
         Insofar as it copies large amounts of text from the W3C XSLT 3.0 Recommendation, W3C copyright and similar provisions
         apply.</p>

         <!--<p>This document is governed by the <loc id="w3c_process_revision" href="https://www.w3.org/2017/Process-20170301/">1 March 2017 W3C Process Document</loc>.</p>

         <p>This is a <loc href="https://www.w3.org/2017/Process-20170301/#rec-publication">Recommendation</loc> of the W3C. It was developed by the W3C <loc href="https://www.w3.org/Style/XSL/">XSLT Working
               Group</loc>.</p>
         
         <p>This Recommendation specifies XSLT version 4.0. Changes since <loc href="https://www.w3.org/TR/xslt20">XSLT 3.0</loc> 
            are listed in <specref ref="changes-since-3.0"/>. The only incompatibilities with XSLT 2.0 relate to the way in which certain error
            conditions are handled: the details are given in <specref ref="incompatibilities"/>.</p>
         
         <p>No substantive changes have been made to this specification since its publication as a Proposed Recommendation. A few corrections
            and clarifications have been made to non-normative text: these are listed in <specref ref="changes-since-apr-2017"/>.</p>
         
         <p>This document has been reviewed by W3C Members, by software developers, and by other W3C groups and interested parties, 
            and is endorsed by the Director as a W3C Recommendation. It is a stable document and may be used as reference material 
            or cited from another document. W3C's role in making the Recommendation is to draw attention to the specification and 
            to promote its widespread deployment. This enhances the functionality and interoperability of the Web.</p>
         
         <p>A test suite for XSLT 4.0, containing over 11,000 test cases, is available at <loc href="https://dvcs.w3.org/hg/xslt30-test/"/>. The metadata
            for each test case describes any dependencies on optional or implementation-defined features of the specification, and provides
            expected results for each test. Documentation on how to run tests is available within the test suite. New tests may be added from time to
            time, and contributions are welcome.</p>
         
         <p>An <loc href="https://dvcs.w3.org/hg/xslt30-test/raw-file/tip/report/simpleReportOut.html">implementation report</loc>  
            is available detailing test results for various implementations. This link points to the latest
            version of the report; older versions are available within the repository. New submissions of test results
            are welcome. Submitted test results and a stylesheet for generating the reports can be found within the
            repository.</p>

         <p>This specification has been developed in conjunction with
               <bibref ref="xpath-30"/> and other documents that underpin both XSLT and XQuery. XSLT
            3.0 <rfc2119>requires</rfc2119> support for XPath 3.0 augmented by a selection of
            features from XPath 3.1 which are described in <specref ref="map"/> and <specref ref="json"/>. XSLT 3.0 in addition allows a processor to support the whole of XPath
            3.1, in which case it must do so as described in <specref ref="xpath31-feature"/>. In
            the event that future versions of XPath are defined beyond XPath 3.1, this specification
            allows XSLT 3.0 processors to provide support for such versions, but leaves it <termref def="dt-implementation-defined"/> how this is done. References in this document to
            XPath and related specifications are by default to the 3.0 versions, but such references
            should be treated as version-agnostic unless the relevant prose indicates otherwise.</p>

         <p><emph>XSLT 3.0 specifies extensions to the XDM 3.0 data
               model, to the XPath 3.0 language syntax, and to the XPath 3.0 function library to
               underpin the introduction of maps, which were found necessary to support some
               XSLT streaming use cases, to enable XSLT to process JSON data, and to make many other
               processing tasks easier. These
               extensions have been incorporated into XDM 3.1 and XPath 3.1. Although XDM 3.1 and XPath 3.1 
               have reached Recommendation status, XSLT 3.0 
               has not been made dependent on XPath 3.1, other than those features needed to meet the XSLT 3.0 requirements.
            </emph></p>



         <p>Please report errors in this document using W3C’s <loc href="https://www.w3.org/Bugs/Public/">public Bugzilla system</loc> (instructions can
            be found at <loc href="https://www.w3.org/XML/2005/04/qt-bugzilla"/>). If access to that
            system is not feasible, you may send your comments to the W3C XSLT/XPath/XQuery public
            comments mailing list, <loc href="mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</loc>. It will be very helpful if you include the string
            “[XSLT30]” in the subject line of your report, whether made in Bugzilla or in email.
            Please use multiple Bugzilla entries (or, if necessary, multiple email messages) if you
            have more than one comment to make. Archives of the comments and responses are available
            at <loc href="https://lists.w3.org/Archives/Public/public-qt-comments/"/>.</p>
         
         <p>The same mechanism may be used for reporting errors in the test suite.</p>

         <p>This document was produced by a group operating under the <loc href="https://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 W3C
               Patent Policy</loc>. W3C maintains a <loc rel="disclosure" href="https://www.w3.org/2004/01/pp-impl/19552/status#disclosures">public list of any
               patent disclosures</loc> made in connection with the deliverables of the group; that
            page also includes instructions for disclosing a patent. An individual who has actual
            knowledge of a patent which the individual believes contains <loc href="https://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential
               Claim(s)</loc> must disclose the information in accordance with <loc href="https://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section 6
               of the W3C Patent Policy</loc>.</p>-->

      </status>
      <abstract>
         <p>This specification defines the syntax and semantics of XSLT 4.0, a language designed
               primarily for transforming XML documents into other XML documents.</p>
         <p>XSLT 4.0 is a revised version of the XSLT 3.0 Recommendation <bibref ref="xslt-30"/>
            published on 8 June 2017.</p>
         <p>The changes in this version of the language are relatively minor usability enhancements. There
         are no changes to the data model or processing model. Instead, the specification attempts to fill
         a number of gaps in functionality resulting from feedback from XSLT 3.0 users. The main areas
         covered are:</p>
         <ulist>
            <item><p>Enhancements to the type system to allow more expressive constraints, especially
            for maps and atomic values.</p></item>
            <item><p>Additional functionality for processing arrays.</p></item>
            <item><p>Exploitation of the power afforded by first-class function items.</p></item>
         </ulist>
         <p>XSLT 4.0 is designed to be used in conjunction with XPath 4.0, which is defined in
               <bibref ref="xpath-40"/>. XSLT shares the same data model as XPath 4.0, which is
            defined in <bibref ref="xpath-datamodel-30"/>, and it uses the library of functions and
            operators defined in <bibref ref="xpath-functions-40"/>. XPath 4.0 and the underlying
            function library introduce a number of enhancements, for example the availability of
            union and record types. </p>
         
 
         <p>XSLT 4.0 also includes optional facilities to serialize the results of a transformation,
            by means of an interface to the serialization component described in 
            <bibref ref="xslt-xquery-serialization-31"/>.
         </p>
         <p>
            <emph>This document contains hyperlinks to specific sections or definitions within other
               documents in this family of specifications. These links are indicated visually by a
               superscript identifying the target specification: for example XP40 for XPath 4.0,
               DM40 for the XDM data model version 4.0, FO40 for Functions and Operators version
               4.0.</emph>
         </p>
         
      </abstract>
      <langusage>
         <language id="EN">English</language>
      </langusage>
      <revisiondesc>
         <slist>
            <sitem>((not used)).</sitem>
         </slist>
      </revisiondesc>
   </header>
   <body>
      <div1 id="introduction">
         <head>Introduction</head>
         <div2 id="what-is-xslt">
            <head>What is XSLT?</head>
            <p>This specification defines the syntax and semantics of the XSLT 4.0 language.</p>
            <p>A transformation in the XSLT language is expressed in the
               form of a <term>stylesheet</term>. A stylesheet is made up of one or more well-formed
               XML <bibref ref="REC-xml"/> documents conforming to the Namespaces in XML
               Recommendation <bibref ref="xml-names"/>. </p>
            <p>A stylesheet generally includes elements that are defined by XSLT as well as elements
               that are not defined by XSLT. XSLT-defined elements are distinguished by use of the
               namespace <code>http://www.w3.org/1999/XSL/Transform</code> (see <specref ref="xslt-namespace"/>), which is referred to in this specification as the
                  <termref def="dt-xslt-namespace">XSLT namespace</termref>. Thus this specification
               is a definition of the syntax and semantics of the XSLT namespace.</p>
            <p>The term <termref def="dt-stylesheet">stylesheet</termref> reflects the fact that one
               of the important roles of XSLT is to add styling information to an XML source
               document, by transforming it into a document consisting of XSL formatting objects
               (see <bibref ref="xsl11"/>), or into another presentation-oriented format such as
               HTML, XHTML, or SVG. However, XSLT is used for a wide range of transformation tasks,
               not exclusively for formatting and presentation applications.</p>
            <p>A transformation expressed in XSLT describes rules for transforming  input data into output data. The inputs and outputs
                  will all be instances of the XDM data model, described in <bibref ref="xpath-datamodel-30"/>. In the simplest and most common case, the input is
                  an XML document referred to as the source tree, and the output is an XML document
                  referred to as the result tree. It is also possible to process multiple source
                  documents, to generate multiple result documents, and to handle formats other than
                  XML.
                The transformation is achieved by a set of
                  <termref def="dt-template-rule">template rules</termref>. A template rule
               associates a <termref def="dt-pattern">pattern</termref>, which typically matches nodes in the source document, with a
                  <termref def="dt-sequence-constructor">sequence constructor</termref>. In many
               cases, evaluating the sequence constructor will cause new nodes to be constructed,
               which can be used to produce part of a result tree. The structure of the result trees
               can be completely different from the structure of the source trees. In constructing a
               result tree, nodes from the source trees can be filtered and reordered, and arbitrary
               structure can be added. This mechanism allows a <termref def="dt-stylesheet">stylesheet</termref> to be applicable to a wide class of documents that have
               similar source tree structures.</p>



            <p>Stylesheets have a modular structure; they may contain several packages developed
               independently of each other, and each package may consist of several stylesheet
               modules. </p>

            <p><termdef id="dt-stylesheet" term="stylesheet">A
                     <term>stylesheet</term> consists of one or more packages: specifically, one
                     <termref def="dt-top-level-package">top-level package</termref> and zero or
                  more <termref def="dt-library-package">library packages</termref>.</termdef></p>

            <p><termdef id="dt-top-level-package" term="top-level package">For a given transformation, one <termref def="dt-package">package</termref> functions as the <term>top-level package</term>. The
                  complete <termref def="dt-stylesheet">stylesheet</termref> is assembled by finding
                  the packages referenced directly or indirectly from the top-level package using
                     <elcode>xsl:use-package</elcode> declarations: see <specref ref="package-dependencies"/>.</termdef></p>

            <p><termdef id="dt-library-package" term="library package">Every <termref def="dt-package">package</termref> within a <termref def="dt-stylesheet">stylesheet</termref>, other than the <termref def="dt-top-level-package">top-level package</termref>, is referred to as a
                     <term>library package</term>.</termdef></p>

            <p><termdef id="dt-principal-stylesheet-module" term="principal stylesheet module">Within a <termref def="dt-package">package</termref>, one <termref def="dt-stylesheet-module"/> functions as the
                     <term>principal stylesheet module</term>. The complete package is assembled by
                  finding the stylesheet modules referenced directly or indirectly from the
                  principal stylesheet module using <elcode>xsl:include</elcode> and
                     <elcode>xsl:import</elcode> elements: see <specref ref="include"/> and <specref ref="import"/>.</termdef></p>


         </div2>
         <div2 id="whats-new-in-xslt4">
            <head>What’s New in XSLT 4.0?</head>
            <!--<p>A major focus for enhancements in XSLT 3.0 is the requirement to enable streaming of
               source documents. This is needed when source documents become too large to hold in
               main memory, and also for applications where it is important to start delivering
               results before the entire source document is available.</p>
            <p>While implementations of XSLT that use streaming have always been theoretically
               possible, the nature of the language has made it very difficult to achieve this in
               practice. The approach adopted in this specification is twofold: it identifies a set
               of restrictions which, if followed by stylesheet authors, will enable implementations
               to adopt a streaming mode of operation without placing excessive demands on the
               optimization capabilities of the processor; and it provides new constructs to
               indicate that streaming is required, or to express transformations in a way that
               makes it easier for the processor to adopt a streaming execution plan.</p>
            <p>Capabilities provided in this category include:</p>
            <ulist>
               <item>
                  <p>A new <elcode>xsl:source-document</elcode> instruction, which reads and processes a
                     source document, optionally in streaming mode;</p>
               </item>
               <item>
                  <p>The ability to declare that a <termref def="dt-mode">mode</termref> is a
                     streaming mode, in which case all the template rules using that mode must be
                     streamable;</p>
               </item>
               <item>
                  <p>A new <elcode>xsl:iterate</elcode> instruction, which iterates over the items
                     in a sequence, allowing parameters for the processing of one item to be set
                     during the processing of the previous item;</p>
               </item>
               <item>
                  <p>A new <elcode>xsl:merge</elcode> instruction, allowing multiple input streams
                     to be merged into a single output stream;</p>
               </item>
               <item>
                  <p>A new <elcode>xsl:fork</elcode> instruction, allowing multiple computations to
                     be performed in parallel during a single pass through an input document;</p>
               </item>
               <item>
                  <p><termref def="dt-accumulator-function">Accumulators</termref>, which allow a
                     value to be computed progressively during streamed processing of a document,
                     and accessed as a function of a node in the document, without compromise to the
                     functional nature of the XSLT language.</p>
               </item>
            </ulist>
            <p>A second focus for enhancements in XSLT 3.0 is the introduction of a new mechanism
               for stylesheet modularity, called the package. Unlike the stylesheet modules of XSLT
               1.0 and 2.0 (which remain available), a package defines an interface that regulates
               which functions, variables, templates and other components are visible outside the
               package, and which can be overridden. There are two main goals for this facility: it
               is designed to deliver software engineering benefits by improving the reusability and
               maintainability of code, and it is intended to streamline stylesheet deployment by
               allowing packages to be compiled independently of each other, and compiled instances
               of packages to be shared between multiple applications.</p>

            <p>Other significant features in XSLT 3.0 include:</p>
            <ulist>
               <item>
                  <p>An <elcode>xsl:evaluate</elcode> instruction allowing evaluation of XPath
                     expressions that are dynamically constructed as strings, or that are read from
                     a source document;</p>
               </item>
               <item>
                  <p>Enhancements to the syntax of <termref def="dt-pattern">patterns</termref>, in
                     particular enabling the matching of atomic values as well as nodes;</p>
               </item>
               <item>
                  <p>An <elcode>xsl:try</elcode> instruction to allow recovery from dynamic
                     errors;</p>
               </item>
               <item>
                  <p>The element <elcode>xsl:global-context-item</elcode>, used to declare the
                     stylesheet’s expectations of the global context item (notably, its
                     type);</p>
               </item>
               <item>
                  <p>A new instruction <elcode>xsl:assert</elcode> to assist developers in producing
                     correct and robust code.</p>
               </item>
            </ulist>
            <p>XSLT 3.0 also delivers enhancements made to the XPath language and to the standard
               function library, including the following:</p>
            <ulist>
               <item>
                  <p>Variables can now be bound in XPath using the <code>let</code> expression.</p>
               </item>
               <item>
                  <p>Functions are now first class values, and can be passed as arguments to other
                     (higher-order) functions, making XSLT a fully-fledged functional programming
                     language.</p>
               </item>
               <item>
                  <p>A number of new functions are available, for example trigonometric functions,
                     and the functions <xfunction>parse-xml</xfunction> and
                        <xfunction>serialize</xfunction> to convert between lexical and tree
                     representations of XML.</p>
               </item>
            </ulist>
            <p>XSLT 3.0 also includes support for maps (a data structure
               consisting of key/value pairs, sometimes referred to in other programming languages
               as dictionaries, hashes, or associative arrays). This feature extends the data model,
               provides new syntax in XPath, and adds a number of new functions and operators. 
               Initially developed as XSLT-specific extensions, maps have now been integrated
               into XPath 3.1 (see <bibref ref="xpath-31"/>). XSLT 3.0 does not require implementations
               to support XPath 3.1 in its entirety, but it does requires support for these specific
               features.</p>-->
            
            <p>A full list of changes is at <specref ref="changes-since-3.0"/>.</p>
         </div2>
      </div1>
      <div1 id="concepts">
         <head>Concepts</head>
         <div2 id="terminology">
            <head>Terminology</head>
            <p>For a full glossary of terms, see <specref ref="glossary"/>.</p>
            <p>
               <termdef id="dt-processor" term="processor">The software responsible for transforming
                  source trees into result trees using an XSLT stylesheet is referred to as the
                     <term>processor</term>. This is sometimes expanded to <emph>XSLT
                     processor</emph> to avoid any confusion with other processors, for example an
                  XML processor.</termdef>
            </p>
            <p>
               <termdef id="dt-implementation" term="implementation">A specific product that
                  performs the functions of an <termref def="dt-processor">XSLT processor</termref>
                  is referred to as an <term>implementation</term>.</termdef></p>
            <p>
               <termdef id="dt-tree" term="tree">The term <term>tree</term> is used (as in <bibref ref="xpath-datamodel-30"/>) to refer to the aggregate consisting of a
                  parentless node together with all its descendant nodes, plus all their attributes
                  and namespaces.</termdef>
            </p>
               <note>
                  <p>The use of the term <term>tree</term> in this document does not imply the use
                     of a data structure in memory that holds the entire contents of the document at
                     one time. It implies rather a logical view of the XML input and output in which
                     elements have a hierarchic relationship to each other. When a source document
                     is being processed in a streaming manner, access to the nodes in this tree is
                     constrained, but it is still viewed and described as a tree.</p>
               </note>
            
            <p>The output of a transformation consists of the
               following:</p>
            <olist>
               <item>
                  <p><termdef id="dt-principal-result" term="principal result">A <term>principal
                           result</term>: this can be any sequence of items (as defined in <bibref ref="xpath-datamodel-30"/>).</termdef> The principal result is the value
                     returned by the function or template in the stylesheet that is nominated as the
                     entry point, as described in <specref ref="initiating"/>.</p>
               </item>
               <item>
                  <p><termdef id="dt-secondary-result" term="secondary result">Zero or more
                           <term>secondary results</term>: each secondary result can be any sequence
                        of items (as defined in <bibref ref="xpath-datamodel-30"/>).</termdef> A
                     secondary result is the value returned by evaluating the body of an
                        <elcode>xsl:result-document</elcode> instruction.</p>
               </item>
               <item>
                  <p>Zero or more messages. Messages are generated by the
                        <elcode>xsl:message</elcode> and <elcode>xsl:assert</elcode> instructions, and are described in <specref ref="message"/> and <specref ref="assertions"/>.</p>
               </item>
               <item>
                  <p>Static or dynamic errors: see <specref ref="errors"/>. </p>
               </item>
            </olist>
            <p>The <termref def="dt-principal-result"/> and the <termref def="dt-secondary-result">secondary results</termref> may be post-processed as
               described in <specref ref="post-processing"/>.</p>
            <p>
               <termdef id="dt-result-tree" term="result tree">The term <term>result tree</term> is
                  used to refer to any <termref def="dt-tree">tree</termref> constructed by <termref def="dt-instruction">instructions</termref> in the stylesheet. A result tree is
                  either a <termref def="dt-final-result-tree">final result tree</termref> or a
                     <termref def="dt-temporary-tree">temporary tree</termref>.</termdef>
            </p>
            <p>
               <termdef id="dt-final-result-tree" term="final result tree">A <term>final result
                     tree</term> is a <termref def="dt-result-tree">result tree</termref> that forms
                  part of the output of a transformation: specifically, a tree built by post-processing the items in the <termref def="dt-principal-result"/> or in a <termref def="dt-secondary-result"/>. Once created, the contents of a final result tree are not
                  accessible within the stylesheet itself.</termdef>
                Any final result tree
                  <rfc2119>may</rfc2119> be serialized as described in <specref ref="serialization"/>.</p>
            <p>
               <termdef id="dt-source-tree" term="source tree">The term <term>source tree</term>
                  means any tree provided as input to the transformation. This includes the document
                  containing the <termref def="dt-global-context-item"/> if any, documents containing
                     nodes present in the <termref def="dt-initial-match-selection"/>,
                  documents containing nodes supplied as the values of <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>, documents
                  obtained from the results of functions such as <function>document</function>,
                     <xfunction>doc</xfunction>, and <xfunction>collection</xfunction>, documents read using the <elcode>xsl:source-document</elcode>
                     instruction, and documents returned by extension functions or
                  extension instructions. In the context of a particular XSLT instruction, the term
                     <term>source tree</term> means any tree provided as input to that instruction;
                  this may be a source tree of the transformation as a whole, or it may be a
                     <termref def="dt-temporary-tree">temporary tree</termref> produced during the
                  course of the transformation.</termdef>
            </p>
            <p>
               <termdef id="dt-temporary-tree" term="temporary tree">The term <term>temporary
                     tree</term> means any tree that is neither a <termref def="dt-source-tree">source tree</termref> nor a <termref def="dt-final-result-tree">final result
                     tree</termref>.</termdef> Temporary trees are used to hold intermediate results
               during the execution of the transformation.</p>
            <p>The use of the term “tree” in phrases such as <term>source
                  tree</term>, <term>result tree</term>, and <term>temporary tree</term> is not
               confined to documents that the processor materializes in memory in their entirety.
               The processor <rfc2119>may</rfc2119>, and in some cases <rfc2119>must</rfc2119>, use
               streaming techniques to limit the amount of memory used to hold source and result
               documents. When streaming is used, the nodes of the tree may never all be in memory
               at the same time, but at an abstract level the information is still modeled as a tree
               of nodes, and the document is therefore still described as a tree. Unless otherwise stated, the term “tree” refers to a tree rooted
                  at a parentless node: that is, the term does not include subtrees of larger trees.
                  Every node therefore belongs to exactly one tree.</p>
            <p>In this specification the phrases <rfc2119>must</rfc2119>, <rfc2119>must
                  not</rfc2119>, <rfc2119>should</rfc2119>, <rfc2119>should not</rfc2119>,
                  <rfc2119>may</rfc2119>, <rfc2119>required</rfc2119>, and
                  <rfc2119>recommended</rfc2119>, when used in normative
                  text and rendered in capitals, are to be interpreted as described in
                  <bibref ref="rfc2119"/>.</p>
            <p>Where the phrase <rfc2119>must</rfc2119>, <rfc2119>must not</rfc2119>, or
                  <rfc2119>required</rfc2119> relates to the behavior of the XSLT processor, then an
               implementation is not conformant unless it behaves as specified, subject to the more
               detailed rules in <specref ref="conformance"/>. </p>
            <p>Where the phrase <rfc2119>must</rfc2119>, <rfc2119>must not</rfc2119>, or
                  <rfc2119>required</rfc2119> relates to a stylesheet then the processor
                  <rfc2119>must</rfc2119> enforce this constraint on stylesheets by reporting an
               error if the constraint is not satisfied.</p>
            <p>Where the phrase <rfc2119>should</rfc2119>, <rfc2119>should not</rfc2119>, or
                  <rfc2119>recommended</rfc2119> relates to a stylesheet then a processor
                  <rfc2119>may</rfc2119> produce warning messages if the constraint is not
               satisfied, but <rfc2119>must not</rfc2119> treat this as an error.</p>
            <p>
               <termdef id="dt-implementation-defined" term="implementation-defined">In this
                  specification, the term <term>implementation-defined</term> refers to a feature
                  where the implementation is allowed some flexibility, and where the choices made
                  by the implementation <rfc2119>must</rfc2119> be described in documentation that
                  accompanies any conformance claim.</termdef>
            </p>
            <p>
               <termdef id="dt-implementation-dependent" term="implementation-dependent">The term
                     <term>implementation-dependent</term> refers to a feature where the behavior
                     <rfc2119>may</rfc2119> vary from one implementation to another, and where the
                  vendor is not expected to provide a full specification of the behavior.</termdef>
               (This might apply, for example, to limits on the size of source documents that can be
               transformed.)</p>
            <p>In all cases where this specification leaves the behavior implementation-defined or
               implementation-dependent, the implementation has the option of providing mechanisms
               that allow the user to influence the behavior.</p>
            <p>A paragraph labeled as a <term>Note</term> or described as an <term>example</term> is
               non-normative.</p>
            <p>Many terms used in this document are defined in the XPath specification <bibref ref="xpath-30"/> or the XDM specification <bibref ref="xpath-datamodel-30"/>.
               Particular attention is drawn to the following:</p>
            <ulist>
               <item>
                  <p>
                     <termdef id="dt-atomization" term="atomize">The term <term>atomization</term>
                        is defined in <!--<bibref ref="xpath-30"/>--><xspecref spec="XP40" ref="id-atomization"/>. It is a process that takes as input a sequence of
                           items, and returns a sequence of
                        atomic values, in which the nodes are replaced by their typed values as
                        defined in <bibref ref="xpath-datamodel-30"/>. 
                        <phrase diff="del" at="2022-01-01">If the XPath 3.1 feature is implemented,
                        then</phrase> Arrays (see <specref ref="arrays"/>) are atomized by atomizing their
                        members, recursively.</termdef> For some items (for example, elements with element-only
                     content, function items, and maps, atomization
                     generates a <termref def="dt-dynamic-error">dynamic error</termref>.</p>
               </item>
               <item>
                  <p>
                     <termdef id="dt-typed-value" term="typed value">The term <term>typed
                           value</term> is defined in <xspecref spec="DM30" ref="dm-typed-value"/>.
                        Every node, other than an element whose type
                           annotation identifies it as having element-only content, has a
                           <termref def="dt-string-value">typed value</termref>. For example, the
                           <termref def="dt-typed-value">typed value</termref> of an attribute of
                        type <code>xs:IDREFS</code> is a sequence of zero or more
                           <code>xs:IDREF</code> values.</termdef>
                  </p>
               </item>
               <item>
                  <p>
                     <termdef id="dt-string-value" term="string value">The term <term>string
                           value</term> is defined in
                           <!--<bibref ref="xpath-datamodel-30"/>--><xspecref spec="DM30" ref="dm-string-value"/>. Every node has a <termref def="dt-string-value">string value</termref>. For example, the <termref def="dt-string-value">string value</termref> of an element is the concatenation of the
                           <termref def="dt-string-value">string values</termref> of all its
                        descendant text nodes.</termdef>
                  </p>
               </item>
               <item>
                  <p>
                     <termdef id="dt-xpath-compat-mode" term="XPath 1.0 compatibility mode">The term
                           <term>XPath 1.0 compatibility mode</term> is defined in 
                        <xspecref spec="XP40" ref="static_context"/>. This is a setting in the static
                        context of an XPath expression; it has two values, <code>true</code> and
                           <code>false</code>. When the value is set to <code>true</code>, the semantics of
                        function calls and certain other operations are adjusted to give a greater
                        degree of backwards compatibility between XPath
                        <phrase diff="chg" at="2023-02-24">4.0</phrase> and XPath 1.0.</termdef>
                  </p>


               </item>
               <item>
                  <p>
                     <termdef id="dt-function-definition" term="function definition">The term
                        <term>function definition</term> is defined in <xspecref spec="XP40" ref="static_context"/>. 
                        It is the definition of a function that can be called statically from within an XPath
                        expression: in the case of XSLT it typically means either a <termref def="dt-stylesheet-function"/>,
                        or a built-in function such as those defined in <bibref ref="xpath-functions-40"/></termdef>
                  </p>
                  <p>
                     <termdef id="dt-arity-range" term="arity range">A <termref def="dt-function-definition"/>
                        has an <term>arity range</term> which defines the minimum and maximum number of arguments
                        that must be supplied in a call to the function. The static context can contain multiple
                        <termref def="dt-function-definition">function definitions</termref> with the same name, 
                        provided that their <term>arity ranges</term> do not overlap.</termdef>
                      
                  </p>
                  
                  
               </item>
            </ulist>
            
         </div2>
         <div2 id="notation">
            <head>Notation</head>
            <p>
               <termdef id="dt-xslt-element" term="XSLT element">An <term>XSLT element</term> is an
                  element in the <termref def="dt-xslt-namespace">XSLT namespace</termref> whose
                  syntax and semantics are defined in this specification.</termdef> For a
               non-normative list of XSLT elements, see <specref ref="element-syntax-summary"/>.</p>
            <p>In this document the specification of each <termref def="dt-xslt-element">XSLT
                  element</termref> is preceded by a summary of its syntax in the form of a model
               for elements of that element type. A full list of all these specifications can be
               found in <specref ref="element-syntax-summary"/>. The meaning of the syntax summary
               notation is as follows:</p>
            <ulist>
               <item>
                  <p>An attribute that is <rfc2119>required</rfc2119> is shown with its name in
                     bold. An attribute that may be omitted is shown with a question mark following
                     its name.</p>
               </item>
               <item>
                  <p>An attribute that is <termref def="dt-deprecated">deprecated</termref> is shown
                     in a grayed font within square brackets.</p>
               </item>
               <item>
                  <p>The string that occurs in the place of an attribute value specifies the allowed
                     values of the attribute. If this is surrounded by curly brackets
                        (<code>{...}</code>), then the attribute value is treated as an <termref def="dt-attribute-value-template">attribute value template</termref>, and
                     the string occurring within curly brackets specifies the allowed values of the
                     result of evaluating the attribute value template. Alternative allowed values
                     are separated by <code>|</code>. A quoted string indicates a value equal to
                     that specific string. An unquoted, italicized name specifies a particular type
                     of value.</p>
                  <p>The types used, and their meanings, are as follows:</p>
                  
                  <glist>
                     <gitem>
                        <label>
                           <code>boolean</code>
                        </label>
                        <def>
                           <p>One of the strings <code>"yes"</code>,
                              <code>"true"</code>, or <code>"1"</code> to indicate the value
                              <code>true</code>, or one of the strings <code>"no"</code>,
                              <code>"false"</code>, or <code>"0"</code> to indicate the value
                              <code>false</code>. Note: the values are synonyms; where this
                              specification uses a phrase such as “If <code>required='yes'</code> is
                              specified ...” this is to be interpreted as meaning “If the attribute
                              named <code>required</code> is present, and has the value
                              <code>yes</code>, <code>true</code>, or <code>1</code> (after
                              stripping leading and trailing whitespace) ...”.
                           </p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>string</code></label>
                        <def>
                           <p>Any string</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>expression</code></label>
                        <def>
                           <p>An XPath <termref def="dt-expression">expression</termref></p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>pattern</code></label>
                        <def>
                           <p>A <termref def="dt-pattern">pattern</termref> as described in
                                 <specref ref="patterns"/>.</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>item-type</code></label>
                        <def>
                           <p>An <xnt spec="XP40" ref="prod-xpath40-ItemType">ItemType</xnt> as defined in the XPath
                              <phrase diff="chg" at="2022-01-01">4.0</phrase> specification.</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>sequence-type</code></label>
                        <def>
                           <p>A <xnt spec="XP40" ref="prod-xpath40-SequenceType">SequenceType</xnt>
                              as defined in the XPath <phrase diff="chg" at="2022-01-01">4.0</phrase> specification.</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>uri; uris</code></label>
                        <def>
                           <p>A URI, for example a namespace URI or a collation URI; a
                              whitespace-separated list of URIs</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>qname</code></label>
                        <def>
                           <p>A <termref def="dt-lexical-qname">lexical QName</termref> as defined
                              in <specref ref="qname"/></p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>eqname; eqnames</code></label>
                        <def>
                           <p>An <termref def="dt-eqname">EQName</termref> as defined in <specref ref="qname"/>; a whitespace-separated list of EQNames</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>token; tokens</code></label>
                        <def>
                           <p>A string containing no significant whitespace; a whitespace-separated
                              list of such strings</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>nmtoken; nmtokens</code></label>
                        <def>
                           <p>A string conforming to the XML schema rules for the type
                                 <code>xs:NMTOKEN</code>; a whitespace-separated list of such
                              strings.</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>char</code></label>
                        <def>
                           <p>A string comprising a single Unicode character</p>
                        </def>
                     </gitem>
                     <gitem diff="add" at="2023-04-18">
                        <label><code>language</code></label>
                        <def>
                           <p>A string in the value space of <code>xs:language</code>, or a zero-length string.</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>integer</code></label>
                        <def>
                           <p>An integer, that is a string <phrase diff="chg" at="2022-11-01">that is castable to</phrase> the schema type
                                 <code>xs:integer</code></p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>decimal</code></label>
                        <def>
                           <p>A decimal value, that is a string <phrase diff="chg" at="2022-11-01">that is castable to</phrase> the schema
                              type <code>xs:decimal</code></p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>ncname;</code> <phrase diff="add" at="2022-01-01"><code>ncnames</code></phrase></label>
                        <def>
                           <p>An unprefixed name: a string <phrase diff="chg" at="2022-11-01">that is castable to</phrase> the schema type
                                 <code>xs:NCName</code>; <phrase diff="add" at="2022-01-01">a whitespace-separated list of such strings</phrase></p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>prefix</code><phrase diff="add" at="2023-04-18">; <code>prefixes</code></phrase></label>
                        <def>
                           <p>An <code>xs:NCName</code> representing a namespace prefix, which must
                              be in scope for the element on which it appears;
                              <phrase diff="add" at="2022-01-01">a whitespace-separated list of such strings</phrase>.</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>id</code></label>
                        <def>
                           <p>An <code>xs:NCName</code> used as a unique identifier for an element
                              in the containing XML document</p>
                        </def>
                     </gitem>
                  </glist>
                  <!--Text replaced by erratum E2 change 1"-->
                  <p>Except where the set of allowed values of an attribute is specified using the
                     italicized name <emph>string</emph> or <emph>char</emph>, leading and trailing
                     whitespace in the attribute value is ignored. In the case of an <termref def="dt-attribute-value-template">attribute value template</termref>, this
                     applies to the <termref def="dt-effective-value">effective value</termref>
                     obtained when the attribute value template is expanded.</p>
                  <!--End of text replaced by erratum E2-->
                  <p>XPath comments (delimited by <code>(: ... :)</code>)
                  are permitted anywhere that inter-token whitespace is permitted in attributes whose
                  type is given as <emph>expression</emph>, <emph>pattern</emph>, <emph>item-type</emph>, 
                     or <emph>sequence-type</emph>, and are not permitted in attributes of other types
                     (other than within expressions enclosed by curly braces within an <termref def="dt-attribute-value-template"/>).</p>
               </item>
               <item diff="add" at="2023-07-04">
                  <p>If an attribute has a simple default value, this is shown between tortoise-shell
                  brackets (for example <code>&#x3014;'no'&#x3015;</code>). Where no default is shown,
                  the consequence of omitting the attribute is explained in the prose narrative. 
                  Default values shown in the summary apply only where the attribute itself
                  is applicable; if an attribute is not permitted to appear in the particular context,
                  then its default value should be ignored. (For example, the <code>stable</code>
                     attribute of <elcode>xsl:sort</elcode> is shown as having a default value
                     of <code>'yes'</code>, but the attribute is only allowed to appear on the
                     first of a sequence of adjacent <elcode>xsl:sort</elcode> elements.) 
                     The quotation marks around a default value are not part of the value.</p>
               </item>
               <item>
                  <p>Unless the element is <rfc2119>required</rfc2119> to be empty, the model
                     element contains a comment specifying the allowed content. The allowed content
                     is specified in a similar way to an element type declaration in XML;
                        <emph>sequence constructor</emph> means that any mixture of text nodes,
                        <termref def="dt-literal-result-element">literal result elements</termref>,
                        <termref def="dt-extension-instruction">extension instructions</termref>,
                     and <termref def="dt-xslt-element">XSLT elements</termref> from the <termref def="dt-instruction">instruction</termref> category is allowed;
                        <emph>other-declarations</emph> means that any mixture of XSLT elements from
                     the <termref def="dt-declaration">declaration</termref> category is allowed, together with <termref def="dt-data-element">user-defined data elements</termref>.</p>
               </item>
               <item>
                  <p>The element is prefaced by comments indicating if it belongs to the
                        <code>instruction</code> category or <code>declaration</code> category or
                     both. The category of an element only affects whether it is allowed in the
                     content of elements that allow a <termref def="dt-sequence-constructor">sequence constructor</termref> or <emph>other-declarations</emph>.</p>
               </item>
            </ulist>
            <example>
               <head>Syntax Notation</head>
               <p>This example illustrates the notation used to describe <termref def="dt-xslt-element">XSLT elements</termref>.</p>
               <e:element-syntax name="example-element">
                  <e:in-category name="instruction"/>
                  <e:attribute name="select" required="yes">
                     <e:data-type name="expression"/>
                  </e:attribute>
                  <e:attribute name="debug">
                     <e:data-type name="boolean"/>
                  </e:attribute>
                  <e:attribute name="validation" default="strict">
                     <e:attribute-value-template>
                        <e:constant value="strict"/>
                        <e:constant value="lax"/>
                     </e:attribute-value-template>
                  </e:attribute>
                  <e:sequence>
                     <e:choice repeat="zero-or-more">
                        <e:element name="variable"/>
                        <e:element name="param"/>
                     </e:choice>
                     <e:element name="sequence"/>
                  </e:sequence>
                  <e:allowed-parents>
                     <e:parent-category name="sequence-constructor"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <p>This example defines a (non-existent) element <code>xsl:example-element</code>.
                  The element is classified as an instruction. It takes the following
                  attributes:</p>

               <olist>
                  <item>
                     <p>A mandatory <code>select</code> attribute, whose value is an XPath <termref def="dt-expression">expression</termref></p>
                  </item>
                  <item>
                     <p>An optional <code>debug</code> attribute, whose
                        value <rfc2119>must</rfc2119> be <code>yes</code>, <code>true</code>, or
                           <code>1</code> to indicate <code>true</code>, or <code>no</code>,
                           <code>false</code>, or <code>0</code> to indicate <code>false</code>.</p>
                  </item>
                  <item>
                     <p>An optional <code>validation</code> attribute, whose value must be
                           <code>strict</code> or <code>lax</code>; the curly brackets indicate that
                        the value can be defined as an <termref def="dt-attribute-value-template">attribute value template</termref>, allowing a value such as
                           <code>validation="{$val}"</code>, where the <termref def="dt-variable">variable</termref>
                        <code>val</code> is evaluated to yield <code>"strict"</code> or
                           <code>"lax"</code> at run-time.</p>
                  </item>
               </olist>
               <p>The content of an <code>xsl:example-element</code> instruction is defined to be a
                  sequence of zero or more <elcode>xsl:variable</elcode> and
                     <elcode>xsl:param</elcode> elements, followed by an
                     <elcode>xsl:sequence</elcode> element.</p>
            </example>
            <p>
               <error spec="XT" type="static" class="SE" code="0010">
                  <p>It is a <termref def="dt-static-error">static error</termref> if an
                     XSLT-defined element is used in a context where it is not permitted, if a
                        <rfc2119>required</rfc2119> attribute is omitted, or if the content of the
                     element does not correspond to the content that is allowed for the element.</p>
               </error>
            </p>
            <p>The rules in the element syntax summary (both for the
               element structure and for its attributes) apply to the stylesheet content after
               preprocessing as described in <specref ref="preprocessing"/>.</p>
            
            <p diff="add" at="2023-04-18"><termdef id="dt-effective-value" term="effective value">The <term>effective value</term>
            of an attribute or text node in the stylesheet is the value after any required expansion or normalization.</termdef></p>
            
            <p diff="add" at="2023-04-18">More specifically, the effective value is the value after:</p>
            <ulist diff="add" at="2023-04-18">
               <item><p>Expanding shadow attributes as described in <specref ref="shadow-attributes"/>;</p></item>
               <item><p>Expanding defaults (for example, if an <elcode>xsl:message</elcode> instruction has
                  no <code>terminate</code> attribute, then the effective value of the <code>terminate</code> attribute
                  is <code>no</code>);</p></item>
               <item><p>Stripping ignored whitespace (for example, the effective value of a boolean attribute written as
                  <code>terminate="  no  "</code> is <code>no</code>);</p></item>
               <item><p>Replacing synonyms (for example in boolean attributes, <code>1</code> and <code>true</code>
                  are synonyms of <code>yes</code>);</p></item>
               <item><p>Expanding <termref def="dt-attribute-value-template">attribute value templates</termref> and 
                  <termref def="dt-text-value-template">text value templates</termref>.</p></item>
               <item><p>Applying rules from the static context: for example, the effective value of a <code>collation</code>
                  attribute is the value after expanding a relative URI against the static base URI.</p></item>
            </ulist>
            <p>Attributes are validated as follows. These rules apply to the value of the attribute
               after removing leading and trailing whitespace.</p>
            <ulist>
               <item>
                  <p>
                     <error spec="XT" type="static" class="SE" code="0020">
                        <p>It is a <termref def="dt-static-error">static error</termref> if an
                           attribute (other than an attribute written using curly brackets in a
                           position where an <termref def="dt-attribute-value-template">attribute
                              value template</termref> is permitted) contains a value that is not
                           one of the permitted values for that attribute.</p>
                     </error>
                  </p>
               </item>
               <item>
                  <p>
                     <error spec="XT" type="dynamic" class="DE" code="0030">
                        <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the <termref def="dt-effective-value">effective value</termref> of an attribute
                           written using curly brackets, in a position where an <termref def="dt-attribute-value-template">attribute value template</termref>
                           is permitted, is a value that is not one of the permitted values for that
                           attribute. If the processor is able to detect the error statically (for
                           example, when any XPath expressions within the curly brackets can be
                           evaluated statically), then the processor may optionally signal this as a
                           static error.</p>
                     </error>
                  </p>
               </item>
            </ulist>
            <p>Special rules apply if the construct appears in part of the <termref def="dt-stylesheet">stylesheet</termref> that is processed with <termref def="dt-forwards-compatible-behavior"/>: see <specref ref="forwards"/>.</p>
            <p>
               <termdef id="dt-deprecated" term="deprecated">Some constructs defined in this
                  specification are described as being <term>deprecated</term>. The use of this term
                  implies that stylesheet authors <rfc2119>should not</rfc2119> use the construct,
                  and that the construct may be removed in a later version of this
                  specification.</termdef></p>
            <note>
               <p>This specification includes a non-normative XML Schema for XSLT <termref def="dt-stylesheet-module">stylesheet modules</termref> (see <specref ref="schema-for-xslt"/>). The syntax summaries described in this section are
                  normative.</p>
            </note>
            <p>XSLT defines a set of standard functions which are additional to those defined in
                  <bibref ref="xpath-functions-40"/>. A list of these
                  functions appears in <specref ref="XSLT-defined-functions"/>. The
               signatures of these functions are described using the same notation as used in
                  <bibref ref="xpath-functions-40"/>. The names of many
                  of these functions are in the <termref def="dt-standard-function-namespace">standard function namespace</termref>.</p>
         </div2>


         <div2 id="initiating">
            <head>Initiating a Transformation</head>
            <p>This document does not specify any application programming interfaces or other
               interfaces for initiating a transformation. This section, however, describes the
               information that is supplied when a transformation is initiated. Except where
               otherwise indicated, the information is <rfc2119>required</rfc2119>.</p>
            <p>The execution of a stylesheet necessarily involves two activities: static analysis
               and dynamic evaluation. Static analysis consists of those tasks that can be performed
               by inspection of the stylesheet alone, including the
                  binding of <termref def="dt-static-variable">static variables</termref>,
               the evaluation of <code>[xsl:]use-when</code> expressions (see <specref ref="conditional-inclusion"/>), and shadow attributes
                  (see <specref ref="shadow-attributes"/>) and detection of <termref def="dt-static-error">static errors</termref>. Dynamic evaluation consists of
               tasks which in general cannot be carried out until a source document is
               available.</p>
            <p>Dynamic evaluation is further divided into two activities:
                  <term>priming</term> the stylesheet, and <term>invoking</term> a selected
               component. </p>
            <ulist>
               <item>
                  <p>Priming the stylesheet provides the dynamic context for evaluation, and
                     supplies all the information needed to establish the values of global
                     variables.</p>
               </item>
               <item>
                  <p>Invoking a component (such as a template or function) causes evaluation of that
                     template or function to produce a result, which is an arbitrary XDM value.</p>
                  <p><termdef id="dt-raw-result" term="raw result">The result of invoking the
                        selected component, after any required conversion to the declared result
                        type of the component, is referred to as the <term>raw
                        result</term>.</termdef></p>
                  <p>The <termref def="dt-raw-result"/> of the invocation
                  is the <termref def="dt-immediate-result"/> of evaluating the <termref def="dt-sequence-constructor"/>
                  contained in the target template or function, modified by applying the <termref def="dt-coercion-rules"/>
                     to convert the <termref def="dt-immediate-result"/> to the type declared in the <code>as</code>
                  attribute of the <elcode>xsl:template</elcode> or <elcode>xsl:function</elcode> declaration, if present.</p>
                  <p>This raw result may optionally be post-processed to construct a result tree, to
                     serialize the result, or both, as described in <specref ref="post-processing"/>.</p>
               </item>
            </ulist>

            <p>Implementations <rfc2119>may</rfc2119> allow static analysis and dynamic evaluation
               to be initiated independently, so that the cost of static analysis can be amortized
               over multiple transformations using the same stylesheet. Implementations <rfc2119>may</rfc2119> also allow priming of a stylesheet and
                  invocation of components to be initiated independently, in which case a single act
                  of priming the stylesheet may be followed by a series of independent component
                  invocations. Although this specification does not require such a separation, this
                  section distinguishes information that is needed before static analysis can
                  proceed, information that is needed to prime the stylesheet, and information that
                  is needed when invoking components.</p>
            <p>The language is designed to allow the static analysis of each
                  <termref def="dt-package"/> to be performed independently of other packages, with
               only basic knowledge of the properties of components made available by used packages.
               Beyond this, the specification leaves it to implementations to decide how to organize
               this process. When packages are not used explicitly, the entire stylesheet is treated
               as a single package.</p>
            <div3 id="info-for-static-analysis">
               <head>Information needed for Static Analysis</head>
               <p>The following information is needed prior to static analysis
                     of a package:</p>
               <ulist>
                  <item>
                     <p>The location of the <termref def="dt-package-manifest"/>,
                        or in the absence of a package manifest, the <termref def="dt-stylesheet-module">stylesheet module</termref> that is to act as
                        the <termref def="dt-principal-stylesheet-module">principal stylesheet
                           module</termref>
                        of the <termref def="dt-package"/>. The complete <termref def="dt-package">package</termref> is
                        assembled by recursively expanding the <elcode>xsl:import</elcode> and
                           <elcode>xsl:include</elcode> declarations in the principal stylesheet
                        module, as described in <specref ref="include"/> and <specref ref="import"/>. </p>
                  </item>
                  <item>
                     <p>Information about the packages referenced from this
                        package using <elcode>xsl:use-package</elcode> declarations. The information
                        needed will include the names and signatures of public components exported
                        by the referenced package.</p>
                  </item>
                  <item>
                     <p>A set (possibly empty) of values for <termref def="dt-static-parameter">static parameters</termref> (see <specref ref="global-variables"/>). These values are available for use within
                           <termref def="dt-static-expression">static expressions</termref> (notably
                        in <code>[xsl:]use-when</code> expressions and shadow attributes) as well as
                        non-static expressions in the <termref def="dt-stylesheet">stylesheet</termref>. As a minimum, values <rfc2119>must</rfc2119> be
                        supplied for any static parameters declared with the attribute
                           <code>required="yes"</code>.</p>
                  </item>
               </ulist>
               <p>Conceptually, the output of the static analysis of a package is
                  an object which might be referred to (without constraining the implementation) as
                  a compiled package. Prior to dynamic evaluation, all the compiled packages needed
                  for execution must be checked for consistency, and component references must be
                  resolved. This process may be referred to, again without constraining the
                  implementation, as linking.</p>

            </div3>
            <div3 id="priming-stylesheet">
               <head>Priming a Stylesheet</head>


               <p>The information needed when priming a stylesheet is as
                  follows:</p>
               <ulist>
                  <item>
                     <p>A set (possibly empty) of values for non-static
                        <termref def="dt-stylesheet-parameter">stylesheet parameters</termref> (see
                           <specref ref="global-variables"/>). These values are available for use
                        within <termref def="dt-expression">expressions</termref> in the <termref def="dt-stylesheet">stylesheet</termref>. As a minimum, values
                           <rfc2119>must</rfc2119> be supplied for any parameters declared with the
                        attribute <code>required="yes"</code>.</p>

                     <p>A supplied value is converted if necessary to the declared
                        type of the stylesheet parameter using the <termref def="dt-coercion-rules"/>.</p>

                     <note>
                        <p>Non-static stylesheet parameters are implicitly
                           <code>public</code>, which ensures that all the parameters in the
                           stylesheet for which values can be supplied externally have distinct
                           names. Static parameters, by contrast,
                              are local to a package.</p>
                     </note>
                  </item>
                  <item>
                     <p>
                        <termdef id="dt-global-context-item" term="global context item">An item that acts as the <term>global
                                 context item</term> for the transformation. This item acts
                           as the <termref def="dt-context-item"/> when evaluating
                            the <code>select</code> expression or <termref def="dt-sequence-constructor"/> of a
                                 <termref def="dt-global-variable"/> <phrase diff="chg" at="2022-01-01">whose declaration is</phrase>
                           within the <termref def="dt-top-level-package"/>, as described in <specref ref="focus"/>. The global context item may also be available in a <termref def="dt-named-template"/>
                        when the stylesheet is invoked as described in <specref ref="invoking-initial-template"/></termdef>.
                        <phrase diff="add" at="2022-01-01">[XSLT 3.0 Erratum E7, bug 30179].</phrase></p>

                     <note>
                        <p>In previous releases of this specification, a single node was typically
                           supplied to represent the source document for the transformation. This
                           node was used as the target node for the implicit call on
                              <elcode>xsl:apply-templates</elcode> used to start the transformation
                           process (now called the <termref def="dt-initial-match-selection"/>), and
                           the root node of the containing tree was used as the context item for
                           evaluation of global variables (now called the <termref def="dt-global-context-item"/>). This relationship between the
                              <termref def="dt-initial-match-selection"/> and the <termref def="dt-global-context-item"/> is likely to be found for compatibility
                           reasons in a transformation API designed to work with earlier versions of
                           this specification, but it is no longer a necessary relationship; the two
                           values can in principle be completely independent of each other.</p>
                        <p>Stylesheet authors wanting to write code that can be invoked using legacy
                           APIs should not rely on the caller being able to supply different values
                           for the <termref def="dt-initial-match-selection"/> and the <termref def="dt-global-context-item"/>.</p>
                     </note>
                     
                     <p>The value given to the <termref def="dt-global-context-item"/>
                        (and the values given to <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>)
                     cannot be nodes in a streamed document. This rule ensures that all global variables can freely
                     navigate within the relevant tree, with no constraints imposed by the streamability rules.</p>

                     

                     <p>The <termref def="dt-global-context-item"/> is potentially
                        used when initializing global variables and parameters. If the
                        initialization of any <termref def="dt-global-variable">global
                           variables</termref> or <termref def="dt-stylesheet-parameter">parameter</termref> depends on the context item, a dynamic error can
                        occur if the context item is absent. It is <termref def="dt-implementation-defined"/> whether this error occurs during
                        priming of the stylesheet or subsequently when the variable is referenced;
                        and it is <termref def="dt-implementation-defined"/> whether the error
                        occurs at all if the variable or parameter is never referenced. The error
                        can be suppressed by use of <elcode>xsl:try</elcode> and
                           <elcode>xsl:catch</elcode> within the sequence constructor used to initialize the variable or parameter. It
                           cannot be suppressed by use of <elcode>xsl:try</elcode> around a
                           reference to the global variable.
                     </p>

                     <imp-def-feature id="idf-api-globalcontext">If the initialization of any
                           <termref def="dt-global-variable">global variables</termref> or <termref def="dt-stylesheet-parameter">parameter</termref> depends on the context
                        item, a dynamic error can occur if the context item is absent. It is
                           <termref def="dt-implementation-defined"/> whether this error occurs
                        during priming of the stylesheet or subsequently when the variable is
                        referenced; and it is <termref def="dt-implementation-defined"/> whether the
                        error occurs at all if the variable or parameter is never referenced. </imp-def-feature>


                     
                     <p>In a <termref def="dt-library-package"/>,
                           the <termref def="dt-context-item">context item</termref>, <termref def="dt-context-position">context position</termref>, and <termref def="dt-context-size">context size</termref> used for evaluation of
                           global variables will be <termref def="dt-absent">absent</termref>, and
                           the evaluation of any expression that references these values will result
                           in a dynamic error. 
                        This will also be the case in the
                              <termref def="dt-top-level-package"/> if no <termref def="dt-global-context-item"/> is supplied.</p>
                     <note>
                        <p>If a context item is available within a global variable declaration, then
                           the <termref def="dt-context-position">context position</termref> and
                              <termref def="dt-context-size">context size</termref> will always be 1
                           (one).</p>
                     </note>
                     <note>
                        <p>For maximum reusability of code, it is best to avoid use of the context
                           item when initializing global variables and parameters. Instead, all
                           external information should be supplied using named <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>.
                           Especially when these use namespaces to avoid conflicts, there is then no
                           risk of confusion between the information supplied externally to
                           different packages.</p>
                        <p>When a stylesheet parameter is defined in a library package, it is
                           possible for a using package to supply a value for the parameter by
                           overriding the parameter declaration within an
                              <elcode>xsl:override</elcode> element. If the using package is the
                              <termref def="dt-top-level-package"/> then the overriding declaration
                           can refer to the <termref def="dt-global-context-item"/>.</p>
                     </note>

                  </item>
                  <item>
                     <p>A mechanism for obtaining a document node and a media type, given an
                        absolute URI. The total set of available documents (modeled as a mapping
                        from URIs to document nodes) forms part of the context for evaluating XPath
                        expressions, specifically the <xfunction>doc</xfunction> function. The XSLT
                           <function>document</function> function additionally requires the media
                        type of the resource representation, for use in interpreting any fragment
                        identifier present within a URI Reference.</p>
                     <note>
                        <p>The set of documents that are available to the stylesheet is <termref def="dt-implementation-dependent">implementation-dependent</termref>,
                           as is the processing that is carried out to construct a tree representing
                           the resource retrieved using a given URI. Some possible ways of
                           constructing a document (specifically, rules for constructing a document
                           from an Infoset or from a PSVI) are described in <bibref ref="xpath-datamodel-30"/>.</p>
                     </note>
                  </item>
               </ulist>
               <p>Once a stylesheet is primed, the values of global variables
                  remain stable through all component invocations. In addition, priming a stylesheet
                  creates an <xtermref spec="FO40" ref="execution-scope">execution scope</xtermref>
                  during which the dynamic context and all calls
                     on <xtermref spec="FO40" ref="dt-deterministic">deterministic</xtermref>
                     functions remain stable; for example two calls on the
                     <xfunction>current-dateTime</xfunction> function within an execution scope are
                  defined to return the same result.</p>

               <p>Parameters passed to the transformation by the client application when a stylesheet is primed are matched against
                     <termref def="dt-stylesheet-parameter">stylesheet parameters</termref> (see
                     <specref ref="global-variables"/>), not against the <termref def="dt-template-parameter">template parameters</termref> of any template
                  executed during the course of the transformation. </p>

               <p>
                  <error spec="XT" type="dynamic" class="DE" code="0050">
                     <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if a
                        stylesheet declares a visible <termref def="dt-stylesheet-parameter">stylesheet parameter</termref>
                        that is <termref def="dt-explicitly-mandatory">explicitly</termref> or <termref def="dt-implicitly-mandatory">implicitly</termref> mandatory,
                        and no value for this parameter is supplied when the stylesheet is primed. A
                        stylesheet parameter is visible if it is not masked by another global
                        variable or parameter with the same name and higher <termref def="dt-import-precedence">import precedence</termref>. If the parameter is a <termref def="dt-static-parameter"/> then the value <rfc2119>must</rfc2119> be
                           supplied prior to the static analysis phase.</p>
                  </error>
               </p>

               <imp-def-feature id="idf-api-input">The way in which an XSLT processor is invoked,
                  and the way in which values are supplied for the source document, starting node,
                     <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>, and
                     <termref def="dt-base-output-uri">base output URI</termref>, are
                  implementation-defined.</imp-def-feature>


            </div3>
            <div3 id="invoking-initial-mode">
               <head>Apply-Templates Invocation</head>

               <p><termdef id="dt-initial-match-selection" term="initial match selection">A stylesheet may be evaluated by supplying a
                     value to be processed, together with an <termref def="dt-initial-mode"/>. The
                     value (which can be any sequence of items) is referred to as the <term>initial
                        match selection</term>. The processing then corresponds to the effect of the
                        <elcode>xsl:apply-templates</elcode> instruction.</termdef></p>

               <p>The <termref def="dt-initial-match-selection"/> will
                  often be a single document node, traditionally called the source document of the
                  transformation; but in general, it can be any sequence. If the initial match selection is an empty sequence, the result of the
                     transformation will be empty, since no template rules are
                  evaluated.</p>

               <p>Processing proceeds by finding the <termref def="dt-template-rule">template rules</termref> that match the items in the
                     <termref def="dt-initial-match-selection"/>, and evaluating these template
                  rules with a <termref def="dt-focus"/> based on the <termref def="dt-initial-match-selection"/>. The template rules are evaluated in
                     <termref def="dt-final-output-state"/>.</p>
               <p>The following information is needed when dynamic evaluation is
                  to start with a <termref def="dt-template-rule"/>:</p>

               <ulist>
                  <item>
                     <p>The <termref def="dt-initial-match-selection"/>.
                        An API that chooses to maintain compatibility with previous versions of this
                        specification <rfc2119>should</rfc2119> allow a method of invocation in which a singleton node is
                        provided, which is then used in two ways: the node itself acts as the
                           <termref def="dt-initial-match-selection"/>, and the root node of the
                        containing tree acts as the <termref def="dt-global-context-item"/>. </p>
                     
                  </item>
                  <item>
                     <p>Optionally, an initial <termref def="dt-mode">mode</termref>.</p>
                     
                     <p><termdef id="dt-initial-mode" term="initial mode">The <term>initial mode</term>
                        is the <termref def="dt-mode">mode</termref> used to select <termref def="dt-template-rule">template rules</termref>
                     for processing items in the <termref def="dt-initial-match-selection"/> when
                     apply-templates invocation is used to initiate a transformation.</termdef></p>
                     
                     
                     <p><!--<termdef id="dt-initial-mode" term="initial mode">The initial mode, if
                           specified, <rfc2119>must</rfc2119> either be the <phrase diff="chg"
                              at="R">unnamed</phrase> mode, or a mode that is explicitly named
                              <phrase diff="add" at="P-bug23343">either in an
                                 <elcode>xsl:mode</elcode> declaration, or</phrase> in the
                              <code>mode</code> attribute of an <elcode>xsl:template</elcode>
                           declaration within the stylesheet<phrase diff="add" at="S-bug28453">, or
                              in the <code>default-mode</code> attribute of an
                                 <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode>
                              element</phrase>. -->In searching
                           for the <termref def="dt-template-rule">template rule</termref> that best
                           matches the items in the <termref def="dt-initial-match-selection"/>, the processor
                           considers only those rules that apply to the <termref def="dt-initial-mode"/>.</p>
                     <p>If no <termref def="dt-initial-mode"/> is supplied explicitly, then the initial mode is that named in the
                              <code>default-mode</code> attribute of the (explicit or implicit) <elcode>xsl:package</elcode>
                              element of the <termref def="dt-top-level-package"/> or in
                           the absence of such an attribute, the <termref def="dt-unnamed-mode"/>.</p>
                     
                     <p>
                        <error spec="XT" type="dynamic" class="DE" code="0044">
                           <p>It is a <termref def="dt-dynamic-error">dynamic error</termref> if the
                              invocation of the <termref def="dt-stylesheet">stylesheet</termref>
                              specifies an <termref def="dt-initial-mode"/> when no <termref def="dt-initial-match-selection"/> is
                                 supplied (either explicitly, or defaulted to the <termref def="dt-global-context-item"/>).</p>
                        </error>
                     </p>
                     
                     <p>A (named or unnamed) <termref def="dt-mode"/> <var>M</var> is <term>eligible as an initial mode</term> if one of the
                        following conditions applies, where <var>P</var> is the <termref def="dt-top-level-package"/> of the stylesheet:</p>
                     <olist>

                        <item><p><var>M</var> is explicitly declared in an <elcode>xsl:mode</elcode> declaration
                           within <var>P</var>, and has <code>public</code> or <code>final</code> <termref def="dt-visibility"/> (either by virtue
                           of its <code>visibility</code> attribute, or by virtue of an <elcode>xsl:expose</elcode> declaration).</p></item>
                        <item><p><var>M</var> is the unnamed mode.</p></item>
                        <item><p><var>M</var> is named in the <code>default-mode</code> attribute of the (explicit or implicit) 
                           <elcode>xsl:package</elcode> element of <var>P</var>.</p></item>
                        <item><p><var>M</var> is declared in a package used by <var>P</var>, and is given <code>public</code> or <code>final</code>
                           <termref def="dt-visibility"/> in <var>P</var> by means of an <elcode>xsl:accept</elcode> declaration.</p></item>
                        <item><p>The <termref def="dt-effective-value"/> of the <code>declared-modes</code> attribute of the explicit or implicit
                        <elcode>xsl:package</elcode> element of <var>P</var> is <code>no</code>, and <var>M</var> appears as 
                        a mode-name in the <code>mode</code> attribute of a <termref def="dt-template-rule"/> declared within <var>P</var>.</p></item>
                     </olist>
                                                           
                     <p>
                        <error spec="XT" type="dynamic" class="DE" code="0045">
                           <p>It is a <termref def="dt-dynamic-error">dynamic error</termref> if the
                              invocation of the <termref def="dt-stylesheet">stylesheet</termref>
                              specifies an <termref def="dt-initial-mode"/> and the
                              specified mode is not eligible as an initial mode (as defined above).</p>
                        </error>
                     </p>
                     
                  </item>
                  
                  <item>
                     <p>Parameters, which will be passed to the template rules
                        used to process items in the input sequence. The parameters consist of two
                        sets of (QName, value) pairs, one set for <termref def="dt-tunnel-parameter">tunnel parameters</termref> and one for non-tunnel parameters, in which
                        the QName identifies the name of a parameter and the value provides the
                        value of the parameter. Either or both sets of parameters may be empty. The
                        effect is the same as when a template is invoked using
                           <elcode>xsl:apply-templates</elcode> with an
                           <elcode>xsl:with-param</elcode> child specifying
                           <code>tunnel="yes"</code> or <code>tunnel="no"</code> as appropriate. If
                        a parameter is supplied that is not declared or used, the value is simply
                        ignored. These parameters are <emph>not</emph> used to set <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>.</p>

                     <p>A supplied value is converted if necessary to the declared
                        type of the template parameter using the <termref def="dt-coercion-rules"/>.</p>
                  </item>
                  <item>
                     <p>Details of how the result of the initial template is to be returned.
                     For details, see <specref ref="post-processing"/></p>
                  </item>
               </ulist>

               <p>The <termref def="dt-raw-result"/> of the invocation is the
                  result of processing the supplied input sequence as if by a call on
                     <elcode>xsl:apply-templates</elcode> in the specified mode: specifically, each
                  item in the input sequence is processed by selecting and evaluating the best
                  matching template rule, and converting the result (if necessary) to the type
                  declared in the <code>as</code> attribute of that template using the <termref def="dt-coercion-rules"/>; and the results of processing each item
                  are then concatenated into a single sequence, respecting the order of items in the
                  input sequence.</p>

               <note>
                  
                  <p>If the initial mode is <termref def="dt-declared-streamable"/>,
                     then a streaming processor <rfc2119>should</rfc2119> allow some or all of the items
                     in the <termref def="dt-initial-match-selection"/> to be nodes supplied in streamable form,
                     and any nodes that are supplied in this form <rfc2119>must</rfc2119> then be processed using streaming.</p>
                  
                  <p>Since the <termref def="dt-global-context-item"/> cannot be a streamed node,
                  in cases where the transformation is to proceed by applying streamable templates
                  to a streamed input document, the <termref def="dt-global-context-item"/> must
                  either be absent, or must be something that differs from the <termref def="dt-initial-match-selection"/>.</p>
               </note>
               <note>
                  <p>The design of the API for invoking a transformation should provide some means
                     for users to designate the <termref def="dt-unnamed-mode"/> as the <termref def="dt-initial-mode"/> in cases where it is not the default mode.</p>
               </note>

               
              <!-- 
               <note diff="add" at="T-bug29234">
                  <p>Or to put it another way: (a) if a named initial mode is specified, then
                  it must exist as a public mode in the top-level package, declared implicitly or explicitly; 
                  (b) if the unnamed initial mode is specified and <code>declared-modes="yes"</code>, then there
                  must be an <elcode>xsl:mode</elcode> declaration for the unnamed mode.</p>
               </note>-->

               <p>It is a <termref def="dt-dynamic-error"/>
                  <errorref spec="XT" type="dynamic" class="DE" code="0700"/> if the <termref def="dt-template-rule"/> selected for processing any item in the <termref def="dt-initial-match-selection"/> defines a <termref def="dt-template-parameter"/> that specifies <code>required="yes"</code>
                  and no value is supplied for that
                  parameter.</p>

               <note>
                  <p>A <termref def="dt-stylesheet">stylesheet</termref> can process further source
                     documents in addition to those supplied when the transformation is invoked.
                     These additional documents can be loaded using the functions
                        <function>document</function> (see <specref ref="func-document"/>) or
                        <xfunction>doc</xfunction> or <xfunction>collection</xfunction> (see <bibref ref="xpath-functions-40"/>), or using the
                           <elcode>xsl:source-document</elcode> instruction; alternatively, they can
                     be supplied as <termref def="dt-stylesheet-parameter">stylesheet
                        parameters</termref> (see <specref ref="global-variables"/>), or returned as
                     the result of an <termref def="dt-extension-function">extension
                        function</termref> (see <specref ref="extension-functions"/>).</p>
               </note>




            </div3>
            <div3 id="invoking-initial-template">
               <head>Call-Template Invocation</head>


               <p><termdef id="dt-initial-named-template" term="initial named template">A stylesheet may be evaluated by selecting a
                     named template to be evaluated; this is referred to as the <term>initial named
                        template</term>.</termdef> The effect is analogous to the effect of
                  executing an <elcode>xsl:call-template</elcode> instruction. The following
                  information is needed in this case:</p>

               <ulist>
                  <item>
                     <p>Optionally, the name of the <termref def="dt-initial-named-template">initial
                           named template</termref> which is to be executed as the entry point to
                        the transformation. If no template name is
                           supplied, the default template name is
                           <code>xsl:initial-template</code>. The selected template
                           <rfc2119>must</rfc2119> exist within the <termref def="dt-stylesheet">stylesheet</termref>. </p>
                  </item>

                  <item>
                     <p>Optionally, a context item for evaluation of this named
                        template, defaulting to the <termref def="dt-global-context-item"/> if it
                        exists. This is constrained by any
                              <elcode>xsl:context-item</elcode> element appearing within the
                           selected <elcode>xsl:template</elcode> element. The initial named
                           template is evaluated with a <termref def="dt-singleton-focus"/> based on
                           this context item if it exists, or with an <termref def="dt-absent"/>
                           focus otherwise.</p>
                  </item>

                  <item>
                     <p>Parameters, which will be passed to the selected template
                        rule. The parameters consist of two sets of (QName, value) pairs, one set
                        for <termref def="dt-tunnel-parameter">tunnel parameters</termref> and one
                        for non-tunnel parameters, in which the QName identifies the name of a
                        parameter and the value provides the value of the parameter. Either or both
                        sets of parameters may be empty. The effect is the same as when a template
                        is invoked using <elcode>xsl:call-template</elcode> with an
                           <elcode>xsl:with-param</elcode> child specifying
                           <code>tunnel="yes"</code> or <code>tunnel="no"</code> as appropriate. If
                        a parameter is supplied that is not declared or used, the value is simply
                        ignored. These parameters are <emph>not</emph> used to set <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>.</p>

                     <p>A supplied value is converted if necessary to the declared
                        type of the template parameter using the <termref def="dt-coercion-rules"/>.</p>
                  </item>

                  <item>
                     <p>Details of how the result of the initial named template is to be returned.
                        For details, see <specref ref="post-processing"/></p>
                  </item>

               </ulist>

               <p>The <termref def="dt-raw-result"/> of the invocation is the
                  result of evaluating the <termref def="dt-initial-named-template"/>, after
                  conversion of the result to the type declared in the <code>as</code> attribute of
                  that template using the <termref def="dt-coercion-rules"/>, if such
                  conversion is necessary.</p>

               <p>The <termref def="dt-initial-named-template"/> is
                  evaluated in <termref def="dt-final-output-state"/>.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="0040">
                     <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the invocation of
                        the <termref def="dt-stylesheet">stylesheet</termref> specifies a template
                        name that does not match the <termref def="dt-expanded-qname">expanded
                           QName</termref> of a named template defined in the <termref def="dt-stylesheet">stylesheet</termref>, whose
                           visibility is <code>public</code> or <code>final</code>.</p>
                  </error>
               </p>
               
               <note diff="add" at="2022-01-01">
                  <p>When the top-level package is rooted at an <elcode>xsl:stylesheet</elcode> or 
                     <elcode>xsl:transform</elcode> element, named templates having no explicit 
                     <code>visibility</code> attribute are automatically exposed as public components. 
                     (This is a consequence of the transformation applied to a package written using 
                     “simplified syntax”, described in <specref ref="packages"/>.) [XSLT 3.0 Erratum E8, bug 30181].</p>
               </note>

               

               


               <p> It is a <termref def="dt-dynamic-error"> dynamic error</termref>
                  <errorref spec="XT" type="dynamic" class="DE" code="0700"/> if the <termref def="dt-initial-named-template">initial named template</termref>, or any of the template rules invoked to
                  process items in the <termref def="dt-initial-match-selection"/>, defines a
                     <termref def="dt-template-parameter">template parameter</termref> that
                  specifies <code>required="yes"</code>
                  and no value is supplied for that parameter.
               </p>




            </div3>
            <div3 id="invoking-initial-function">
               <head>Function Call Invocation</head>

               <p><termdef id="dt-initial-function" term="initial function">A stylesheet may be evaluated by calling a named
                        <termref def="dt-stylesheet-function"/>, referred to as the <term>initial
                        function</term>.</termdef> The following additional information is needed in
                  this case:</p>

               <ulist>
                  <item>
                     <p>The name and arity of a <termref def="dt-stylesheet-function"/> which is to
                        be executed as the entry point to the transformation.</p>
                     <note>
                        <p>In the design of a concrete API, the arity may be inferred from the
                           length of the parameter list.</p>
                     </note>
                  </item>

                  <item>
                     <p>A list of values to act as parameters to the <termref def="dt-initial-function"/>. The number of values in the list must be the
                        same as the arity of the function.</p>

                     <p>A supplied value is converted if necessary to the declared
                        type of the function parameter using the <termref def="dt-coercion-rules"/>.</p>
                  </item>

                  <item>
                     <p>Details of how the result of the initial function is to be returned.
                        For details, see <specref ref="post-processing"/></p>
                  </item>

               </ulist>

               <p>The <termref def="dt-raw-result"/> of the invocation is the
                  result of evaluating the <termref def="dt-initial-function"/>, after conversion of
                  the result to the type declared in the <code>as</code> attribute of that function
                  using the <termref def="dt-coercion-rules"/>, if such conversion is
                  necessary.</p>

               <note>
                  <p> The <termref def="dt-initial-function"/> (like all stylesheet functions) is
                     evaluated with an <termref def="dt-absent"/>
                     <termref def="dt-focus"/>.</p>
               </note>
               
               <p>If the <termref def="dt-initial-function"/> is 
                  <termref def="dt-declared-streamable"/>, a streaming processor <rfc2119>should</rfc2119> 
                  allow the value of the first argument to be supplied in streamable form, and if it is 
                  supplied in this form, then it <rfc2119>must</rfc2119> be processed using streaming.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="0041">
                     <p>It is a <termref def="dt-dynamic-error"/> if the invocation of the <termref def="dt-stylesheet">stylesheet</termref> specifies a function name and
                        arity that does not match the <termref def="dt-expanded-qname">expanded
                           QName</termref> and arity of a named <termref def="dt-stylesheet-function"/> defined in the <termref def="dt-stylesheet">stylesheet</termref>, whose visibility is
                           <code>public</code> or <code>final</code>.</p>
                  </error>
               </p>

               


               <p>When a transformation is invoked by calling an <termref def="dt-initial-function"/>, the entire transformation executes in <termref def="dt-temporary-output-state"/>, which means that calls on
                     <elcode>xsl:result-document</elcode> are not permitted.</p>
               
               <p>[TODO: Generalize the above description to allow for the possibility of keyword-based and optional arguments.]</p>

            </div3>
            <div3 id="post-processing">
               <head>Post-processing the Raw Result</head>
               
               <p>There are three ways the result of a transformation
               may be delivered. (This applies both to the principal result, described here, and
               also to secondary results, generated using <elcode>xsl:result-document</elcode>.)</p>
               
               <olist>
                  <item><p>The <termref def="dt-raw-result"/> (a sequence of values) may be returned
                  directly to the calling application.</p></item>
                  <item><p>A result tree may be constructed from the <termref def="dt-raw-result"/>.
                     By default, a result tree is constructed if the <code>build-tree</code>
                     attribute of the unnamed <termref def="dt-output-definition"/>
                     has the <termref def="dt-effective-value"/> <code>yes</code>. An API for invoking transformations <rfc2119>may</rfc2119>
                     allow this setting to be overridden by the calling application. If result tree construction
                     is requested, it is performed as described in <specref ref="result-tree-construction"/>.
                   </p></item>
                  <item><p>Alternatively, the <termref def="dt-raw-result"/> may be serialized
                  as described in <specref ref="result-serialization"/>. The decision whether or not to
                  serialize the result is determined by the rules of transformation API provided by the
                  <termref def="dt-processor"/>, and is not influenced by anything in the stylesheet.</p></item>
               </olist>
               
               <note>
                  <p>This specification does not constrain the design of application programming
                     interfaces or the choice of defaults. In previous versions of this
                     specification, result tree construction was a mandatory process, while
                     serialization was optional. When invoking stylesheet functions directly,
                     however, result tree construction and serialization may be inappropriate as
                     defaults. These considerations may affect the design of APIs.</p>
                  <p>In previous versions of XSLT, results were delivered either
                  in serialized form (as a character or byte stream), or as a tree. In the latter case processors
                  typically would use either their own tree representation, or a standardized tree
                  representation such as the W3C Document Object Model (DOM) (see <bibref ref="DOM-Level-2-Core"/>),
                     adapted to the data structures offered by the programming language in which the API is defined.
                  To deliver a raw result, processors need to define a representation not only of XDM nodes but
                  also of sequences, atomic values, maps and even functions. As with the return of a simple tree, 
                  this may involve a trade-off between strict fidelity to the XDM data model and usability in the particular 
                  programming language environment. It is <emph>not</emph> a requirement that an API should return results 
                     in a way that exposes every property of the XDM data model; for example there may be APIs that do not expose
                  the precise type annotation of a returned node or atomic value, or that fail to expose the base URI
                  or document URI of a node, or that provide no way of determining whether two nodes in the result
                  sequence are the same node in the sense of the XPath <code>is</code> operator.
                     The way in which maps, arrays, and functions 
                  are returned requires careful design choices. It is <rfc2119>recommended</rfc2119> that an API should be capable
                  of returning any XDM value without error, and that there should be minimal loss of information if
                  the raw results output by one transformation are subsequently used as input to another transformation.</p>
               </note>
 
 <div4 id="result-tree-construction">
    <head>Result Tree Construction</head>
    
    <p>If a result tree is to be constructed from the <termref def="dt-raw-result"/>, then this is done
    by applying the rules for the process of <xtermref spec="SER30" ref="sequence-normalization"/> as defined in 
       <bibref ref="xslt-xquery-serialization-30"/>. This process takes as input the serialization parameters defined in the
    unnamed <termref def="dt-output-definition"/> of the <termref def="dt-top-level-package"/>; though the only parameter
    that is actually used by this process is <code>item-separator</code>. <phrase diff="del" at="2022-01-01">In particular, sequence normalization is carried
       out regardless of any <code>method</code> attribute in the unnamed <termref def="dt-output-definition"/>.</phrase>
    <phrase diff="add" at="2022-01-01">[XSLT 3.0 Erratum E14, bug 30208].</phrase></p>
    
    <p>The sequence normalization process either returns a document node, or raises
    a serialization error. The content of the document node is not necessarily well-formed (the document node may have any number
    of element or text nodes among its children).</p>
    
    <note><p>More specifically, the process raises a serialization error if any item in the <termref def="dt-raw-result"/> is
    an attribute node, a namespace node, or a function (including a map, but not an array: arrays are flattened).</p></note>
    
    <p>The tree that is constructed is referred to as a <termref def="dt-final-result-tree">final result tree</termref>.</p>
    
    <p>If the <termref def="dt-raw-result"/> is an empty sequence, the <termref def="dt-final-result-tree"/> will consist
    of a document node with no children.</p>
    
    <p>The base URI of the document node is set to the <termref def="dt-base-output-uri"/>.</p>
    
    <note>
       <p>The <code>item-separator</code> property has no effect if the raw result of the transformation is a sequence
       of length zero or one, which in practice will often be the case, especially in a traditional scenario such as
       transformation of an XML document to HTML.</p>
       <p>If there is no <code>item-separator</code>, then a single space is inserted between adjacent atomic values;
       for example if the raw result is the sequence <code>1 to 5</code>, then sequence normalization produces a tree
       comprising a document node with a single child, the child being a text node with the string value 
       <code>1 2 3 4 5</code>.</p>
       <p>If there is an <code>item-separator</code>, then it is used not only between adjacent atomic values,
       but between any pair of items in the raw result. For example if the raw result is a sequence of two
       element nodes <code>A</code> and <code>B</code>, and the <code>item-separator</code> is a comma,
       then the result of sequence normalization will be a document node with three children: a copy of <code>A</code>,
       a text node whose string value is a single comma, and a copy of <code>B</code>.</p>
    </note>
 
              <!--       <p>If the raw result is non-empty, then it is used to construct an implicit
                           <termref def="dt-final-result-tree">final result tree</termref>,
                        following the rules described in <specref ref="constructing-complex-content"
                        />: the effect is as if the raw result <var>R</var> were processed by the
                        following function:</p>
                     <eg xml:space="preserve" role="xslt-declaration xmlns:f='f'"><![CDATA[
<xsl:function name="f:construct-result-tree" as="document-node()">
  <xsl:param name="R" as="item()*"/>
  <xsl:document validation="preserve">
    <xsl:sequence select="$R"/>
  </xsl:document>  
</xsl:function>]]></eg>
                     <p>An implicit result tree is also created when the raw result is empty,
                        provided that no <elcode>xsl:result-document</elcode> instruction has been
                        evaluated during the course of the transformation <phrase diff="add"
                           at="R-bug24690">(which will always be the case if the stylesheet is
                           invoked by calling an initial function)</phrase>. In this situation the
                        implicit result tree will consist of a document node with no children.</p>
                     <note>
                        <p diff="chg" at="Q">This means that there is always at least one result
                           tree. It also means that <phrase diff="add" at="R-bug24690">when
                              stylesheet invocation is by supplying an <termref
                                 def="dt-initial-mode"/> (see <specref ref="invoking-initial-mode"
                              />) or a named template (see <specref ref="invoking-initial-template"
                              />), and</phrase> the content of the <termref
                              def="dt-initial-named-template"/> is a single
                              <elcode>xsl:result-document</elcode> instruction, as in the example
                              <phrase diff="chg" at="R-bug24690">template with
                                 <code>name="IMPLICIT"</code> shown in <specref
                                 ref="executing-a-transformation"/></phrase>, then only one result
                           tree is produced, not two. It is useful to make the result document
                           explicit as this is a convenient way of invoking document-level
                           validation. (Validation of the implicit result document can also be
                           achieved by adding an <elcode>xsl:document</elcode> instruction to the
                           initial template.) </p>
                        <p>If the result of the <termref def="dt-initial-named-template"/> is
                           non-empty, and an explicit <elcode>xsl:result-document</elcode>
                           instruction has been evaluated with the empty attribute
                              <code>href=""</code>, then an error will occur <errorref spec="XT"
                              class="DE" code="1490"/>, since it is not possible to create two final
                           result trees with the same URI.</p>
                     </note>
                     -->
 </div4>
               <div4 id="result-serialization">
                     <head>Serializing the Result</head>
                     <p>See <specref ref="parsing-and-serialization"/>.</p>
                     <p>The <termref def="dt-raw-result"/>
                        may optionally be serialized as described in <specref ref="serialization"/>. The serialization is controlled by the serialization
                     parameters defined in the unnamed <termref def="dt-output-definition"/> of the
                     <termref def="dt-top-level-package"/>.</p>
                  
                  <note>
                     <p>The first phase of serialization, called <xtermref spec="SER30" ref="sequence-normalization"/>,
                     takes place for some output methods but not others. For example, if the <code>json</code> output method
                        (defined in <bibref ref="xslt-xquery-serialization-31"/>) is selected, then the process of constructing
                     a tree is bypassed.</p>
                  </note>
                  
                  <p>The effect of serialization is to generate a sequence of octets, representing the serialized result
                     in some character encoding. The processor’s API may define mechanisms enabling this sequence of octets
                  to be written to persistent storage at some location. The default location is the location identified
                  by the <termref def="dt-base-output-uri"/>.</p>
                  
                     

                  <p>In previous versions of this specification it was stated that
                  when the <termref def="dt-raw-result"/> of the initial template or function is an empty sequence,
                  a result tree should be produced if and only if the transformation generates no secondary results
                  (that is, if it does not invoke <elcode>xsl:result-document</elcode>). This provision is most likely
                  to have a noticeable effect if the transformation produces serialized results, and these results
                  are written to persistent storage: the effect is then that a transformation producing an empty
                  principal result will overwrite any existing content at the base output URI location if and only
                  if the transformation produces no other output. Processor APIs offering backwards compatibility
                  with earlier versions of XSLT must respect this behavior, but there is no requirement for new
                  processor APIs to do so.</p>

               <p><termdef id="dt-base-output-uri" term="base output URI"> The <term>base output URI</term> is a URI to be used as the base URI when
                     resolving a relative URI reference allocated
                     to a <termref def="dt-final-result-tree">final result tree</termref>. If the
                     transformation generates more than one final result tree, then typically each
                     one will be allocated a URI relative to this base URI.</termdef> The way in
                  which a base output URI is established is <termref def="dt-implementation-defined">implementation-defined</termref>. Each invocation of the stylesheet may supply
                  a different base output URI. It is acceptable for the base output URI to be
                     <termref def="dt-absent"/>, provided no constructs (such as
                     <elcode>xsl:result-document</elcode>) are evaluated that depend on the value of
                  the base output URI.</p>
               <note>
                  <p>It will often be convenient for the base output URI to be the same as the
                     location to which the principal result document is serialized, but this
                     relationship is not a necessary one.</p>
               </note>

               <imp-def-feature id="idf-api-baseoutputuri">The way in which a <termref def="dt-base-output-uri"/> is established is <termref def="dt-implementation-defined">implementation-defined</termref></imp-def-feature>

 
               </div4>
            </div3>

         </div2>
         
         <div2 id="executing-a-transformation">
            <head>Instructions</head>
            
            <p>The main executable components of a stylesheet are templates and functions. The body of
            a template or function is a <termref def="dt-sequence-constructor"/>, which is a sequence of elements
            and text nodes that can be evaluated to produce a result.</p>
            
            
            <p>A <termref def="dt-sequence-constructor"/> is a sequence of sibling nodes in the
               stylesheet, each of which is either an <termref def="dt-xslt-instruction">XSLT
                  instruction</termref>, a <termref def="dt-literal-result-element">literal result
                     element</termref>, a text node, or an <termref def="dt-extension-instruction">extension instruction</termref>.</p>
            <p>
               <termdef id="dt-instruction" term="instruction">An <term>instruction</term> is either
                  an <termref def="dt-xslt-instruction">XSLT instruction</termref> or an <termref def="dt-extension-instruction">extension instruction</termref>.</termdef>
            </p>
            <p>
               <termdef id="dt-xslt-instruction" term="XSLT instruction">An <term>XSLT
                  instruction</term> is an <termref def="dt-xslt-element">XSLT element</termref>
                  whose syntax summary in this specification contains the annotation <code>&lt;!--
                     category: instruction --&gt;</code>.</termdef>
            </p>
            <p>
               <termref def="dt-extension-instruction">Extension instructions</termref> are
               described in <specref ref="extension-instruction"/>.</p>
            <p>The main categories of <termref def="dt-xslt-instruction">XSLT instruction</termref>
               are as follows:</p>
            <ulist>
               <item>
                  <p>instructions that create new nodes: <elcode>xsl:document</elcode>,
                     <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                     <elcode>xsl:processing-instruction</elcode>, <elcode>xsl:comment</elcode>,
                     <elcode>xsl:value-of</elcode>, <elcode>xsl:text</elcode>,
                     <elcode>xsl:namespace</elcode>;</p>
               </item>
               <item>
                  <p>instructions that copy nodes: <elcode>xsl:copy</elcode>,
                     <elcode>xsl:copy-of</elcode>;</p>
               </item>
               <item>
                  <p>an instruction that returns an arbitrary sequence by evaluating an XPath
                     expression: <elcode>xsl:sequence</elcode>;</p>
               </item>
               <item>
                  <p>instructions that cause conditional or repeated evaluation of nested
                     instructions: <elcode>xsl:if</elcode>, <elcode>xsl:choose</elcode>, <elcode>xsl:try</elcode>,
                     <elcode>xsl:for-each</elcode>, <elcode>xsl:for-each-group</elcode>, <elcode>xsl:fork</elcode>, <elcode>xsl:iterate</elcode>
                        and its subordinate instructions <elcode>xsl:next-iteration</elcode> and
                        <elcode>xsl:break</elcode>;</p>
               </item>
               <item>
                  <p>instructions that generate output conditionally if elements are or are not
                     empty: <elcode>xsl:on-empty</elcode>, <elcode>xsl:on-non-empty</elcode>,
                     <elcode>xsl:where-populated</elcode>;</p>
               </item>
               <item>
                  <p>instructions that invoke templates: <elcode>xsl:apply-templates</elcode>,
                     <elcode>xsl:apply-imports</elcode>, <elcode>xsl:call-template</elcode>,
                     <elcode>xsl:next-match</elcode>;</p>
               </item>
               <item>
                  <p>Instructions that declare variables: <elcode>xsl:variable</elcode>;</p>
               </item>
               <item>
                  <p>Instructions to assist debugging: <elcode>xsl:message</elcode>,
                     <elcode>xsl:assert</elcode>;</p>
               </item>
               <item>
                  <p>other specialized instructions: <elcode>xsl:number</elcode>,
                     <elcode>xsl:analyze-string</elcode>, <elcode>xsl:fork</elcode>, 
                     <elcode>xsl:result-document</elcode>, <elcode>xsl:source-document</elcode>, <elcode>xsl:perform-sort</elcode>,
                        <elcode>xsl:merge</elcode>.</p>
               </item>
            </ulist>
         </div2>
         <div2 id="rule-based-processing">
            <head>Rule-Based Processing</head>
            
            
            <p>The classic method of executing an XSLT transformation is to apply
               template rules to the root node of an input document (see <specref ref="invoking-initial-mode"/>).
               The operation of applying templates to a node searches the stylesheet for the best matching template
               rule for that node. This template rule is then evaluated. A common coding pattern, especially when XSLT
               is used to convert XML documents into display formats such as HTML, is to have one template rule 
               for each kind of element in the source document, and for that template rule to generate some 
               appropriate markup elements, and to apply templates recursively to its own children. The effect is to 
               perform a recursive traversal of the source tree, in which each node is processed using the best-fit 
               template rule for that node. The final result of the transformation is then the tree produced by this 
               recursive process. This result can then be optionally serialized (see <specref ref="post-processing"/>). 
            </p>
            <example id="rule-based-processing-example">
               <head>Example of Rule-Based Processing</head>
               <p>This example uses rule-based processing to convert a simple XML input document into an HTML
               output document.</p>
               <p>The input document takes the form:</p>
               <eg role="xml" xml:space="preserve">

  &lt;PERSONAE PLAY="OTHELLO"&gt;
    &lt;TITLE&gt;Dramatis Personae&lt;/TITLE&gt;
    &lt;PERSONA&gt;DUKE OF VENICE&lt;/PERSONA&gt;
    &lt;PERSONA&gt;BRABANTIO, a senator.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;Other Senators.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;GRATIANO, brother to Brabantio.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;LODOVICO, kinsman to Brabantio.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;OTHELLO, a noble Moor in the service of the Venetian state.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;CASSIO, his lieutenant.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;IAGO, his ancient.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;RODERIGO, a Venetian gentleman.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;MONTANO, Othello's predecessor in the government of Cyprus.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;Clown, servant to Othello. &lt;/PERSONA&gt;
    &lt;PERSONA&gt;DESDEMONA, daughter to Brabantio and wife to Othello.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;EMILIA, wife to Iago.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;BIANCA, mistress to Cassio.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;Sailor, Messenger, Herald, Officers, 
             Gentlemen, Musicians, and Attendants.&lt;/PERSONA&gt;
  &lt;/PERSONAE&gt;</eg>
               
               <p>The stylesheet to render this as HTML can be written as a set of template rules:</p>
               
               <eg role="xslt" xml:space="preserve">
 &lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    version="3.0"
    expand-text="yes"&gt;
    
 &lt;xsl:strip-space elements="PERSONAE"/&gt;   
    
 &lt;xsl:template match="PERSONAE"&gt;
   &lt;html&gt;
     &lt;head&gt;
       &lt;title&gt;The Cast of {@PLAY}&lt;/title&gt;
     &lt;/head&gt;
     &lt;body&gt;
       &lt;xsl:apply-templates/&gt;
     &lt;/body&gt;
   &lt;/html&gt;
 &lt;/xsl:template&gt;
 
 &lt;xsl:template match="TITLE"&gt;
   &lt;h1&gt;{.}&lt;/h1&gt;
 &lt;/xsl:template&gt;
 
 &lt;xsl:template match="PERSONA[count(tokenize(., ',') = 2]"&gt;
   &lt;p&gt;&lt;b&gt;{substring-before(., ',')}&lt;/b&gt;: {substring-after(., ',')}&lt;/p&gt;
 &lt;/xsl:template&gt; 

 &lt;xsl:template match="PERSONA"&gt;
   &lt;p&gt;&lt;b&gt;{.}&lt;/b&gt;&lt;/p&gt;
 &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg>
               
               <p>There are four template rules here:</p>
               <ulist>
                  <item><p>The first rule matches the outermost element, named <code>PERSONAE</code> (it could equally
                  have used <code>match="/"</code> to match the document node). The effect of this rule is to create
                  the skeleton of the output HTML page. Technically, the body of the template is a sequence constructor
                  comprising a single <termref def="dt-literal-result-element"/> (the <code>html</code> element); this
                  in turn contains a sequence constructor comprising two literal result elements (the <code>head</code>
                  and <code>body</code> elements). The <code>head</code> element is populated with a literal <code>title</code>
                     element whose content is computed as a mixture of fixed and variable text using a <termref def="dt-text-value-template"/>. 
                     The <code>body</code> element is populated by evaluating an <elcode>xsl:apply-templates</elcode>
                  instruction.</p>
                     <p>The effect of the <elcode>xsl:apply-templates</elcode> instruction is to process the children of
                     the <code>PERSONAE</code> element in the source tree: that is, the <code>TITLE</code> and
                     <code>PERSONA</code> elements. (It would also process any whitespace text node children, but these
                     have been stripped by virtue of the <elcode>xsl:strip-space</elcode> declaration.) Each of these
                     child elements is processed by the best matching template rule for that element, which will be one 
                     of the other three rules in the stylesheet.</p></item>
                  <item><p>The template rule for the <code>TITLE</code> element outputs an <code>h1</code> element
                  to the HTML result document, and populates this with the value of <code>.</code>, the context item. That is,
                  it copies the text content of the <code>TITLE</code> element to the output <code>h1</code> element.</p></item>
                  <item><p>The last two rules match <code>PERSONA</code> element. The first rule matches <code>PERSONA</code>
                  elements whose text content contains exactly one comma; the second rule matches all <code>PERSONA</code> elements,
                     but it has lower priority than the first rule, so in practice it only applies to <code>PERSONA</code>
                  elements that contain no comma or multiple commas.</p>
                  <p>For both rules the body of the rule is a sequence constructor containing a single literal result element,
                  the <code>p</code> element. These literal result elements contain
                  further sequence constructors comprising literal result elements and text nodes. 
                  In each of these examples the text nodes are in the form of a <termref def="dt-text-value-template"/>:
                  in general this is a combination of fixed text together with XPath expressions enclosed in curly braces, which 
                  are evaluated to form the content of the containing literal result element. </p></item>
               </ulist>
               
            </example>
            <p>
               <termdef id="dt-template-rule" term="template rule">A stylesheet contains a set of
                  <term>template rules</term> (see <specref ref="rules"/>). A template rule has
                  three parts: a <termref def="dt-pattern">pattern</termref> that is matched against
                  selected items (often but not necessarily nodes), a (possibly empty) set of <termref def="dt-template-parameter">template
                     parameters</termref>, and a <termref def="dt-sequence-constructor">sequence
                        constructor</termref> that is evaluated to produce a sequence of
                  items.</termdef> In many cases these items are newly constructed nodes, which are
               then written to a <termref def="dt-result-tree">result tree</termref>.</p>
            
            
         </div2>

         
         <div2 id="context">
            <head>The Evaluation Context</head>
            <p>The results of some expressions and instructions in a stylesheet may depend on
               information provided contextually. This context information is divided into two
               categories: the static context, which is known during static analysis of the
               stylesheet, and the dynamic context, which is not known until the stylesheet is
               evaluated. Although information in the static context is known at analysis time, it
               is sometimes used during stylesheet evaluation.</p>
            <p>Some context information can be set by means of declarations within the stylesheet
               itself. For example, the namespace bindings used for any XPath expression are
               determined by the namespace declarations present in containing elements in the
               stylesheet. Other information may be supplied externally or implicitly: an example is
               the current date and time.</p>
            <p>The context information used in processing an XSLT stylesheet includes as a subset
               all the context information required when evaluating XPath expressions. 
               The XPath 4.0 specification defines a static and dynamic
               context that the host language (in this case, XSLT) may initialize, which affects the
               results of XPath expressions used in that context. XSLT augments the context with
               additional information: this additional information is used firstly by XSLT
               constructs outside the scope of XPath (for example, the <elcode>xsl:sort</elcode>
               element), and secondly, by functions that are defined in the XSLT specification (such
               as <function>key</function> and <function>current-group</function>) that are
               available for use in XPath expressions appearing within a stylesheet.</p>
            <p>The static context for an expression or other construct in a stylesheet is determined
               by the place in which it appears lexically. The details vary for different components
               of the static context, but in general, elements within a stylesheet module affect the
               static context for their descendant elements within the same stylesheet module.</p>
            <p>The dynamic context is maintained as a stack. When an instruction or expression is
               evaluated, it may add dynamic context information to the stack; when evaluation is
               complete, the dynamic context reverts to its previous state. An expression that
               accesses information from the dynamic context always uses the value at the top of the
               stack.</p>
            <p>The most commonly used component of the dynamic context is the <termref def="dt-context-item">context item</termref>. This is an implicit variable whose
               value is the item currently being processed (it may be a node, an atomic value,
                  or a function item). The value of the context
               item can be referenced within an XPath expression using the expression <code>.</code>
               (dot).</p>
            <p>Full details of the static and dynamic context are provided in <specref ref="static-and-dynamic-context"/>.</p>
         </div2>
         <div2 id="parsing-and-serialization">
            <head>Parsing and Serialization</head>
            

            <p>An XSLT <termref def="dt-stylesheet">stylesheet</termref>
               describes a process that constructs a set of results from a set of inputs. The inputs
               are the data provided at stylesheet invocation, as described in <specref ref="initiating"/>. The results include the <termref def="dt-principal-result"/>
               (an arbitrary sequence), which is the result of the initial component invocation,
               together with any <termref def="dt-secondary-result">secondary results</termref>
               produced using <elcode>xsl:result-document</elcode> instructions. </p>


            <p>The <termref def="dt-stylesheet">stylesheet</termref> does not describe how a
                  <termref def="dt-source-tree">source tree</termref> is constructed. Some possible
               ways of constructing source trees are described in <bibref ref="xpath-datamodel-30"/>. Frequently an <termref def="dt-implementation">implementation</termref> will
               operate in conjunction with an XML parser (or more strictly, in the terminology of
                  <bibref ref="REC-xml"/>, an <emph>XML processor</emph>), to build a source tree
               from an input XML document. An implementation <rfc2119>may</rfc2119> also provide an
               application programming interface allowing the tree to be constructed directly, or
               allowing it to be supplied in the form of a DOM Document object (see <bibref ref="DOM-Level-2-Core"/>). This is outside the scope of this specification. Users
               should be aware, however, that since the input to the transformation is a tree
               conforming to the XDM data model as described in <bibref ref="xpath-datamodel-30"/>,
               constructs that might exist in the original XML document, or in the DOM, but which
               are not within the scope of the data model, cannot be processed by the <termref def="dt-stylesheet">stylesheet</termref> and cannot be guaranteed to remain
               unchanged in the transformation output. Such constructs include CDATA section
               boundaries, the use of entity references, and the DOCTYPE declaration and internal
               DTD subset.</p>
            <p>
               <termdef id="dt-serialization" term="serialization">A frequent requirement is to
                  output a <termref def="dt-final-result-tree">final result tree</termref> as an XML
                  document (or in other formats such as HTML). This process is referred to as
                     <term>serialization</term>.</termdef>
            </p>
            <p>Like parsing, serialization is not part of the transformation process, and it is not
                  <rfc2119>required</rfc2119> that an XSLT processor <rfc2119>must</rfc2119> be able
               to perform serialization. However, for pragmatic reasons, this specification
               describes declarations (the <elcode>xsl:output</elcode> element and the
                  <elcode>xsl:character-map</elcode> declarations, see <specref ref="serialization"/>), and attributes on the <elcode>xsl:result-document</elcode> instruction, that
               allow a <termref def="dt-stylesheet">stylesheet</termref> to specify the desired
               properties of a serialized output file. When serialization is not being performed,
               either because the implementation does not support the serialization option, or
               because the user is executing the transformation in a way that does not invoke
               serialization, then the content of the <elcode>xsl:output</elcode> and
                  <elcode>xsl:character-map</elcode> declarations has no effect. Under these
               circumstances the processor <rfc2119>may</rfc2119> report any errors in an
                  <elcode>xsl:output</elcode> or <elcode>xsl:character-map</elcode> declaration, or
               in the serialization attributes of <elcode>xsl:result-document</elcode>, but is not
                  <rfc2119>required</rfc2119> to do so.</p>
         </div2>
         <div2 id="packages-and-modules">
            <head>Packages and Modules</head>
            <p>In XSLT 1.0 and 2.0 it was possible to structure a
               stylesheet as a collection of modules, using the <elcode>xsl:include</elcode> and
                  <elcode>xsl:import</elcode> declarations to express the dependency of one module on
               others.</p>
            <p>In XSLT 3.0 an additional layer of modularization of stylesheet code was enabled
               through the introduction of <termref def="dt-package">packages</termref>. A package
               is a collection of stylesheet modules with a controlled interface to the packages
               that use it: for example, it defines which functions and templates defined in the
               package are visible to callers, which are purely internal, and which are not only
               public but capable of being overridden by other functions and templates supplied by
               the using package.</p>
            <p>Packages are introduced with several motivations, which broadly divide into two
               categories:</p>
            <olist>
               <item>
                  <p>Software engineering benefits: greater re-use of code, greater robustness
                     through ease of testing, controlled evolution of code in response to new
                     requirements, ability to deliver code that users cannot see or modify.</p>
               </item>
               <item>
                  <p>Efficiency benefits: the ability to avoid compiling libraries repeatedly when
                     they are used in multiple stylesheets, and to avoid holding multiple copies of
                     the same library in memory simultaneously.</p>
               </item>
            </olist>
            <p>Packages are designed to allow separate compilation: that is, a package can be
               compiled independently of the packages that use it. This specification does not
               define a process model for compilation, or expand on what it means to compile
               different packages independently. Nor does it mandate that implementations offer any
               feature along these lines. It merely defines language features that are designed to
               make separate compilation of packages possible.</p>
            <p>To achieve this, packages (unlike modules):</p>
            <ulist>
               <item>
                  <p>Must not contain unresolved references to functions, templates, or variables
                     declared in other packages;</p>
               </item>
               <item>
                  <p>Have strict rules governing the ability to override declarations in a <termref def="dt-library-package">library package</termref> with declarations in a
                     package that uses the library;</p>
               </item>
               <item>
                  <p>Constrain the visibility of component names and of context declarations such as
                     the declarations of keys and decimal formats;</p>
               </item>
               <item>
                  <p>Can declare a mode (a collection of template rules) as final, which disallows
                     the addition of new overriding template rules in a using package;</p>
               </item>
               <item>
                  <p>Require explicit disambiguation where naming conflicts arise, for example when
                     a package uses two other packages that both export like-named components;</p>
               </item>
               <item>
                  <p>Allow multiple specializations of library components to coexist in the same
                     application.</p>
               </item>
            </ulist>

            <p>A package is defined in XSLT
               by means of an XML document whose
               outermost element is an <elcode>xsl:package</elcode> element. This is referred to as
               the <termref def="dt-package-manifest"/>. The <elcode>xsl:package</elcode> element
               has optional child elements <elcode>xsl:use-package</elcode> and
                  <elcode>xsl:expose</elcode> describing properties of the package. The package
               manifest may refer to an external top-level stylesheet module using an
                  <elcode>xsl:include</elcode> or <elcode>xsl:import</elcode> declaration, or it may
               contain the body of a stylesheet module inline (the two approaches can also be
               mixed).</p>
            
            <p>Although this specification defines packages as constructs 
               written using a defined XSLT syntax, implementations <rfc2119>may</rfc2119> provide mechanisms that allow 
               packages to be written using other languages (for example, XQuery).</p>   

            <p>When no packages are explicitly defined, the entire
               stylesheet is treated as a single package; the effect is as if the
                  <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element of the
                  <termref def="dt-principal-stylesheet-module">principal stylesheet
                  module</termref> were replaced by an <elcode>xsl:package</elcode> element with no
               other information in the package manifest.</p>

         </div2>
         <div2 id="extensibility">
            <head>Extensibility</head>
            <p>XSLT defines a number of features that allow the language to be extended by
               implementers, or, if implementers choose to provide the capability, by users. These
               features have been designed, so far as possible, so that they can be used without
               sacrificing interoperability. Extensions other than those explicitly defined in this
               specification are not permitted.</p>
            <p>These features are all based on XML namespaces; namespaces are used to ensure that
               the extensions provided by one implementer do not clash with those of a different
               implementer.</p>
            <p>The most common way of extending the language is by providing additional functions,
               which can be invoked from XPath expressions. These are known as 
               <termref def="dt-extension-function">extension functions</termref>, and are described in
                  <specref ref="extension-functions"/>.</p>
            <p>It is also permissible to extend the language by providing new <termref def="dt-instruction">instructions</termref>. 
               These are referred to as <termref def="dt-extension-instruction">extension instructions</termref>, and are described
               in <specref ref="extension-instruction"/>. A stylesheet that uses extension
               instructions in a particular namespace must declare that it is doing so by using the
                  <code>[xsl:]extension-element-prefixes</code> attribute.</p>
            <p>Extension instructions and extension functions defined according to these rules
                  <rfc2119>may</rfc2119> be provided by the implementer of the XSLT processor, and
               the implementer <rfc2119>may</rfc2119> also provide facilities to allow users to
               create further extension instructions and extension functions.</p>
            <p>This specification defines how extension instructions and extension functions are
               invoked, but the facilities for creating new extension instructions and extension
               functions are <termref def="dt-implementation-defined">implementation-defined</termref>. 
               For further details, see <specref ref="extension"/>.</p>
            <imp-def-feature id="idf-ext-mechanisms">The mechanisms for creating new <termref def="dt-extension-instruction">extension instructions</termref> and <termref def="dt-extension-function">extension functions</termref> are <termref def="dt-implementation-defined"/>. It is not <rfc2119>required</rfc2119> that
               implementations provide any such mechanism.</imp-def-feature>
            <p>The XSLT language can also be extended by the use of <termref def="dt-extension-attribute">extension attributes</termref> (see <specref ref="extension-attributes"/>), and by means of <termref def="dt-data-element">user-defined data elements</termref> (see <specref ref="user-defined-top-level"/>).</p>
         </div2>
         <div2 id="stylesheets-and-schemas">
            <head>Stylesheets and XML Schemas</head>
            <p>An XSLT <termref def="dt-stylesheet">stylesheet</termref> can make use of information
               from a schema. An XSLT transformation can take place in the absence of a schema (and,
               indeed, in the absence of a DTD), but where the source document has undergone schema
               validity assessment, the XSLT processor has access to the type information associated
               with individual nodes, not merely to the untyped text.</p>
            <p>Information from a schema can be used both statically (when the <termref def="dt-stylesheet">stylesheet</termref> is compiled), and dynamically (during
               evaluation of the stylesheet to transform a source document).</p>
            <p>There are places within a <termref def="dt-stylesheet">stylesheet</termref>, and
               within XPath <termref def="dt-expression">expressions</termref> and <termref def="dt-pattern">patterns</termref> in a <termref def="dt-stylesheet">stylesheet</termref>, where it is possible to refer to named type definitions in
               a schema, or to element and attribute declarations. For example, it is possible to
               declare the types expected for the parameters of a function. This is done using
               a <termref def="dt-sequence-type"/>.</p>
            <p><termdef id="dt-sequence-type" term="SequenceType">A <term>SequenceType</term>
            constrains the type and number of items in a sequence. The term is used both to denote the
            concept, and to refer to the syntactic form in which sequence types are expressed in the
            XPath grammar: specifically <xnt spec="XP40" ref="prod-xpath40-SequenceType">SequenceType</xnt> in
                <bibref ref="xpath-30"/>.</termdef><phrase diff="del" at="2022-01-01">, or <xnt spec="XP40" ref="prod-xpath40-SequenceType">SequenceType</xnt> in
                <bibref ref="xpath-31"/>, depending on whether or not the XPath 3.1 feature
            is implemented.</phrase></p>
            <p>
               <termdef id="dt-schema-component" term="schema component">Type definitions and
                  element and attribute declarations are referred to collectively as <term>schema
                     components</term>.</termdef>
            </p>
            <p>
               <termdef id="dt-in-scope-schema-component" term="in-scope schema component">The
                     <termref def="dt-schema-component">schema components</termref> that may be
                  referenced by name in a <termref def="dt-package">package</termref> are referred to as the
                     <term>in-scope schema components</term>.</termdef></p>

            <p>The set of in-scope schema components may vary between
               one package and another, but as explained in <specref ref="import-schema"/>, the
               schema components used in different packages must be consistent with each other.</p>

            <p>The conformance rules for XSLT 4.0, defined in
                  <specref ref="conformance"/>, distinguish between a <termref def="dt-basic-xslt-processor">basic XSLT processor</termref> and a <termref def="dt-schema-aware-xslt-processor">schema-aware XSLT processor</termref>. As the
               names suggest, a basic XSLT processor does not support the features of XSLT that
               require access to schema information, either statically or dynamically. A <termref def="dt-stylesheet">stylesheet</termref> that works with a basic XSLT processor
               will produce the same results with a schema-aware XSLT processor provided that the
               source documents are untyped (that is, they are not validated against a schema).
               However, if source documents are validated against a schema then the results may be
               different from the case where they are not validated. Some constructs that work on
               untyped data may fail with typed data (for example, an attribute of type
                  <code>xs:date</code> cannot be used as an argument of the
                  <xfunction>substring</xfunction> function) and other constructs may produce
               different results depending on the datatype (for example, given the element
                  <code>&lt;product price="10.00" discount="2.00"/&gt;</code>, the expression
                  <code>@price gt @discount</code> will return <code>true</code> if the attributes have type
                  <code>xs:decimal</code>, but will return <code>false</code> if they are untyped).</p>
            <p>There is a standard set of type definitions that are always available as <termref def="dt-in-scope-schema-component">in-scope schema components</termref> in every
               stylesheet. These are defined in <specref ref="built-in-types"/>. </p>
            <p>The remainder of this section describes facilities that are available only with a
                  <termref def="dt-schema-aware-xslt-processor">schema-aware XSLT
                  processor</termref>.</p>
            <p>Additional <termref def="dt-schema-component">schema components</termref> (type
               definitions, element declarations, and attribute declarations) may be added to the
                  <termref def="dt-in-scope-schema-component">in-scope schema components</termref>
               by means of the <elcode>xsl:import-schema</elcode> declaration in a stylesheet.</p>
            <p>The <elcode>xsl:import-schema</elcode> declaration may reference an external schema
               document by means of a URI, or it may contain an inline <code>xs:schema</code>
               element.</p>
            <p>It is only necessary to import a schema explicitly if one or more of its <termref def="dt-schema-component">schema components</termref> are referenced explicitly by
               name in the <termref def="dt-stylesheet">stylesheet</termref>; it is not necessary to
               import a schema merely because the stylesheet is used to process a source document
               that has been assessed against that schema. It is possible to make use of the
               information resulting from schema assessment (for example, the fact that a particular
               attribute holds a date) even if no schema has been imported by the stylesheet.</p>
            <p>Importing a schema does not of itself say anything about the type of the source
               document that the <termref def="dt-stylesheet">stylesheet</termref> is expected to
               process. The imported type definitions can be used for temporary nodes or for nodes
               on a <termref def="dt-result-tree">result tree</termref> just as much as for nodes in
               source documents. It is possible to make assertions about the type of an input
               document by means of tests within the <termref def="dt-stylesheet">stylesheet</termref>. For example:</p>
            <example>
               <head>Asserting the Required Type of the Source Document</head>
               <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:mode typed="lax"/&gt;
&lt;xsl:global-context-item use="required"
            as="document-node(schema-element(my:invoice))"/&gt;</eg>
               <p>This example will cause the transformation to fail with an error message, unless
                  the <termref def="dt-global-context-item"/> is valid against the top-level element
                  declaration <code>my:invoice</code>, and has been annotated as such.</p>
               <p>The setting <code>typed="lax"</code> further ensures that in any
                  match pattern for a template rule in this mode, an element name that corresponds
                  to the name of an element declaration in the schema is taken as referring to
                  elements validated against that declaration: for example,
                     <code>match="employee"</code> will only match a validated <code>employee</code>
                  element. Selecting this option enables the XSLT processor to do more compile-time
                  type-checking against the schema, for example it allows the processor to produce
                  warning or error messages when path expressions contain misspelt element names, or
                  confuse an element with an attribute.</p>
            </example>
            <p>It is also true that importing a schema does not of itself say
               anything about the structure of the result tree. It is possible to request validation
               of a result tree against the schema by using the <elcode>xsl:result-document</elcode>
               instruction, for example:</p>
            <example>
               <head>Requesting Validation of the Result Document</head>
               <eg role="xslt-declaration xmlns:xhtml='xhtml'" xml:space="preserve">&lt;xsl:template match="/"&gt;
  &lt;xsl:result-document validation="strict"&gt;
    &lt;xhtml:html&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xhtml:html&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;
               </eg>
               <p>This example will cause the transformation to fail with an error message unless
                  the document element of the result document is valid against the top-level element
                  declaration <code>xhtml:html</code>.</p>
            </example>

            <p>It is possible that a source document may contain nodes whose <termref def="dt-type-annotation">type annotation</termref> is not one of the types
               imported by the stylesheet. This creates a potential problem because in the case of
               an expression such as <code>data(.) instance of xs:integer</code> the system needs to
               know whether the type named in the type annotation of the context node is derived by
               restriction from the type <code>xs:integer</code>. This information is not explicitly
               available in an XDM tree, as defined in <bibref ref="xpath-datamodel-30"/>. The
               implementation may choose one of several strategies for dealing with this
               situation:</p>
            <olist>
               <item>
                  <p>The processor may signal a <termref def="dt-dynamic-error"> dynamic error</termref> if a source
                     document is found to contain a <termref def="dt-type-annotation"/> that is not
                     known to the processor.</p>
               </item>
               <item>
                  <p>The processor may maintain additional metadata, beyond that described in
                        <bibref ref="xpath-datamodel-30"/>, that allows the source document to be
                     processed as if all the necessary schema information had been imported using
                        <elcode>xsl:import-schema</elcode>. Such metadata might be held in the data
                     structure representing the source document itself, or it might be held in a
                     system catalog or repository.</p>
               </item>
               <item>
                  <p>The processor may be configured to use a fixed set of schemas, which are
                     automatically used to validate all source documents before they can be supplied
                     as input to a transformation. In this case it is impossible for a source
                     document to have a <termref def="dt-type-annotation"/> that the processor is
                     not aware of.</p>
               </item>
               <item>
                  <p>The processor may be configured to treat the source document as if no schema
                     processing had been performed, that is, effectively to strip all type
                     annotations from elements and attributes on input, marking them instead as
                     having type <code>xs:untyped</code> and <code>xs:untypedAtomic</code>
                     respectively.</p>
               </item>
            </olist>
            <p>Where a stylesheet author chooses to make assertions about the types of nodes or of
                  <termref def="dt-variable">variables</termref> and <termref def="dt-parameter">parameters</termref>, it is possible for an XSLT processor to perform static
               analysis of the <termref def="dt-stylesheet">stylesheet</termref> (that is, analysis
               in the absence of any source document). Such analysis <rfc2119>may</rfc2119> reveal
               errors that would otherwise not be discovered until the transformation is actually
               executed. An XSLT processor is not <rfc2119>required</rfc2119> to perform such static
               type-checking. Under some circumstances (see <specref ref="errors"/>) type errors
               that are detected early <rfc2119>may</rfc2119> be reported as static errors. In
               addition an implementation <rfc2119>may</rfc2119> report any condition found during
               static analysis as a warning, provided that this does not prevent the stylesheet
               being evaluated as described by this specification.</p>
            <p>A <termref def="dt-stylesheet">stylesheet</termref> can also control the <termref def="dt-type-annotation">type annotations</termref> of nodes that it constructs in
               a <termref def="dt-result-tree">result
                     tree</termref>. This can be done in a number of ways.</p>
            <ulist>
               <item>
                  <p>It is possible to request explicit validation of a complete document, that is,
                     a <termref def="dt-result-tree">result
                           tree</termref> rooted at a document node.  Validation
                     is either strict or lax, as described in <bibref ref="xmlschema-1"/>. If
                     validation of a <termref def="dt-result-tree">result tree</termref> fails
                     (strictly speaking, if the outcome of the validity assessment is
                        <code>invalid</code>), then the transformation fails, but in all other
                     cases, the element and attribute nodes of the tree will be annotated with the
                     names of the types to which these nodes conform. These <termref def="dt-type-annotation">type annotations</termref> will be discarded if the
                     result tree is serialized as an XML document, but they remain available when
                     the result tree is passed to an application (perhaps another <termref def="dt-stylesheet">stylesheet</termref>) for further processing.</p>
               </item>
               <item>
                  <p>It is also possible to validate individual element and attribute nodes as they
                     are constructed. This is done using the <code>type</code> and
                        <code>validation</code> attributes of the <elcode>xsl:element</elcode>,
                        <elcode>xsl:attribute</elcode>, <elcode>xsl:copy</elcode>, and
                        <elcode>xsl:copy-of</elcode> instructions, or the <code>xsl:type</code> and
                        <code>xsl:validation</code> attributes of a literal result element.</p>
               </item>
               <item>
                  <p>When elements, attributes, or document nodes are copied, either explicitly
                     using the <elcode>xsl:copy</elcode> or <elcode>xsl:copy-of</elcode>
                     instructions, or implicitly when nodes in a sequence are attached to a new
                     parent node, the options <code>validation="strip"</code> and
                        <code>validation="preserve"</code> are available, to control whether
                     existing <termref def="dt-type-annotation">type annotations</termref> are to be
                     retained or not.</p>
               </item>
            </ulist>
            <p>When nodes in a <termref def="dt-temporary-tree">temporary tree</termref> are
               validated, type information is available for use by operations carried out on the
               temporary tree, in the same way as for a source document that has undergone schema
               assessment.</p>
            <p>For details of how validation of element and attribute nodes works, see <specref ref="validation"/>.</p>
         </div2>
         <div2 id="streaming-concepts">
            <head>Streaming</head>
            <p><termdef id="dt-streaming" term="streaming">The term <term>streaming</term> refers to
                  a manner of processing in which XML documents (such as source and result documents)
                  are not represented by a complete tree of nodes occupying memory proportional to
                  document size, but instead are processed “on the fly” as a sequence of events,
                  similar in concept to the stream of events notified by an XML parser to represent
                  markup in lexical XML.</termdef></p>

            <p><termdef id="dt-streamed-document" term="streamed document">A <term>streamed
                     document</term> is a <termref def="dt-source-tree">source tree</termref> that
                  is processed using streaming, that is, without constructing a complete tree of
                  nodes in memory.</termdef></p>

            <p><termdef id="dt-streamed-node" term="streamed node">A <term>streamed
                     node</term> is a node in a <termref def="dt-streamed-document">streamed
                     document</termref>.</termdef></p>

            <p>Many processors implementing earlier versions of this specification adopted an
               architecture that allowed streaming of the <termref def="dt-result-tree">result
                  tree</termref> directly to a serializer, without first materializing the complete
               result tree in memory. Streaming of the <termref def="dt-source-tree">source
                  tree</termref>, however, has proved to be more difficult without subsetting the
               language. This has created a situation where documents exceeding the capacity of
               virtual memory could not be transformed. XSLT 3.0 therefore introduced facilities
               allowing stylesheets to be written in a way that makes streaming of source documents
               possible, without excessive reliance on processor-specific optimization
               techniques.</p>

            <p>Streaming achieves two important objectives: it allows large documents to be
               transformed without requiring correspondingly large amounts of memory; and it allows
               the processor to start producing output before it has finished receiving its input,
               thus reducing latency.</p>

            <p>This specification does not attempt to legislate precisely which implementation
               techniques fall under the definition of streaming, and which do not. A number of
               techniques are available that reduce memory requirements, while still requiring a
               degree of buffering, or allocation of memory to partial results. A stylesheet that
               requests streaming of a source document is indicating that the processor should avoid
               assuming that the entire source document will fit in memory; in return, the
               stylesheet must be written in a way that makes streaming possible. This specification
               does not attempt to describe the algorithms that the processor should actually use,
               or to impose quantitative constraints on the resources that these algorithms should
               consume.</p>

            <p>Nothing in this specification, nor in its predecessors <bibref ref="xslt"/> and
                  <bibref ref="xslt20"/>, prevents a processor using streaming whenever it sees an
               opportunity to do so. However, experience has shown that in order to achieve
               streaming, it is often necessary to write stylesheet code in such a way as to make
               this possible. Therefore, XSLT provides explicit constructs allowing the
               stylesheet author to request streaming, and defines explicit static constraints on
               the structure of the code which are designed to make streaming possible.</p>

            <p>A processor that claims conformance with the streaming option offers a guarantee that
               when streaming is requested for a source document, and when the stylesheet conforms
               to the rules that make the processing <termref def="dt-guaranteed-streamable"/>, then
               an algorithm will be adopted in which memory consumption is either completely
               independent of document size, or increases only very slowly as document size
               increases, allowing documents to be processed that are orders-of-magnitude larger
               than the physical memory available. A processor that does not claim conformance with
               the streaming option must still process a stylesheet and deliver the correct results,
               but is not required to use streaming algorithms, and may therefore fail with
               out-of-memory errors when presented with large source documents.</p>

            <p>Apart from the fact that there are constructs to request streaming, and rules that
               must be followed to guarantee that streaming is possible, the language has been
               designed so there are as few differences as possible between streaming and
               non-streaming evaluation. The semantics of the language continue to be expressed in
               terms of the XDM data model, which is substantively unchanged; but readers must take
               care to observe that when terms like “node” and “axis” are used, the concepts are
               completely abstract and may have no direct representation in the run-time execution
               environment.</p>
            <p>Streamed processing of a document can be initiated in one of three ways:</p>
            <ulist>
               <item>
                  <p>The <termref def="dt-initial-mode">initial mode</termref> can be declared as a
                        <termref def="dt-streamable-mode">streamable mode</termref>. In this case
                     the <termref def="dt-initial-match-selection"/> will generally be a document node (or
                        sequence of document nodes), supplied by the calling application in
                     a form that allows streaming (that is, in some form other than a tree in
                     memory; for example, as a reference to a push or pull XML parser primed to
                     deliver a stream of events). The type of
                        these nodes can be constrained by using the attribute
                           <code>on-no-match="fail"</code> on the <termref def="dt-initial-mode"/>,
                        and using this mode only for processing the top-level nodes.
                     </p>
               </item>
               <item>
                  <p>Streamed processing of any document can be initiated using the
                        <elcode>xsl:source-document</elcode> instruction. This has an attribute  
                        <code>href</code> whose value is the URI of a document to be processed,
                     and an attribute <code>streamable</code> that
                     indicates whether it is to be processed using
                     streaming; the actual processing to be applied is defined by the
                     instructions written as children of the <elcode>xsl:source-document</elcode>
                     instruction. </p>
               </item>
               <item>
                  <p>Streamed merging of a set of input documents can be initiated using the
                        <elcode>xsl:merge</elcode> instruction.</p>
               </item>
            </ulist>
            <p>The rules for streamability, which are defined in detail in <specref ref="streamability"/>, impose two main constraints:</p>
            <ulist>
               <item>
                  <p>The only nodes reachable from the node that is currently being processed are
                     its attributes and namespaces, its ancestors and their attributes and
                     namespaces, and its descendants and their attributes and namespaces. The
                     siblings of the node, and the siblings of its ancestors, are not reachable in
                     the tree, and any attempt to use their values is a <termref def="dt-static-error">static error</termref>. </p>
               </item>
               <item>
                  <p>When processing a given node in the tree, each descendant node can only be
                     visited once. Essentially this allows two styles of processing: either visit
                     each of the children once, and then process that child with the same
                     restrictions applied; or process all the descendants in a single pass, in which
                     case it is not possible while processing a descendant to make any further
                     downward selection.</p>
               </item>
            </ulist>
            <p>The second restriction, that only one visit to the children is
               allowed, means that XSLT code that was not designed with streaming in mind will often
               need to be rewritten to make it streamable. In many cases it is possible to do this
               using a technique sometimes called <emph>windowing</emph> or <emph>burst-mode
                  streaming</emph> (note this is not quite the same meaning as
                  <emph>windowing</emph> in XQuery 3.0). Many XML documents consist of a large
               number of elements, each of manageable size, representing transactions or business
               objects where each such element can be processed independently: in such cases, an
               effective design pattern is to write a streaming transformation that takes a snapshot
               of each element in turn, processing the snapshot using the full power of the XSLT
               language. Each snapshot is a tree built in memory and is therefore fully navigable.
               For details see the <function>snapshot</function> and <function>copy-of</function>
               functions.</p>

            <p>The new facility of <emph>accumulators</emph> allows applications
               complete control over how much information is retained (and by implication, how much
               memory is required) in the course of a pass over a <termref def="dt-streamed-document"/>. An accumulator computes a value for every node in a
               streamed document: or more accurately, two values, one for the first visit to a node
               (before visiting its descendants), and a second value for the second visit to the
               node (after visiting the descendants). The computation is structured in such a way
               that the value for a given node can depend only on the value for the previous node in
               document order together with the data available when positioned at the current node
               (for example, the attribute values). Based on the well-established fold operation of
               functional programming languages, accumulators provide the convenience and economy of
               mutable variables while remaining within the constraints of a purely declarative
               processing model.</p>

            <p>When streaming is initiated, for example using the
                  <elcode>xsl:source-document</elcode> instruction, it is necessary to declare which
               accumulators are applicable to the streamed document.</p>


            <p>Streaming applications often fall into one of the following categories:</p>
            <ulist>
               <item>
                  <p>Aggregation applications, where a single aggregation operation (perhaps
                        <xfunction>count</xfunction>, <xfunction>sum</xfunction>,
                        <xfunction>exists</xfunction>, or <xfunction>distinct-values</xfunction>) is
                     applied to a set of elements selected from the streamed source document by
                     means of a path expression.</p>
               </item>
               <item>
                  <p>Record-at-a-time applications, where the source document consists of a long
                     sequence of elements with similar structure (“records”), and each “record” is
                     processed using the same logic, independently of any other “records”. This kind
                     of processing is facilitated using the <function>snapshot</function> and
                        <function>copy-of</function> function mentioned earlier.</p>
               </item>
               <item>
                  <p>Grouping applications, where the output follows the structure of the input,
                     except that an extra layer of hierarchy is added. For example, the input might
                     be a flat series of banking transactions in date/time order, and the output
                     might contain the same transactions grouped by date.</p>
               </item>
               <item>
                  <p>Accumulator applications, which are the same as record-at-a-time applications,
                     except that the processing of one “record” might depend on data encountered
                     earlier in the document. A classic example is processing a sequence of banking
                     transactions in which the input transaction contains a debit or credit amount,
                     and the output adds a running total (the account balance). The
                        <elcode>xsl:iterate</elcode> instruction has been introduced to facilitate
                     this style of processing.</p>
               </item>
               <item>
                  <p>Isomorphic transformations, in which there is an ordered (often largely
                     one-to-one) relationship between the nodes of the source tree and the nodes of
                     the result tree: for example, transformations that involve only the renaming or
                     selective deletion of nodes, or scalar manipulations of the values held in the
                     leaf nodes. Such transformations are most conveniently expressed using
                     recursive application of template rules. This is possible with a streamed input
                     document only if all the template rules adhere to the constraints required for
                     streamability. To enforce these rules, while still allowing unrestricted
                     processing of other documents within the same transformation, all streaming
                     evaluation must be carried out using a specific <termref def="dt-mode">mode</termref>, which is declared to be a streaming mode by means of an
                        <elcode>xsl:mode</elcode> declaration in the stylesheet.</p>
               </item>
            </ulist>
            <p>There are important classes of application in which streaming is possible only if
               multiple streams can be processed in parallel. This specification therefore provides
               facilities:</p>
            <olist>
               <item>
                  <p>allowing multiple sorted input sequences to be merged into one sorted output
                     sequence (the <elcode>xsl:merge</elcode> instruction)</p>
               </item>
               <item>
                  <p>allowing multiple output sequences to be generated during a single pass of an
                     input sequence (the <elcode>xsl:fork</elcode> instruction).</p>
               </item>
            </olist>
            <p>These facilities have been designed in such a way that they can readily be
               implemented using streaming, that is, without materializing the input or output
               sequences in memory.</p>

         </div2>
         <div2 id="streamed-validation">
            <head>Streamed Validation</head>
            
            <p>Streaming can be combined with schema-aware processing: that is, the streamed input to a transformation 
               can be subjected to on-the-fly validation, a process which typically accepts an input stream from the 
               XML parser and delivers an output stream (of type-annotated nodes) to the transformation processor. 
               The XSD specification is designed so that validation is, with one or two exceptions, a streamable process. 
               The exceptions include:
            </p>
            
            <ulist>
               <item><p>There may be a need to allocate memory to hold keys, in order to enforce uniqueness and 
                  referential integrity constraints (<code>xs:unique</code>, <code>xs:key</code>, <code>xs:keyref</code>).
               </p></item>
               <item><p>In XSD 1.1, assertions can be defined by means of XPath expressions. These are not constrained 
                  to be streamable; in the general case, any subtree of the document that is validated using an assertion 
                  may need to be buffered in memory while the assertion is processed.
               </p></item>
            </ulist>

            <p>Applications that need to run in finite memory may therefore need to avoid these XSD features, 
               or to use them with care.
            </p>
            
            <p>XSD is designed so that the intended type of an element (the “governing type”) can be determined as soon 
               as the start tag of the element is encountered: the process of validation checks whether the content of 
               the element actually conforms to this type, and by the time the end tag is encountered, the process will 
               have established either that the element is valid against the governing type, or that it is invalid. 
            </p>
            
            <p>By default, dynamic errors occurring during streamed processing are fatal: they typically cause the 
               transformation to fail immediately. XSLT 3.0 introduced the ability to catch dynamic errors and recover 
               from them. Schema invalidity, however, is treated as a dynamic error of the instruction that 
               processes the entire input stream, so after a validation failure, no further processing of that input stream 
               is possible.
            </p>
            
            <p>In consequence, a streamed validator that is running in tandem with a streamed transformation 
               can present the transformer with element nodes that carry a provisional type annotation representing 
               the type that the element will have if it turns out to be valid. As soon as a node is encountered that 
               violates this assumption, the validator should stop the flow of data to the transformer, so that the 
               transformer never sees invalid data. This allows the stylesheet code to be compiled with the assumption 
               of type-safety: at run-time, all nodes seen by the transformation will conform to their XSLT-declared types
               (for example, a type declared implicitly using <code>match="schema-element(invoice)"</code> on an 
               <elcode>xsl:template</elcode> element).
            </p>
            
            <p>A streamed transformation that only accesses part of the input document (for example, a header
               at the start of a document) is not required to continue reading once the data it needs 
               has been read. This means that XML well-formedness or validity errors occurring in the unread part 
               of the input stream may go undetected.
            </p>
            
            
            
            
            
         </div2>
         <div2 id="streaming-non-xml">
            <head>Streaming of non-XML data</head>
            <p>The facilities in this specification designed to enable large data sets to be processed in a streaming
            manner are oriented almost entirely to XML data. This does not mean that there is never a requirement
            to stream non-XML data, or that the Working Group has ignored this requirement; rather, the Working Group
            has concluded that for the most part, streaming of non-XML data can be achieved by implementations without
            the need for specific language features in XSLT.</p>
            
            <p>To make streamed processing of unparsed text files easier, the function <xfunction>unparsed-text-lines</xfunction>
            has been introduced. This is not only more convenient for stylesheet authors than reading the entire input
            using the <xfunction>unparsed-text</xfunction> function and then tokenizing the result, it is also easier for implementations
            to optimize, allowing each line of text to be discarded from memory after it has been processed.</p>
            
            <p>For all functions that access external data, including <function>document</function>, <xfunction>doc</xfunction>,
            <xfunction>collection</xfunction>, <xfunction>unparsed-text</xfunction>, <xfunction>unparsed-text-lines</xfunction>,
            and <xfunction spec="FO40">json-doc</xfunction>, the requirements on determinism can now
            be relaxed using <termref def="dt-implementation-defined"/> configuration options. This is significant
            because it means that when a transformation reads the same external resource more than once, it becomes
            legitimate for the contents of the resource to be different on different invocations, and this eliminates
            the need for the processor to cache the contents of the resource in memory.</p>
            
            <p>In the XDM data model, every value is a sequence, and (as with most functional programming languages),
            processing of sequences of items is pervasive throughout the XSLT and XPath languages and their function
            library. Good performance of a functional programming language often depends on sequence-based operations
            being pipelined, and being evaluated in a lazy fashion (that is, many operations process items in a sequence
            one at a time, in order; and many operations can deliver a result without processing the entire sequence).
            The semantics of XSLT and XPath permit pipelined and lazy evaluation (for example, the error handling semantics
            are carefully written to ensure this), but they do not require it: the details are left to implementations.
            Pipelined processing of a sequence is not the same thing as streamed processing of a tree, and where the XSLT
            specification talks of operations being “guaranteed streamable”, this is always referring to processing of
            trees, not of sequences.</p>
            
            <p>The facilities for streaming of XML trees include operations such as <function>copy-of</function>
            and <function>snapshot</function> which are able to take a sequence of streamed nodes as input, 
               and produce a sequence of in-memory (unstreamed) nodes as output. It is also possible to generate
               a sequence of strings or other atomic values through the process of <termref def="dt-atomization">atomization</termref>.
               The actual memory usage of a streamed
            XSLT application may depend significantly on whether the processing of the resulting sequence of in-memory
            nodes or atomic values is pipelined or not. The specification, however, has nothing to say on this matter: 
            it is considered an area where implementers can exercise their discretion and ingenuity.</p>
            
            <p>Streaming of JSON input receives little attention in this specification. One can envisage an implementation
            of the <function>json-to-xml</function> function in which the XML delivered by the function consists of
            streamed nodes; but the Working Group has not researched the feasibility of such an implementation in any detail.</p>
         </div2>
         <div2 id="errors">
            <head>Error Handling</head>
            <!--Text replaced by erratum E5 change 1"-->
            <p>
               <termdef id="dt-static-error" term="static error">An error that can be detected by
                  examining a <termref def="dt-stylesheet">stylesheet</termref> before execution
                  starts (that is, before the source document and values of stylesheet parameters
                  are available) is referred to as a <term>static error</term>.</termdef>
            </p>
            
            
            <p>Generally, errors in the structure of the <termref def="dt-stylesheet">stylesheet</termref>, or in the syntax of XPath <termref def="dt-expression">expressions</termref> contained in the stylesheet, are classified as <termref def="dt-static-error">static errors</termref>. Where this specification states
               that an element in the stylesheet <rfc2119>must</rfc2119> or <rfc2119>must
                  not</rfc2119> appear in a certain position, or that it <rfc2119>must</rfc2119> or
                  <rfc2119>must not</rfc2119> have a particular attribute, or that an attribute
                  <rfc2119>must</rfc2119> or <rfc2119>must not</rfc2119> have a value satisfying
               specified conditions, then any contravention of this rule is a static error unless
               otherwise specified. </p>
            
            <p>A processor <rfc2119>must</rfc2119> provide a mode of operation 
               that takes a (possibly erroneous) stylesheet <termref def="dt-package">package</termref> as 
               input and enables the user to determine whether or not that package contains any
               <termref def="dt-static-error">static errors</termref>.
            </p>
            
            <note>
            <p>The manner in which static errors are reported, and the behavior when there are multiple
               static errors, are left as design choices for the implementer. It is <rfc2119>recommended</rfc2119> 
               that the error codes defined in this specification should be made available in any diagnostics.
            </p></note>
            
            <p>A processor <rfc2119>may</rfc2119> also provide a mode of operation in which 
               <termref def="dt-static-error">static errors</termref> in parts of the stylesheet that 
               are not evaluated can go unreported.
            </p>
            
            <note><p>For example, when operating in this mode, a processor might report static errors 
               in a template rule only if the input document contains nodes that match that template rule. 
               Such a mode of operation can provide performance benefits when large and well-tested stylesheets 
               are used to process source documents that might only use a small part of the XML vocabulary 
               that the stylesheet is designed to handle.
            </p></note>
            <p>
               <termdef id="dt-dynamic-error" term="dynamic error">An error that is not 
                  capable of detection
                  until a source document is being transformed is referred to as a <term>dynamic
                     error</term>.</termdef>
            </p>
            <p>When a <termref def="dt-dynamic-error"/> occurs, and is not caught
               using <elcode>xsl:catch</elcode>, the <termref def="dt-processor">processor</termref>
               <rfc2119>must</rfc2119> signal the error, and the transformation fails.</p>
            
            

            
            
            
            <p>Because different implementations may optimize execution of the <termref def="dt-stylesheet">stylesheet</termref> in different ways, the detection of
               dynamic errors is to some degree <termref def="dt-implementation-dependent">implementation-dependent</termref>. In cases where an implementation is able to
               produce a <termref def="dt-principal-result"/> or
                     <termref def="dt-secondary-result"/>
                without evaluating a particular construct, the
               implementation is never <rfc2119>required</rfc2119> to evaluate that construct solely
               in order to determine whether doing so causes a dynamic error. For example, if a
                  <termref def="dt-variable">variable</termref> is declared but never referenced, an
               implementation <rfc2119>may</rfc2119> choose whether or not to evaluate the variable
               declaration, which means that if evaluating the variable declaration causes a dynamic
               error, some implementations will signal this error and others will not.</p>
            <p>There are some cases where this specification requires that a construct <rfc2119>must
                  not</rfc2119> be evaluated: for example, the content of an <elcode>xsl:if</elcode>
               instruction <rfc2119>must not</rfc2119> be evaluated if the test condition is false.
               This means that an implementation <rfc2119>must not</rfc2119> signal any dynamic
               errors that would arise if the construct were evaluated.</p>
            <p>An implementation <rfc2119>may</rfc2119> signal a <termref def="dt-dynamic-error">dynamic error</termref> before any source document is available, but only if it
               can determine that the error would be signaled for every possible source document and
               every possible set of parameter values. For example, some <termref def="dt-circularity">circularity</termref> errors fall into this category: see
                  <specref ref="circularity"/>.</p>
            <p>There are also some <termref def="dt-dynamic-error">dynamic
                  errors</termref> where the specification gives a processor license to signal the
               error during the analysis phase even if the construct might never be executed; an
               example is the use of an invalid QName as a literal argument to a function such as
                  <function>key</function>, or the use of an invalid regular expression in the
                  <code>regex</code> attribute of the <elcode>xsl:analyze-string</elcode>
               instruction.</p>
            <p>A <termref def="dt-dynamic-error"/>
               is also signaled during the static
               analysis phase if the error occurs during evaluation of a <termref def="dt-static-expression"/>.</p>
            <p>The XPath specification states (see <xspecref spec="XP40" ref="id-kinds-of-errors"/>)
               that if any expression (at any level) can be evaluated during the analysis phase
               (because all its explicit operands are known and it has no dependencies on the
               dynamic context), then any error in performing this evaluation <rfc2119>may</rfc2119>
               be reported as a static error. For XPath expressions used in an XSLT stylesheet,
               however, any such errors <rfc2119>must not</rfc2119> be reported as static errors in
               the stylesheet unless they would occur in every possible evaluation of that
               stylesheet; instead, they must be signaled as dynamic errors, and signaled only if
               the XPath expression is actually evaluated.</p>
            <example>
               <head>Errors in Constant Subexpressions</head>
               <p>An XPath processor may report statically that the expression <code>1 div 0</code>
                  fails with a “divide by zero” error. But suppose this XPath expression occurs in
                  an XSLT construct such as:</p>
               <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:choose&gt;
  &lt;xsl:when test="system-property('xsl:version') = '1.0'"&gt;
    &lt;xsl:value-of select="1 div 0"/&gt;
  &lt;/xsl:when&gt;
  &lt;xsl:otherwise&gt;
    &lt;xsl:value-of select="xs:double('INF')"/&gt;
  &lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;</eg>
               <p>Then the XSLT processor must not report an error, because the relevant XPath
                  construct appears in a context where it will never be executed by an XSLT 
                  <phrase diff="chg" at="2023-02-24">4.0</phrase>. (An XSLT 1.0 processor
                  will execute this code successfully, returning positive infinity, because it uses
                  double arithmetic rather than decimal arithmetic.)</p>
            </example>
            <p>
               <termdef id="dt-type-error" term="type error">Certain errors are classified as
                     <term>type errors</term>. A type error occurs when the value supplied as input
                  to an operation is of the wrong type for that operation, for example when an
                  integer is supplied to an operation that expects a node.</termdef> If a type error
               occurs in an instruction that is actually evaluated, then it <rfc2119>must</rfc2119>
               be signaled in the same way as a <termref def="dt-dynamic-error"> dynamic error</termref>. Alternatively, an
               implementation <rfc2119>may</rfc2119> signal a type error during the analysis phase
               in the same way as a <termref def="dt-static-error">static error</termref>, even if
               it occurs in part of the stylesheet that is never evaluated, provided it can
               establish that execution of a particular construct would never succeed.</p>
            <p>It is <termref def="dt-implementation-defined"/> whether type errors are signaled
               statically.</p>
            <imp-def-feature id="idf-err-statictypechecking">It is <termref def="dt-implementation-defined"/> whether type errors are signaled
               statically.</imp-def-feature>
            <example>
               <head>A Type Error</head>
               <p>The following construct contains a type error, because
                     <code>42</code> is not allowed as the value of the <code>select</code>
                  expression of the <elcode>xsl:number</elcode> instruction (it must be a node). An
                  implementation <rfc2119>may</rfc2119> optionally signal this as a static error,
                  even though the offending instruction will never be evaluated, and the type error
                  would therefore never be signaled as a dynamic error.</p>
               <eg role="error" xml:space="preserve">&lt;xsl:if test="false()"&gt;
  &lt;xsl:number select="42"/&gt;
&lt;/xsl:if&gt;</eg>
               <p>On the other hand, in the following example it is not possible to determine
                  statically whether the operand of <elcode>xsl:number</elcode> will have a suitable dynamic type. An
                  implementation <rfc2119>may</rfc2119> produce a warning in such cases, but it
                     <rfc2119>must not</rfc2119> treat it as an error.</p>
               <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:template match="para"&gt;
  &lt;xsl:param name="p" as="item()"/&gt;
  &lt;xsl:number select="$p"/&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <p>If more than one error arises, an implementation is not <rfc2119>required</rfc2119>
               to signal any errors other than the first one that it detects. It is <termref def="dt-implementation-dependent">implementation-dependent</termref> which of the
               several errors is signaled. This applies both to static errors and to dynamic errors.
               An implementation is allowed to signal more than one error, but if any errors have
               been signaled, it <rfc2119>must not</rfc2119> finish as if the transformation were
               successful.</p>
            <p>When a transformation signals one or more dynamic errors, the final state of any
               persistent resources updated by the transformation is <termref def="dt-implementation-dependent">implementation-dependent</termref>.
               Implementations are not <rfc2119>required</rfc2119> to restore such resources to
               their initial state. In particular, where a transformation produces multiple result
               documents, it is possible that one or more serialized result documents
                  <rfc2119>may</rfc2119> be written successfully before the transformation
               terminates, but the application cannot rely on this behavior.</p>
            <p>Everything said above about error handling applies equally to errors in evaluating
               XSLT instructions, and errors in evaluating XPath <termref def="dt-expression">expressions</termref>. Static errors and dynamic errors may occur in both
               cases.</p>
            <p>
               <termdef id="dt-serialization-error" term="serialization error">If a transformation
                  has successfully produced a <termref def="dt-principal-result"/> or <termref def="dt-secondary-result"/>, it is
                     still possible that errors may occur in serializing that result
                  . For example, it may be impossible to
                  serialize the result  using the
                  encoding selected by the user. Such an error is referred to as a
                     <term>serialization error</term>.</termdef> If the processor performs
               serialization, then it <rfc2119>must</rfc2119> do so as specified in <specref ref="serialization"/>, and in particular it <rfc2119>must</rfc2119> signal any
               serialization errors that occur.</p>
            <p>Errors are identified by a QName. For errors defined in this specification, the
               namespace of the QName is always <code>http://www.w3.org/2005/xqt-errors</code> (and
               is therefore not given explicitly), while the local part is an 8-character code in
               the form <var>PPSSNNNN</var>. Here <var>PP</var> is always <code>XT</code> (meaning
               XSLT), and <var>SS</var> is one of <code>SE</code> (static error), <code>DE</code>
               (dynamic error),  or <code>TE</code>
               (type error). Note that the allocation of an error to one of these categories is
               purely for convenience and carries no normative implications about the way the error
               is handled. Many errors, for example, can be reported either dynamically or
               statically. These error codes are used to label error conditions in this
               specification, and are summarized in <specref ref="error-summary"/>. </p>
            <p>Errors defined in related specifications (<bibref ref="xpath-40"/>, <bibref ref="xpath-functions-40"/>
               <bibref ref="xslt-xquery-serialization-30"/>) use QNames with a similar structure, in
               the same namespace. When errors occur in processing XPath expressions, an XSLT
               processor <rfc2119>should</rfc2119> use the original error code reported by the XPath
               processor, unless a more specific XSLT error code is available.</p>
            <p>Implementations <rfc2119>must</rfc2119> use the codes
               defined in these specifications when signaling dynamic errors, to ensure that
                     <elcode>xsl:catch</elcode> behaves in an interoperable way across
                  implementations. Stylesheet authors should note, however, that there are many
                  examples of errors where more than one rule in this specification is violated, and
                  where the processor therefore has discretion in deciding which error code to
                  associate with the condition: there is therefore no guarantee that different
                  processors will always use the same error code for the same erroneous
                  input.</p>
            <p>Additional errors defined by an implementation (or by an application)
                  <rfc2119>may</rfc2119> use QNames in an implementation-defined (or user-defined)
               namespace without risk of collision.</p>

         </div2>
      </div1>
      <div1 id="stylesheet-structure">
         <head>Stylesheet Structure</head>
         <p>This section describes the overall structure of a stylesheet as a collection of XML
            documents.</p>
         <div2 id="xslt-namespace">
            <head>XSLT Namespace</head>
            <p>
               <termdef id="dt-xslt-namespace" term="XSLT namespace">The <term>XSLT namespace</term>
                  has the URI <code>http://www.w3.org/1999/XSL/Transform</code>. It is used to
                  identify elements, attributes, and other names that have a special meaning defined
                  in this specification.</termdef>
            </p>
            <note>
               <p>The <code>1999</code> in the URI indicates the year in which the URI was allocated
                  by the W3C. It does not indicate the version of XSLT being used, which is
                  specified by attributes (see <specref ref="stylesheet-element"/> and <specref ref="simplified-stylesheet"/>).</p>
            </note>
            <p>XSLT <termref def="dt-processor">processors</termref>
               <rfc2119>must</rfc2119> use the XML namespaces mechanism <bibref ref="xml-names"/> to
               recognize elements and attributes from this namespace. Elements from the XSLT
               namespace are recognized only in the <termref def="dt-stylesheet">stylesheet</termref> and not in the source document. The complete list of
               XSLT-defined elements is specified in <specref ref="element-syntax-summary"/>.
                  <termref def="dt-implementation">Implementations</termref>
               <rfc2119>must not</rfc2119> extend the XSLT namespace with additional elements or
               attributes. Instead, any extension <rfc2119>must</rfc2119> be in a separate
               namespace. Any namespace that is used for additional instruction elements
                  <rfc2119>must</rfc2119> be identified by means of the <termref def="dt-extension-instruction">extension instruction</termref> mechanism specified
               in <specref ref="extension-instruction"/>.</p>
            
            <p>Except where the rules for <termref def="dt-forwards-compatible-behavior"/>
                  dictate otherwise, it is a <termref def="dt-static-error">static error</termref>
                  for any element in the stylesheet to be in the XSLT namespace unless it is an element defined in this
                  specification <errorref spec="XT" class="SE" code="0010"/>.</p>
            
            <p>This specification uses a prefix of <code>xsl:</code> for referring to elements in
               the XSLT namespace. However, XSLT stylesheets are free to use any prefix, provided
               that there is a namespace declaration that binds the prefix to the URI of the XSLT
               namespace.</p>
            <note>
               <p>Throughout this specification, an element or attribute that is in no namespace, or
                  an <termref def="dt-expanded-qname">expanded QName</termref> whose namespace part
                  is an empty sequence, is referred to as having a <term>null namespace
                  URI</term>.</p>
            </note>
            <note>
               <p>By convention, the names of <termref def="dt-xslt-element">XSLT
                     elements</termref>, attributes and functions are all lower-case;
                  they use hyphens to separate words, and they use abbreviations only if these already appear
                  in the syntax of a related language such as XML or HTML. Names of types defined in
                  XML Schema are regarded as single words and are capitalized exactly as in XML
                  Schema. This sometimes leads to composite function names such as
                     <xfunction>current-dateTime</xfunction>.</p>
            </note>
         </div2>

         <div2 id="extension-attributes">
            <head>Extension Attributes</head>
            <p>
               <termdef id="dt-extension-attribute" term="extension attribute">An element from the
                  XSLT namespace may have any attribute not from the XSLT namespace, provided that
                  the <termref def="dt-expanded-qname">expanded QName</termref> (see <bibref ref="xpath-30"/>) of the attribute has a non-null namespace URI. These
                  attributes are referred to as <term>extension attributes</term>.</termdef> The
               presence of an extension attribute <rfc2119>must not</rfc2119> cause the <termref def="dt-principal-result"/> or any <termref def="dt-secondary-result"/> of the transformation to be different from the
                  results
                that a conformant XSLT 4.0
               processor might produce. They <rfc2119>must not</rfc2119> cause the processor to fail
               to signal an error that a conformant processor is required to signal. This means that
               an extension attribute <rfc2119>must not</rfc2119> change the effect of any <termref def="dt-instruction">instruction</termref> except to the extent that the effect is
                  <termref def="dt-implementation-defined">implementation-defined</termref> or
                  <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p>
            <p>Furthermore, if serialization is performed using one of the serialization methods
                   described in <bibref ref="xslt-xquery-serialization-30"/>, the presence of an extension attribute must
               not cause the serializer to behave in a way that is inconsistent with the mandatory
               provisions of that specification.</p>
            <note>
               <p>
                  <termref def="dt-extension-attribute">Extension attributes</termref> may be used
                  to modify the behavior of <termref def="dt-extension-function">extension
                     functions</termref> and <termref def="dt-extension-instruction">extension
                     instructions</termref>. They may be used to select processing options in cases
                  where the specification leaves the behavior <termref def="dt-implementation-defined">implementation-defined</termref> or <termref def="dt-implementation-dependent">implementation-dependent</termref>. They may
                  also be used for optimization hints, for diagnostics, or for documentation.</p>
               <p>
                  <termref def="dt-extension-attribute">Extension attributes</termref> may also be
                  used to influence the behavior of the serialization methods <code>xml</code>,
                     <code>xhtml</code>, <code>html</code>, or <code>text</code>, to the extent that
                  the behavior of the serialization method is <termref def="dt-implementation-defined"/> or <termref def="dt-implementation-dependent">implementation-dependent</termref>. For example, an extension attribute might
                  be used to define the amount of indentation to be used when
                     <code>indent="yes"</code> is specified. If a serialization method other than
                  one of these four is requested (using a prefixed QName in the method parameter)
                  then extension attributes may influence its behavior in arbitrary ways. Extension
                  attributes must not be used to cause the  standard serialization methods to
                  behave in a non-conformant way, for example by failing to report serialization
                  errors that a serializer is required to report. An implementation that wishes to
                  provide such options must create a new serialization method for the purpose.</p>
               <p>An implementation that does not recognize the name of an extension attribute, or
                  that does not recognize its value, must perform the transformation as if the
                  extension attribute were not present. As always, it is permissible to produce
                  warning messages.</p>
               <p>The namespace used for an extension attribute will be copied to the <termref def="dt-result-tree">result tree</termref> in the normal way if it is in scope
                  for a <termref def="dt-literal-result-element">literal result element</termref>.
                  This can be prevented using the <code>[xsl:]exclude-result-prefixes</code>
                  attribute.</p>
            </note>
            <example>
               <head>An Extension Attribute for <code>xsl:message</code>
               </head>
               <p>The following code might be used to indicate to a particular implementation that
                  the <elcode>xsl:message</elcode> instruction is to ask the user for confirmation
                  before continuing with the transformation:</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:message abc:pause="yes"
    xmlns:abc="http://vendor.example.com/xslt/extensions"&gt;
       Phase 1 complete
&lt;/xsl:message&gt;
</eg>
               <p>Implementations that do not recognize the namespace
                     <code>http://vendor.example.com/xslt/extensions</code> will simply ignore the
                  extra attribute, and evaluate the <elcode>xsl:message</elcode> instruction in the
                  normal way.</p>
            </example>
            <p>
               <error spec="XT" type="static" class="SE" code="0090">
                  <p>It is a <termref def="dt-static-error">static error</termref> for an element
                     from the XSLT namespace to have an attribute whose namespace is either null
                     (that is, an attribute with an unprefixed name) or the XSLT namespace, other
                     than attributes defined for the element in this document.</p>
               </error>
            </p>
         </div2>
         <div2 id="xslt-media-type">
            <head>XSLT Media Type</head>
            <p>The media type <code>application/xslt+xml</code>
               has been registered for XSLT stylesheet
               modules.</p>
            <p>The definition of the media type is at <bibref ref="XSLT-Mime-Type"/>.</p>
            <p>This media type <rfc2119>should</rfc2119> be used for an XML document containing a
                  <termref def="dt-standard-stylesheet-module">standard stylesheet module</termref>
               at its top level, and it <rfc2119>may</rfc2119> also be used for a <termref def="dt-simplified-stylesheet-module">simplified stylesheet module</termref>. It
                  <rfc2119>should not</rfc2119> be used for an XML document containing an <termref def="dt-embedded-stylesheet-module">embedded stylesheet module</termref>.</p>
         </div2>
         <div2 id="standard-attributes">
            <head>Standard Attributes</head>
            <p>
               <termdef id="dt-standard-attributes" term="standard attributes">There are a number of
                     <term>standard attributes</term> that may appear on any <termref def="dt-xslt-element">XSLT element</termref>: specifically
                     <code>default-collation</code>, 
                     <code diff="add" at="2022-01-01">default-element-namespace</code>, 
                     <code>default-mode</code>,
                     <code diff="add" at="2022-01-01">default-type-namespace</code>, 
                     <code>default-validation</code>,
                     <code>exclude-result-prefixes</code>, <code>expand-text</code>, <code>extension-element-prefixes</code>,
                     <code>use-when</code>, <code>version</code>, and
                     <code>xpath-default-namespace</code>.</termdef>
            </p>
            <p>These attributes may also appear on a <termref def="dt-literal-result-element">literal result element</termref>, but in this case, to distinguish them from
               user-defined attributes, the names of the attributes are in the <termref def="dt-xslt-namespace">XSLT namespace</termref>. They are thus typically written
               as <code>xsl:default-collation</code>,
               <code diff="add" at="2022-01-01">xsl:default-element-namespace</code>,
               <code>xsl:default-mode</code>, 
               <code diff="add" at="2022-01-01">xsl:default-type-namespace</code>,
               <code>xsl:default-validation</code>,
                  <code>xsl:exclude-result-prefixes</code>, <code>xsl:expand-text</code>, 
               <code>xsl:extension-element-prefixes</code>, <code>xsl:use-when</code>,
                  <code>xsl:version</code>, or <code>xsl:xpath-default-namespace</code>.</p>
            <p>It is <rfc2119>recommended</rfc2119> that all these attributes should also be
               permitted on <termref def="dt-extension-instruction">extension
               instructions</termref>, but this is at the discretion of the implementer of each
               extension instruction. They <rfc2119>may</rfc2119> also be permitted on <termref def="dt-data-element">user-defined data elements</termref>, though they will only
               have any useful effect in the case of data elements that are designed to behave like
               XSLT declarations or instructions.</p>
            <p>In the following descriptions, these attributes are referred to generically as
                  <code>[xsl:]version</code>, and so on.</p>
            <p>These attributes all affect the element they appear on, together with any elements
               and attributes that have that element as an ancestor. The two forms with and without
               the XSLT namespace have the same effect; the XSLT namespace is used for the attribute
               if and only if its parent element is <emph>not</emph> in the XSLT namespace.</p>
            <p>In the case of <code>[xsl:]default-collation</code>, 
               <code diff="add" at="2022-01-01">[xsl:]default-element-namespace</code>,
               <code diff="add" at="2022-01-01">[xsl:]default-type-namespace</code>, 
               <code>[xsl:]expand-text</code>, 
               <code>[xsl:]version</code>, and <code>[xsl:]xpath-default-namespace</code>, the value
               can be overridden by a different value for the same attribute appearing on a
               descendant element. The <termref def="dt-effective-value"/> of the attribute for a particular stylesheet
               element is determined by the innermost ancestor-or-self element on which the
               attribute appears.</p>
            <p>In an <termref def="dt-embedded-stylesheet-module">embedded stylesheet
                  module</termref>, <termref def="dt-standard-attributes">standard
                  attributes</termref> appearing on ancestors of the outermost element of the
               stylesheet module have no effect.</p>
            <p>In the case of <code>[xsl:]exclude-result-prefixes</code> and
                  <code>[xsl:]extension-element-prefixes</code> the values are cumulative. For these
               attributes, the value is given as a whitespace-separated list of namespace prefixes,
               and the <termref def="dt-effective-value"/> for an element is the combined set of namespace URIs
               designated by the prefixes that appear in this attribute for that element and any of
               its ancestor elements. Again, the two forms with and without the XSLT namespace are
               equivalent.</p>
            <p>The effect of the <code>[xsl:]use-when</code> attribute is described in <specref ref="conditional-inclusion"/>.</p>
            <p>Because these attributes may appear on any <termref def="dt-xslt-element">XSLT
                  element</termref>, they are not listed in the syntax summary of each individual
               element. Instead they are listed and described in the entry for the
                  <elcode>xsl:stylesheet</elcode>, <elcode>xsl:transform</elcode>, and <elcode>xsl:package</elcode> elements only. This
               reflects the fact that these attributes are often used on the outermost element of the stylesheet, in which case they apply to
               the entire <termref def="dt-stylesheet-module"/>
               or <termref def="dt-package-manifest"/>.</p>
            <p>Note that the effect of these attributes does <emph>not</emph> extend to <termref def="dt-stylesheet-module">stylesheet modules</termref> referenced by
                  <elcode>xsl:include</elcode> or <elcode>xsl:import</elcode> declarations, nor to packages referenced using
                     <elcode>xsl:use-package</elcode>.</p>
            <p>For the detailed effect of each attribute, see the following sections:</p>
            <glist>
               <gitem>
                  <label>
                     <code>[xsl:]default-collation</code>
                  </label>
                  <def>
                     <p>see <specref ref="default-collation-attribute"/>
                     </p>
                  </def>
               </gitem>
               <gitem diff="add" at="2022-01-01">
                  <label>
                     <code>[xsl:]default-element-namespace</code>
                  </label>
                  <def>
                     <p>see <specref ref="unprefixed-qnames"/>
                     </p>
                  </def>
               </gitem>
               
               <gitem>
                  <label>
                     <code>[xsl:]default-mode</code>
                  </label>
                  <def>
                     <p>see <specref ref="default-mode"/>
                     </p>
                  </def>
               </gitem>
               <gitem diff="add" at="2022-01-01">
                  <label>
                     <code>[xsl:]default-type-namespace</code>
                  </label>
                  <def>
                     <p>see <specref ref="unprefixed-qnames"/>
                     </p>
                  </def>
               </gitem>
               <gitem>
                  <label>
                     <code>[xsl:]default-validation</code>
                  </label>
                  <def>
                     <p>see <specref ref="validation"/>
                     </p>
                  </def>
               </gitem>
               <gitem>
                  <label>
                     <code>[xsl:]exclude-result-prefixes</code>
                  </label>
                  <def>
                     <p>see <specref ref="lre-namespaces"/>
                     </p>
                  </def>
               </gitem>
               <gitem>
                  <label>
                     <code>[xsl:]expand-text</code>
                  </label>
                  <def>
                     <p>see <specref ref="text-value-templates"/>
                     </p>
                  </def>
               </gitem>
               <gitem>
                  <label>
                     <code>[xsl:]extension-element-prefixes</code>
                  </label>
                  <def>
                     <p>see <specref ref="extension-instruction"/>
                     </p>
                  </def>
               </gitem>
               <gitem>
                  <label>
                     <code>[xsl:]use-when</code>
                  </label>
                  <def>
                     <p>see <specref ref="conditional-inclusion"/>
                     </p>
                  </def>
               </gitem>
               <gitem>
                  <label>
                     <code>[xsl:]version</code>
                  </label>
                  <def>
                     <p>see <specref ref="backwards"/> and <specref ref="forwards"/>
                     </p>
                  </def>
               </gitem>
               <gitem>
                  <label>
                     <code>[xsl:]xpath-default-namespace</code>
                  </label>
                  <def>
                     <p>see <specref ref="unprefixed-qnames"/>
                     </p>
                  </def>
               </gitem>

            </glist>
         </div2>
         <div2 id="packages">
            <head>Packages</head>

            <p><termdef id="dt-package" term="package">An explicit <term>package</term> is
                  represented by an <elcode>xsl:package</elcode> element, which will generally be
                  the outermost element of an XML document. When the
                        <elcode>xsl:package</elcode> element is not used explicitly, the entire
                     stylesheet comprises a single implicit package.</termdef> (This
               specification does not preclude the <elcode>xsl:package</elcode> being embedded in
               another XML document, but it will never have any other XSLT element as an
               ancestor).</p>

            <?element xsl:package?>

            <p><termdef id="dt-package-manifest" term="package manifest">The content of the
                     <elcode>xsl:package</elcode> element is referred to as the <term>package
                     manifest</term></termdef>.</p>

            <p>The <code>version</code> attribute indicates the
               version of the XSLT language specification to which the package manifest conforms.
                  The value <rfc2119>should</rfc2119> normally be
                     <phrase diff="chg" at="2023-02-24"><code>4.0</code></phrase>. 
               If the value is numerically less than <phrase diff="chg" at="2023-02-24"><code>4.0</code></phrase>, the
                  content of the <elcode>xsl:package</elcode> element is processed using the rules
                  for <termref def="dt-backwards-compatible-behavior">backwards compatible
                     behavior</termref> (see <specref ref="backwards"/>). If the value is
               numerically greater than <phrase diff="chg" at="2023-02-24"><code>4.0</code></phrase>, it is processed using the rules for
                     <termref def="dt-forwards-compatible-behavior"/> (see <specref ref="forwards"/>).</p>


            <p>A package typically has a name, given in its <code>name</code>
               attribute, which <rfc2119>must</rfc2119> be an absolute URI. Unnamed packages are
               allowed, but they can only be used as the “top level” of an application; they cannot
               be the target of an <elcode>xsl:use-package</elcode> declaration in another
               package.</p>

            <p>A package may have a version identifier, given in
               its <code>package-version</code> attribute. This is used to distinguish different
               versions of a package. The value of the version
                  attribute, after trimming leading and trailing whitespace, <rfc2119>must</rfc2119>
                  conform to the syntax given in <specref ref="package-versions"/>. If no version
                  number is specified for a package, version <code>1</code> is assumed.</p>

            <p>The attributes <code>default-collation</code>, <code>default-mode</code>, <code>default-validation</code>,
                  <code>exclude-result-prefixes</code>, <code>expand-text</code>,
                  <code>extension-element-prefixes</code>, <code>use-when</code>,
                  <code>version</code>, and <code>xpath-default-namespace</code> are standard
               attributes that can appear on any XSLT element, and potentially affect all descendant
               elements. Their meaning is described in <specref ref="standard-attributes"/>.</p>

            <p>The package manifest contains the following
                  elements, arbitrarily ordered:</p>
            <olist>
               <item>
                  <p>Zero or more <elcode>xsl:expose</elcode> declarations that define the interface
                     offered by this package to the outside world. An <elcode>xsl:expose</elcode>
                  declaration may appear only as a child of <elcode>xsl:package</elcode>.</p>
               </item>
               <item>
                  <p>Zero or more additional <termref def="dt-declaration">declarations</termref>.
                     These are the same as the declarations permitted as children of <elcode>xsl:stylesheet</elcode>
                     or <elcode>xsl:transform</elcode>.</p> 
                  <p>Some declarations of particular relevance to packages include:</p>
                  <olist>
                     <item><p>The <elcode>xsl:use-package</elcode> declaration, which declares the names and
                     versions of the packages on which this package is dependant.</p></item>
                     <item>
                        <p>The optional <elcode>xsl:global-context-item</elcode> element; if present this
                           element defines constraints on the existence and type of the <termref def="dt-global-context-item"/>.</p>
                     </item>
                     <item><p>Zero or more <elcode>xsl:include</elcode> and <elcode>xsl:import</elcode>
                     declarations, which define additional stylesheet modules to be incorporated into this package.</p></item>
                     <item><p>Zero or more ordinary <termref def="dt-declaration">declarations</termref>, that is,
                        elements that are permitted as children of <elcode>xsl:stylesheet</elcode> or
                        <elcode>xsl:transform</elcode>. One possible coding style is to include in
                        the package manifest just a single <elcode>xsl:import</elcode> or
                        <elcode>xsl:include</elcode> declaration as a reference to the effective
                        top-level stylesheet module; this approach is particularly suitable when
                        writing code that is required to run under releases of XSLT 
                        <phrase diff="add" at="2023-02-24">earlier than 3.0</phrase>. 
                        Another approach is to include the substance of the top-level
                        stylesheet module inline within the package manifest.</p></item>
                  </olist>
               </item>

            </olist>

            <example>
               <head>An example package</head>
               <p>The following example shows a package that offers a number of functions for
                  manipulating complex numbers. A complex number is represented as a map with two
                  entries, the keys being 0 for the real part, and 1 for the imaginary part.</p>
               

               <eg role="xslt-document" xml:space="preserve">
&lt;xsl:package
  name="http://example.org/complex-arithmetic.xsl"
  package-version="1.0"
  version="3.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:f="http://example.org/complex-arithmetic.xsl"&gt;
  
  &lt;xsl:function name="f:complex-number" 
                as="map(xs:integer, xs:double)" visibility="public"&gt;
    &lt;xsl:param name="real" as="xs:double"/&gt;
    &lt;xsl:param name="imaginary" as="xs:double"/&gt;
    &lt;xsl:sequence select="map{ 0:$real, 1:$imaginary }"/&gt;
  &lt;/xsl:function&gt;
  
  &lt;xsl:function name="f:real" 
                as="xs:double" visibility="public"&gt;
    &lt;xsl:param name="complex" as="map(xs:integer, xs:double)"/&gt;
    &lt;xsl:sequence select="$complex(0)"/&gt;
  &lt;/xsl:function&gt;
  
  &lt;xsl:function name="f:imag" 
                as="xs:double" visibility="public"&gt;
    &lt;xsl:param name="complex" as="map(xs:integer, xs:double)"/&gt;
    &lt;xsl:sequence select="$complex(1)"/&gt;
  &lt;/xsl:function&gt;
  
  &lt;xsl:function name="f:add" 
                as="map(xs:integer, xs:double)" visibility="public"&gt;
    &lt;xsl:param name="x" as="map(xs:integer, xs:double)"/&gt;
    &lt;xsl:param name="y" as="map(xs:integer, xs:double)"/&gt;
    &lt;xsl:sequence select="
         f:complex-number(
           f:real($x) + f:real($y), 
           f:imag($x) + f:imag($y))"/&gt;
  &lt;/xsl:function&gt;
  
  &lt;xsl:function name="f:multiply" 
                as="map(xs:integer, xs:double)" visibility="public"&gt;
    &lt;xsl:param name="x" as="map(xs:integer, xs:double)"/&gt;
    &lt;xsl:param name="y" as="map(xs:integer, xs:double)"/&gt;
    &lt;xsl:sequence select="
         f:complex-number(
           f:real($x)*f:real($y) - f:imag($x)*f:imag($y),
           f:real($x)*f:imag($y) + f:imag($x)*f:real($y))"/&gt;
  &lt;/xsl:function&gt;
  
  &lt;!-- etc. --&gt;
  
&lt;/xsl:package&gt;</eg>

               <p>A more complex package might include private or abstract functions as well as
                  public functions; it might expose components other than functions (for example,
                  templates or global variables), and it might contain
                     <elcode>xsl:use-package</elcode> elements to allow it to call on the services
                  of other packages.</p>

               <note>
                  <p>In this example, the way in which complex numbers are represented is exposed to
                     users of the package. It would be possible to hide the representation by
                     declaring the types on public functions simply as <code>item()</code>; but this
                     would be at the cost of type safety.</p>
               </note>
            </example>



            <p>A package that does not itself expose any components  may be written
               using a simplified syntax: the <elcode>xsl:package</elcode> element is omitted, and
               the <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element is now
               the outermost element of the stylesheet module. For compatibility reasons, all the
               named templates and modes declared in the package are made public. More formally, the
               principal stylesheet module of the <termref def="dt-top-level-package">top-level
                  package</termref> may be expressed as an <elcode>xsl:stylesheet</elcode> or
                  <elcode>xsl:transform</elcode> element, which is equivalent to the package represented
               by the output of the following transformation, preserving the base URI of the
               source:</p>

            <eg role="xslt-document" xml:space="preserve">
 &lt;xsl:transform version="3.0" 
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:t="http://www.w3.org/1999/XSL/TransformAlias"&gt;
 
    &lt;xsl:namespace-alias stylesheet-prefix="t" result-prefix="xsl"/&gt;
    
    &lt;xsl:template match="xsl:stylesheet|xsl:transform"&gt;
      &lt;t:package declared-modes="no"&gt;
        &lt;xsl:copy-of select="@*"/&gt;
        &lt;t:expose component="mode" names="*" visibility="public"/&gt;
        &lt;t:expose component="template" names="*" visibility="public"/&gt;
        &lt;xsl:copy-of select="node()"/&gt;
      &lt;/t:package&gt;
    &lt;/xsl:template&gt;
 &lt;/xsl:transform&gt;
       </eg>

            <p>The effect of the <code>input-type-annotations</code>
               attribute is defined in <specref ref="stripping-annotations"/>.</p>


            <p>A more extensive example of a package, illustrating how components
               in a package can be overridden in a client package, is given in <specref ref="packages-csv-library-example"/>.</p>


            <div3 id="package-versions">
               <head>Versions of a Package</head>

               <p>If a package has a version number, the version number must conform to the
                  grammar:</p>

               <eg role="non-xml" xml:space="preserve">
        PackageVersion   ::= NumericPart ( "-" NamePart )?
        NumericPart      ::= IntegerLiteral ( "." IntegerLiteral )*
        NamePart         ::= NCName
               </eg>

 

               <p>Here <xnt ref="prod-xpath40-IntegerLiteral" spec="XP40">IntegerLiteral</xnt> and <code>NCName</code> are as defined in
                  the XPath <phrase diff="chg" at="2023-02-24">4.0</phrase> grammar productions of the same name (including rules on
                     limits). Leading and trailing whitespace is ignored; no other
                  whitespace is allowed.</p>
               <p>Examples of valid version numbers are <code>2.0.5</code> or
                     <code>3.10-alpha</code>.</p>
               <p><termdef id="dt-portion" term="portion">The integer literals and the optional
                        <code>NamePart</code> within the version number are referred to as the
                        <term>portions</term> of the version number.</termdef></p>

               <note>
                  <p>This means that <code>1-alpha-2</code> is a valid version number, with two
                        <termref def="dt-portion">portions</termref>: <code>1</code> and
                        <code>alpha-2</code>. The second hyphen is part of the <code>NCName</code>,
                     it does not act as a portion separator.</p>
               </note>

               <p>Versions are ordered. When comparing two versions:</p>
               <olist>
                  <item>
                     <p>Trailing zero <termref def="dt-portion">portions</termref> (that is, any
                        zero-valued integer that is not followed by another integer) are
                        discarded.</p>
                  </item>
                  <item>
                     <p>Comparison proceeds by comparing <termref def="dt-portion">portions</termref> pairwise from the left.</p>
                  </item>
                  <item>
                     <p>If both versions have the same number of <termref def="dt-portion">portions</termref> and all <termref def="dt-portion">portions</termref>
                        compare equal (under the rules of the
                           XPath <code>eq</code> operator using the Unicode codepoint
                           collation), then the versions compare equal.</p>
                  </item>
                  <item>
                     <p>If the number of <termref def="dt-portion">portions</termref> in the two
                        versions <var>V1</var> and <var>V2</var> is <var>N1</var> and <var>N2</var>,
                        with <var>N1</var>&lt;<var>N2</var>, and if all <termref def="dt-portion">portions</termref> in positions 1 to <var>N</var> compare equal, then
                           <var>V1</var> is less than <var>V2</var> if the <termref def="dt-portion"/> of <var>V2</var> in position <var>N1+1</var> is an integer, and is
                        greater than <var>V2</var> if this <termref def="dt-portion"/> is an
                           <code>NCName</code>. For example, <code>1.2</code> is less than
                           <code>1.2.5</code>, while <code>2.0</code> is greater than
                           <code>2.0-rc1</code>.</p>
                  </item>
                  <item>
                     <p><termref def="dt-portion">Portions</termref> are compared as follows:</p>
                     <olist>
                        <item>
                           <p>If both <termref def="dt-portion">portions</termref> are integers,
                              they are compared using the rules
                                 of XPath value comparisons.</p>
                        </item>
                        <item>
                           <p>If both <termref def="dt-portion">portions</termref> are NCNames, they
                              are compared using the rules of
                                 XPath value comparisons, using the Unicode Codepoint
                              Collation.</p>
                        </item>
                        <item>
                           <p>If one <termref def="dt-portion"/> is an integer and the other is an
                                 <code>NCName</code>, the <code>NCName</code> comes first.</p>
                        </item>
                     </olist>
                  </item>

               </olist>

               <p>For example, the following shows a possible ordered sequence of version
                  numbers:</p>

               <eg role="non-xml" xml:space="preserve">0-rc1 &lt; 0-rc2 &lt; 0 &lt; 1 = 1.0 &lt; 1.0.2 
   &lt; 1.0.3-rc1 &lt; 1.0.3 &lt; 1.0.3.2 &lt; 1.0.10</eg>

               <note>
                  <p>The version number format defined here is designed to be general enough to
                     accommodate a variety of conventions in common use, and to allow useful
                     semantics for matching of versions and ranges of versions, without being
                     over-prescriptive. It is influenced by <bibref ref="SemVer"/>, but is not as
                     prescriptive, and it imposes no assumptions about backwards compatibility of
                     packages between successive versions.</p>
               </note>
               
               <p>Implementations <rfc2119>may</rfc2119> impose limits on the values
               used in a version number (or a version range: see below). Such limits are
               <termref def="dt-implementation-defined"/>. As a minimum, 
               a processor <rfc2119>must</rfc2119> accept version numbers including:</p>
               
               <ulist>
                  <item><p>A numeric part containing four integers;</p></item>
                  <item><p>Each integer being in the range 0 to 999999;</p></item>
                  <item><p>An <code>NCName</code> of up to 100 characters</p></item>
               </ulist>

               <p>Dependencies between packages may specify a version range (see <specref ref="package-dependencies"/>). A version range represents a set of accepted
                  versions. The syntax of a version range is
                     shown below. Whitespace is permitted only where indicated, using the terminal
                     symbol <var>S</var>.</p>

               <eg role="non-xml" xml:space="preserve">
        PackageVersionRange    ::=  AnyVersion | VersionRanges
        AnyVersion             ::=  "*"
        VersionRanges          ::=  VersionRange (S? "," S? VersionRange)*
        VersionRange           ::=  PackageVersion | VersionPrefix | 
                                      VersionFrom | VersionTo | VersionFromTo
        VersionPrefix          ::=  PackageVersion ".*"
        VersionFrom            ::=  PackageVersion "+"
        VersionTo              ::=  "to" S (PackageVersion | VersionPrefix)
        VersionFromTo          ::=  PackageVersion S "to" S (PackageVersion | VersionPrefix)     
               </eg>

               

               <p>The meanings of the various forms of version range are
                  defined below:</p>

               <ulist>
                  <item>
                     <p>The range <code>AnyVersion</code> matches any version.</p>
                  </item>

                  <item>
                     <p>The range <code>VersionRanges</code> matches a version if any constituent
                           <code>VersionRange</code> matches that version.</p>
                     <p>For example, <code>9.5.0.8, 9.6.1.2</code>
                        matches those specific versions only, while <code>9.5.0.8, 9.6+</code>
                        matches either version 9.5.0.8 or any version from 9.6 onwards.</p>
                  </item>

                  <item>
                     <p>A range that is a <code>PackageVersion</code> matches that version only.</p>
                  </item>

                  <item>
                     <p>The range <code>VersionPrefix</code> matches any version whose leading
                           <termref def="dt-portion">portions</termref> are the same as the <termref def="dt-portion">portions</termref> in the <code>PackageVersion</code> part of the
                              <code>VersionPrefix</code>.</p>
                     <p>For example, <code>1.3.*</code> matches <code>1.3</code>, 
                           <code>1.3.5</code>,  <code>1.3.10.2</code>,  and
                           <code>1.3-beta</code>
                        (but not <code>1</code> or
                              <code>1.4</code>).</p>

                     <note>
                        <p>The <code>.*</code> indicates that additional <termref def="dt-portion">portions</termref> may follow; it does not indicate a substring match
                           on the final <termref def="dt-portion">portion</termref>. So
                              <code>1.3.*</code> does not match <code>1.35</code>, and
                              <code>3.3-beta.*</code> does not match <code>3.3-beta12</code>. Also,
                              <code>3.3-beta.*</code> does not match <code>3.3-beta.5</code>: this
                           is because the last dot is not a portion separator, but is part of the
                           final <code>NCName</code>. In fact, using <code>.*</code> after a version
                           number that includes an <code>NCName</code> portion is pointless, because
                           an <code>NCName</code> portion can never be followed by further
                           portions.</p>
                     </note>

                  </item>

                  <item>
                     <p>The range <code>VersionFrom</code> matches any version that is greater than
                        or equal to the version supplied.</p>
                     <p>For example <code>1.3+</code> matches
                           <code>1.3</code>,  <code>1.3.2</code>,  <code>1.4</code>, 
                        and <code>2.1</code> (but not <code>1.3-beta</code> or <code>1.2</code>).
                        And <code>1.3-beta+</code> matches <code>1.3-beta</code>, 
                           <code>1.3-gamma</code>,  <code>1.3.0</code>,  <code>1.4</code>,
                        and <code>8.0</code>, but not <code>1.3-alpha</code> or
                        <code>1.2</code>.</p>
                  </item>

                  <item>
                     <p>The range <code>VersionTo</code> matches any version that is less than or
                        equal to some version that matches the <code>VersionPrefix</code>.</p>
                     <p>For example, <code>to 4.0</code> matches <code>1.5</code>, 
                           <code>2.3</code>,  <code>3.8</code>,  <code>4.0</code>, 
                        and <code>4.0-beta</code> (but not <code>4.0.1</code>), while <code>to
                           3.3.*</code> matches <code>1.5</code> or <code>2.0.6</code> or
                           <code>3.3.4621</code>, but not <code>3.4.0</code> or
                           <code>3.4.0-beta</code>. </p>
                  </item>

                  <item>
                     <p>The range <code>VersionFromTo</code> matches any version that is greater
                        than or equal to the starting <code>PackageVersion</code>, and less than or
                        equal to some version that matches the <code>VersionPrefix</code>.</p>
                     <p>For example, <code>1 to 5</code> matches <code>1.1</code>, 
                           <code>2.1</code>,  <code>3.1</code>,  or <code>5.0</code> (but
                        not <code>5.1</code>), while <code>1 to 5.*</code> matches all of these,
                        plus versions such as <code>5.7.2</code> (but not <code>6.0</code> or
                           <code>6.0-beta</code>). Similarly,
                              <code>1.0-beta to 1.0</code> matches <code>1.0-beta</code>,
                              <code>1.0-beta.2</code>, <code>1.0-gamma</code>, and <code>1.0</code>,
                           but not <code>1.0-alpha</code> or <code>1.0.1</code>.</p>
                  </item>

               </ulist>



            </div3>

            <div3 id="package-dependencies">
               <head>Dependencies between Packages</head>

               <p>When <termref def="dt-component">components</termref> in one <termref def="dt-package"/> reference components in another, the dependency of the first
                  package on the second must be represented by an <elcode>xsl:use-package</elcode>
                  element. This may appear in the <termref def="dt-principal-stylesheet-module"/>
               of the first package (which may be a <termref def="dt-package-manifest"/>), or
               it may appear in a <termref def="dt-stylesheet-module"/> that is referenced from
                  the <termref def="dt-principal-stylesheet-module"/> via one or more
               <elcode>xsl:include</elcode> declarations; however it must not be referenced
               via <elcode>xsl:import</elcode> declarations (this is to avoid complications
                     caused by multiple <elcode>xsl:use-package</elcode> declarations with
                     different <termref def="dt-import-precedence"/>).</p>

               <p><termdef id="dt-use" term="use">If a package <var>Q</var> contains an
                        <elcode>xsl:use-package</elcode> element that references package
                        <var>P</var>, then package <var>Q</var> is said to <term>use</term> package
                        <var>P</var>. In this relationship package <var>Q</var> is referred to as
                     the <term>using</term> package, package <var>P</var> as the <term>used</term>
                     package.</termdef></p>

               <p>The phrase <term>directly uses</term> is synonymous with <term>uses</term> as
                  defined above, while <term>directly or indirectly uses</term> refers to the
                  transitive closure of this relationship.</p>



               <?element xsl:use-package?>

               <p>A <termref def="dt-package">package</termref> may be <termref def="dt-use">used</termref> by more than one other package, but the relationship
                     <rfc2119>must not</rfc2119> be cyclic. It is possible, but by no means
                  inevitable, that using the same package in more than one place within a stylesheet
                  will cause static errors due to the presence of conflicting components according
                  to the above rules. Where a package is successfully used by more than one other
                  package, its components may be overridden in different ways by different using
                  packages.</p>



               <p>The <code>name</code> and <code>package-version</code> attributes together
                  identify the used package. The value of the
                        <code>package-version</code> attribute, if present, must conform to the
                     rules for a <code>PackageVersionRange</code> given in <specref ref="package-versions"/>; if omitted the value <code>*</code> is assumed,
                     which matches any version. The used package must have a name that is an exact
                     match for the name in the <code>name</code> attribute (using codepoint
                     comparison), and its explicit or implicit <code>package-version</code> must
                     match the version range given in the <code>package-version</code>
                     attribute.</p>

               

               <p>This specification does not define how the implementation locates a package given
                  its name and version. If several matching
                     versions of a package are available, it does not define which of them is
                     chosen. Nor does it define whether this process locates source code or
                  some other representation of the package contents. Such mechanisms are <termref def="dt-implementation-defined"/>. Use of the package name as a dereferenceable
                  URI is <rfc2119>not recommended</rfc2119>, because the intent of the packaging
                  feature is to allow a package to be distributed as reusable code and therefore to
                  exist in many different locations.</p>

               <imp-def-feature id="idf-api-packageversions">It is <termref def="dt-implementation-defined"/> how a package is located given its name and
                  version, and which version of a package is chosen if several are
                  available.</imp-def-feature>

               <p><error spec="XT" type="static" class="SE" code="3000">
                     <p>It is a <termref def="dt-static-error"/> if no package matching the package
                        name and version specified in an <elcode>xsl:use-package</elcode>
                        declaration can be located.</p>
                  </error></p>

               <p><error spec="XT" type="static" class="SE" code="3005">
                     <p>It is a <termref def="dt-static-error"/> if a package is dependent on
                        itself, where package <var>A</var> is defined as being dependent on package
                           <var>B</var> if <var>A</var> contains an <elcode>xsl:use-package</elcode>
                        declaration that references <var>B</var>, or if <var>A</var> contains an
                           <elcode>xsl:use-package</elcode> declaration that references a package
                           <var>C</var> that is itself dependent on <var>B</var>.</p>
                  </error></p>
               
               <p><error spec="XT" type="static" class="SE" code="3008">
                  <p>It is a <termref def="dt-static-error"/> if an <elcode>xsl:use-package</elcode>
                  declaration appears in a <termref def="dt-stylesheet-module"/> that is not in the
                  same <termref def="dt-stylesheet-level"/> as the <termref def="dt-principal-stylesheet-module"/>
                  of the <termref def="dt-package"/>.</p>
               </error></p>

               <note>
                  <p>Depending on the implementation architecture, there may be a need to locate
                     used packages both during static analysis (for example, to get information
                     about the names and type signatures of the components exposed by the used
                     package), and also at evaluation time (to link to the implementation of these
                     components so they can be invoked). A failure to locate a package may cause an
                     error at either stage.</p>
               </note>



               <p>The <elcode>xsl:accept</elcode> and <elcode>xsl:override</elcode> elements are
                  used to modify the visibility or behavior of components acquired from the used
                  package; they are described in <specref ref="accepting-components"/> below.</p>

               
               
               <note>
                  <p>It is not intrinsically an error to have two 
                  <elcode>xsl:use-package</elcode> declarations that identify the same package
                  (or different versions of the same package). This has the same effect as
                  having two declarations that identify packages with different names but
                  identical content. In most cases it will result in an error (<errorref spec="XT" class="SE" code="3050"/>)
                  due to the presence of multiple components with the same name; but 
                  no error would occur, for example, if the used package is empty, or if the 
                  two <elcode>xsl:use-package</elcode> declarations use <elcode>xsl:accept</elcode>
                  to accept non-overlapping subsets of the components in the used package.</p>
               </note>

            </div3>

            <div3 id="named-components">
               <head>Named Components in Packages</head>

               <p>This section discusses the use of named components in packages.</p>

               <p>The components which can be declared in one package and
                  referenced in another are: <termref def="dt-stylesheet-function">functions</termref>, <termref def="dt-named-template">named
                     templates</termref>, <termref def="dt-attribute-set">attribute sets</termref>,
                     <termref def="dt-mode">modes</termref>,  and <termref def="dt-global-variable">global variables</termref> and <termref def="dt-stylesheet-parameter">parameters</termref>.</p>

               <p>In addition, <termref def="dt-key">keys</termref> and <termref def="dt-accumulator">accumulators</termref>
                  are classified as named components because they can contain references to
                  components in another package, even though they cannot themselves be referenced
                  from outside the package.</p>



               <p>Named and unnamed <termref def="dt-mode">modes</termref> come within the scope of this section, but there are
                  differences noted in <specref ref="modes-and-packages"/>.</p>

               <p>Not all <termref def="dt-declaration">declarations</termref> result in <termref def="dt-component">components</termref>:</p>

               <ulist>
                  <item>
                     <p>Named <termref def="dt-declaration">declarations</termref> that can neither be referenced from outside their
                        containing package, nor can contain references to components in other
                        packages (examples are <elcode>xsl:output</elcode>,
                           <elcode>xsl:character-map</elcode>, and
                           <elcode>xsl:decimal-format</elcode>) are not considered to be components
                        and are therefore outside the scope of this section.</p>
                  </item>
                  <item>
                     <p>Some declarations, such as <elcode>xsl:decimal-format</elcode> and
                           <elcode>xsl:strip-space</elcode>, declare aspects of the processing
                        context which are not considered to be components as defined here.</p>
                  </item>
                  <item>
                     <p><termref def="dt-template-rule">Template rules</termref>
                           (<elcode>xsl:template</elcode> with a <code>match</code> attribute) are
                        also not considered to be components for the purposes of this section, which
                        is concerned only with components that are bound by name. However, when an
                           <elcode>xsl:template</elcode> has both a <code>match</code> attribute and
                        a <code>name</code> attribute, then it establishes both a template rule and
                        a <termref def="dt-named-template">named template</termref>, and in its role
                        as a named template it comes within the scope of this discussion.</p>
                  </item>
                  <item>
                     <p>A named declaration, for example a named template, a function, 
                         or a global
                        variable, may be overridden within the same package by another like-named
                        declaration having higher <termref def="dt-import-precedence">import
                           precedence</termref>. When a declaration is overridden in this way it cannot
                        be referenced by name either from within its containing package or
                        from outside that package. </p>
                  </item>
                  <item>
                     <p>In the case of <elcode>xsl:attribute-set</elcode>
                        and <elcode>xsl:key</elcode> declarations, several declarations combine to
                        form a single component.</p>
                  </item>
               </ulist>

               <p>The section is largely concerned with details of the rules that affect references
                  from one component to another by name, whether the components are in the same
                  package or in different packages. The rules are designed to meet a number of
                  requirements:</p>

               <ulist>
                  <item>
                     <p>A component defined in one package can be overridden by a component in
                        another package, provided the signatures are type-compatible.</p>
                  </item>
                  <item>
                     <p>The author of a package can declare whether the components in the package
                        are public or private (that is, whether or not they can be used from outside
                        the package) and whether they are final, overridable, or abstract (that is
                        whether they can or must be overridden by the using package).</p>
                  </item>
                  <item>
                     <p>Within an application, two packages can make use of a common library and
                        override its components in different ways.</p>
                  </item>
                  <item>
                     <p>Visibility of components can be defined either as part of the declaration of
                        the component, or in the package manifest.</p>
                  </item>
                  <item>
                     <p>An application that wishes to make use of a <termref def="dt-library-package">library package</termref> can be selective about
                        which components from the library it acquires, perhaps to avoid name clashes
                        between components acquired from different libraries.</p>
                  </item>
               </ulist>


               <p><termdef id="dt-component" term="component">The term <term>component</term> is
                     used to refer to any of the following: a <termref def="dt-stylesheet-function">stylesheet function</termref>, a <termref def="dt-named-template">named
                        template</termref>, a <termref def="dt-mode">mode</termref>, an <termref def="dt-accumulator-function">accumulator</termref>, an <termref def="dt-attribute-set">attribute set</termref>, a <termref def="dt-key">key</termref>, <termref def="dt-global-variable">global variable</termref>, or a <termref def="dt-mode">mode</termref>.</termdef></p>

               <p><termdef id="dt-symbolic-identifier" term="symbolic identifier">The <term>symbolic
                        identifier</term> of a <termref def="dt-component">component</termref> is a
                     composite name used to identify the component uniquely within a package. The
                     symbolic identifier comprises the kind of component (stylesheet function, named
                     template, accumulator, attribute set, global
                     variable, key, or mode), the <termref def="dt-expanded-qname">expanded
                        QName</termref> of the component (namespace URI plus local name), and in the
                     case of stylesheet functions, <phrase diff="chg" at="variadicity">the upper
                     bound of the <termref def="dt-arity-range"/></phrase>.</termdef></p>

               <note>
                  <p>In the case of the <termref def="dt-unnamed-mode"/>,
                     the expanded QName of the component may be considered to be some
                     system-allocated name different from any user-defined mode name.</p>
               </note>

               <p><termdef id="dt-homonymous" term="homonymous">Two <termref def="dt-component">components</termref> are said to be <term>homonymous</term> if they have
                     the same <termref def="dt-symbolic-identifier">symbolic
                     identifier</termref>.</termdef></p>

               <p>Every <termref def="dt-component">component</termref> has a <termref def="dt-declaration">declaration</termref> in some <termref def="dt-stylesheet-module"/> and therefore within some <termref def="dt-package">package</termref>. In the
                     case of <termref def="dt-attribute-set">attribute sets</termref> and <termref def="dt-key">keys</termref>, there may be several declarations. The
                  declaration is an element in an XDM tree representing the stylesheet module.
                  Declarations therefore have identity, based on XDM node identity.</p>





               <!--<p><termdef id="dt-original-identity" term="original identity">The <term>original identity</term>
            of a <termref def="dt-component">component</termref> is the XDM node identity of the element
               acting as the <termref def="dt-declaration">declaration</termref> of the component.</termdef></p>-->

               <!--<p>A component is originally declared within one package, and this declaration determines the original
            identity of the component. Each package that directly or indirectly uses this package contains 
            information about the component called a <termref def="dt-component-occurrence">component occurrence</termref>.
            </p>-->

               <p><termdef id="dt-declaring-package" term="declaring package">The <term>declaring
                        package</term> of a <termref def="dt-component">component</termref> is the
                     package that contains the declaration (or,
                        in the case of <elcode>xsl:attribute-set</elcode> and
                           <elcode>xsl:key</elcode>, multiple declarations) of the
                     component.</termdef></p>

               <p>When a <termref def="dt-component">component</termref> declared in one <termref def="dt-package">package</termref> is made available in another, the using
                  package will contain a separate component that can be regarded as a modified copy
                  of the original. The new component shares the same <termref def="dt-symbolic-identifier">symbolic identifier</termref> as the original, and
                  it has the same <termref def="dt-declaration">declaration</termref>, but it has
                  other properties such as its <termref def="dt-visibility">visibility</termref>
                  that may differ from the original.</p>

               <p><termdef id="dt-containing-package" term="containing package">A
                     component declaration results in multiple components, one in the package in
                     which the declaration appears, and potentially one in each package that uses
                     the declaring package, directly or indirectly, subject to the visibility of the
                     component. Each of these multiple components has the same <termref def="dt-declaring-package"/>, but each has a different <term>containing
                        package</term>. For the original component, the declaring package and the
                     containing package are the same; for a copy of a component made as a result of
                     an <elcode>xsl:use-package</elcode> declaration, the declaring package will be
                     the original package, and the containing package will be the package in which
                     the <elcode>xsl:use-package</elcode> declaration appears.</termdef></p>

               <note>
                  <p>Within this specification, we generally use the
                     notation <var>C/P</var> for a component named C whose declaring package and
                     containing package are both <var>P</var>; and the notation <var>C/PQ</var> for
                     a component whose containing package is <var>P</var> and whose declaring
                     package is <var>Q</var> (that is, a component in <var>P</var> that is derived
                     from a component <var>C/Q</var> in the used package <var>Q</var>).</p>
               </note>

               <!--<p><termdef id="dt-component-occurrence" term="component occurrence">A <term>component occurrence</term>
            represents the availability of a particular <termref def="dt-component">component</termref> within a 
            particular <termref def="dt-package">package</termref>; for every component, there is a <term>component occurrence</term>
            of the component in its <termref def="dt-declaring-package">declaring package</termref>, 
               and one in each package that directly or indirectly
            <termref def="dt-use">uses</termref> its declaring package.</termdef></p>-->

               <p>The properties of a <termref def="dt-component">component</termref> are as
                  follows:</p>

               <ulist>
                  <item>
                     <p>The original <termref def="dt-declaration">declaration</termref> of the
                        component.</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-package">package</termref> to which the component
                        belongs (called its <term>containing</term> package, not to be confused with
                        the <termref def="dt-declaring-package">declaring package</termref>).</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-symbolic-identifier">symbolic identifier</termref> of
                        the component.</p>
                  </item>

                  <item>
                     <p>The <termref def="dt-visibility">visibility</termref> of the component,
                        which determines the way in which the component is seen by other components
                        within the same package and within using packages. This is one of
                           <code>public</code>, <code>private</code>, <code>abstract</code>,
                           <code>final</code>, or <code>hidden</code>. The visibility of components
                        is discussed further in <specref ref="visibility"/>.</p>
                  </item>
                  <item>
                     <p>A set of bindings for the <termref def="dt-symbolic-reference">symbolic
                           references</termref> in the component. The way in which these bindings
                        are established is discussed further in <specref ref="component-references"/>.</p>
                  </item>
               </ulist>

               <note>
                  <p>When a function <var>F</var> defined in a package <var>P</var> is acquired by
                     two using packages <var>Q</var> and <var>R</var>, we may think of <var>P</var>,
                     <var>Q</var>, and <var>R</var> as all providing access to the “same”
                     function. The detailed semantics, however, demand an understanding that there
                     is one function declaration, but three components. The three components
                     representing the function <var>F</var> within packages <var>P</var>,
                        <var>Q</var>, and <var>R</var> have some properties in common (the same
                     symbolic identifier, the same declaration), but other properties (the
                     visibility and the bindings of symbolic references) that may vary from one of
                     these components to another.</p>
               </note>


               <p><termdef id="dt-symbolic-reference" term="symbolic reference">The <termref def="dt-declaration">declaration</termref> of a component includes
                     constructs that can be interpreted as references to other <termref def="dt-component">components</termref> by means of their <termref def="dt-symbolic-identifier">symbolic identifiers</termref>. These
                     constructs are generically referred to as <term>symbolic references</term>.
                     Examples of constructs that give rise to symbolic references are the
                        <code>name</code> attribute of <elcode>xsl:call-template</elcode>; the
                        <code>[xsl:]use-attribute-sets</code> attribute of
                     <elcode>xsl:copy</elcode>, <elcode>xsl:element</elcode>, and <termref def="dt-literal-result-element">literal result elements</termref>; the
                        explicit or implicit
                     <code>mode</code> attribute of <elcode>xsl:apply-templates</elcode>; XPath
                     variable references referring to global variables; XPath static function calls (including partial function
                        applications) referring to <termref def="dt-stylesheet-function">stylesheet functions</termref>; and
                        named function references (example: <code>my:f#1</code>) referring to
                        stylesheet functions.
                     </termdef></p>

               <p>Symbolic references exist as properties of the <termref def="dt-declaration">declaration</termref> of a <termref def="dt-component">component</termref>.
                  The <termref def="dt-symbolic-identifier">symbolic identifier</termref> being
                  referred to can be determined straightforwardly from the syntactic form and
                  context of the reference: for example, the instruction <code>&lt;xsl:value-of
                     select="f:price($o)" xmlns:f="http://f.com/"/&gt;</code> contains a symbolic
                  reference to a function with expanded name <code>{http://f.com/}price</code> and
                  with arity=1. However, because there may be several (homonymous) function
                  components with this symbolic identifier, translating this symbolic reference into
                  a reference to a specific component (a process called “binding”) is less
                  straightforward, and is described in the text that follows. </p>

               <p>The process of assembling a stylesheet from its constituent packages is primarily
                  a process of binding these symbolic references to actual components. Within any
                     <termref def="dt-component">component</termref> whose <termref def="dt-declaration">declaration</termref> is <var>D</var>, there is a set of
                  bindings; each binding is an association between a <termref def="dt-symbolic-reference">symbolic reference</termref> in <var>D</var> and a
                     <termref def="dt-component">component</termref> whose <termref def="dt-symbolic-identifier">symbolic identifier</termref> matches the outward
                  reference. Outward references for which a component <var>C</var> contains a
                  binding are said to be <term>bound</term> in <var>C</var>; those for which
                     <var>C</var> contains no binding are said to be <term>unbound</term>.</p>

               <p>For example, suppose that in some package <var>Q</var>, function <var>A</var>
                  calls <var>B</var>, which in turn calls <var>C</var>, and that <var>B</var> is
                     <code>private</code>. Now suppose that in some package <var>P</var> which uses
                     <var>Q</var>, <var>C</var> is overridden. The effect of the binding process is
                  that <var>P</var> will contain three components corresponding to <var>A</var>,
                     <var>B</var>, and <var>C</var>, which we might call <var>A/P</var>,
                     <var>B/P</var>, and <var>C/P</var>. The <termref def="dt-declaration">declarations</termref> of <var>A/P</var> and <var>B/P</var> are in package
                     <var>Q</var>, but the declaration of <var>C/P</var> is in <var>P</var>. The
                  internal visibility of <var>B/P</var> will be <code>hidden</code> (meaning that it
                  cannot be referenced from within <var>P</var>), and <var>B/P</var> will contain a
                  binding for the component <var>C/P</var> that corresponds to the outward reference
                  from <var>B</var> to <var>C</var>. The effect is that when <var>A</var> calls
                     <var>B</var> and <var>B</var> calls <var>C</var>, it is the overriding version
                  of <var>C</var> that is executed.</p>

               <p>In another package <var>R</var> that uses <var>Q</var> without overriding
                     <var>C</var>, there will be three different components <var>A/R</var>,
                     <var>B/R</var>, and <var>C/R</var>. This time the declaration of all three
                  components is in the original package <var>Q</var>. Component <var>B/R</var> will
                  contain a binding to <var>C/R</var>, so in this package, the original version of
                     <var>C</var> is executed. The fact that one package <var>P</var> overrides
                     <var>C</var> thus has no effect on <var>R</var>, which does not override
                  it.</p>

               <p>The binding process outlined above is described in more detail in <specref ref="component-references"/>.</p>

               <p>Template rules are not components in their own right;
                  unlike named templates, they are never referenced by name. Component references
                  within a template rule (for example, references to functions, global variables, or
                  named templates) are treated as occurring within the component that represents the
                  containing mode. This includes component references within the match patterns of
                  template rules. If a template rule lists several modes, it is treated as if there
                  were multiple template rules one in each mode.</p>

               <p>An <elcode>xsl:apply-templates</elcode> instruction
                  with no <code>mode</code> attribute is treated as a reference to the default mode
                  defined for that <termref def="dt-instruction"/> (see <specref ref="default-mode"/>), which in turn defaults to the <termref def="dt-unnamed-mode"/>. An implicit
                  reference to the unnamed made is treated in the same way as any other <termref def="dt-symbolic-reference"/>. Note that there is an unnamed mode in every
                  package, and the unnamed mode always has private visibility.</p>

               <p>Where an <elcode>xsl:template</elcode> element has both
                  a <code>name</code> and a <code>match</code> attribute, it is treated as if there
                  were two separate <elcode>xsl:template</elcode> elements, one with a
                     <code>name</code> attribute and one with a <code>match</code> attribute. </p>

               <p><termref def="dt-key">Keys</termref>
                  and <termref def="dt-accumulator">accumulators</termref> behave rather differently from other
                  components. Their visibility is always private, which means they can only be used
                  within their declaring package. In addition, the component binding is generally
                  made dynamically rather than statically, by
                     virtue of a string passed as an argument to the function
                        <function>key</function>, <function>accumulator-before</function>, or
                        <function>accumulator-after</function>. (In the case of accumulators, there
                     can also be static references: see the <code>use-accumulators</code> attribute
                     of <elcode>xsl:source-document</elcode>, 
                     <elcode>xsl:merge-source</elcode>, and <elcode>xsl:mode</elcode>.) 
                     However, outward references from key
                  definitions and <termref def="dt-accumulator">accumulators</termref> to other components (such as global
                  variables and functions) behave in the same way as component references contained
                  in any other private component, in that they may be re-bound to an overriding
                  declaration of the target component.</p>

               <div4 id="visibility">
                  <head>Visibility of Components</head>


                  <p><termdef id="dt-visibility" term="visibility">The <term>visibility</term> of a
                           <termref def="dt-component">component</termref> is one of:
                           <code>private</code>, <code>public</code>, <code>abstract</code>,
                           <code>final</code>, or <code>hidden</code>.</termdef></p>

                  <p>The meanings of these visibility values is as follows:</p>
                  
                  <glist>
                     <gitem>
                        <label>public</label>
                        <def><p>The component can be referenced from other components in this package
                              or in any using package; it can be overridden by a different component
                              in any using package.</p></def>
                     </gitem>
                     <gitem>
                        <label>private</label>
                        <def><p>The component can be referenced from other components in this
                              package; it cannot be referenced or overridden within a using
                              package.</p></def>
                     </gitem>
                     <gitem>
                        <label>abstract</label>
                        <def><p>The component can be referenced from other components in this package
                              or in any using package; in a using package it can either remain
                              abstract or be overridden by a different component. </p></def>
                     </gitem>
                     <gitem>
                        <label>final</label>
                        <def><p>The component can be referenced from other components in this package
                              or in any using package; it cannot be overridden by a different
                              component in any using package.</p></def>
                     </gitem>
                     <gitem>
                        <label>hidden</label>
                        <def><p>The component cannot be referenced from other components in this
                              package; it cannot be referenced or overridden within a using
                              package.</p></def>
                     </gitem>
                  </glist>

                  <note>
                     <p>The visibility of a component in a package <var>P</var> primarily affects
                        how the component can be used in other packages, specifically, packages that
                        use <var>P</var>. There is one exception: if the visibility is
                           <code>hidden</code>, it also affects how the component can be used within
                           <var>P</var>.</p>
                  </note>

                  <p>When a component is declared within a particular
                     package, its <termref def="dt-visibility">visibility</termref>, which affects
                     how it can be used in other (using) packages, depends on two factors: the value
                     of the <code>visibility</code> declaration on the declaration itself (if
                     present), and the rules given in the <elcode>xsl:expose</elcode> declarations
                     of the package manifest.</p>

                  <p>The <elcode>xsl:function</elcode>, <elcode>xsl:template</elcode>,
                        <elcode>xsl:attribute-set</elcode>, <elcode>xsl:variable</elcode>, 
                      and
                        <elcode>xsl:mode</elcode>
                     <termref def="dt-declaration">declarations</termref> each have an optional
                        <code>visibility</code> attribute. The value is one of <code>private</code>,
                        <code>public</code>, <code>abstract</code>, or <code>final</code> (never
                        <code>hidden</code>). In the case of
                           an <elcode>xsl:param</elcode> element there is no explicit 
                           <code>visibility</code> attribute; rather the declaration has the
                           implicit attribute <code>visibility="public"</code>.</p>

                  <p>Any <elcode>xsl:expose</elcode> declarations that
                     appear as children of <elcode>xsl:package</elcode> define the visibility of
                     components whose declaration has no explicit <code>visibility</code> attribute,
                     and can also be used to reduce the visibility of components where this
                     attribute is present.</p>

                  <?element xsl:expose?>

                  <p>The <elcode>xsl:expose</elcode> element allows the <termref def="dt-visibility"/> of selected components within a package to be defined.</p>

                  <p>The components in question are identified using their <termref def="dt-symbolic-identifier">symbolic identifiers</termref>. The
                        <code>component</code> attribute defines the kind of component that is
                        selected.
                     The value <code>*</code> means “all component kinds”;
                        in this case the value of the <code>names</code> attribute must be a <xnt spec="XP40" ref="prod-xpath40-Wildcard">Wildcard</xnt>.</p>
                  
                  <p>An <elcode>xsl:expose</elcode> declaration has no effect on the 
                     <termref def="dt-unnamed-mode"/>, which is always private to a package.</p>
                     
                     <p>The <code>names</code> attribute selects a subset of these components by name
                     (and in the case of functions, arity); its value is a whitespace-separated
                     sequence of tokens each of which is either a <xnt spec="XP40" ref="prod-xpath40-NameTest">NameTest</xnt> or a <xnt spec="XP40" ref="prod-xpath40-NamedFunctionRef">NamedFunctionRef</xnt>. (Examples are
                        <code>*</code>, <code>p:*</code>, <code>*:local</code>,
                     <code>p:local</code>, and <code>p:local#2</code>.)</p>

                  <p>The value may be a <code>NamedFunctionRef</code> only in the case of stylesheet
                     functions, and distinguishes functions with the same name and different
                     arity. <phrase diff="add" at="2022-01-01">A <xnt spec="XP40" ref="prod-xpath40-NameTest">NameTest</xnt>
                     on its own (that is, with no arity) cannot be used to identify a function. [XSLT 3.0 Erratum E36, bug 30323].</phrase></p>

                  <p>The visibility of a 
                     named template, function, variable, attribute set, or mode
                     declared within a package is the first of the following that applies, subject to consistency
                     constraints which are defined below:</p>

                  <olist>
                     <item>
                        <p>The visibility of a variable declared using
                           an <elcode>xsl:param</elcode> element is
                           always <code>public</code>. No <elcode>xsl:expose</elcode> element
                        ever matches an <elcode>xsl:param</elcode> component.</p>
                        <note><p>Attempting to match an <elcode>xsl:param</elcode> with
                        an explicit <code>EQName</code> will therefore always give an error, while
                        using a wildcard has no effect.</p></note>
                     </item>
                     <item>
                        <p>If the package manifest contains an <elcode>xsl:expose</elcode> element
                           that matches this component by virtue of an explicit <code>EQName</code>
                           or <code>NamedFunctionRef</code> (that is, not by virtue of a wildcard
                           match), then the value of the <code>visibility</code> attribute of the
                           last such <elcode>xsl:expose</elcode> element in document order (call
                           this the <term>explicit exposed visibility</term>).</p>
                     </item>

                     <item>
                        <p>If the declaration of the component has a <code>visibility</code>
                           attribute, then the value of this attribute (call this the <term>declared
                              visibility</term>).</p>
                     </item>

                     <item>
                        <p>If the package manifest contains an <elcode>xsl:expose</elcode> element
                           that matches this component by virtue of a wildcard match that specifies
                           either the namespace part of the component name or the local part of the
                           name (for example, <code>prefix:*</code> or <code>*:local</code> or
                              <code>Q{uri}*</code>), then the value of the <code>visibility</code>
                           attribute of the last such <elcode>xsl:expose</elcode> element in
                           document order.</p>
                     </item>

                     <item>
                        <p>If the package manifest contains an <elcode>xsl:expose</elcode> element
                           that matches this component by virtue of a wildcard match that matches
                           all names (that is, <code>*</code>), then the value of the
                              <code>visibility</code> attribute of the last such
                              <elcode>xsl:expose</elcode> element in document order.</p>
                     </item>

                     <item>
                        <p>Otherwise, <code>private</code>.</p>
                     </item>
                  </olist>
                  
                  <note><p>In the above rules, no distinction is made between declarations that specify
                  a specific component kind, and those that specify <code>component="*"</code>. If both match,
                  the value of the <code>component</code> attribute plays no role in deciding which 
                  declaration wins.</p></note>


                  <p>If both a declared visibility and an explicit
                     exposed visibility exist for the same component, then as mentioned above, they
                     must be consistent. This is determined by reference to the following table,
                     where the entry N/P means “not permitted”. (In cases where the combination is
                     permitted, the actual visibility is always the same as the visibility
                     determined by <elcode>xsl:expose</elcode>.)</p>


                  <table class="data">
                     <caption>Relationship of Exposed Visibility to Potential Visibility</caption>
                     <thead>
                        <tr>
                           <th rowspan="2" colspan="1">Explicit exposed visibility</th>
                           <th colspan="4" rowspan="1">Declared visibility</th>
                        </tr>
                        <tr>
                           <th rowspan="1" colspan="1">public</th>
                           <th rowspan="1" colspan="1">private</th>
                           <th rowspan="1" colspan="1">final</th>
                           <th rowspan="1" colspan="1">abstract</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <th rowspan="1" colspan="1">public</th>
                           <td rowspan="1" colspan="1">public</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">N/P</td>
                        </tr>
                        <tr>
                           <th rowspan="1" colspan="1">private</th>
                           <td rowspan="1" colspan="1">private</td>
                           <td rowspan="1" colspan="1">private</td>
                           <td rowspan="1" colspan="1">private</td>
                           <td rowspan="1" colspan="1">N/P</td>
                        </tr>
                        <tr>
                           <th rowspan="1" colspan="1">final</th>
                           <td rowspan="1" colspan="1">final</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">final</td>
                           <td rowspan="1" colspan="1">N/P</td>
                        </tr>
                        <tr>
                           <th rowspan="1" colspan="1">abstract</th>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">abstract</td>
                        </tr>

                     </tbody>
                  </table>

                  <p>
                     <error spec="XT" type="static" class="SE" code="3010">
                        <p>It is a <termref def="dt-static-error">static error</termref> if the
                           explicit exposed visibility of a component is inconsistent with its
                           declared visibility, as defined in the above table. (This error occurs
                           only when the component declaration has an explicit
                              <code>visibility</code> attribute, and the component is also listed
                           explicitly by name in an <elcode>xsl:expose</elcode> declaration.)</p>
                     </error>
                  </p>

                  <p>
                     <error spec="XT" type="static" class="SE" code="3020">
                        <p>It is a <termref def="dt-static-error">static error</termref> if a token
                           in the <code>names</code> attribute of <elcode>xsl:expose</elcode>, other
                           than a wildcard, matches no component in the containing package.</p>
                     </error>
                  </p>
                  
                  <p>
                     <error spec="XT" type="static" class="SE" code="3022">
                        <p>It is a <termref def="dt-static-error">static error</termref> if the 
                           <code>component</code> attribute of <elcode>xsl:expose</elcode> specifies <code>*</code>
                           (meaning all component kinds) and the <code>names</code> attribute is not a wildcard.</p>
                     </error>
                  </p>



                  <note>
                     <p>There is no ambiguity, and no error, if several tokens within the same
                           <elcode>xsl:expose</elcode> element match the same component.</p>
                  </note>
                  
                  <p>If the visibility of a component as established by the above rules
                  is <code>abstract</code>, then the component must have a declared visibility of <code>abstract</code>.</p>
                  
                  <note><p>In other words, the <elcode>xsl:expose</elcode> declaration cannot be used to make a component
                  abstract unless it was declared as abstract to start with.</p></note>
                  
                  <p>
                     <error spec="XT" type="static" class="SE" code="3025">
                        <p>It is a <termref def="dt-static-error">static error</termref> if the
                           effect of an <elcode>xsl:expose</elcode> declaration would be to make a component
                           <code>abstract</code>, unless the component is already <code>abstract</code>
                           in the absence of the <elcode>xsl:expose</elcode> declaration.
                        </p>
                     </error>
                  </p>



                  <p>For a component accepted into a package <var>P</var>
                     from another package <var>Q</var>, the <termref def="dt-visibility">visibility</termref> of the component in <var>P</var> (which primarily
                     affects how it can be used in a package <var>R</var> that uses <var>P</var>)
                     depends on the visibility declared in the relevant <elcode>xsl:accept</elcode>
                     or <elcode>xsl:override</elcode> element in <var>P</var> (see <specref ref="accepting-components"/>); this in turn has a default that depends on
                     the visibility of the corresponding component in <var>Q</var>. In this case the
                     visibility is unaffected by any <elcode>xsl:expose</elcode> declaration in
                        <var>P</var>.</p>




               </div4>


               <div4 id="accepting-components">
                  <head>Accepting Components</head>

                  <p>When a package <var>P</var> uses a package <var>Q</var>, by virtue of an
                        <elcode>xsl:use-package</elcode> element in the <termref def="dt-package-manifest">package manifest</termref> of <var>P</var>, then
                        <var>P</var> will contain a <termref def="dt-component">component</termref>
                     corresponding to every component in <var>Q</var>. The <termref def="dt-visibility">visibility</termref> of the component within
                        <var>P</var> depends on the <termref def="dt-visibility">visibility</termref> of the component in <var>Q</var>, optionally modified
                     by two elements that may appear as children of the
                        <elcode>xsl:use-package</elcode> element, namely <elcode>xsl:accept</elcode>
                     and <elcode>xsl:override</elcode>.</p>

                  <p>For every component <var>C/Q</var> in package <var>Q</var> that is not matched
                     by any <elcode>xsl:override</elcode> or <elcode>xsl:accept</elcode> element in
                     the package manifest of <var>P</var>, there will be a corresponding component
                        <var>C/P</var> in package <var>P</var> that has the same <termref def="dt-symbolic-identifier">symbolic identifier</termref> and <termref def="dt-declaration">declaration</termref> as <var>C/Q</var>.</p>
                  
                     <p>If <var>C/Q</var> is an <elcode>xsl:param</elcode>
                        component, then the <termref def="dt-visibility"/> of <var>C/P</var> is
                        <code>public</code>.</p>
                     
                     <p>In other cases, the <termref def="dt-visibility"/> of <var>C/P</var> 
                        depends on the <termref def="dt-visibility"/> of <var>C/Q</var>, as defined by the following table:</p>
                  
                  <table class="data">
                     <caption>Visibility of Components in Used and Using Packages</caption>
                     <thead>
                        <tr>
                           <th rowspan="1" colspan="1">Visibility in used package <var>C/Q</var></th>
                           <th rowspan="1" colspan="1">Visibility in using package <var>C/P</var></th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td rowspan="1" colspan="1">public</td>
                           <td rowspan="1" colspan="1">private</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">final</td>
                           <td rowspan="1" colspan="1">private</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">private</td>
                           <td rowspan="1" colspan="1">hidden</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">hidden</td>
                           <td rowspan="1" colspan="1">hidden</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">abstract</td>
                           <td rowspan="1" colspan="1">hidden</td>
                        </tr>
                     </tbody>
                  </table>
                  
                  <note>
                     <p>The effect of these rules is as follows:</p>
                     <ulist>
                        <item><p>Components that are public or final in the used package <var>Q</var> become
                        private in the using package <var>P</var>. This means that they can be referenced
                        within <var>P</var> but are not (by default) visible within a package <var>R</var>
                        that uses <var>P</var>.</p></item>
                        <item><p>Components that are private or hidden in the used package <var>Q</var> become
                           hidden in the using package <var>P</var>. This means that they cannot be referenced
                           within <var>P</var>; but if they contain references to components that are overridden
                           in <var>P</var>, the hidden component’s references are bound to the overriding components
                        in <var>P</var>.</p></item>
                        <item><p>Components that are abstract in the used package <var>Q</var> become
                           hidden in the using package <var>P</var>. The hidden component in this case raises a dynamic
                           error if it is invoked. Such an invocation cannot originate within <var>P</var>,
                           because the component is not visible within <var>P</var>; but it can occur
                        if a public component in <var>Q</var> is invoked, which in turn invokes the abstract
                        component.</p></item>
                     </ulist>
                  </note>

                  

                  <!--<p>If there is a declaration of a component within <elcode>xsl:override</elcode>, then the 
                  component that is overridden remains in the using package with internal visibility 
                  <code>hidden</code> and this is supplemented by the overriding component which appears with the
                  visibility given in its declaration.
                  In this case any <elcode>xsl:accept</elcode> element that matches the component is ignored.
                  For more details of <elcode>xsl:override</elcode> see <specref ref="package-overriding-components"/>.</p>
                -->
                  <?element xsl:accept?>

                  <p>The <elcode>xsl:accept</elcode> element has very similar syntax and semantics
                     to <elcode>xsl:expose</elcode>. Whereas <elcode>xsl:expose</elcode> allows a
                     package to restrict the visibility of its own components to other (using)
                     packages, <elcode>xsl:accept</elcode> allows a package to restrict the
                     visibility of components exposed by a package that it uses. This may be
                     necessary if, for example, it uses two different packages whose component names
                     conflict. It may also simply be good practice if the package author knows that
                     only a small subset of the functionality of a used package is required.</p>

                  <p>The rules for determining whether an <elcode>xsl:accept</elcode> element
                     matches a particular component, and for which element to use if there are
                     several matches, are the same as the rules for the <elcode>xsl:expose</elcode>
                     element.</p>
                  
                  <p>No <elcode>xsl:accept</elcode> element
                     ever matches a variable declared using <elcode>xsl:param</elcode>.</p>
                  <note><p>Attempting to match an <elcode>xsl:param</elcode> with
                     an explicit <code>EQName</code> will therefore always give an error, while
                     using a wildcard has no effect.</p></note>

                  <p>
                     <error spec="XT" type="static" class="SE" code="3030">
                        <p>It is a <termref def="dt-static-error">static error</termref> if a token
                           in the <code>names</code> attribute of <elcode>xsl:accept</elcode>, other
                           than a wildcard, matches no component in the used package.</p>
                     </error>
                  </p>
                  
                  <p>
                     <error spec="XT" type="static" class="SE" code="3032">
                        <p>It is a <termref def="dt-static-error">static error</termref> if the 
                           <code>component</code> attribute of <elcode>xsl:accept</elcode> specifies <code>*</code>
                           (meaning all component kinds) and the <code>names</code> attribute is not a wildcard.</p>
                     </error>
                  </p>


                  <p>In the absence of a matching <elcode>xsl:override</elcode> element (see
                        <specref ref="package-overriding-components"/>), the <termref def="dt-visibility"/> of a component that matches an
                        <elcode>xsl:accept</elcode> element depends both on the
                        <code>visibility</code> attribute of the best-matching
                        <elcode>xsl:accept</elcode> element and on the <termref def="dt-visibility">visibility</termref> of the corresponding component in the used package,
                     according to the following table. In this table the entry “N/P” means “not
                     permitted”.</p>

                  <table class="data">
                     <caption>Relationship of the Visibility given in xsl:accept to Visibility in the Used Package</caption>
                     <thead>
                        <tr>
                           <th rowspan="2" colspan="1">Visibility in <elcode>xsl:accept</elcode> element</th>
                           <th colspan="4" rowspan="1">Visibility in used package</th>
                        </tr>
                        <tr>
                           <th rowspan="1" colspan="1">public</th>
                           <th rowspan="1" colspan="1">private</th>
                           <th rowspan="1" colspan="1">final</th>
                           <th rowspan="1" colspan="1">abstract</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <th rowspan="1" colspan="1">public</th>
                           <td rowspan="1" colspan="1">public</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">N/P</td>
                        </tr>
                        <tr>
                           <th rowspan="1" colspan="1">private</th>
                           <td rowspan="1" colspan="1">private</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">private</td>
                           <td rowspan="1" colspan="1">N/P</td>
                        </tr>
                        <tr>
                           <th rowspan="1" colspan="1">final</th>
                           <td rowspan="1" colspan="1">final</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">final</td>
                           <td rowspan="1" colspan="1">N/P</td>
                        </tr>
                        <tr>
                           <th rowspan="1" colspan="1">abstract</th>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">abstract</td>
                        </tr>
                        <tr>
                           <th rowspan="1" colspan="1">hidden</th>
                           <td rowspan="1" colspan="1">hidden</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">hidden</td>
                           <td rowspan="1" colspan="1">hidden</td>
                        </tr>

                     </tbody>
                  </table>

                  <p>
                     <error spec="XT" type="static" class="SE" code="3040">
                        <p>It is a <termref def="dt-static-error">static error</termref> if the
                           visibility assigned to a component by an <elcode>xsl:accept</elcode>
                           element is incompatible with the visibility of the corresponding
                           component in the used package, as defined by the above table, unless the
                           token that matches the component name is a wildcard, in which case the
                              <elcode>xsl:accept</elcode> element is treated as not matching that
                           component.</p>
                     </error>
                  </p>

                  <p>
                     <error spec="XT" type="static" class="SE" code="3050">
                        <p>It is a <termref def="dt-static-error">static error</termref> if the
                              <elcode>xsl:use-package</elcode> elements in a <termref def="dt-package-manifest">package manifest</termref> cause two or more
                              <termref def="dt-homonymous">homonymous</termref> components to be
                           accepted with a visibility other than <code>hidden</code>.</p>
                     </error>
                  </p>


                  <p>Conflicts between the components accepted from used packages and those declared
                     within the package itself are handled as follows:</p>

                  <olist>
                     <item>
                        <p>If the conflict is between two components both declared within the
                           package itself, then it is resolved by the rules relating to <termref def="dt-import-precedence">import precedence</termref> defined for
                           each kind of component.</p>
                     </item>
                     <item>
                        <p>If the conflict is between two components both accepted from used
                           packages, or between a component declared within the package and an
                           accepted component, then a static error occurs.</p>
                     </item>
                     <item>
                        <p>If a component is explicitly accepted from a used package (by name, rather
                           than by a matching wildcard), and if the same component is the subject
                           of an <elcode>xsl:override</elcode> declaration, then a static error
                        occurs (see below). There is no conflict, however, if a component declared
                        within <elcode>xsl:override</elcode> also matches a wildcard in an <elcode>xsl:accept</elcode>
                        element.</p>
                        <p>
                           <error spec="XT" type="static" class="SE" code="3051">
                              <p>It is a <termref def="dt-static-error">static error</termref> if
                                 a token in the <code>names</code> attribute of <elcode>xsl:accept</elcode>,
                                 other than a wildcard, matches the symbolic name of a component declared
                                 within an <elcode>xsl:override</elcode> child of the same
                                 <elcode>xsl:use-package</elcode> element.</p>
                           </error>
                        </p>
                     </item>
                  </olist>

                  
                  
                  <p>Where the used package <var>Q</var> contains a component whose
                     visibility is <code>abstract</code>, the using package <var>P</var> has three options:</p>
                  
                  <olist>
                     <item><p><var>P</var> can accept the component with <code>visibility="abstract"</code>.
                        In this case <var>P</var> can contain references to the component, but invocation via
                     these references will fail unless a non-abstract overriding component has
                     been supplied in some package <var>R</var> that (directly or indirectly) uses <var>P</var>.</p></item>
                     <item><p><var>P</var> can accept the component with <code>visibility="hidden"</code>.
                        In this case <var>P</var> cannot contain references to the component, and invocation via
                        references in <var>Q</var> will always fail with a dynamic error. This is the default
                     if <var>P</var> does not explicitly accept or override the component.</p></item>
                     <item><p><var>P</var> can provide a concrete implementation of the component
                     within an <elcode>xsl:override</elcode> element.</p></item>
                  </olist>

                  
                        <p>Any invocation of the absent component (typically from within its
                           declaring package) causes a dynamic error, as if the component were
                           overridden by a component that unconditionally raises a dynamic
                           error.</p>
                        <p>
                           <error spec="XT" type="dynamic" class="DE" code="3052">
                              <p>It is a <termref def="dt-dynamic-error">dynamic error</termref> if
                                 an invocation of an abstract component is evaluated.
                              </p>
                           </error>                          
                        </p>
                        <note><p>This can occur when a public component in the used package invokes
                           an abstract component in the used package, and the using package provides
                           no concrete implementation for the component in an <elcode>xsl:override</elcode>
                           element.</p></note>

                  <note>
                     <p>To override a component accepted from a used package, the overriding
                        declaration must appear as a child of the <elcode>xsl:override</elcode>
                        element.</p>
                  </note>

                  <note>
                     <p>There is no rule that prevents a function (say) being declared in the using
                        package with the same name as a <code>private</code> function in the used
                        package. This does not create a conflict, since all references in the used
                        package are bound to one function and all those in the using package are
                        bound to another.</p>
                  </note>



               </div4>

               <div4 id="package-overriding-components">
                  <head>Overriding Components from a Used Package</head>

                  <p><termdef id="dt-override" term="override">A component in a using package may
                           <term>override</term> a component in a used package, provided that the
                           <termref def="dt-visibility">visibility</termref> of the component in the
                        used package is either <code>abstract</code> or <code>public</code>. The
                        overriding declaration is written as a child of the
                           <elcode>xsl:override</elcode> element, which in turn appears as a child
                        of <elcode>xsl:use-package</elcode>.</termdef></p>

                  <?element xsl:override?>

                  <note>
                     <p>This mechanism is distinct from the mechanism for overriding declarations
                        within the same package by relying on <termref def="dt-import-precedence">import precedence</termref>. It imposes stricter rules: the overriding
                        component is required to be type-compatible with the component that it
                        overrides.</p>
                  </note>

                  <p>If the used package <var>Q</var> contains a <termref def="dt-component">component</termref>
                     <var>C/Q</var> and the <elcode>xsl:use-package</elcode> element contains an
                        <elcode>xsl:override</elcode> element which contains a declaration
                        <var>D</var> whose <termref def="dt-symbolic-identifier">symbolic
                        identifier</termref> matches the symbolic identifier of <var>C/Q</var>, then
                     the using package <var>P</var> will contain a component <var>C/P</var> whose
                     declaration is D, whose symbolic identifier is that of D, and whose <termref def="dt-visibility"/> is equal to the value of the <code>visibility</code>
                     attribute of <var>D</var>, or <code>private</code> if this is absent, 
                     except in the case
                           of <elcode>xsl:param</elcode>, which is implicitly
                           <code>public</code>.</p>

                  <p>The using package <var>P</var> will also contain a component <var>C/PQ</var>
                     whose body is the same as the body of <var>C/Q</var> and whose <termref def="dt-visibility">visibility</termref> is <code>hidden</code>. This
                     component is used as the target of a binding for the symbolic reference
                        <code>xsl:original</code> described below.</p>

                  <p>Other than its appearance as a child of <elcode>xsl:override</elcode>, the
                     overriding declaration is a normal <elcode>xsl:function</elcode>,
                        <elcode>xsl:template</elcode>, ,
                     <elcode>xsl:variable</elcode>, <elcode>xsl:param</elcode>, or
                        <elcode>xsl:attribute-set</elcode> element. In the case of
                        <elcode>xsl:variable</elcode> and <elcode>xsl:param</elcode>, the variable
                     that is declared is a <termref def="dt-global-variable">global
                        variable</termref>.</p>

                  <p>The rules in the remainder of this section apply to
                     components having a <code>name</code> attribute (<term>named
                     components</term>). The only element with no <code>name</code> attribute that
                     can appear as a child of <elcode>xsl:override</elcode> is an
                        <elcode>xsl:template</elcode> declaration having a <code>match</code>
                     attribute (that is, a <termref def="dt-template-rule"/>). The rules for
                     overriding of template rules appear in <specref ref="modes-and-packages"/>. If
                     an <elcode>xsl:template</elcode> element has both a <code>name</code> attribute
                     and a <code>match</code> attribute, then it defines both a named component and
                     a template rule, and both sections apply.</p>
                  
                  


                  <p>
                     <error spec="XT" type="static" class="SE" code="3055">
                        <p>It is a <termref def="dt-static-error">static error</termref> if a
                           component declaration appearing as a child of
                              <elcode>xsl:override</elcode> is <termref def="dt-homonymous">homonymous</termref> with any other declaration in the using package,
                           regardless of <termref def="dt-import-precedence">import
                              precedence</termref>, including any other overriding declaration in
                           the package manifest of the using package.</p>
                     </error></p>

                  <note>
                     <p>When an attribute set is overridden, the
                        overriding attribute set must be defined using a single
                           <elcode>xsl:attribute-set</elcode> element. Attribute sets defined in
                        different packages are never merged by virtue of having the same name,
                        though they may be merged explicitly by using the
                           <code>use-attribute-sets</code> attribute.</p>
                  </note>

                  <p>
                     <error spec="XT" type="static" class="SE" code="3058">
                        <p>It is a <termref def="dt-static-error">static error</termref> if a
                           component declaration appearing as a child of
                              <elcode>xsl:override</elcode> does not match (is not <termref def="dt-homonymous">homonymous</termref> with) some component in the
                           used package.</p>
                     </error></p>

                  <p>
                     <error spec="XT" type="static" class="SE" code="3060">
                        <p>It is a <termref def="dt-static-error">static error</termref> if the
                           component referenced by an <elcode>xsl:override</elcode> declaration has
                              <termref def="dt-visibility">visibility</termref> other than
                              <code>public</code> or <code>abstract</code></p>
                     </error>
                  </p>

                  <p>A package is executable if and only if it contains no <termref def="dt-component">component</termref> whose <termref def="dt-visibility">visibility</termref> is <code>abstract</code>. A package that is not
                     executable is not a <termref def="dt-stylesheet">stylesheet</termref>, and
                     therefore cannot be nominated as the stylesheet to be used when initiating a
                     transformation.</p>

                  <note>
                     <p>In other words, if a component is declared as abstract, then some package
                        that uses the declaring package of that component directly or indirectly
                        must override that component with one that is not abstract. It is not
                        necessary for the override to happen in the immediately using package.</p>
                  </note>

                  <p>
                     <error spec="XT" type="static" class="SE" code="3070">
                        <p>It is a <termref def="dt-static-error">static error</termref> if the
                           signature of an overriding component is not <termref def="dt-compatible">compatible</termref> with the signature of the component that it is
                           overriding.</p>
                     </error>
                  </p>



                  <p><termdef id="dt-compatible" term="compatible">The signatures of two <termref def="dt-component">components</termref> are <term>compatible</term> if
                        they present the same interface to the user of the component. The additional
                        rules depend on the kind of component.</termdef></p>

                  <p>Compatibility is only relevant when comparing two components that have the same
                        <termref def="dt-symbolic-identifier"/>. The compatibility rules for each
                     kind of component are as follows:</p>

                  <ulist>
                     <item>
                        <p>Two attribute sets with the same name are compatible if
                           and only if they satisfy the following rule:</p>
                        <olist>
                           <item>
                              <p>If the overridden attribute set specifies
                                    <code>streamable="yes"</code> then the overriding attribute set
                                 also specifies <code>streamable="yes"</code>.</p>
                           </item>
                        </olist>
                     </item>
                     <item diff="chg" at="variadicity">
                        <p>Two functions with the same symbolic identifier are compatible if and only if
                           they satisfy all the following rules:</p>
                        <olist>
                           <item>
                              <p>They have the same <termref def="dt-arity-range"/>
                              (which implies they have the same number of required and optional parameters)</p>
                           </item>
                           <item>
                              <p>The declared types of the parameters 
                                 (defaulting to <code>item()*</code>) are pairwise <termref def="dt-identical-types">identical</termref>.</p>
                           </item>
                           <item>
                              <p>The declared return types 
                                 (defaulting to <code>item()*</code>) are <termref def="dt-identical-types">identical</termref>.</p>
                           </item>
                           <item>
                              <p>The <termref def="dt-effective-value"/> of the 
                                 <code>new-each-time</code> 
                                 attribute on the overriding function is the same as its value on the overridden function.</p>
                           </item>
                           
                           <item>
                              <p diff="chg" at="2022-01-01">If the overridden function has a <code>streamability</code> attribute with a value
                              other than <code>unspecified</code>, then the overriding function has a
                                 <code>streamability</code> attribute with the same value. [XSLT 3.0 Erratum E32, bug 30297]</p>
                           </item>
                        </olist>
                        
                        <p>It is <rfc2119>recommended</rfc2119>
                        that the parameter names on the overriding function should be the same as on the overridden function.
                        (However, in order to maintain backwards compatibility with XSLT 3.0, 
                        this is not <rfc2119>required</rfc2119>.) If the parameter names are not the same,
                        then the parameter names on the overriding function are effectively replaced with the names declared
                        on the overridden function, so that any static function calls using keyword arguments to set the values
                        of arguments must use the names defined on the overridden function.</p>
                     </item>
                     
                     <item>
                        <p>Two named templates with the same name are compatible if and only if they
                           satisfy all the following rules:</p>
                        <olist>
                           <item>
                              <p>Their return types are <termref def="dt-identical-types">identical</termref>.</p>
                           </item>
                           <item>
                              <p>For every non-tunnel parameter on the overridden template, there is a
                                 non-tunnel parameter on the overriding template that has the same name, an
                                    <termref def="dt-identical-types">identical</termref> required
                                 type, and the same <termref def="dt-effective-value"/> for the <code>required</code> attributes.</p>
                           </item>
                           <item>
                              <p>For every tunnel parameter <var>P</var> on the overridden template, if there is a
                                 parameter <var>Q</var> on the overriding template that has the same name 
                                 as <var>P</var> then <var>Q</var> is also a tunnel parameter, and <var>P</var> and <var>Q</var> have
                                 <termref def="dt-identical-types">identical</termref> required
                                 types.</p>
                           </item>
                           <item>
                              <p>Any parameter on the overriding template for which there is no
                                 corresponding parameter on the overridden template specifies
                                    <code>required="no"</code>.</p>
                           </item>
                           <item>
                              <p>The two templates have equivalent
                                    <elcode>xsl:context-item</elcode> children, where equivalence
                                 means that the <code>use</code> attributes are the same and the
                                 required types are <termref def="dt-identical-types">identical</termref>; an absent
                                    <elcode>xsl:context-item</elcode> is equivalent to one that
                                 specifies <code>use="optional"</code> and
                                 <code>as="item()"</code>.</p>
                           </item>
                        </olist>
                     </item>
                     <item>
                        <p>Two variables (including parameters) with the same name are compatible if
                           and only if they satisfy all the following rules:</p>
                        <olist>
                           <item>
                              <p>Their declared types are <termref def="dt-identical-types">identical</termref>.
                              <phrase diff="add" at="2022-01-01">For this purpose, the declared type is the first
                              of the following that applies:</phrase></p>
                              <ulist diff="add" at="2022-01-01">
                                 <item><p>If there is an <code>as</code> attribute, then the type defined by that attribute.</p></item>
                                 <item><p>If there is a <code>select</code> attribute, then <code>item()*</code>.</p></item>
                                 <item><p>If there is a non-empty sequence constructor, then <code>document-node()</code>.</p></item>
                                 <item><p>Otherwise, <code>xs:string</code>. [XSLT 3.0 Erratum E35, bug 30313].</p></item>
                              </ulist>
                           </item>
                           
                        </olist>
                        <note>
                           <p>A variable may override a parameter or vice-versa, and the initial
                              value may differ.</p>
                           <p>Because static variables and parameters are
                              constrained to have visibility <code>private</code>
                              ,
                              they cannot be overridden in another package. The compatibility rules
                              therefore do not arise. The reason that such variables cannot be
                              overridden is that they are typically used during stylesheet
                              compilation (for example, in <code>[xsl:]use-when</code> expressions
                              and shadow attributes) and it is a design goal that packages should be
                              capable of independent compilation.</p>
                        </note>
                     </item>

                  </ulist>

                  <p><termdef id="dt-identical-types" term="identical (types)">Types S and T are considered <term>identical</term> for the purpose of
                        these rules if and only if <code>subtype(S, T)</code> and <code>subtype(T,
                           S)</code> both hold, where the subtype relation is defined in <xspecref spec="XP40" ref="id-seqtype-subtype"/>.</termdef></p>

                  <note>
                     <olist>
                        <item>
                           <p>One consequence of this rule is that two plain union types are
                              considered identical if they have the same set of member types, even
                              if the union types have different names or the ordering of the member
                              types is different.</p>
                           <p>Consider a function that accepts an argument
                           whose declared type is a union type with member types <code>xs:double</code>
                           and <code>xs:decimal</code>, in that order (we might write this as <code>union(xs:double, xs:decimal)</code>).
                           Using the same notation, this can be overridden by a function that declares the argument
                           type as <code>union(xs:decimal, xs:double)</code>. This does not affect type checking:
                              a function call that passes the type checking rules with one signature will also pass the
                              type checking rules with the other. It does however affect the way that the function
                           conversion rules work: a call that passes the <code>xs:untypedAtomic</code> value
                           <code>"93.7"</code> (or an untyped node with this as its string value) will be converted to 
                              an <code>xs:decimal</code> in one case and an <code>xs:double</code> in the other.</p>
                        </item>

                        <item>
                           <p>While this rule may appear formal, it is not as straightforward as
                              might be supposed, because the subtype relation in XPath has a
                              dependency on the “Type derivation OK (Simple)” relation in XML
                              Schema, which itself appeals to a judgement as to whether the two type
                              definitions being compared “are the same type definition”. Both XSD
                              1.0 and XSD 1.1 add the note “The wording of [this rule] appeals to a
                              notion of component identity which is only incompletely defined by
                              this version of this specification.” However, they go on to say that
                              component identity is well defined if the components are named simple
                              type definitions, which will always apply in this case. For named
                              atomic types, the final result of these rules is that two atomic types
                              are identical if and only if they have the same name.</p>
                        </item>
                     </olist>
                  </note>


                  <p>Modes are not overridable, so the <elcode>xsl:mode</elcode> declaration cannot
                     appear as a child of <elcode>xsl:override</elcode>.</p>
               </div4>
               <div4 id="refer-to-overridden">
                  <head>Referring to Overridden Components</head>


                  <p>Within the declaration of an overriding named <termref def="dt-component"/>
                     (that is, a component whose declaration is a child of
                        <elcode>xsl:override</elcode>, and has a <code>name</code> attribute), where
                     the overridden component has public <termref def="dt-visibility"/>, it is
                     possible to use the name <code>xsl:original</code> as a symbolic reference to
                     the overridden component. More specifically: </p>

                  <ulist>
                     <item>
                        <p>Within a <termref def="dt-named-template"/> appearing as a child of
                              <elcode>xsl:override</elcode>, the name <code>xsl:original</code>
                           may appear as the value of the <code>name</code> attribute of
                              <elcode>xsl:call-template</elcode>: for example,
                              <code>&lt;xsl:call-template name="xsl:original"/&gt;</code>. </p>
                     </item>
                     <item>
                        <p>Within a <termref def="dt-stylesheet-function"/> appearing as a child of
                              <elcode>xsl:override</elcode>, the static context for contained XPath
                           expressions (other than <termref def="dt-static-expression">static
                              expressions</termref>) is augmented as follows: the <term>statically
                              known function signatures</term> includes a mapping from the name
                              <code>xsl:original</code> to the signature of the overridden
                           function (which is the same as the signature of the overriding function).
                           This means that the name <code>xsl:original</code> can be used in static
                           function calls, including calls that use partial function application
                           (where one of the arguments is given as <code>"?"</code>), and also in named function
                           references. For example: <code>xsl:original($x)</code>,
                              <code>xsl:original($x, ?)</code>, <code>xsl:original#2</code>.</p>
                        <note>
                           <p>The result of calling <code>function-name(xsl:original#2)</code> is
                              the name of the overridden function, not
                              <code>xsl:original</code>.</p>
                        </note>
                        <p diff="add" at="issue663">If the function <code>xsl:original</code> is called
                        with keyword arguments, the keywords used are those of the overridden function.</p>
                        <p>Neither <code>xsl:original</code>, nor the overridden function, is added
                           to the <xtermref ref="dt-dynamically-known-function-definitions" spec="XP40">dynamically
                           known function definitions</xtermref> component of the dynamic context for
                           XPath expressions within the overriding function. This means that any
                           attempt to bind the function name <code>xsl:original</code> dynamically
                           (for example using <xfunction>function-lookup</xfunction>, or
                              <function>function-available</function>, or
                              <elcode>xsl:evaluate</elcode>) will fail, and any attempt to bind
                           the name of the overriding/overridden function dynamically will return
                           the overriding function. </p>
                     </item>
                     <item>
                        <p>Within a <termref def="dt-global-variable"/> or parameter appearing as a
                           child of <elcode>xsl:override</elcode>, the static context for contained
                           XPath expressions (other than <termref def="dt-static-expression">static
                              expressions</termref>) is augmented as follows: the <term>in-scope
                              variables</term> includes a mapping from the name
                              <code>xsl:original</code> to the declared type of the overridden
                           variable or parameter (which is the same as the type of the overriding
                           global variable or parameter). </p>
                     </item>
                     <item>
                        <p>Within an <termref def="dt-attribute-set"/> appearing as a child of
                              <elcode>xsl:override</elcode>, any
                              <code>[xsl:]use-attribute-sets</code> attribute (whether on the
                              <elcode>xsl:attribute-set</elcode> element itself, or on any
                           descendant element) may include the name <code>xsl:original</code> as a
                           reference to the overridden attribute set. </p>
                     </item>
                  </ulist>

                  <p>Within the overriding component <var>C/P</var>, the <termref def="dt-symbolic-reference"/>
                     <code>xsl:original</code> is bound to the hidden component <var>C/PQ</var>
                     described earlier, whose body is that of the component <var>C/Q</var> in the
                     used package. </p>

                  <p>
                     <error spec="XT" type="static" class="SE" code="3075">
                        <p>It is a <termref def="dt-static-error">static error</termref> to use the
                           component reference <code>xsl:original</code> when the overridden
                           component has <code>visibility="abstract"</code>.</p>
                     </error>
                  </p>

                  <p>Modes are not overridable, so the name
                        <code>xsl:original</code> cannot be used to refer to a <termref def="dt-mode"/> (for example in the <code>mode</code> attribute of
                        <elcode>xsl:apply-templates</elcode>). </p>



                  <note>
                     <p>In the case of variables, templates, and attribute sets, the invocation of
                        the overridden component can occur only within the lexical scope of the
                        overriding component. With functions, however, there is greater flexibility.
                        The overriding component can obtain a reference to the overridden component
                        in the form of a function item, and can export this value by passing it to
                        other functions or returning it in its result. A dynamic invocation of this
                        function item (and hence, of the overridden function) can thus occur
                        anywhere. </p>
                  </note>




               </div4>

               <div4 id="component-references">
                  <head>Binding References to Components</head>
                  <p><termdef id="dt-reference-binding" term="reference binding">The process of
                        identifying the <termref def="dt-component">component</termref> to which a
                           <termref def="dt-symbolic-reference">symbolic reference</termref> applies
                        (possibly chosen from several <termref def="dt-homonymous">homonymous</termref> alternatives) is called <term>reference
                           binding</term>.</termdef>
                  </p>

                  <p>The process of <termref def="dt-reference-binding"/> in the presence of
                     overriding declarations is best illustrated by an example. The formal rules
                     follow later in the section.</p>
                  <example id="example-of-component-binding">
                     <head>Binding References to Named Components</head>


                     <p>Consider a package <var>Q</var> defined as follows:</p>

                     <eg role="xslt-document" xml:space="preserve">&lt;xsl:package name="Q"
        version="3.0"                
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:variable name="A" visibility="final" select="$B + 1"/&gt;
  &lt;xsl:variable name="B" visibility="private" select="$C * 2"/&gt;
  &lt;xsl:variable name="C" visibility="public" select="22"/&gt;
&lt;/xsl:package&gt;</eg>

                     <p>(The process is illustrated here using variables as the components, but the
                        logic would be the same if the example used functions, named templates, or
                        attribute sets.)</p>

                     <p>There are three components in this package, and their properties are
                        illustrated in the following table. (The ID column is an arbitrary component
                        identifier used only for the purposes of this exposition.)</p>

                     
                     <table class="data">
                        <caption>Components in the above Package and their Properties</caption>
                        <thead>
                           <tr>
                              <th rowspan="1" colspan="1">ID</th>
                              <th rowspan="1" colspan="1">Symbolic Name</th>
                              <th rowspan="1" colspan="1">Declaring Package</th>
                              <th rowspan="1" colspan="1">Containing Package</th>
                              <th rowspan="1" colspan="1">Visibility</th>
                              <th rowspan="1" colspan="1">Body</th>
                              <th rowspan="1" colspan="1">Bindings</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr>
                              <td rowspan="1" colspan="1"><var>A/Q</var></td>
                              <td rowspan="1" colspan="1">variable <var>A</var></td>
                              <td rowspan="1" colspan="1">Q</td>
                              <td rowspan="1" colspan="1">Q</td>
                              <td rowspan="1" colspan="1">final</td>
                              <td rowspan="1" colspan="1"><code>$B + 1</code></td>
                              <td rowspan="1" colspan="1">$B → <var>B/Q</var></td>
                           </tr>
                           <tr>
                              <td rowspan="1" colspan="1"><var>B/Q</var></td>
                              <td rowspan="1" colspan="1">variable <var>B</var></td>
                              <td rowspan="1" colspan="1">Q</td>
                              <td rowspan="1" colspan="1">Q</td>
                              <td rowspan="1" colspan="1">private</td>
                              <td rowspan="1" colspan="1"><code>$C * 2</code></td>
                              <td rowspan="1" colspan="1">$C → <var>C/Q</var></td>
                           </tr>
                           <tr>
                              <td rowspan="1" colspan="1"><var>C/Q</var></td>
                              <td rowspan="1" colspan="1">variable <var>C</var></td>
                              <td rowspan="1" colspan="1">Q</td>
                              <td rowspan="1" colspan="1">Q</td>
                              <td rowspan="1" colspan="1">public</td>
                              <td rowspan="1" colspan="1"><code>22</code></td>
                              <td rowspan="1" colspan="1">none</td>
                           </tr>

                        </tbody>
                     </table>

                     <p>Now consider a package <var>P</var> that uses <var>Q</var>, and that
                        overrides one of the variables declared in <var>Q</var>:</p>

                     <eg role="xslt-document" xml:space="preserve">&lt;xsl:package name="P"
        version="3.0"                
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:use-package name="Q"&gt;
    &lt;xsl:override&gt;
      &lt;xsl:variable name="C" visibility="private" select="$xsl:original + 3"/&gt;
    &lt;/xsl:override&gt;
  &lt;/xsl:use-package&gt;
  
  &lt;xsl:template name="T" visibility="public"&gt;
    &lt;xsl:value-of select="$A"/&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:package&gt;</eg>

                     <p>Package <var>P</var> has five components, whose properties are shown in the
                        following table:</p>

                     <table class="data">
                        <caption>Components in the above Package and their Properties</caption>
                        <thead>
                           <tr>
                              <th rowspan="1" colspan="1">ID</th>
                              <th rowspan="1" colspan="1">Symbolic Name</th>
                              <th rowspan="1" colspan="1">Declaring Package</th>
                              <th rowspan="1" colspan="1">Containing Package</th>
                              <th rowspan="1" colspan="1">Visibility</th>
                              <th rowspan="1" colspan="1">Body</th>
                              <th rowspan="1" colspan="1">Bindings</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr>
                              <td rowspan="1" colspan="1"><var>A/PQ</var></td>
                              <td rowspan="1" colspan="1">variable <var>A</var></td>
                              <td rowspan="1" colspan="1">Q</td>
                              <td rowspan="1" colspan="1">P</td>
                              <td rowspan="1" colspan="1">final</td>
                              <td rowspan="1" colspan="1"><code>$B + 1</code></td>
                              <td rowspan="1" colspan="1">$B → <var>B/PQ</var></td>
                           </tr>
                           <tr>
                              <td rowspan="1" colspan="1"><var>B/PQ</var></td>
                              <td rowspan="1" colspan="1">variable <var>B</var></td>
                              <td rowspan="1" colspan="1">Q</td>
                              <td rowspan="1" colspan="1">P</td>
                              <td rowspan="1" colspan="1">hidden</td>
                              <td rowspan="1" colspan="1"><code>$C * 2</code></td>
                              <td rowspan="1" colspan="1">$C → <var>C/P</var></td>
                           </tr>
                           <tr>
                              <td rowspan="1" colspan="1"><var>C/PQ</var></td>
                              <td rowspan="1" colspan="1">variable <var>C</var></td>
                              <td rowspan="1" colspan="1">Q</td>
                              <td rowspan="1" colspan="1">P</td>
                              <td rowspan="1" colspan="1">hidden</td>
                              <td rowspan="1" colspan="1"><code>22</code></td>
                              <td rowspan="1" colspan="1">none</td>
                           </tr>
                           <tr>
                              <td rowspan="1" colspan="1"><var>C/P</var></td>
                              <td rowspan="1" colspan="1">variable <var>C</var></td>
                              <td rowspan="1" colspan="1">P</td>
                              <td rowspan="1" colspan="1">P</td>
                              <td rowspan="1" colspan="1">private</td>
                              <td rowspan="1" colspan="1"><code>$xsl:original + 3</code></td>
                              <td rowspan="1" colspan="1">$xsl:original → <var>C/PQ</var></td>
                           </tr>
                           <tr>
                              <td rowspan="1" colspan="1"><var>T/P</var></td>
                              <td rowspan="1" colspan="1">template <var>T</var></td>
                              <td rowspan="1" colspan="1">P</td>
                              <td rowspan="1" colspan="1">P</td>
                              <td rowspan="1" colspan="1">public</td>
                              <td rowspan="1" colspan="1"><code>value-of select="$A</code></td>
                              <td rowspan="1" colspan="1">$A → <var>A/PQ</var></td>
                           </tr>

                        </tbody>
                     </table>

                     <p>The effect of these bindings is that when template <var>T</var> is called,
                        the result is <code>51</code>. This is why:</p>

                     <olist>
                        <item>
                           <p>The result of <var>T</var> is the value of <var>A/PQ</var>.</p>
                        </item>
                        <item>
                           <p>The value of <var>A/PQ</var> is the value of <var>B/PQ</var> plus
                              1.</p>
                        </item>
                        <item>
                           <p>The value of <var>B/PQ</var> is the value of <var>C/P</var> times
                              2.</p>
                        </item>
                        <item>
                           <p>The value of <var>C/P</var> is the value of <var>C/PQ</var> plus
                              3.</p>
                        </item>
                        <item>
                           <p>The value of <var>C/PQ</var> is 22.</p>
                        </item>
                        <item>
                           <p>So the final result is ((22 + 3) * 2) + 1</p>
                        </item>
                     </olist>

                     <p>In this example, the components of <var>P</var> are established in three
                        different ways:</p>

                     <olist>
                        <item>
                           <p>Components <var>A/PQ</var>, <var>B/PQ</var>, and <var>C/PQ</var> are
                              modified copies of the corresponding component <var>A/Q</var>,
                                 <var>B/Q</var>, and <var>C/Q</var> in the used package
                              <var>Q</var>. The properties of these components are modified as
                              follows:</p>
                           <olist>
                              <item>
                                 <p>The <termref def="dt-symbolic-identifier"/>, <termref def="dt-declaring-package"/>, and body are unchanged.</p>
                              </item>
                              <item>
                                 <p>The <termref def="dt-containing-package"/> is changed to
                                       <var>P</var>.</p>
                              </item>
                              <item>
                                 <p>The <termref def="dt-visibility"/> is changed according to the
                                    rules in <specref ref="accepting-components"/>: in particular,
                                       <code>visibility="private"</code> changes to
                                       <code>visibility="hidden"</code>.</p>
                              </item>
                              <item>
                                 <p>The references to other components are rebound as described in
                                    this section.</p>
                              </item>
                           </olist>
                        </item>
                        <item>
                           <p>Component <var>C/P</var> is the overriding component. Its properties
                              are exactly as if it were declared as a top-level component in
                                 <var>P</var> (outside the <elcode>xsl:use-package</elcode>
                              element), except that (a) it must adhere to the constraints on
                              overriding components (see <specref ref="package-overriding-components"/>), (b) it is allowed to use
                              the variable reference <code>$xsl:original</code>, and (c) the fact
                              that it overrides <var>C/Q</var> affects the way that references from
                              other components are rebound.</p>
                        </item>
                        <item>
                           <p>Component <var>T/P</var> is a new component declared locally in
                                 <var>P</var>.</p>
                        </item>
                     </olist>

                  </example>

                  <p>The general rules for <termref def="dt-reference-binding"/> can now be
                     stated:</p>

                  <olist>
                     <item>
                        <p>If the <termref def="dt-containing-package"/> of a component
                              <var>C/P</var> is <var>P</var>, then all <termref def="dt-symbolic-reference">symbolic references</termref> in
                              <var>C/P</var> are bound to components whose <termref def="dt-containing-package"/> is <var>P</var>.</p>
                     </item>
                     <item>
                        <p>When a package <var>P</var> uses a package <var>Q</var>, then for every
                           component <var>C/Q</var> in <var>Q</var>, there is a <term>corresponding
                              component</term>
                           <var>C/P</var> in <var>P</var>, as described in <specref ref="accepting-components"/>.</p>
                     </item>
                     <item>
                        <p>Given a component <var>C/P</var> whose <termref def="dt-containing-package"/> and <termref def="dt-declaring-package"/> are the same package <var>P</var>, then (as a consequence of rules
                           elsewhere in this specification) for every <termref def="dt-symbolic-reference"/>
                           <var>D</var> within <var>C/P</var>, other than a reference using the name
                              <code>xsl:original</code>, there will always be exactly one non-hidden
                           component <var>D/P</var> whose containing package is <var>P</var> and
                           whose <termref def="dt-symbolic-identifier"/> matches <var>D</var>
                           (otherwise a static error will have been reported). The reference is then
                           bound to <var>D/P</var>.</p>
                     </item>
                     <item>
                        <p>In the case of a component reference using the name
                              <code>xsl:original</code>, this will in general appear within a
                           component <var>C/P</var> that overrides a component <var>C/Q</var> whose
                           corresponding component in <var>P</var> is <var>C/PQ</var>, and the
                              <code>xsl:original</code> reference is bound to <var>C/PQ</var>.</p>
                     </item>
                     <item>
                        <p>Given a component <var>C/P</var> whose <termref def="dt-containing-package"/>
                           <var>P</var> is a different package from its <termref def="dt-declaring-package"/>
                           <var>R</var> (that is, <var>C/P</var> is present in <var>P</var> by
                           virtue of an <elcode>xsl:use-package</elcode> declaration referencing
                           package <var>Q</var>, which may or may not be the same as <var>R</var>),
                           then the component bindings in <var>C/P</var> are derived from the
                           component bindings in the corresponding component <var>C/Q</var> as
                           follows: if the component binding within <var>C/Q</var> is to a component
                              <var>D/Q</var>, then:</p>
                        <olist>
                           <item>
                              <p>If <var>D/Q</var> is overridden within <var>P</var> by a component
                                    <var>D/P</var>, then the reference is bound to
                                 <var>D/P</var>;</p>
                           </item>
                           <item>
                              <p>Otherwise, the reference is bound to the component <var>D/PQ</var>
                                 in <var>P</var> whose corresponding component in <var>Q</var> is
                                    <var>D/Q</var>.</p>
                           </item>
                        </olist>
                     </item>
                  </olist>


                  <p>When reference resolution is performed on a package that is intended to be used
                     as a <termref def="dt-stylesheet">stylesheet</termref> (that is, for the
                        <termref def="dt-top-level-package">top-level package</termref>), there must
                     be no symbolic references referring to components whose visibility is
                        <code>abstract</code> (that is, an implementation must be provided for every
                     abstract component). </p>

                  <p>
                     <error spec="XT" type="static" class="SE" code="3080">
                        <p>It is a <termref def="dt-static-error">static error</termref> if a
                              <termref def="dt-top-level-package">top-level package</termref> (as
                           distinct from a <termref def="dt-library-package">library
                              package</termref>) contains 
                           components whose visibility is <code>abstract</code>.</p>
                     </error>
                  </p>

                  <note diff="chg" at="2022-01-01">
                     <p>Abstract components in a used package by default become hidden in the using package, 
                        which means that a reference to the component in the top-level package will fail 
                        to resolve (resulting in a different static error). This particular error occurs 
                        only if the abstract component is declared within the top-level package.
                     [XSLT 3.0 Erratum E4, bug 30142].</p>
                  </note>

                  <note>
                     <p>Unresolved references are allowed at the module level but not at the package
                        level. A stylesheet module can contain references to components that are
                        satisfied only when the module is imported into another module that declares
                        the missing component.</p>
                  </note>


                  <note>
                     <p>The process of resolving references (or linking) is critical to an
                        implementation that uses separate compilation. One of the aims of these
                        rules is to ensure that when compiling a package, it is always possible to
                        determine the signature of called functions, templates, and other
                        components. A further aim is to establish unambiguously in what
                        circumstances components can be overridden, so that compilers know when it
                        is possible to perform optimizations such as inlining of function and
                        variable references.</p>
                     <p>Suppose a public template <var>T</var> calls a private function
                        <var>F</var>. When the package containing these two components is referenced
                        by a using package, the template remains public, while the function becomes
                        hidden. Because the function becomes hidden, it can no longer conflict with
                        any other function of the same name, or be overridden by any other function;
                        at this stage the compiler knows exactly which function <var>T</var> will be
                        calling, and can perform optimizations based on this knowledge.</p>
                  </note>

                  <p>The mechanism for resolving component references described in
                     this section is consistent with the mechanism used for binding function and
                     variable references described in the XPath specification. XPath requires these
                     variable and function names to be present in the static context for an XPath
                     expression. XSLT ensures that all the non-hidden functions, global variables,
                     and global parameters in a package are present in the static context for every
                     XPath expression that appears in that package, along with required information
                     such as the type of a variable and the signature of a function.</p>

                  <example>
                     <!--https://lists.w3.org/Archives/Public/public-xsl-wg/2016Jul/0005.html-->
                     <head>Named Component References in Inline Functions</head>
                     
                     <p>Named component references within inline functions follow the standard rules, but the rules need
                        to be interpreted with care. Suppose that in package <var>P</var> we find the declarations:</p>
                     
                     <eg role="xslt-declarations" xml:space="preserve">
&lt;xsl:variable name="v" as="xs:integer" visibility="public" select="3"/&gt;

&lt;xsl:function name="f:factory" as="function(*)" visibility="final"&gt;
  &lt;xsl:sequence select="function() {$v}"/&gt;
&lt;/xsl:function&gt;  
                  </eg>
                     
                     <p>and that in a using package Q we find:</p>
                     
                     <eg role="xslt-declarations" xml:space="preserve">
      
&lt;xsl:use-package name="P"&gt;
  &lt;xsl:override&gt;
    &lt;xsl:variable name="v" as="xs:integer" select="4"/&gt;
  &lt;/xsl:override&gt;
&lt;/xsl:use-package&gt;

&lt;xsl:template name="xsl:initial-template"&gt;
  &lt;v value="{f:factory()()}"/&gt;
&lt;/xsl:template&gt;  
      </eg>
                     
                     <p>The correct output here is <code>&lt;v value="4"/&gt;</code>.</p>
                     
                     <p>The explanation for this is as follows. Package <var>Q</var> contains a function <var>f:factory/QP</var>
                        whose declaring package is <var>P</var> and whose containing package is <var>Q</var>. The symbolic reference
                        <code>$v</code> within the body of this function is resolved in the normal way; since the containing package
                        is <var>Q</var>, it is resolved to the global variable <var>v/Q</var>: that is, the overriding declaration
                        of <code>$v</code> that appears within the <elcode>xsl:override</elcode> element within package <var>Q</var>,
                        whose value is 4.</p>
                     
                     <p>In terms of internal implementation, one way of looking at this is that the anonymous function returned
                        by <code>f:factory</code> contains within its closure bindings for the global variables and functions that
                        the anonymous function references; these bindings are inherited from the component bindings of the
                        component that lexically contains these symbolic references, which in this case is <code>f:factory</code>,
                        and more specifically the version of the <code>f:factory</code> component in package <var>Q</var>.</p>
                  </example>

               </div4>

               <div4 id="dynamic-component-references">
                  <head>Dynamic References to Components</head>

                  <p>There are several functions in which a dynamically evaluated QName is used to
                     identify a component: these include <function>key</function>,
                        <function>accumulator-before</function>,
                        <function>accumulator-after</function>,
                     <xfunction>function-lookup</xfunction>, and
                        <function>function-available</function>. Dynamic references can also occur
                     in the XPath expression supplied to the <elcode>xsl:evaluate</elcode>
                     instruction. </p>
                  <p>In all these cases, the set of components that are available to be referenced
                     are those that are declared in the package where this function call appears,
                     including components declared within an <elcode>xsl:override</elcode>
                     declaration in that package, but excluding components declared with
                        <code>visibility="abstract"</code>. If the relevant component has been
                     overridden in a different package, the overriding declarations are not
                     considered. </p>
                  <p>If one of these functions (for example <function>key</function> or
                        <function>accumulator-before</function>) is invoked via a dynamic function
                     invocation, then the relevant package is the one in which the function item is
                     created (using a construct such as <code>key#2</code>, <code>key('my-key',
                        ?)</code>, or <code>function-lookup($KEYFN, 2)</code>). Function items
                     referring to context-dependent functions bind the context at the point where
                     the function item is created, not the context at the point where the function
                     item is invoked.</p>
                  
                  <note>
                     <p>This means that if a package wishes to make a key available for use by a
                        calling package, it can do so by creating a public global variable whose
                        value is a partial application of the <function>key</function> function:</p>
                     <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:variable name="get-order" select="key('orders-key', ?, ?)"/&gt;</eg>
                     <p>which the calling code can invoke as <code>$get-order('123-456', /)</code>.</p>
                  </note>

               </div4>

            </div3>

            <div3 id="modes-and-packages">
               <head>Overriding Template Rules from a Used Package</head>
               <p>The rules in the previous section apply to named components including functions,
                  named templates, global variables, and named attribute sets. The rules for
                     <termref def="dt-mode">modes</termref>, and the <termref def="dt-template-rule">template rules</termref> appearing within a mode, are slightly different.</p>

               <p>The unnamed mode is local to a package: in effect, each package has its own
                  private unnamed mode, and the unnamed mode of one package does not interact with
                  the unnamed mode of any other package. An
                        <elcode>xsl:apply-templates</elcode> instruction with no <code>mode</code>
                     attribute is treated as a <termref def="dt-symbolic-reference"/> to the default
                     mode defined for that instruction (see <specref ref="default-mode"/>), which in
                     turn defaults to the <termref def="dt-unnamed-mode"/>. Because the unnamed mode
                     always has private visibility, it cannot be overridden in another 
                     package.</p>

               <p>A named mode may be declared in an <elcode>xsl:mode</elcode> declaration as being
                  either <code>public</code>, <code>private</code>, or <code>final</code>. The
                  values of the <code>visibility</code> attribute are interpreted as follows:</p>
               <table class="def">
                  <caption>Visibility Values for Named Modes, and their Meaning</caption>
                  <thead>
                     <tr>
                        <th rowspan="1" colspan="1">Value</th>
                        <th rowspan="1" colspan="1">Meaning</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td rowspan="1" colspan="1">public</td>
                        <td rowspan="1" colspan="1">A <term>using</term> package may use
                              <elcode>xsl:apply-templates</elcode> to invoke templates in this mode;
                           it may also declare additional template rules in this mode, which are
                           selected in preference to template rules in the used package. These may
                           appear only as children of the <elcode>xsl:override</elcode> element
                           within the <elcode>xsl:use-package</elcode> element.</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">private</td>
                        <td rowspan="1" colspan="1">A <term>using</term> package may neither reference the mode nor provide
                           additional templates in this mode; the name of the mode is not even
                           visible in the using package, so no such attempt is possible. The using
                           package can use the same name for its own modes without risk of conflict.
                        </td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">final</td>
                        <td rowspan="1" colspan="1">A <term>using</term> package may use
                              <elcode>xsl:apply-templates</elcode> to invoke templates in this mode,
                           but it must not provide additional template rules in this mode. </td>
                     </tr>
                  </tbody>
               </table>
               <p>As with other named components, an <elcode>xsl:use-package</elcode> declaration
                  may contain an <elcode>xsl:accept</elcode> element to control the visibility of a
                  mode acquired from the <term>used</term> package. The allowed values of its
                     <code>visibility</code> attribute are <code>public</code>,
                  <code>private</code>, and <code>final</code>.</p>



               <p>The <elcode>xsl:mode</elcode> declaration itself must not be overridden. A using
                  package must not contain an <elcode>xsl:mode</elcode> declaration whose name
                  matches that of a <code>public</code> or <code>final</code>
                  <elcode>xsl:mode</elcode> component accepted from a used package.</p>

               <p>The <elcode>xsl:expose</elcode> and <elcode>xsl:accept</elcode> elements may be
                  used to reduce the visibility of a mode in a using package; the same rules apply
                  in general, though some of the rules are not applicable because, for example,
                  modes cannot be <code>abstract</code>.</p>

               <p>It is not possible for a package to combine the template rules from two other
                  packages into a single mode. When <elcode>xsl:apply-templates</elcode> is used
                  without specifying a mode, the chosen template rules will always come from the
                  same package; when it is used with a named mode, then they will come from the
                  package where the mode is defined, or any package that uses that package and adds
                  template rules to the mode. If two template rules defined in different packages
                  match the same node, then the rule in the using package wins over any rule in the
                  used package; this decision is made before taking other factors such as import
                  precedence and priority into account.</p>

               <p>A static error occurs if two modes with the same name are visible within a
                  package, either because they are both declared within the package, or because one
                  is declared within the package and the other is acquired from a used package, or
                  because both are accepted from different used packages.</p>

               <p>The rules for matching template rules by <termref def="dt-import-precedence"/> and <termref def="dt-priority"/> operate as
                  normal, with the addition that template rules declared within an
                     <elcode>xsl:use-package</elcode> element have higher precedence than any
                  template rule declared in the used package. More specifically, given an <elcode>xsl:apply-templates</elcode> instruction
                     in package <var>P</var>, naming a mode <var>M</var> that is declared in a used
                     package <var>Q</var> and is overridden in <var>P</var>, the search order for
                     template rules is:</p>

               <olist>
                  <item>
                     <p>Rules declared within <var>P</var> (specifically,
                           <elcode>xsl:template</elcode> rules declared as children of an
                           <elcode>xsl:override</elcode> element within the
                           <elcode>xsl:use-package</elcode> element that references package
                           <var>Q</var>). If there are multiple rules declared within <var>P</var>
                        that match a selected node, they are resolved on the basis of their explicit
                        or implicit <termref def="dt-priority"/>, and if the priorities are equal, the last one in <termref def="dt-declaration-order"/> wins.</p>
                  </item>
                  <item>
                     <p>Rules declared within <var>Q</var>, taking <termref def="dt-import-precedence"/>, <termref def="dt-priority"/>, and <termref def="dt-declaration-order"/> into account in the usual way (see <specref ref="conflict"/>).</p>
                  </item>
                  <item>
                     <p>Built-in template rules (see <specref ref="built-in-rule"/>) selected
                        according to the <code>on-no-match</code> attribute of the
                           <elcode>xsl:mode</elcode> declaration (in <var>Q</var>), or its
                        default.</p>
                  </item>
               </olist>

               <p>If the mode is overridden again in a package
                     <var>R</var> that uses <var>P</var>, then this search order is extended by
                  adding <var>R</var> at the start of the search list, and so on recursively.</p>

               <note>
                  <p>If existing XSLT code has been written to use template rules in the unnamed
                     mode, a convenient way to incorporate this code into a <termref def="dt-library-package">library package</termref> is to add a stub module
                     that defines a new named <code>public</code> or <code>final</code> mode, in
                     which there is a single template rule whose content is the single instruction
                        <code>&lt;xsl:apply-templates select="."/&gt;</code>. This in effect redirects
                        <elcode>xsl:apply-templates</elcode> instructions using the named mode to
                     the rules defined in the unnamed mode.</p>
               </note>

               <div4 id="requiring-explicit-modes">
                  <head>Requiring Explicit Mode Declarations</head>
                  <p>In previous versions of XSLT, modes were implicitly declared by simply using a
                     mode name in the <code>mode</code> attribute of <elcode>xsl:template</elcode>
                     or <elcode>xsl:apply-templates</elcode>. XSLT 3.0 introduced the ability to
                     declare a mode explicitly using an <elcode>xsl:mode</elcode> declaration (see
                        <specref ref="declaring-modes"/>).</p>
                  <p>By default, within a package that is defined using an explicit
                        <elcode>xsl:package</elcode> element, all modes must be explicitly declared.
                     In an implicit package, however (that is, one rooted at an
                        <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element),
                     modes can be implicitly declared as in previous XSLT versions.</p>

                  <p>The <code>declared-modes</code>
                     attribute of <elcode>xsl:package</elcode> determines whether or not modes that
                     are referenced within the package must be explicitly declared. 
                     
                     If the value is <code>yes</code> (the default),
                     then it is an error to use a mode name 
                        unless the package either contains
                     an explicit <elcode>xsl:mode</elcode> declaration for that mode, or accepts the mode
                     from a used package. If the value is <code>no</code>, then this is not an error.
                     
                     
                  
                  </p>
                  <p>This attribute affects all modules making up the package, it is not confined to
                     declarations appearing as children of the <elcode>xsl:package</elcode>
                     element.</p>

                  <p>
                     <error spec="XT" type="static" class="SE" code="3085">
                        <p>It is a <termref def="dt-static-error">static error</termref>, 
                           when the <termref def="dt-effective-value"/> of the <code>declared-modes</code> attribute of 
                           an <elcode>xsl:package</elcode> element is <code>yes</code>, if the 
                           package contains an explicit reference to an undeclared mode, or if 
                           it implicitly uses the unnamed mode and the unnamed mode is undeclared.</p></error></p>
                     
                     <p>For the purposes of the above rule:</p>
                     
                     <olist>
                        <item><p>A mode is <term>declared</term> if either of the following conditions is true:</p>
                           <olist>
                              <item><p>The package contains an <elcode>xsl:mode</elcode> 
                                 declaration for that mode.</p></item>
                              <item><p>The mode is a public or final mode accepted 
                                 from a used package. </p></item>
                           </olist>                       
                        </item>
                        <item><p>The offending reference may be either an explicit mode name, or the token <code>#unnamed</code> 
                           treated as a reference to the unnamed mode, or a defaulted mode attribute, and it may occur in any of the following:</p>
                           <olist>
                              <item><p>The <code>mode</code> 
                                 attribute of an <elcode>xsl:template</elcode> declaration</p></item>
                              <item><p>The <code>mode</code> 
                                 attribute of an <elcode>xsl:apply-templates</elcode> instruction</p></item>
                              <item><p>An <code>[xsl:]default-mode</code> attribute.</p></item>
                           </olist>
                        </item>
                        <item><p>A package <term>implicitly uses the unnamed mode</term>
                           if either of the following conditions is true:</p>
                           <olist>
                              <item><p>There is an <elcode>xsl:apply-templates</elcode> 
                                 element with no <code>mode</code> attribute, and with no ancestor-or-self having 
                                 an <code>[xsl:]default-mode</code> attribute.</p></item>
                              <item><p>There is an <elcode>xsl:template</elcode> 
                                 element with a <code>match</code> attribute and no <code>mode</code> attribute, and with no ancestor-or-self having 
                                 an <code>[xsl:]default-mode</code> attribute.</p></item>
                           </olist>
                        </item>
                     </olist>
                     

             
                  
                  
               </div4>


            </div3>
            <div3 id="package-local-declarations">
               <head>Declarations Local to a Package</head>

               <p>The <elcode>xsl:import</elcode> and
                     <elcode>xsl:include</elcode> declarations are local to a package.</p>

               <p>Declarations of <termref def="dt-key">keys</termref>, <termref def="dt-accumulator">accumulators</termref>, 
                  <termref def="dt-decimal-format">decimal formats</termref>, namespace aliases (see
                     <specref ref="namespace-aliasing"/>), <termref def="dt-output-definition">output definitions</termref>, and <termref def="dt-character-map">character
                     maps</termref> within a package have local scope within that package —
                  they are all effectively private. The elements that declare these constructs do
                  not have a <code>visibility</code> attribute. The unnamed decimal format and the
                  unnamed output format are also local to a package.</p>
               <p>If <elcode>xsl:strip-space</elcode> or <elcode>xsl:preserve-space</elcode>
                  declarations appear within a <termref def="dt-library-package">library
                     package</termref>, they only affect calls to the <xfunction>doc</xfunction> or
                     <function>document</function> functions appearing within that package. Such a declaration within the <termref def="dt-top-level-package"/> additionally affects stripping of whitespace in
                     the document that contains the <termref def="dt-global-context-item"/>.</p>

               <p>An <elcode>xsl:decimal-format</elcode> declaration within a package applies only
                  to calls on <xfunction>format-number</xfunction> appearing within that
                  package.</p>

               <p>An <elcode>xsl:namespace-alias</elcode> declaration within a package applies only
                  to literal result elements within the same package.</p>

               <p>An <elcode>xsl:import-schema</elcode> declaration within a package adds the names
                  of the imported schema components to the static context for that package only;
                  these names are effectively private, in the sense that they do not become
                  available for use in any other packages. However, the names of schema components
                  must be consistent across the stylesheet as a whole: it is not possible for two
                  different packages within a stylesheet to use a type-name such as <code>part-number</code> to
                  refer to different schema-defined simple or complex types.</p>

               <p>Type names used in the interface of public components in a package (for example,
                  in the arguments of a function) must be respected by callers of those components,
                  in the sense that the caller must supply values of the correct type. Often this
                  will mean that the using component, if it contains calls on such interfaces, must
                  itself import the necessary schema components. However, the requirement for an
                  explicit schema import applies only where the package contains explicit use of the
                  names of schema components required to call such interfaces.</p>

               <note>
                  <p>For example, suppose a <termref def="dt-library-package">library
                        package</termref> contains a function which requires an argument of type
                        <code>mfg:part-number</code>. The caller of this function must supply an
                     argument of the correct type, but does not need to import the schema unless it
                     explicitly uses the schema type name <code>mfg:part-number</code>. If it
                     obtains an instance of this type from outside the package, for example as the
                     result of another function call, then it can supply this instance to the
                     acquired function even though it has not imported a schema that defines this
                     type.</p>
               </note>


               <p>At execution time, the schema available for validating instance documents contains
                  (at least) the union of the schema components imported into all constituent
                  packages of the stylesheet.</p>

            </div3>


            <div3 id="declaring-global-context-item">
               <head>Declaring the Global Context Item</head>

               <p>The <elcode>xsl:global-context-item</elcode> element is used to declare whether a
                     <termref def="dt-global-context-item"/> is required, and if so, what its
                     <termref def="dt-required-type"/> is.</p>

               <p>The element is a <termref def="dt-declaration"/> that
                  can appear at most once in any stylesheet module; and if more than one
                     <elcode>xsl:global-context-item</elcode> declaration appears within a <termref def="dt-package"/>, then the declarations must be consistent. Specifically, all
                  the attributes <rfc2119>must</rfc2119> have semantically equivalent values.</p>

               <note>
                  <p>This means that omitting an attribute is equivalent to specifying its default
                     value explicitly; and purely lexical variations, such as the presence of whitespace
                     in an attribute value, are not considered significant.</p>
               </note>

               <p>
                  <error spec="XT" type="static" class="SE" code="3087">
                     <p>It is a <termref def="dt-static-error">static error</termref> if more than
                        one <elcode>xsl:global-context-item</elcode> declaration appears within a
                           <termref def="dt-stylesheet-module"/>, or if several modules within a
                        single <termref def="dt-package"/> contain inconsistent
                           <elcode>xsl:global-context-item</elcode> declarations</p>
                  </error></p>

               <p>If there is no <elcode>xsl:global-context-item</elcode> declaration for a package,
                  this is equivalent to specifying the empty element
                     <code>&lt;xsl:global-context-item/&gt;</code>, which imposes no constraints.</p>



               <?element xsl:global-context-item?>

               <p>The <code>use</code> attribute takes the value <code>required</code>,
                     <code>optional</code>, or <code>absent</code>. The
                  default is <code>optional</code>.</p>
               <ulist>
                     <item>
                        <p>If the value <code>required</code> is specified, then there must be a
                           global context item. </p>
                     </item>
                     <item>
                        <p>If the value <code>optional</code> is specified, or if the attribute is
                           omitted, or if the <elcode>xsl:global-context-item</elcode> element is
                           omitted, then there may or may not be a global context item.</p>
                     </item>
                     <item>
                        <p>If the value <code>absent</code> is specified, then the global focus
                           (context item, position, and size) will be <termref def="dt-absent"/></p>
                        <note>
                           <p>This specification does not define whether supplying a global context
                              item in this situation results in an error or warning, or whether the
                              supplied context item is simply ignored.</p>
                        </note>
                     </item>
                  </ulist>

               <p>If the <code>as</code> attribute is present then its value must be an <xnt spec="XP40" ref="prod-xpath40-ItemType">ItemType</xnt>. If the attribute is
                  omitted this is equivalent to specifying <code>as="item()"</code>.</p>
               <p>The <code>as</code> attribute defines the required type of the global context
                  item. The default value is <code>as="item()"</code>. If a global context item is
                  supplied then it must conform to the required type, after conversion (if
                  necessary) using the <termref def="dt-coercion-rules"/>.</p>

               <p><error spec="XT" type="static" class="SE" code="3089">
                     <p>It is a <termref def="dt-static-error"/> if the <code>as</code> attribute is
                        present <error.extra>on the <elcode>xsl:global-context-item</elcode>
                           element</error.extra> when <code>use="absent"</code> is specified.</p>
                  </error></p>

               

               

               

               <p>The global context item is available only within the <termref def="dt-top-level-package"/>. If a valid <elcode>xsl:global-context-item</elcode>
                  declaration appears within a <termref def="dt-library-package"/>, then it is
                  ignored, unless it specifies <code>use="required"</code>, in which case an error
                  is signaled: <errorref spec="XT" class="TE" code="0590"/>.</p>
               

               <note>
                  <p>In earlier releases of this specification, the <termref def="dt-global-context-item"/> and
                  the <termref def="dt-initial-match-selection"/> were essentially the same thing, often referred
                  to as the <emph>principal source document</emph>. In XSLT 3.0, they were separated:
                  the global context item is a single item accessible to the initializers of global variables
                  as the value of the expression <code>.</code> (dot), while the initial match selection
                  is a sequence of nodes or other items supplied to an initial implicit <elcode>xsl:apply-templates</elcode>
                  invocation.</p>
                  <p>APIs that were originally designed for use with earlier versions of XSLT
                  are likely to bundle the two concepts together.</p>
                  <p>With a streamable processor, the <termref def="dt-initial-match-selection"/> can consist
                  of streamed nodes, but the <termref def="dt-global-context-item"/> is always <termref def="dt-grounded"/>,
                  because it is available to all global variables and there is no control over the sequence of processing.</p>
                  
                  
               </note>



               <p>A <termref def="dt-type-error"/> is signaled if 
                  <phrase diff="chg" at="2022-01-01">the <termref def="dt-top-level-package"/> contains</phrase>
                  an <elcode>xsl:global-context-item</elcode>
                  declaration specifying a required type that does not match the supplied <termref def="dt-global-context-item"/>. The error code is the same as for
                     <elcode>xsl:param</elcode>: <errorref spec="XT" class="TE" code="0590"/>.
                  <phrase diff="add" at="2022-01-01">[XSLT 3.0 Erratum E7, bug 30179].</phrase></p>



               <note>
                  <p>If the <code>ItemType</code> is one that can only be satisfied by a
                     schema-validated input document, for example
                        <code>as="schema-element(invoice)"</code>, the <termref def="dt-processor">processor</termref> may interpret this as a request to apply schema
                     validation to the input. Similarly, if the <code>KindTest</code> indicates that
                     an element node is required, the processor may interpret this as a request to
                     supply the document element rather than the document node of a supplied input
                     document.</p>
               </note>
               
               <p diff="add" at="2022-01-01">
                  <error spec="XT" type="dynamic" class="DE" code="3086">
                     <p>It is a <termref def="dt-dynamic-error">dynamic error</termref> if an
                        <elcode>xsl:global-context-item</elcode> declaration specifies
                     <code>use="required"</code>, and no global context item is supplied. [XSLT 3.0 Erratum E6, bug 30173].</p>
                  </error></p>

            </div3>



            <div3 id="packages-csv-library-example">
               <head>Worked Example of a Library Package</head>





               <p>The example in this section illustrates the use of overrides to customize or
                  extend a (fictional) library package named
                     <code>http://example.com/csv-parser</code>, which provides a parsing function
                  for data formatted as lines containing comma-separated values. For simplicity of
                  exposition, the example shows a simple, naive implementation; a realistic CSV
                  parser would be more complicated and make the example harder to follow.</p>

               <div4 id="csv-example-default-functionality">
                  <head>Default Functionality of the CSV Package</head>

                  <p>The basic functionality of the package is provided by the function
                        <code>csv:parse</code>, which expects a string parameter named
                        <code>input</code>. By default, the function parses the input into lines,
                     and breaks lines on commas, returning as result an element named
                        <code>csv</code> containing one <code>row</code> element per line, each
                        <code>row</code> containing a sequence of <code>field</code> elements.</p>

                  <p>A simple stylesheet which uses this library and applies it to a string might
                     look like the following. The initial template applies <code>csv:parse</code> to
                     a suitable string and returns a copy of the result:</p>
                  <eg role="xslt-document" xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   xmlns:xs="http://www.w3.org/2001/XMLSchema"
   xmlns:csv="http://example.com/csv"
   exclude-result-prefixes="xs csv"
   version="3.0"&gt;

   &lt;xsl:output indent="yes" /&gt;

   &lt;xsl:use-package name="http://example.com/csv-parser" 
                    package-version="*" /&gt;

   &lt;!-- example input "file"  --&gt;
   &lt;xsl:variable name="input" as="xs:string"&gt;
       name,id,postal code
       "Abel Braaksma",34291,1210 KA
       "Anders Berglund",473892,9843 ZD
   &lt;/xsl:variable&gt;

   &lt;!-- entry point --&gt;
   &lt;xsl:template name="xsl:initial-template"&gt;
       &lt;xsl:copy-of select="csv:parse($input)" /&gt;
   &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</eg>
                  <p>The result returned by this stylesheet would be:</p>
                  <eg role="xml" xml:space="preserve">&lt;csv&gt;
  &lt;row&gt;
    &lt;field quoted="no"&gt;name&lt;/field&gt;
    &lt;field quoted="no"&gt;id&lt;/field&gt;
    &lt;field quoted="no"&gt;postal code&lt;/field&gt;
  &lt;/row&gt;
  &lt;row&gt;
    &lt;field quoted="yes"&gt;Abel Braaksma&lt;/field&gt;
    &lt;field quoted="no"&gt;34291&lt;/field&gt;
    &lt;field quoted="no"&gt;1210 KA&lt;/field&gt;
  &lt;/row&gt;
  &lt;row&gt;
    &lt;field quoted="yes"&gt;Anders Berglund&lt;/field&gt;
    &lt;field quoted="no"&gt;473892&lt;/field&gt;
    &lt;field quoted="no"&gt;9843 ZD&lt;/field&gt;
  &lt;/row&gt;
&lt;/csv&gt;
</eg>

                  <p>Variations on this default behavior are achieved by overriding selected
                     declarations in the package, as described below.</p>
               </div4>

               <div4 id="csv-example-package-structure">
                  <head>Package Structure</head>

                  <p>The package module itself is version 1.0.0 of a package called
                        <code>http://example.com/csv-parser</code>; it has the following
                     structure:</p>
                  <eg role="xslt-document" xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:package
   name="http://example.com/csv-parser"
   package-version="1.0.0"
   xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   xmlns:xs="http://www.w3.org/2001/XMLSchema"
   xmlns:csv="http://example.com/csv"
   exclude-result-prefixes="xs csv"
   declared-modes="yes"
   version="3.0"&gt;

   &lt;!--* Mode declarations ... *--&gt;
   &lt;!--* Variable declarations ... *--&gt;
   &lt;!--* Attribute-set declaration ... *--&gt;
   &lt;!--* Function declarations ... *--&gt;
   &lt;!--* Templates ... *--&gt;

&lt;/xsl:package&gt;</eg>

                  <p>The contents of the package (represented here by comments) are described more
                     fully below.</p>
               </div4>

               <div4 id="csv-example-customizing-parse">
                  <head>The <code>csv:parse</code> Function and its User-customization Hooks</head>

                  <p>The <code>csv:parse</code> function is final and cannot be overridden. As can be
                     seen from the code below, it (1) parses its <code>input</code> parameter into
                     lines, (2) calls function <code>csv:preprocess-line</code> on each line, then
                     (3) applies the templates of mode <code>csv:parse-line</code> to the
                     pre-processed value. The result is then (4) processed again by mode
                        <code>csv:post-process</code>.</p>

                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:function name="csv:parse" visibility="final"&gt;
    &lt;xsl:param name="input" as="xs:string" /&gt;   
    &lt;xsl:variable name="result" as="element()"&gt;
        &lt;csv&gt;
            &lt;xsl:apply-templates 
                select="(tokenize($input, $csv:line-separator) 
                        ! csv:preprocess-line(.))" 
                mode="csv:parse-line" /&gt;
        &lt;/csv&gt;
    &lt;/xsl:variable&gt;
    &lt;xsl:apply-templates select="$result" 
                         mode="csv:post-process" /&gt;
&lt;/xsl:function&gt;
</eg>

                  <p>The default code for this processing is given below. Each part of the
                     processing except the first (the tokenization into lines) can be overridden by
                     the user of the package.</p>
               </div4>
               <div4 id="csv-example-line-breaking">
                  <head>Breaking the Input into Lines</head>
                  <p>The first user-customization hook is given by the global variable
                        <code>csv:line-separator</code>, which specifies the line separator used to
                     break the input string into lines. It can be overridden by the user if need be.
                     The default declaration attempts to handle the line-separator sequences used by
                     most common operating systems in text files:</p>
                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:variable name="csv:line-separator" 
              as="xs:string" 
              select="'\r\n?|\n\r?'" 
              visibility="public"/&gt;
</eg>
               </div4>

               <div4 id="csv-example-preprocessing-lines">
                  <head>Pre-processing the Lines</head>

                  <p>The function <code>csv:preprocess-line</code> calls
                        <code>normalize-space()</code> on its argument:</p>
                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:function name="csv:preprocess-line" 
                 as="xs:string?" 
                 visibility="public"&gt;
    &lt;xsl:param name="line" as="xs:string" /&gt;
    &lt;xsl:sequence select="normalize-space($line)" /&gt;
&lt;/xsl:function&gt;
</eg>
                  <p>Because the function is declared <code>public</code>, it can be overridden by a
                     user. (This might be necessary, for example, if whitespace within quoted
                     strings needs to be preserved.)</p>
               </div4>

               <div4 id="example-csv-mode-parse-line">
                  <head>The Mode <code>csv:parse-line</code></head>

                  <p>By default, the mode <code>csv:parse-line</code> parses the current item (this
                     will be one line of the input data) into fields, using mode
                        <code>csv:parse-field</code> on the individual fields and (by default)
                     wrapping the result in a <code>row</code> element.</p>
                  <p>The mode is declared with <code>visibility="public"</code> to allow it to be
                     called from elsewhere and overridden:</p>

                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:mode name="csv:parse-line" visibility="public"/&gt;</eg>

                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:template match="." mode="csv:parse-line"&gt;
    &lt;row&gt;
        &lt;xsl:apply-templates 
            select="tokenize(., $csv:field-separator)" 
            mode="csv:parse-field" /&gt;
    &lt;/row&gt;
&lt;/xsl:template&gt;
</eg>
                  <p>This relies on the variable <code>csv:field-separator</code>, which is a comma
                     by default but which can be overridden by the user to parse tab-separated data
                     or data with other delimiters.</p>
                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:variable name="csv:field-separator" 
              as="xs:string" 
              select="','" 
              visibility="public"/&gt;
</eg>
                  <p>The default implementation of <code>csv:parse-line</code> does not handle
                     occurrences of the field separator occurring within quoted strings. The user
                     can add templates to the mode to provide that functionality. </p>
               </div4>

               <div4 id="csv-example-mode">
                  <head>Mode <code>csv:parse-field</code></head>

                  <p>Mode <code>csv:parse-field</code> processes the current item as a field; by
                     default it strips quotation marks from the value, calls the function
                        <code>csv:preprocess-field()</code> on it, and wraps the result in a
                        <code>field</code> element, which carries the attributes declared in the
                     attribute set <code>csv:field-attributes</code>.</p>

                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">
&lt;xsl:template match="." 
              mode="csv:parse-field" 
              expand-text="yes"&gt;
    &lt;xsl:variable name="string-body-pattern"
                  as="xs:string"
                  select="'([^' || $csv:validated-quote || ']*)'"/&gt;
    &lt;xsl:variable name="quoted-value"
                  as="xs:string"
                  select="$csv:validated-quote 
                          || $string-body-pattern 
                          || $csv:validated-quote"/&gt;
    &lt;xsl:variable name="unquoted-value"
                  as="xs:string"
                  select="'(.+)'"/&gt;

    &lt;field xsl:use-attribute-sets="csv:field-attributes"&gt;{
        csv:preprocess-field(
          replace(., 
                  $quoted-value || '|' || $unquoted-value, 
                  '$1$2'))
    }&lt;/field&gt;
&lt;/xsl:template&gt;
</eg>


                  <!--<p>I am having trouble deciding whether a user will find it more
convenient to have csv:preprocess-field() called before or after
quotation marks are stripped.  I don't suppose that for purposes of
the example it is essential that we have the best possible design, but
there is no need to make it needlessly implausible.</p>-->


                  <p>The attribute set <code>csv:field-attributes</code> includes, by default, a
                        <code>quoted</code> attribute which has the values <code>yes</code> or
                        <code>no</code> to show whether the input value was quoted or not.</p>

                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:attribute-set name="csv:field-attributes" 
                   visibility="public"&gt;
    &lt;xsl:attribute name="quoted" 
                   select="if (starts-with(., $csv:validated-quote)) 
                           then 'yes' 
                           else 'no'" /&gt;
&lt;/xsl:attribute-set&gt;
</eg>

                  <p>The mode <code>csv:parse-field</code> is declared with
                        <code>visibility="public"</code> to allow it to be called from elsewhere and
                     overridden; it specifies <code>on-no-match="shallow-copy"</code> so that any
                     string not matching a template will simply be copied:</p>
                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:mode name="csv:parse-field"
          on-no-match="shallow-copy" 
          visibility="public"/&gt;
</eg>
               </div4>

               <div4 id="csv-example-variable">
                  <head>The <code>csv:quote</code> Variable</head>

                  <p>The variable <code>csv:quote</code> can be used to specify the character used
                     in a particular input stream to quote values.</p>

                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:variable name="csv:quote" 
              as="xs:string" 
              select="'&amp;quot;'" 
              visibility="public"/&gt;
</eg>

                  <p>The template given above assumes that the variable is one character long. To
                     ensure that any overriding value of the variable is properly checked, references to the value use a
                     second variable <code>csv:validated-quote</code>, which
                     is declared <code>private</code> to ensure that the checking cannot be
                     disabled.</p>

                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:variable name="csv:validated-quote" visibility="private"
   as="xs:string" select="
       if (string-length($csv:quote) ne 1) 
       then error(xs:QName('csv:ERR001'), 
                  'Incorrect length for $csv:quote, should be 1') 
       else $csv:quote" /&gt;
</eg>

                  <p>When the value of <code>csv:quote</code> is not
                     exactly one character long, the reference to
                        <code>csv:validated-quote</code> will cause an error (csv:ERR001)
                     to be raised.</p>

               </div4>
               <div4 id="csv-example-preprocess-field">
                  <head>The <code>csv:preprocess-field</code> Function</head>

                  <p>The function <code>csv:preprocess-field</code> is called on each field after
                     any quotation marks are stripped and before it is written out as the value of a
                        <code>field</code> element:</p>
                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:function name="csv:preprocess-field" 
              as="xs:string"&gt;
    &lt;xsl:param name="field" 
               as="xs:string" /&gt;
    &lt;xsl:sequence select="$field" /&gt;
&lt;/xsl:function&gt;
</eg>
                  <p>As can be seen, the function does nothing but return its input; its only
                     purpose is to provide the opportunity for the user to supply a suitable
                     function to be invoked at this point in the processing of each field.</p>

               </div4>


               <div4 id="csv-example-postprocess">
                  <head>The Mode <code>csv:post-process</code></head>
                  <p>The mode <code>csv:post-process</code> is intended solely as a hook for user
                     code. By default, it does nothing.</p>

                  <p>The package defines no templates for this mode; the mode definition makes it
                     return a copy of its input:</p>
                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:mode name="csv:post-process" 
          on-no-match="shallow-copy" 
          visibility="public"/&gt;
</eg>
               </div4>

               <div4 id="csv-example-overriding">
                  <head>Overriding the Default Behavior</head>

                  <p>As can be seen from the code shown above, the package provides several
                     opportunities for users to override the default behavior:</p>
                  <ulist>
                     <item>
                        <p>The global variables <code>csv:line-separator</code>,
                              <code>csv:field-separator</code>, and <code>csv:quote</code> can be
                           overridden to specify the character strings used to separate lines and
                           fields and to quote individual field values.</p>
                     </item>
                     <item>
                        <p>The function <code>csv:preprocess-line</code> can be overridden to do
                           more (or less) than stripping white space; the function
                              <code>csv:preprocess-field</code> can be overridden to process
                           individual field values.</p>
                     </item>
                     <item>
                        <p>Templates can be added to the modes <code>csv:parse-line</code>,
                              <code>csv:parse-field</code>, and <code>csv:post-process</code> to
                           change their behavior.</p>
                     </item>
                     <item>
                        <p>The attribute set <code>csv:field-attributes</code> can be overridden to
                           specify a different set of attributes (or none) for <code>field</code>
                           elements.</p>
                     </item>
                  </ulist>

                  <p>The following using stylesheet illustrates the use of the
                        <elcode>xsl:override</elcode> element to take advantage of several of these
                     opportunities:</p>


                  <eg role="xslt-document" xml:space="preserve">
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   xmlns:xs="http://www.w3.org/2001/XMLSchema"
   xmlns:csv="http://example.com/csv"
   exclude-result-prefixes="xs csv"
   version="3.0"&gt;

   &lt;xsl:output indent="yes" /&gt;

   &lt;xsl:use-package name="http://example.com/csv-parser" 
                    package-version="*"&gt;
       &lt;xsl:override&gt;
           &lt;!-- Change the root element from 'csv' to 'root' --&gt;
           &lt;xsl:template match="csv" mode="csv:post-process"&gt;
               &lt;root&gt;
                   &lt;xsl:apply-templates mode="csv:post-process" /&gt;
               &lt;/root&gt;
           &lt;/xsl:template&gt;

           &lt;!-- add an extra attribute that uses the context item --&gt;
           &lt;xsl:attribute-set name="csv:field-attributes" 
                              use-attribute-sets="xsl:original"&gt;
               &lt;xsl:attribute name="type" 
                              select="if (. castable as xs:decimal) 
                                      then 'numeric' 
                                      else 'string'" /&gt;
           &lt;/xsl:attribute-set&gt;          

           &lt;!-- use semicolon not comma between fields --&gt;
           &lt;xsl:variable name="csv:field-separator" 
                         as="xs:string" select="';'" 
                         visibility="public"/&gt;

           &lt;!-- prevent empty rows from appearing with empty lines --&gt;
           &lt;xsl:function name="csv:preprocess-line" 
                         as="xs:string?" 
                         visibility="public"&gt;
               &lt;xsl:param name="line" as="xs:string" /&gt;
               &lt;xsl:variable name="norm-line" 
                             select="normalize-space(xsl:original($line))" /&gt;
               &lt;xsl:sequence select="if (string-length($norm-line) &gt; 0) 
                                     then $norm-line 
                                     else ()" /&gt;
           &lt;/xsl:function&gt;
       &lt;/xsl:override&gt;
   &lt;/xsl:use-package&gt;

   &lt;!-- example input "file"  --&gt;
   &lt;xsl:variable name="input" as="xs:string"&gt;
       name;id;postal code
       "Braaksma Abel";34291;1210 KA
       "Berglund Anders";473892;9843 ZD
   &lt;/xsl:variable&gt;

   &lt;!-- entry point --&gt;
   &lt;xsl:template name="xsl:initial-template"&gt;
       &lt;xsl:copy-of select="csv:parse($input)" /&gt;
   &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg>
                  <note>
                     <ulist>
                        <item>
                           <p>As it does elsewhere, the visibility of components declared within
                                 <elcode>xsl:override</elcode> defaults to <code>private</code>; to keep
                              the component public, it is necessary to specify visibility
                              explicitly.</p>
                        </item>
                        <item>
                           <p>The types and optionality of all function parameters must match those
                              of the function being overridden; for function overriding to be
                              feasible, packages must document the function signature
                              thoroughly.</p>
                        </item>
                        <item>
                           <p>The names, types, and optionality of all named-template parameters
                              must match those of the template being overridden; for overriding to
                              be feasible, packages must document the template signature
                              thoroughly.</p>
                        </item>
                        <item>
                           <p>The values for the attributes in the attribute set
                                 <code>csv:field-attributes</code> are calculated once for each
                              element for which the attribute set is supplied; the
                                 <code>select</code> attributes which determine the values can thus
                              refer to the context item. Here, the value specification for the
                                 <code>type</code> attribute checks to see whether the string value
                              of the context item is numeric by inquiring whether it can be cast to
                              decimal, and sets the value for the <code>type</code> attribute
                              accordingly.</p>
                        </item>
                     </ulist>
                  </note>

                  <p>The result returned by this stylesheet would be:</p>
                  <eg role="xml" xml:space="preserve">&lt;root&gt;
  &lt;row&gt;
    &lt;field quoted="no" type="string"&gt;name&lt;/field&gt;
    &lt;field quoted="no" type="string"&gt;id&lt;/field&gt;
    &lt;field quoted="no" type="string"&gt;postal code&lt;/field&gt;
  &lt;/row&gt;
  &lt;row&gt;
    &lt;field quoted="yes" type="string"&gt;Braaksma Abel&lt;/field&gt;
    &lt;field quoted="no" type="numeric"&gt;34291&lt;/field&gt;
    &lt;field quoted="no" type="string"&gt;1210 KA&lt;/field&gt;
  &lt;/row&gt;
  &lt;row&gt;
    &lt;field quoted="yes" type="string"&gt;Berglund Anders&lt;/field&gt;
    &lt;field quoted="no" type="numeric"&gt;473892&lt;/field&gt;
    &lt;field quoted="no" type="string"&gt;9843 ZD&lt;/field&gt;
  &lt;/row&gt;
&lt;/root&gt;
</eg>
               </div4>


            </div3>


            


         </div2>
         <div2 id="stylesheet-modules">
            <head>Stylesheet Modules</head>

            <p>
               <termdef id="dt-stylesheet-module" term="stylesheet module">A <termref def="dt-package">package</termref> consists of one or
                  more <term>stylesheet modules</term>, each one forming all or part of an XML
                  document.</termdef>
            </p>
            <note>
               <p>A stylesheet module is represented by an XDM element node (see <bibref ref="xpath-datamodel-30"/>). In the case of a standard stylesheet module, this
                  will be an <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode>
                  element. In the case of a simplified stylesheet module, it can be any element (not
                  in the <termref def="dt-xslt-namespace">XSLT namespace</termref>) that has an
                     <code>xsl:version</code> attribute.</p>
               <p>Although stylesheet modules will commonly be maintained in the form of documents
                  conforming to XML 1.0 or XML 1.1, this specification does not mandate such a
                  representation. As with <termref def="dt-source-tree">source trees</termref>, the
                  way in which stylesheet modules are constructed, from textual XML or otherwise, is
                  outside the scope of this specification.</p>
            </note>

            <p>The principal stylesheet module of a package may take one
               of three forms:</p>

            <ulist>
               <item>
                  <p>A package manifest, as described in <specref ref="packages"/>, which is a
                     subtree rooted at an <elcode>xsl:package</elcode> element</p>
               </item>
               <item>
                  <p>An implicit package, which is a subtree rooted at an
                        <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element.
                     This is transformed automatically to a package as described in <specref ref="packages"/>. </p>
               </item>
               <item>
                  <p>A simplified stylesheet, which is a subtree rooted at a literal result element,
                     as described in <specref ref="simplified-stylesheet"/>. This is first converted
                     to an implicit package by wrapping it in an <elcode>xsl:stylesheet</elcode>
                     element using the transformation described in <specref ref="simplified-stylesheet"/>, and then to an explicit package (rooted at an
                        <elcode>xsl:package</elcode> element) using the transformation described in
                        <specref ref="packages"/>. </p>
               </item>
            </ulist>

            <p>A stylesheet module other than the principal stylesheet
               module of a package may take either of two forms:</p>

            <ulist>
               <item>
                  <p><termdef id="dt-standard-stylesheet-module" term="standard stylesheet module">A
                           <term>standard stylesheet module</term>, which is a subtree rooted at an
                           <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode>
                        element.</termdef></p>
               </item>
               <item>
                  <p><termdef id="dt-simplified-stylesheet-module" term="simplified stylesheet">A
                           <term>simplified stylesheet</term>, which is a subtree rooted at a
                           <termref def="dt-literal-result-element">literal result
                        element</termref>, as described in <specref ref="simplified-stylesheet"/>.
                        This is first converted to a <termref def="dt-standard-stylesheet-module">standard stylesheet module</termref> by wrapping it in an xsl:stylesheet
                        element using the transformation described in <specref ref="simplified-stylesheet"/>.</termdef>
                  </p>
               </item>
            </ulist>
            <p>Whichever of the above forms a module takes, the outermost
               element (<elcode>xsl:package</elcode>, <elcode>xsl:stylesheet</elcode>, or a <termref def="dt-literal-result-element"/>) <rfc2119>may</rfc2119> either be the outermost
               element of an XML document, or it <rfc2119>may</rfc2119> be a child of some
               (non-XSLT) element in a host document. </p>
            <p><termdef id="dt-embedded-stylesheet-module" term="embedded stylesheet module">A stylesheet module whose outermost element is
                  the child of a non-XSLT element in a host document is referred to as an
                     <term>embedded stylesheet module</term>. See <specref ref="embedded"/>.</termdef>
            </p>


         </div2>
         <div2 id="stylesheet-element">
            <head>Stylesheet Element</head>
            <?element xsl:stylesheet?>
            <?element xsl:transform?>

            <p>A stylesheet module is represented by an <elcode>xsl:stylesheet</elcode> element in
               an XML document. <elcode>xsl:transform</elcode> is allowed as a synonym for
                  <elcode>xsl:stylesheet</elcode>; everything this specification says about the
                  <elcode>xsl:stylesheet</elcode> element applies equally to
                  <elcode>xsl:transform</elcode>.</p>

            <p>The <code>version</code> attribute indicates the version
               of XSLT that the stylesheet module requires. The attribute is
                  <rfc2119>required</rfc2119>.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0110">
                  <p>The value of the <code>version</code> attribute <rfc2119>must</rfc2119> be a number:
                     specifically, it <rfc2119>must</rfc2119> be a valid instance of the type
                        <code>xs:decimal</code> as defined in <bibref ref="xmlschema-2"/>.</p>
               </error>
            </p>
            <p>The <code>version</code> attribute is intended to indicate the
               version of the XSLT specification against which the stylesheet is written. In a
               stylesheet written to use XSLT 4.0, the value <rfc2119>should</rfc2119> normally be
               set to <code>4.0</code>. If the value is numerically less than 4.0, the
               stylesheet is processed using the rules for <termref def="dt-backwards-compatible-behavior">backwards compatible behavior</termref>
               (see <specref ref="backwards"/>). If the value is numerically greater than
               <phrase diff="chg" at="2023-02-24">4.0</phrase>, the stylesheet is processed using the rules for 
               <termref def="dt-forwards-compatible-behavior"/> (see <specref ref="forwards"/>).</p>

            <!--For this version of XSLT, the value <rfc2119>should</rfc2119> normally
be <code>
                  <phrase diff="chg" at="2022-01-01">3.0</phrase>
               </code>.  A value of <code>1.0</code> indicates that the stylesheet module
was written with the intention that it <rfc2119>should</rfc2119> be processed using an XSLT 1.0 processor,
               <phrase diff="add" at="D">while a value of <code>2.0</code> indicates that the module
                  was intended to be processed using an XSLT 2.0 processor</phrase>.</p>
            <p>If a <termref def="dt-stylesheet">stylesheet</termref>
that specifies <code>[xsl:]version="1.0"</code> in the
outermost element of the <termref def="dt-principal-stylesheet-module">principal
stylesheet module</termref> (that is, <code>version="1.0"</code> in the case of a 
<termref def="dt-standard-stylesheet-module">standard stylesheet module</termref>, or
<code>xsl:version="1.0"</code> in the case of a <termref def="dt-simplified-stylesheet-module">simplified
stylesheet module</termref>) is submitted to an XSLT <phrase diff="chg" at="2022-01-01">3.0</phrase> processor, the processor <rfc2119>should</rfc2119> output
a warning advising the user of possible incompatibilities, unless the user has requested otherwise. 
The processor <rfc2119>must</rfc2119> then process the stylesheet
using the rules for <termref def="dt-backwards-compatible-behavior"/>.
These rules require that if the processor does not support 
<termref def="dt-backwards-compatible-behavior"/>, it <rfc2119>must</rfc2119>
signal an error and <rfc2119>must not</rfc2119> execute the transformation.</p>
            <p>When the value of the <code>version</code> attribute is greater than <phrase diff="chg" at="2022-01-01">3.0</phrase>, 
<termref def="dt-forwards-compatible-behavior">forwards compatible behavior</termref> 
is enabled (see <specref ref="forwards"/>).</p>
            <note>
               <p>XSLT 1.0 allowed the <code>[xsl:]version</code> attribute to take any numeric value,
and specified that if the value was not equal to 1.0, the <termref def="dt-stylesheet">stylesheet</termref> would be executed in
forwards compatible mode. XSLT 2.0 <phrase diff="chg" at="2022-01-01">and 3.0</phrase>continue to allow the attribute to take any unsigned decimal value.
A software product that includes both an XSLT <phrase diff="chg" at="2022-01-01">3.0</phrase> processor and
<phrase diff="chg" at="2022-01-01">a processor supporting a different XSLT version</phrase> (or that can execute as either) may use the <code>[xsl:]version</code> attribute to 
decide which processor to invoke; such behavior is outside the scope of this specification. 
When the stylesheet is executed with an XSLT <phrase diff="chg" at="2022-01-01">3.0</phrase> processor, the value
<code>1.0</code> is taken to indicate that the stylesheet module
was written with XSLT 1.0
in mind: if this value appears on the outermost element of the principal stylesheet module then
an XSLT <phrase diff="chg" at="2022-01-01">3.0</phrase> processor will either reject the stylesheet or execute it in backwards compatible
mode, as described above. 
Setting <code>version="<phrase diff="chg" at="2022-01-01">3.0</phrase>"</code> indicates that the <termref def="dt-stylesheet">stylesheet</termref> is to be
executed with neither backwards nor forwards compatible behavior enabled. Any other value less than
<code>2.0</code> enables backwards compatible behavior, while any value greater than <code>
                     <phrase diff="chg" at="2022-01-01">3.0</phrase>
                  </code>
enables forwards compatible behavior.</p>
               
               <p>When developing a <termref def="dt-stylesheet">stylesheet</termref> that is designed to execute under either XSLT 1.0 or XSLT 2.0,
the recommended practice is to create two alternative <termref def="dt-stylesheet-module">stylesheet modules</termref>, 
one specifying
<code>version="1.0"</code>, and the other specifying <code>version="2.0"</code>; these
modules can use <elcode>xsl:include</elcode> or <elcode>xsl:import</elcode> to incorporate 
the common code. When running under an XSLT 1.0 processor, the <code>version="1.0"</code> module can
be selected as the <termref def="dt-principal-stylesheet-module">principal stylesheet module</termref>;
when running under an XSLT 2.0 processor, the <code>version="2.0"</code> module can
be selected as the <termref def="dt-principal-stylesheet-module">principal stylesheet module</termref>.
Stylesheet modules that are included or imported should specify <code>version="2.0"</code> if they make use of XSLT 2.0 facilities,
and <code>version="1.0"</code> otherwise.</p>
            </note>-->
            <p>The effect of the <code>input-type-annotations</code> attribute is described in
                  <specref ref="stripping-annotations"/>.</p>
            <p>The <code>[xsl:]default-validation</code> attribute defines the default value of the
                  <code>validation</code> attribute of all relevant instructions appearing within
               its scope. For details of the effect of this attribute, see <specref ref="validation"/>.</p>
            
            <p diff="add" at="2023-02-16">The optional <code>main-module</code> attribute is purely documentary.
            By including this attribute in every <termref def="dt-stylesheet-module"/> of a <termref def="dt-package"/>,
            an XSLT editing tool may be enabled to locate the top-level module of the relevant package,
            and thus to gather information about all the global variables, templates, and functions available
            within the module being edited.
            This information can be used (for example) to enable auto-completion and error highlighting of the code as it is
            entered. Note that it may be inconvenient or misleading to use this attribute when the stylesheet
            module is used as a shared component within multiple stylesheets.
          </p>
            <p>
               <error spec="XT" type="static" class="SE" code="0120">
                  <p>An <elcode>xsl:stylesheet</elcode>, <elcode>xsl:transform</elcode>,
                  or <elcode>xsl:package</elcode> element <rfc2119>must not</rfc2119> have any
                     text node children.</p>
               </error> (This rule applies after stripping of <termref def="dt-whitespace-text-node">whitespace text nodes</termref> as described in <specref ref="stylesheet-stripping"/>.)</p>
            <p>
               <termdef id="dt-top-level" term="top-level">An element occurring as a child of an
                     <elcode>xsl:package</elcode>,
                     <elcode>xsl:stylesheet</elcode>,
                        <elcode>xsl:transform</elcode>, or <elcode>xsl:override</elcode>
                  element is called a <term>top-level</term> element.</termdef>
            </p>
            <p>
               <termdef id="dt-declaration" term="declaration">Top-level elements fall into two
                  categories: declarations, and user-defined data elements. Top-level elements whose
                  names are in the <termref def="dt-xslt-namespace">XSLT namespace</termref> are
                     <term>declarations</term>. Top-level elements in any other namespace are
                     <termref def="dt-data-element">user-defined data elements</termref> (see
                     <specref ref="user-defined-top-level"/>)</termdef>.</p>
            <p>The <termref def="dt-declaration">declaration</termref> elements permitted in the
                  <elcode>xsl:stylesheet</elcode> element are:</p>
            <slist>
               <sitem>
                  <elcode>xsl:accumulator</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:attribute-set</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:character-map</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:decimal-format</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:function</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:global-context-item</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:import</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:import-schema</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:include</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:key</elcode>
               </sitem>
               <sitem>
                  
                     <elcode>xsl:mode</elcode>
                  
               </sitem>
               <sitem>
                  <elcode>xsl:namespace-alias</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:output</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:param</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:preserve-space</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:strip-space</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:template</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:use-package</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:variable</elcode>
               </sitem>
            </slist>
            <p>Note that the <elcode>xsl:variable</elcode> and <elcode>xsl:param</elcode> elements
               can act either as <termref def="dt-declaration">declarations</termref> or as <termref def="dt-instruction">instructions</termref>. A global variable or parameter is
               defined using a declaration; a local variable or parameter using an instruction.</p>
            <p>The child elements of the <elcode>xsl:stylesheet</elcode>
               element may appear in any order. In most cases, the ordering of these elements does
               not affect the results of the transformation; however:</p>

            <ulist>
               <item>
                  <p>As described in <specref ref="conflict"/>, when two template rules with the
                     same <termref def="dt-priority">priority</termref> match the same nodes, there
                     are situations where the order of the template rules will affect which is
                     chosen.</p>
               </item>
               <item>
                  <p>Forwards references to <termref def="dt-static-variable">static variables</termref> are not allowed in <termref def="dt-static-expression">static expressions</termref>.</p>
               </item>
            </ulist>

            
            <div3 id="default-collation-attribute">
               <head>The <code>default-collation</code> Attribute</head>
               <p>The <code>default-collation</code> attribute is a <termref def="dt-standard-attributes">standard attribute</termref> that may appear on
                  any element in the XSLT namespace, or (as <code>xsl:default-collation</code>) on a
                     <termref def="dt-literal-result-element">literal result element</termref>.</p>
               <p>The attribute, when it appears on an element
                        <var>E</var>, is used to specify the default collation used by all XPath
                     expressions appearing in attributes or <termref def="dt-text-value-template">text value templates</termref> that have <var>E</var> as an
                     ancestor, unless overridden by another <code>default-collation</code>
                  attribute on an inner element. It also determines the collation used by certain
                  XSLT constructs (such as <elcode>xsl:key</elcode> and
                     <elcode>xsl:for-each-group</elcode>) within its scope.</p>
               <p>The value of the attribute is a whitespace-separated list of collation URIs. If
                  any of these URIs is a relative URI reference,
                  then it is resolved <phrase diff="chg" at="2023-05-19">as described in 
                     <xspecref spec="FO40" ref="collations"/>.</phrase>. If the implementation recognizes one or more of the resulting absolute
                  collation URIs, then it uses the first one that it recognizes as the default
                  collation.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0125">
                     <p>It is a <termref def="dt-static-error">static error</termref> if the value
                        of an <code>[xsl:]default-collation</code> attribute, after resolving
                        against the base URI, contains no URI that the implementation recognizes as
                        a collation URI.</p>
                  </error>
               </p>
               <note>
                  <p>The reason the attribute allows a list of collation URIs is that collation URIs
                     will often be meaningful only to one particular XSLT implementation.
                     Stylesheets designed to run with several different implementations can
                     therefore specify several different collation URIs, one for use with each. To
                     avoid the above error condition, it is possible to include as the last
                     collation URI in the list either the Unicode Codepoint Collation or a collation in the UCA family (see <specref ref="uca-collations"/>) with the parameter
                        <code>fallback=yes</code>.</p>
               </note>
               <p>The <code>[xsl:]default-collation</code> attribute does not affect the collation
                  used by <elcode>xsl:sort</elcode> or by <elcode>xsl:merge</elcode>.</p>
               <p>In the absence of an
                     <code>[xsl:]default-collation</code> attribute, the default collation
                     <rfc2119>may</rfc2119> be set by the calling application in an <termref def="dt-implementation-defined"/> way. The recommended default, unless the user
                  chooses otherwise, is to use the Unicode codepoint collation.</p>
               <imp-def-feature id="idf-api-defaultcollation">In the absence of an
                     <code>[xsl:]default-collation</code> attribute, the default collation
                     <rfc2119>may</rfc2119> be set by the calling application in an <termref def="dt-implementation-defined"/> way.</imp-def-feature>
            </div3>
            <div3 id="default-mode">
               <head>The <code>default-mode</code> Attribute</head>
               <p>The <code>[xsl:]default-mode</code> attribute defines the default value for the
                     <termref def="dt-mode">mode</termref> attribute of all
                     <elcode>xsl:template</elcode> and <elcode>xsl:apply-templates</elcode> elements
                     within its scope.</p>
               
               

               <p>More specifically, when an element <var>E</var> matches
                  the pattern <code>(xsl:template[@match] | xsl:apply-templates)[not(@mode) or
                     normalize-space(@mode) eq "#default"]</code> (using the Unicode codepoint
                  collation), then the <termref def="dt-effective-value"/> of the <code>mode</code> attribute is taken
                  from the value of the <code>[xsl:]default-mode</code> attribute of the innermost
                  ancestor-or-self element of <var>E</var> that has such an attribute. If there is
                  no such element, then the default is the <termref def="dt-unnamed-mode">unnamed
                     mode</termref>. This is equivalent to specifying <code>#unnamed</code>.</p>
               
               <p>In addition, when the attribute appears on the <elcode>xsl:package</elcode>,
                  <elcode>xsl:stylesheet</elcode>, or <elcode>xsl:transform</elcode> element of the 
                  <termref def="dt-principal-stylesheet-module"/> of the <termref def="dt-top-level-package"/>,
                     it provides a default value for the <termref def="dt-initial-mode"/> used on stylesheet
                     invocation.</p>

               <p>The value of the <code>[xsl:]default-mode</code> attribute <rfc2119>must</rfc2119>
                  either be an <termref def="dt-eqname">EQName</termref>, or the token <code>#unnamed</code> which refers to
                  the <termref def="dt-unnamed-mode">unnamed mode</termref>.</p>

               <note>
                  <p>This attribute is provided to support an approach to stylesheet modularity in
                     which all the template rules for one <termref def="dt-mode">mode</termref> are
                     collected together into a single <termref def="dt-stylesheet-module">stylesheet
                        module</termref>. Using this attribute reduces the risk of forgetting to
                     specify the mode in one or more places where it is needed, and it also makes it
                     easier to reuse an existing stylesheet module that does not use modes in an
                     application where modes are needed to avoid conflicts with existing template
                     rules.</p>
                  <p>It is not necessary for the referenced mode to be
                     explicitly declared in an <elcode>xsl:mode</elcode> declaration, unless this is
                     mandated by the <code>declared-modes</code> attribute (which defaults to
                        <code>yes</code> on an <elcode>xsl:package</elcode> element).</p>
               </note>

            </div3>
            <div3 id="user-defined-top-level">
               <head>User-defined Data Elements</head>
               <p>
                  <termdef id="dt-data-element" term="user-defined data element">In addition to
                        <termref def="dt-declaration">declarations</termref>, the
                        <elcode>xsl:stylesheet</elcode> element may contain among its children any
                     element not from the <termref def="dt-xslt-namespace">XSLT namespace</termref>,
                     provided that the <termref def="dt-expanded-qname">expanded QName</termref> of
                     the element has a non-null namespace URI. Such elements are referred to as
                        <term>user-defined data elements</term>.</termdef>
               </p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0130">
                     <p>It is a <termref def="dt-static-error">static error</termref> if an
                        <elcode>xsl:stylesheet</elcode>, <elcode>xsl:transform</elcode>,
                           or <elcode>xsl:package</elcode> element has a child element whose name
                        has a null namespace URI.</p>
                  </error>
               </p>
               <p>An implementation <rfc2119>may</rfc2119> attach an <termref def="dt-implementation-defined"/> meaning to user-defined data elements that
                  appear in particular namespaces. The set of namespaces that are recognized for
                  such data elements is <termref def="dt-implementation-defined">implementation-defined</termref>. The presence of a user-defined data element
                     <rfc2119>must not</rfc2119> change the behavior of <termref def="dt-xslt-element">XSLT elements</termref> and functions defined in this
                  document; for example, it is not permitted for a user-defined data element to
                  specify that <elcode>xsl:apply-templates</elcode> should use different rules to
                  resolve conflicts. The constraints on what user-defined data elements can and
                  cannot do are exactly the same as the constraints on <termref def="dt-extension-attribute">extension attributes</termref>, described in
                     <specref ref="extension-attributes"/>. Thus, an implementation is always free
                  to ignore user-defined data elements, and <rfc2119>must</rfc2119> ignore such data
                  elements without giving an error if it does not recognize the namespace URI. </p>

               <imp-def-feature id="idf-ext-namespaces">The set of namespaces that are specially
                  recognized by the implementation (for example, for user-defined data elements, and
                     <termref def="dt-extension-attribute">extension attributes</termref>) is
                     <termref def="dt-implementation-defined"/>.</imp-def-feature>
               <imp-def-feature id="idf-ext-dataelements">The effect of user-defined data elements
                  whose name is in a namespace recognized by the implementation is <termref def="dt-implementation-defined"/>.</imp-def-feature>
               <p>User-defined data elements can provide, for example,</p>
               <ulist>
                  <item>
                     <p>information used by <termref def="dt-extension-instruction">extension
                           instructions</termref> or <termref def="dt-extension-function">extension
                           functions</termref> (see <specref ref="extension"/>),</p>
                  </item>
                  <item>
                     <p>information about what to do with any <termref def="dt-final-result-tree">final result tree</termref>,</p>
                  </item>
                  <item>
                     <p>information about how to construct <termref def="dt-source-tree">source
                           trees</termref>,</p>
                  </item>
                  <item>
                     <p>optimization hints for the <termref def="dt-processor">processor</termref>,</p>
                  </item>
                  <item>
                     <p>metadata about the stylesheet,</p>
                  </item>
                  <item>
                     <p>structured documentation for the stylesheet.</p>
                  </item>
               </ulist>
               
            </div3>
         </div2>
         <div2 id="simplified-stylesheet">
            <head>Simplified Stylesheet Modules</head>
            <p>A simplified syntax is allowed for a <termref def="dt-stylesheet-module">stylesheet
                  module</termref> that defines only a single template rule for the document node.
               The stylesheet module may consist of just a <termref def="dt-literal-result-element">literal result element</termref> (see <specref ref="literal-result-element"/>)
               together with its contents. The literal result element must have an
                  <code>xsl:version</code> attribute (and it must therefore also declare the XSLT
               namespace). Such a stylesheet module is equivalent to a standard stylesheet module
               whose <elcode>xsl:stylesheet</elcode> element contains a <termref def="dt-template-rule">template rule</termref> containing the literal result
               element, minus its <code>xsl:version</code> attribute; the template rule has a match
                  <termref def="dt-pattern">pattern</termref> of <code>/</code>.</p>
            <example>
               <head>A Simplified Stylesheet</head>
               <p>For example:</p>
               <eg xml:space="preserve" role="xml">&lt;html xsl:version="3.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns="http://www.w3.org/1999/xhtml"&gt;
  &lt;head&gt;
    &lt;title&gt;Expense Report Summary&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Total Amount: &lt;xsl:value-of select="expense-report/total"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</eg>
               <p>has the same meaning as</p>
               <eg xml:space="preserve" role="xslt-document">&lt;xsl:stylesheet version="3.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;xsl:template match="/"&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Expense Report Summary&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Total Amount: &lt;xsl:value-of select="expense-report/total"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</eg>
               <p>Note that it is not possible, using a simplified stylesheet, to request that the
                  serialized output contains a <code>DOCTYPE</code> declaration. This can only be
                  done by using a standard stylesheet module, and using the
                     <elcode>xsl:output</elcode> element.</p>
            </example>
            <p>More formally, a simplified stylesheet module is equivalent to the standard
               stylesheet module that would be generated by applying the following transformation to
               the simplified stylesheet module, invoking the transformation by calling the <termref def="dt-named-template">named template</termref>
               <code>expand</code>, with the containing literal result element as the <termref def="dt-context-node">context node</termref>: </p>
            <eg xml:space="preserve" role="xslt-document">&lt;xsl:stylesheet version="3.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template name="expand"&gt;
  &lt;xsl:element name="xsl:stylesheet"&gt;
    &lt;xsl:attribute name="version" select="@xsl:version"/&gt;
    &lt;xsl:element name="xsl:template"&gt;
      &lt;xsl:attribute name="match" select="'/'"/&gt;
      &lt;xsl:copy-of select="."/&gt;
    &lt;/xsl:element&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;  

&lt;/xsl:stylesheet&gt;</eg>
            <p>
               <error spec="XT" type="static" class="SE" code="0150">
                  <p>A <termref def="dt-literal-result-element">literal result element</termref>
                     that is used as the outermost element of a simplified stylesheet module
                        <rfc2119>must</rfc2119> have an <code>xsl:version</code> attribute.</p>
               </error> This indicates the version of XSLT that the stylesheet requires. For this
               version of XSLT, the value will normally be <phrase diff="chg" at="2023-02-24">4.0</phrase>; the 
               value <rfc2119>must</rfc2119> be a valid instance of the type
                  <code>xs:decimal</code> as defined in <bibref ref="xmlschema-2"/>.</p>
            
            <p>The allowed content of a literal result element when used as a simplified stylesheet
               is the same as when it occurs within a <termref def="dt-sequence-constructor">sequence constructor</termref>. Thus, a literal result element used as the
               document element of a simplified stylesheet cannot contain <termref def="dt-declaration">declarations</termref>. Simplified stylesheets therefore
               cannot use <termref def="dt-template-rule">template rules</termref>, <termref def="dt-global-variable">global variables</termref>, <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>, <termref def="dt-stylesheet-function">stylesheet functions</termref>, <termref def="dt-key">keys</termref>, <termref def="dt-attribute-set">attribute-sets</termref>, or
                  <termref def="dt-output-definition">output definitions</termref>. In turn this
               means that the only useful way to initiate the transformation is to supply a document
               node as the <termref def="dt-initial-match-selection"/>, to be matched by the implicit
                  <code>match="/"</code> template rule using the <termref def="dt-unnamed-mode">unnamed mode</termref>. </p>
         </div2>
         <div2 id="backwards">
            <head>Backwards Compatible Processing</head>
            <p><termdef id="dt-effective-version" term="effective version">The <term>effective
                     version</term> of an element in a <termref def="dt-stylesheet-module"/> or <termref def="dt-package-manifest"/> is the decimal value of the <code>[xsl:]version</code> attribute
                  (see <specref ref="standard-attributes"/>) on that element or on the innermost
                  ancestor element that has such an attribute, excluding the <code>version</code>
                  attribute on an <elcode>xsl:output</elcode> element.</termdef></p>
            <p>
               <termdef id="dt-backwards-compatible-behavior" term="backwards compatible behavior">An element is 
                  processed with <term>backwards compatible behavior</term> if its
                     <termref def="dt-effective-version">effective version</termref> is less than
                  <phrase diff="chg" at="2023-02-24">4.0</phrase>.</termdef>
            </p>
            <p>Specifically:</p>
            <ulist>
               <item>
                  <p>If the <termref def="dt-effective-version">effective version</termref> is equal
                     to 1.0, then the element is processed with XSLT 1.0 behavior as described in
                        <specref ref="backwards-1.0"/>.</p>
               </item>
               <item>
                  <p>If the <termref def="dt-effective-version">effective version</termref> is equal
                     to 2.0, then the element is processed with XSLT 2.0 behavior as described in
                        <specref ref="backwards-2.0"/>.</p>
               </item>
               <item diff="add" at="2023-02-28">
                  <p>If the <termref def="dt-effective-version">effective version</termref> is equal
                     to 3.0, then the element is processed with XSLT 3.0 behavior as described in
                     <specref ref="backwards-3.0"/>.</p>
               </item>
               <item>
                  <p>If the <termref def="dt-effective-version">effective version</termref> is any
                     other value less than <phrase diff="chg" at="2023-02-24">4.0</phrase>, 
                     the <rfc2119>recommended</rfc2119> action is to
                     report a static error; however, processors <rfc2119>may</rfc2119> recognize
                     such values and process the element in an <termref def="dt-implementation-defined"/> way.</p>
                  <imp-def-feature id="idf-err-unknownversion">If the 
                     <termref def="dt-effective-version">effective version</termref> of any element in the
                     stylesheet is not 1.0 or 2.0 but is less than <phrase diff="chg" at="2023-02-24">4.0</phrase>, the
                        <rfc2119>recommended</rfc2119> action is to report a static error; however,
                     processors <rfc2119>may</rfc2119> recognize such values and process the element
                     in an <termref def="dt-implementation-defined"/> way.</imp-def-feature>
                  <note>
                     <p>XSLT 1.0 allowed the <code>version</code> attribute to take any decimal
                        value, and invoked forwards compatible processing for any value other than
                        1.0. XSLT 2.0 allowed the attribute to take any decimal value, and invoked
                        backwards compatible (i.e. 1.0-compatible) processing for any value less
                        than 2.0. Some stylesheets may therefore be encountered that use values
                        other than 1.0 or 2.0. In particular, the value 1.1 is sometimes
                        encountered, as it was used at one stage in a draft language proposal.</p>
                  </note>
               </item>
            </ulist>
            <p>These rules do not apply to the <elcode>xsl:output</elcode> element, whose
                  <code>version</code> attribute has an entirely different purpose: it is used to
               define the version of the output method to be used for serialization.</p>

            

            <p>It is <termref def="dt-implementation-defined"/> whether a particular XSLT 4.0
               implementation supports backwards compatible behavior for any XSLT version earlier
               than XSLT 4.0.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0160">
                  <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if an element has
                     an <termref def="dt-effective-version">effective version</termref> of
                     <var>V</var> (with <var>V</var> &lt; <phrase diff="chg" at="2023-02-24">4.0</phrase>) when the implementation does not
                     support backwards compatible behavior for XSLT version <var>V</var>.</p>
               </error>
            </p>
            <imp-def-feature id="idf-feature-backwardscompatibility">It is implementation-defined
               whether an XSLT 4.0 processor supports backwards
               compatible behavior for any XSLT version earlier than XSLT 4.0.</imp-def-feature>

            <note>
               <p>By making use of backwards compatible behavior, it is possible to write the
                  stylesheet in a way that ensures that its results when processed with an XSLT 4.0
                  processor are identical to the effects of processing the same stylesheet using
                     a processor for an earlier version of XSLT.
                  To assist with transition, some parts of a stylesheet may be processed with
                  backwards compatible behavior enabled, and other parts with this behavior
                  disabled.</p>
               <p>All data values manipulated by an XSLT 4.0
                  processor are defined by the XDM data model, whether or not the relevant
                  expressions use backwards compatible behavior. Because the same data model is used
                  in both cases, expressions are fully composable. The result of evaluating
                  instructions or expressions with backwards compatible behavior is fully defined in
                  the XSLT 4.0 and XPath 4.0 specifications, it is not defined by reference to earlier versions of the XSLT and XPath
                     specifications. </p>

               <p>To write a stylesheet that makes use of features that
                     are new in version <var>N</var>, while also working with a processor that only
                     supports XSLT version <var>M</var> (<var>M</var> &lt; <var>N</var>),
                  it is necessary to understand both the rules for backwards compatible behavior in
                     XSLT version <var>N</var>, and the rules for
                  forwards compatible behavior in XSLT version
                        <var>M</var>. If the <elcode>xsl:stylesheet</elcode> element
                  specifies <phrase>a <code>version</code> attribute with a value greater than 1.0</phrase>, then an XSLT 1.0
                  processor will ignore <phrase diff="del" at="2023-02-24">XSLT 2.0 and XSLT 3.0</phrase>
                  <termref def="dt-declaration">declarations</termref> that were not defined in XSLT
                  1.0, for example <elcode>xsl:function</elcode>,
                     <elcode>xsl:import-schema</elcode><phrase diff="add" at="2023-02-24">, 
                        and <elcode>xsl:mode</elcode></phrase>. If any new XSLT
                  <phrase diff="chg" at="2023-02-24">4.0 instructions are used (for example <elcode>xsl:switch</elcode>
                     or <elcode>xsl:array</elcode>)</phrase>, or if new XPath
                  <phrase diff="chg" at="2023-02-24">4.0 features are used (for example, keyword arguments in function calls)</phrase>, 
                     then the stylesheet must provide
                  fallback behavior that relies only on facilities available in the earliest XSLT version supported. The fallback
                  behavior can be invoked by using the <elcode>xsl:fallback</elcode> instruction, or
                  by testing the results of the <function>function-available</function> or
                     <function>element-available</function> functions, or by testing the value of
                  the <code>xsl:version</code> property returned by the
                     <function>system-property</function> function.</p>
            </note>

            <div3 id="backwards-1.0">
               <head>XSLT 1.0 Compatibility Mode</head>
               <p><termdef id="dt-xslt-10-behavior" term="XSLT 1.0 behavior">An element in the
                     stylesheet is processed with <term>XSLT 1.0 behavior</term> if its <termref def="dt-effective-version">effective version</termref> is equal to
                     1.0.</termdef></p>
               <p>In this mode, if any attribute contains an XPath <termref def="dt-expression">expression</termref>, then the expression is evaluated with <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> set to
                     <code>true</code>. For details of this mode, see <xspecref spec="XP40" ref="static_context"/>. Expressions contained in
                        <termref def="dt-text-value-template">text value templates</termref> are
                     always evaluated with <termref def="dt-xpath-compat-mode">XPath 1.0
                        compatibility mode</termref> set to <code>false</code>, since this construct
                     was not available in XSLT 1.0.</p>

               <p>Furthermore, in such an expression any function call for which no implementation
                  is available (unless it uses the <termref def="dt-standard-function-namespace">standard function namespace</termref>) is bound to a fallback error function
                  whose effect when evaluated is to raise a dynamic error <errorref spec="XT" class="DE" code="1425"/> . The effect is that with backwards compatible
                  behavior enabled, calls on <termref def="dt-extension-function">extension
                     functions</termref> that are not available in a particular implementation do
                  not cause an error unless the function call is actually evaluated. For further
                  details, see <specref ref="extension-functions"/>.</p>
               <note>
                  <p>This might appear to contradict the specification of XPath 3.0, which states that a static error [XPST0017] is raised
                     when an expression contains a call to a function that is not present (with
                     matching name and arity) in the static context. This apparent contradiction is
                     resolved by specifying that the XSLT processor constructs a static context for
                     the expression in which every possible function name and arity (other than
                     names in the <termref def="dt-standard-function-namespace">standard function
                        namespace</termref>) is present; when no other implementation of the
                     function is available, the function call is bound to a fallback error function
                     whose run-time effect is to raise a dynamic error.</p>
               </note>
               <p>Certain XSLT constructs also produce different results when XSLT 1.0 compatibility
                  mode is enabled. This is described separately for each such construct.</p>

               <p>Processing an <termref def="dt-instruction"/> with XSLT
                  1.0 behavior is not compatible with streaming. More specifically, and
                  notwithstanding anything stated in <specref ref="streamability"/>, an instruction
                  that is processed with XSLT 1.0 behavior is <termref def="dt-roaming"/> and
                     <termref def="dt-free-ranging"/>, which has the effect that any construct
                  containing such an instruction is not <termref def="dt-guaranteed-streamable"/>.</p>


            </div3>
            <div3 id="backwards-2.0">
               <head>XSLT 2.0 Compatibility Mode</head>
               <p><termdef id="dt-xslt-20-behavior" term="XSLT 2.0 behavior">An element is processed
                     with <term>XSLT 2.0 behavior</term> if its <termref def="dt-effective-version">effective version</termref> is equal to 2.0.</termdef></p>
               <p>In this specification, no differences are defined for XSLT 2.0 behavior. An XSLT
                  <phrase diff="chg" at="2023-02-24">4.0</phrase> processor will therefore 
                  produce the same results whether the <termref def="dt-effective-version">effective version</termref> of an element is set to
                  2.0 or <phrase diff="chg" at="2023-02-24">4.0</phrase>.</p>
               <note>
                  <p>An XSLT 2.0 processor, by contrast, will in some cases produce different
                     results in the two cases. For example, if the stylesheet contains an
                        <elcode>xsl:switch</elcode> instruction with an
                     <elcode>xsl:fallback</elcode> child, an XSLT <phrase diff="chg" at="2023-02-24">4.0</phrase> processor will process the
                        <elcode>xsl:switch</elcode> instruction regardless whether the effective
                     version is 2.0, 3.0, <phrase diff="chg" at="2023-02-24">or 4.0</phrase>, while an 
                     XSLT 2.0 processor will report a static error
                     if the effective version is 2.0, and will take the fallback action if the
                     effective version is 3.0 or 4.0.</p>
               </note>

            </div3>
            <div3 id="backwards-3.0" diff="add" at="2023-02-24">
               <head>XSLT 3.0 Compatibility Mode</head>
               <p><termdef id="dt-xslt-30-behavior" term="XSLT 3.0 behavior">An element is processed
                  with <term>XSLT 3.0 behavior</term> if its <termref def="dt-effective-version">effective version</termref> 
                  is equal to 3.0.</termdef></p>
               <p>In this specification, no differences are defined for XSLT 3.0 behavior. An XSLT
                  <phrase diff="chg" at="2023-02-24">4.0</phrase> processor will therefore 
                  produce the same results whether the <termref def="dt-effective-version">effective version</termref> of an element is set to
                  3.0 or <phrase diff="chg" at="2023-02-24">4.0</phrase>.</p>
               <note>
                  <p>An XSLT 3.0 processor, by contrast, will in some cases produce different
                     results in the two cases. For example, if the stylesheet contains an
                     <elcode>xsl:switch</elcode> instruction with an
                     <elcode>xsl:fallback</elcode> child, an XSLT <phrase diff="chg" at="2023-02-24">4.0</phrase> processor will process the
                     <elcode>xsl:switch</elcode> instruction regardless whether the effective
                     version is 2.0, 3.0, <phrase diff="chg" at="2023-02-24">or 4.0</phrase>, while an 
                     XSLT 3.0 processor will report a static error
                     if the effective version is 2.0 or 3.0, and will take the fallback action if the
                     effective version is 4.0.</p>
               </note>
               
            </div3>
         </div2>
         <div2 id="forwards">
            <head>Forwards Compatible Processing</head>
            <p>The intent of forwards compatible behavior is to make it possible to write a
               stylesheet that takes advantage of features introduced in some version of XSLT
               subsequent to XSLT 4.0, while retaining the
               ability to execute the stylesheet with an XSLT 4.0
               processor using appropriate fallback behavior.</p>
            <p>It is always possible to write conditional code to run under different XSLT versions
               by using the <code>use-when</code> feature described in <specref ref="conditional-inclusion"/>. 
               The rules for forwards compatible behavior
               supplement this mechanism in two ways:</p>
            <ulist>
               <item>
                  <p>Certain constructs in the stylesheet that mean nothing to an XSLT 4.0 processor are ignored, 
                     rather than being treated as errors.</p>
               </item>
               <item>
                  <p>Explicit fallback behavior can be defined for instructions defined in a future
                     XSLT release, using the <elcode>xsl:fallback</elcode> instruction.</p>
               </item>
            </ulist>
            <p>The detailed rules follow.</p>
            <p>
               <termdef id="dt-forwards-compatible-behavior" term="forwards compatible behavior">An
                  element is processed with <term>forwards compatible behavior</term> if its
                     <termref def="dt-effective-version">effective version</termref> is greater than
                     <phrase diff="chg" at="2023-02-24">4.0</phrase>.</termdef>
            </p>
            
            <p>These rules do not apply to the <code>version</code> attribute of the
                  <elcode>xsl:output</elcode> element, which has an entirely different purpose: it
               is used to define the version of the output method to be used for serialization.</p>
            <p>When an element is processed with forwards compatible behavior:</p>
            <ulist>
               <item>
                  <p>If the element is in the XSLT namespace and appears as a child of the
                        <elcode>xsl:stylesheet</elcode> element, and XSLT 4.0 does not allow the element 
                        to appear as a child of the
                        <elcode>xsl:stylesheet</elcode> element, then the element and its content
                        <rfc2119>must</rfc2119> be ignored.</p>
               </item>
               <item>
                  <p>If the element has an attribute that XSLT 4.0 does not allow the element to have, then the attribute
                        <rfc2119>must</rfc2119> be ignored.</p>
               </item>
               <item>
                  <p>If the element is in the XSLT namespace and appears as a child of an element 
                     whose content model requires a
                     <termref def="dt-sequence-constructor">sequence constructor</termref>, and XSLT
                     <phrase diff="chg" at="2023-02-24">4.0</phrase> does not allow such elements to
                     appear as part of a sequence constructor, then:</p>
                  <olist>
                     <item>
                        <p>If the element has one or more <elcode>xsl:fallback</elcode> children,
                           then no error is reported either statically or dynamically, and the
                           result of evaluating the instruction is the concatenation of the
                           sequences formed by evaluating the sequence constructors within its
                              <elcode>xsl:fallback</elcode> children, in document order. Siblings of
                           the <elcode>xsl:fallback</elcode> elements are ignored, even if they are
                           valid XSLT 4.0 instructions.</p>
                     </item>
                     <item>
                        <p>If the element has no <elcode>xsl:fallback</elcode> children, then a
                           static error is reported in the same way as if forwards compatible
                           behavior were not enabled.</p>
                     </item>
                  </olist>
               </item>
            </ulist>
            <example>
               <head>Forwards Compatible Behavior</head>
               <p>For example, an XSLT 4.0
                  <termref def="dt-processor">processor</termref> will process the following
                  stylesheet without error, although the stylesheet includes elements from the
                     <termref def="dt-xslt-namespace">XSLT namespace</termref> that are not defined
                  in this specification:</p>
               <eg xml:space="preserve" role="xml">&lt;xsl:stylesheet version="17.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:template match="/"&gt;
    &lt;xsl:exciting-new-17.0-feature&gt;
      &lt;xsl:fly-to-the-moon/&gt;
      &lt;xsl:fallback&gt;
        &lt;html&gt;
          &lt;head&gt;
            &lt;title&gt;XSLT 17.0 required&lt;/title&gt;
          &lt;/head&gt;
          &lt;body&gt;
            &lt;p&gt;Sorry, this stylesheet requires XSLT 17.0.&lt;/p&gt;
          &lt;/body&gt;
        &lt;/html&gt;
      &lt;/xsl:fallback&gt;
    &lt;/xsl:exciting-new-17.0-feature&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</eg>
            </example>
            <note>
               <p>If a stylesheet depends crucially on a <termref def="dt-declaration">declaration</termref> 
                  introduced by a version of XSLT after <phrase diff="chg" at="2023-02-24">4.0</phrase>, then the stylesheet can use an
                     <elcode>xsl:message</elcode> element with <code>terminate="yes"</code> (see
                     <specref ref="message"/>) to ensure that implementations that conform to an
                  earlier version of XSLT will not silently ignore the <termref def="dt-declaration">declaration</termref>.</p>
            </note>
            <example>
               <head>Testing the XSLT Version</head>
               <p>For example,</p>
               <eg xml:space="preserve" role="xml">&lt;xsl:stylesheet version="18.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:important-new-17.0-declaration/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="number(system-property('xsl:version')) lt 17.0"&gt;
        &lt;xsl:message terminate="yes"&gt;
          &lt;xsl:text&gt;Sorry, this stylesheet requires XSLT 17.0.&lt;/xsl:text&gt;
        &lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        ...
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
  ...
&lt;/xsl:stylesheet&gt;</eg>
            </example>
            <note>
               <p>The XSLT 1.0 and XSLT 2.0 specifications did not anticipate the
                  introduction of the <elcode>xsl:package</elcode> element. An XSLT 1.0 or 2.0
                  processor encountering this element will report a static error, regardless of the
                     <code>version</code> setting.</p>
               <p>This problem can be circumvented by using the simplified package
                  syntax (whereby an
                        <elcode>xsl:stylesheet</elcode> element is implicitly treated as
                        <elcode>xsl:package</elcode>), or by writing the stylesheet code in
                  a separate module from the package manifest, and using the separate module as the
                  version of the stylesheet that is presented to a 2.0 processor.</p>
            </note>
         </div2>
         <div2 id="combining-modules">
            <head>Combining Stylesheet Modules</head>
            <p>XSLT provides two mechanisms to construct a <termref def="dt-package">package</termref> from multiple <termref def="dt-stylesheet-module">stylesheet modules</termref>:</p>
            <ulist>
               <item>
                  <p>an inclusion mechanism that allows stylesheet modules to be combined without
                     changing the semantics of the modules being combined, and</p>
               </item>
               <item>
                  <p>an import mechanism that allows stylesheet modules to override each other.</p>
               </item>
            </ulist>
            <div3 id="locating-modules">
               <head>Locating Stylesheet Modules</head>
               <p>The include and import mechanisms use two declarations,
                     <elcode>xsl:include</elcode> and <elcode>xsl:import</elcode>, which are defined
                  in the sections that follow.</p>
               <p>These declarations use an <code>href</code> attribute, whose value is a <termref def="dt-uri-reference">URI reference</termref>, to identify the <termref def="dt-stylesheet-module">stylesheet module</termref> to be included or
                  imported. If the value of this attribute is a relative URI reference, it is resolved as described in <specref ref="uri-references"/>.</p>
               <p>After resolving against the base URI, the way in which the URI reference is used
                  to locate a representation of a <termref def="dt-stylesheet-module">stylesheet
                     module</termref>, and the way in which the stylesheet module is constructed
                  from that representation, are <termref def="dt-implementation-defined">implementation-defined</termref>. In particular, it is implementation-defined
                  which URI schemes are supported, whether fragment identifiers are supported, and
                  what media types are supported. Conventionally, the URI is a reference to a
                  resource containing the stylesheet module as a source XML document, or it may
                  include a fragment identifier that selects an embedded stylesheet module within a
                  source XML document; but the implementation is free to use other mechanisms to
                  locate the stylesheet module identified by the URI reference.</p>

               <imp-def-feature id="idf-api-moduleuri"> It is implementation-defined what forms of
                  URI reference are acceptable in the <code>href</code> attribute of the
                     <elcode>xsl:include</elcode> and <elcode>xsl:import</elcode> elements, for
                  example, the URI schemes that may be used, the forms of fragment identifier that
                  may be used, and the media types that are supported. The way in which the URI
                  reference is used to locate a representation of a <termref def="dt-stylesheet-module">stylesheet module</termref>, and the way in which
                  the stylesheet module is constructed from that representation, are also
                  implementation-defined.</imp-def-feature>

               <p>The referenced <termref def="dt-stylesheet-module">stylesheet module</termref>
                  <rfc2119>must</rfc2119> be either a <termref def="dt-standard-stylesheet-module"/>
                  or a <termref def="dt-simplified-stylesheet-module"/>. It <rfc2119>must
                     not</rfc2119> be a <termref def="dt-package-manifest"/>. If it is a simplified
                  stylesheet module then it is transformed into the equivalent standard stylesheet
                  module by applying the transformation described in <specref ref="simplified-stylesheet"/>. </p>


               <p>Implementations <rfc2119>may</rfc2119> choose to accept URI references containing
                  a fragment identifier defined by reference to the XPointer specification (see
                     <bibref ref="xptr-framework"/>). Note that if the implementation does not
                  support the use of fragment identifiers in the URI reference, then it will not be
                  possible to include an <termref def="dt-embedded-stylesheet-module">embedded
                     stylesheet module</termref>.</p>

               <p>
                  <error spec="XT" type="static" class="SE" code="0165">
                     <p>It is a <termref def="dt-static-error">static error</termref> if the
                        processor is not able to retrieve the resource identified by the URI
                           reference<error.extra> in the <code>href</code> attribute of
                              <elcode>xsl:include</elcode> or <elcode>xsl:import</elcode>
                        </error.extra>, or if the resource that is retrieved does not contain a
                        stylesheet module.</p>
                  </error>
               </p>
               <note>
                  <p><!--bug 9992--> It is appropriate to use this error code when
                     the resource cannot be retrieved, or when the retrieved resource is not well
                     formed XML. If the resource contains XML that can be parsed but that violates
                     the rules for stylesheet modules, then a more specific error code may be more
                     appropriate.</p>
               </note>
            </div3>
            <div3 id="include">
               <head>Stylesheet Inclusion</head>
               <?element xsl:include?>
               <p>A stylesheet module may include another stylesheet module using an
                     <elcode>xsl:include</elcode> declaration.</p>
               <p>The <elcode>xsl:include</elcode> declaration has a <rfc2119>required</rfc2119>
                  <code>href</code> attribute whose value is a URI reference identifying the
                  stylesheet module to be included. This attribute is used as described in <specref ref="locating-modules"/>.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0170">
                     <p>An <elcode>xsl:include</elcode> element <rfc2119>must</rfc2119> be a
                           <termref def="dt-top-level">top-level</termref> element.</p>
                  </error>
               </p>
               <p>
                  <termdef id="dt-stylesheet-level" term="stylesheet level">A <term>stylesheet
                        level</term> is a collection of <termref def="dt-stylesheet-module">stylesheet modules</termref> connected using <elcode>xsl:include</elcode>
                     declarations: specifically, two stylesheet modules <var>A</var> and
                        <var>B</var> are part of the same stylesheet level if one of them includes
                     the other by means of an <elcode>xsl:include</elcode> declaration, or if there
                     is a third stylesheet module <var>C</var> that is in the same stylesheet level
                     as both <var>A</var> and <var>B</var>.</termdef>
               </p>
               <note>
                  <p>A stylesheet level thus groups the <termref def="dt-declaration">declarations</termref> 
                     in a <termref def="dt-package"/> by <termref def="dt-import-precedence"/>:
                  two declarations within a package are in the same stylesheet level if and only if they
                  have the same import precedence.</p>
               </note>
               <p>
                  <termdef id="dt-declaration-order" term="declaration order">The <termref def="dt-declaration">declarations</termref> within a <termref def="dt-stylesheet-level">stylesheet level</termref> have a total ordering
                     known as <term>declaration order</term>. The order of declarations within a
                     stylesheet level is the same as the document order that would result if each
                     stylesheet module were inserted textually in place of the
                        <elcode>xsl:include</elcode> element that references it.</termdef> In other
                  respects, however, the effect of <elcode>xsl:include</elcode> is not equivalent to
                  the effect that would be obtained by textual inclusion.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0180">
                     <p>It is a <termref def="dt-static-error">static error</termref> if a
                        stylesheet module directly or indirectly includes itself.</p>
                  </error>
               </p>
               <note>
                  <p>It is not intrinsically an error for a <termref def="dt-stylesheet">stylesheet</termref> to include the same module more than once. However,
                     doing so can cause errors because of duplicate definitions. Such multiple
                     inclusions are less obvious when they are indirect. For example, if stylesheet
                        <var>B</var> includes stylesheet <var>A</var>, stylesheet <var>C</var>
                     includes stylesheet <var>A</var>, and stylesheet <var>D</var> includes both
                     stylesheet <var>B</var> and stylesheet <var>C</var>, then <var>A</var> will be
                     included indirectly by <var>D</var> twice. If all of <var>B</var>, <var>C</var>
                     and <var>D</var> are used as independent stylesheets, then the error can be
                     avoided by separating everything in <var>B</var> other than the inclusion of
                        <var>A</var> into a separate stylesheet <var>B'</var> and changing
                        <var>B</var> to contain just inclusions of <var>B'</var> and <var>A</var>,
                     similarly for <var>C</var>, and then changing <var>D</var> to include
                        <var>A</var>, <var>B'</var>, <var>C'</var>.</p>
               </note>
            </div3>
            <div3 id="import">
               <head>Stylesheet Import</head>
               <?element xsl:import?>
               <p>A stylesheet module may import another <termref def="dt-stylesheet-module">stylesheet module</termref> using an <elcode>xsl:import</elcode>
                  <termref def="dt-declaration">declaration</termref>. Importing a stylesheet module
                  is the same as including it (see <specref ref="include"/>) except that <termref def="dt-template-rule">template rules</termref> and other <termref def="dt-declaration">declarations</termref> in the importing module take
                  precedence over template rules and declarations in the imported module; this is
                  described in more detail below.</p>
               <p>The <elcode>xsl:import</elcode> declaration has a <rfc2119>required</rfc2119>
                  <code>href</code> attribute whose value is a URI reference identifying the
                  stylesheet module to be included. This attribute is used as described in <specref ref="locating-modules"/>.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0190">
                     <p>An <elcode>xsl:import</elcode> element <rfc2119>must</rfc2119> be a <termref def="dt-top-level">top-level</termref> element.</p>
                  </error>
               </p>
               
               <example>
                  <head>Using <elcode>xsl:import</elcode>
                  </head>
                  <p>For example,</p>
                  <eg xml:space="preserve" role="xslt-document">&lt;xsl:stylesheet version="3.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:import href="article.xsl"/&gt;
  &lt;xsl:import href="bigfont.xsl"/&gt;
  &lt;xsl:attribute-set name="note-style"&gt;
    &lt;xsl:attribute name="font-style"&gt;italic&lt;/xsl:attribute&gt;
  &lt;/xsl:attribute-set&gt;
&lt;/xsl:stylesheet&gt;</eg>
               </example>
               <p>
                  <termdef id="dt-import-tree" term="import tree">The <termref def="dt-stylesheet-level">stylesheet levels</termref> making up a <termref def="dt-stylesheet">stylesheet</termref> are treated as forming an
                        <term>import tree</term>. In the import tree, each stylesheet level has one
                     child for each <elcode>xsl:import</elcode> declaration that it
                     contains.</termdef> The ordering of the children is the <termref def="dt-declaration-order">declaration order</termref> of the
                     <elcode>xsl:import</elcode> declarations within their stylesheet level.</p>
               <p>
                  <termdef id="dt-import-precedence" term="import precedence">A <termref def="dt-declaration">declaration</termref>
                     <var>D</var> in the stylesheet is defined to have lower <term>import
                        precedence</term> than another declaration <var>E</var> if the stylesheet
                     level containing <var>D</var> would be visited before the stylesheet level
                     containing <var>E</var> in a post-order traversal of the import tree (that is,
                     a traversal of the import tree in which a stylesheet level is visited after its
                     children). Two declarations within the same stylesheet level have the same
                     import precedence.</termdef>
               </p>
               <p>For example, suppose</p>
               <ulist>
                  <item>
                     <p>stylesheet module <var>A</var> imports stylesheet modules <var>B</var> and
                           <var>C</var> in that order;</p>
                  </item>
                  <item>
                     <p>stylesheet module <var>B</var> imports stylesheet module <var>D</var>;</p>
                  </item>
                  <item>
                     <p>stylesheet module <var>C</var> imports stylesheet module <var>E</var>.</p>
                  </item>
               </ulist>
               <p>Then the import tree has the following structure:</p>

               <g:graph rankdir="LR">
                  <g:node label="A" shape="box">
                     <g:node label="B" shape="box">
                        <g:node label="D" shape="box"/>
                     </g:node>
                     <g:node label="C" shape="box">
                        <g:node label="E" shape="box"/>
                     </g:node>
                  </g:node>
               </g:graph>


               <!--<p><emph>Here you should see a diagram. If it does not appear correctly in your
                     browser, you need to install an SVG Plugin.</emph></p>--> 

               <p>The order of import precedence (lowest first) is <var>D</var>, <var>B</var>,
                     <var>E</var>, <var>C</var>, <var>A</var>.</p>
               <p>In general, a <termref def="dt-declaration">declaration</termref> with higher
                  import precedence takes precedence over a declaration with lower import
                  precedence. This is defined in detail for each kind of declaration.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0210">
                     <p>It is a <termref def="dt-static-error">static error</termref> if a
                        stylesheet module directly or indirectly imports itself.</p>
                  </error>
               </p>
               <note>
                  <p>The case where a stylesheet module with a particular URI is imported several
                     times is not treated specially. The effect is exactly the same as if several
                     stylesheet modules with different URIs but identical content were imported.
                     This might or might not cause an error, depending on the content of the
                     stylesheet module.</p>
               </note>
            </div3>
         </div2>
         <div2 id="embedded">
            <head>Embedded Stylesheet Modules</head>
            <p>An <termref def="dt-embedded-stylesheet-module">embedded stylesheet module</termref>
               is a <termref def="dt-stylesheet-module">stylesheet module</termref> whose containing
               element is not the outermost element of the containing XML document. Both <termref def="dt-standard-stylesheet-module">standard stylesheet modules</termref> and
                  <termref def="dt-simplified-stylesheet-module">simplified stylesheet
                  modules</termref> may be embedded in this way.</p>
            <p>Two situations where embedded stylesheets may be useful are:</p>
            <ulist>
               <item>
                  <p>The stylesheet may be embedded in the source document to be transformed.</p>
               </item>
               <item>
                  <p>The stylesheet may be embedded in an XML document that describes a sequence of
                     processing of which the XSLT transformation forms just one part.</p>
               </item>
            </ulist>
            <p>The <elcode>xsl:stylesheet</elcode> element <rfc2119>may</rfc2119> have an
                  <code>id</code> attribute to facilitate reference to the stylesheet module within
               the containing document.</p>
            <note>
               <p>In order for such an attribute value to be used as a fragment identifier in a URI,
                  the XDM attribute node must generally have the <code>is-id</code> property: see
                     <xspecref spec="DM30" ref="dm-is-id"/>. This property will typically be set if
                  the attribute is defined in a DTD as being of type <code>ID</code>, or if it is
                  defined in a schema as being of type <code>xs:ID</code>. It is also necessary that
                  the media type of the containing document should support the use of ID values as
                  fragment identifiers. 
                  Such support is widespread in existing products, and is
                     endorsed in respect of the media type <code>application/xml</code> by <bibref ref="rfc7303"/>.</p>

               <p>An alternative, if the implementation supports it, is to use an
                     <code>xml:id</code> attribute. XSLT allows this attribute (like other
                  namespaced attributes) to appear on any <termref def="dt-xslt-element">XSLT
                     element</termref>.</p>
            </note>
            <example>
               <head>The <code>xml-stylesheet</code> Processing Instruction</head>
               <p>The following example shows how the <code>xml-stylesheet</code> processing
                  instruction (see <bibref ref="xml-stylesheet"/>) can be used to allow a source
                  document to contain its own stylesheet. The URI reference uses  a fragment identifier to locate the
                     <elcode>xsl:stylesheet</elcode> element:</p>
               <eg xml:space="preserve" role="xml">&lt;?xml-stylesheet type="application/xslt+xml" href="#style1"?&gt;
&lt;!DOCTYPE doc SYSTEM "doc.dtd"&gt;
&lt;doc&gt;
  &lt;head&gt;
    &lt;xsl:stylesheet id="style1"
                    version="3.0"
                    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                    xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;
    &lt;xsl:import href="doc.xsl"/&gt;
    &lt;xsl:template match="id('foo')"&gt;
      &lt;fo:block font-weight="bold"&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="xsl:stylesheet"&gt;
      &lt;!-- ignore --&gt;
    &lt;/xsl:template&gt;
    &lt;/xsl:stylesheet&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;para id="foo"&gt;
    ...
    &lt;/para&gt;
  &lt;/body&gt;
&lt;/doc&gt;
</eg>
            </example>
            <note>
               <p>A stylesheet module that is embedded in the document to which it is to be applied
                  typically needs to contain a <termref def="dt-template-rule">template
                     rule</termref> that specifies that <elcode>xsl:stylesheet</elcode> elements are
                  to be ignored.</p>
            </note>
            <note>
               <p>The above example uses the pseudo-attribute
                     <code>type="application/xslt+xml"</code> in the <code>xml-stylesheet</code>
                  processing instruction to denote an XSLT stylesheet. This is the officially
                  registered media type for XSLT: see <specref ref="xslt-media-type"/>. However,
                  browsers developed before this media type was registered are more likely to accept
                  the unofficial designation <code>type="text/xsl"</code>.</p>
            </note>
            <note>
               <p>Support for the <code>xml-stylesheet</code> processing instruction is not required
                  for conformance with this Recommendation. Implementations are not constrained in
                  the mechanisms they use to identify a stylesheet when a transformation is
                  initiated: see <specref ref="initiating"/>.</p>
            </note>
         </div2>
         <div2 id="preprocessing">
            <head>Stylesheet Preprocessing</head>
            <p>This specification provides <phrase diff="chg" at="2023-02-16">three</phrase> features that cause the
               raw stylesheet to be preprocessed as the first stage of static processing:
               <ulist>
                  <item diff="add" at="2023-02-16"><p>Whitespace and commentary are stripped (see <specref ref="stylesheet-stripping"/>).</p></item>
                  <item><p>Elements
                     may be conditionally included or excluded by means of an <code>[xsl:]use-when</code>
                     attribute as described in <specref ref="conditional-inclusion"/>.</p></item>
                  <item><p>Attributes may
                     be conditionally computed as described in <specref ref="shadow-attributes"/>.</p></item>
               </ulist>
            </p>

            <p>Note that many of the rules affecting the validity of
               stylesheet documents apply to a stylesheet after this preprocessing phase has been
               carried out.</p>
            
            <div3 id="stylesheet-stripping">
               <head>Stripping Whitespace and Commentary from the Stylesheet</head>
               <p>The tree representing the stylesheet is preprocessed as follows:</p>
               <olist>
                  <item>
                     <p>All comments and processing instructions are removed.</p>
                  </item>
                  <item diff="add" at="2023-02-16">
                     <p>All <elcode>xsl:note</elcode> elements are removed, together with their content
                     (see <specref ref="xsl-note-elements"/>).</p>
                  </item>
                  <item>
                     <p>Any text nodes that are now adjacent to each other are merged.</p>
                  </item>
                  <item>
                     <p>Any <termref def="dt-whitespace-text-node">whitespace text node</termref> that
                        satisfies both the following conditions is removed from the tree:</p>
                     <ulist>
                        <item>
                           <p>The parent of the text node is not an <elcode>xsl:text</elcode>
                              element</p>
                        </item>
                        <item>
                           <p>The text node does not have an ancestor element that has an
                              <code>xml:space</code> attribute with a value of
                              <code>preserve</code>, unless there is a closer ancestor element having
                              an <code>xml:space</code> attribute with a value of
                              <code>default</code>.</p>
                        </item>
                     </ulist>
                  </item>
                  <item>
                     <p>Any <termref def="dt-whitespace-text-node">whitespace text node</termref> whose
                        parent is one of the following elements is removed from the tree, regardless of
                        any <code>xml:space</code> attributes:</p>
                     <slist>
                        <sitem>
                           
                           <elcode>xsl:accumulator</elcode>
                           
                        </sitem>
                        <sitem>
                           <elcode>xsl:analyze-string</elcode>
                        </sitem>
                        <sitem>
                           <elcode>xsl:apply-imports</elcode>
                        </sitem>
                        <sitem>
                           <elcode>xsl:apply-templates</elcode>
                        </sitem>
                        <sitem>
                           <elcode>xsl:attribute-set</elcode>
                        </sitem>
                        <sitem>
                           <elcode>xsl:call-template</elcode>
                        </sitem>
                        <sitem>
                           <elcode>xsl:character-map</elcode>
                        </sitem>
                        <sitem>
                           <elcode>xsl:choose</elcode>
                        </sitem>
                        <sitem>
                           
                           <elcode>xsl:evaluate</elcode>
                           
                        </sitem>
                        <sitem>
                           
                           <elcode>xsl:fork</elcode>
                           
                        </sitem>
                        <sitem>
                           
                           <elcode>xsl:merge</elcode>
                           
                        </sitem>
                        <sitem>
                           
                           <elcode>xsl:merge-source</elcode>
                           
                        </sitem>
                        <sitem>
                           
                           <elcode>xsl:mode</elcode>
                           
                        </sitem>
                        <sitem>
                           
                           <elcode>xsl:next-iteration</elcode>
                           
                        </sitem>
                        <sitem>
                           <elcode>xsl:next-match</elcode>
                        </sitem>
                        <sitem>
                           
                           <elcode>xsl:override</elcode>
                           
                        </sitem>
                        <sitem>
                           
                           <elcode>xsl:package</elcode>
                           
                        </sitem>
                        <sitem>
                           <elcode>xsl:stylesheet</elcode>
                        </sitem>
                        <sitem>
                           <elcode>xsl:transform</elcode>
                        </sitem>
                        <sitem>
                           
                           <elcode>xsl:use-package</elcode>
                           
                        </sitem>
                     </slist>
                  </item>
                  <item>
                     <p>Any <termref def="dt-whitespace-text-node">whitespace text node</termref> whose
                        immediate following-sibling node is an <elcode>xsl:param</elcode> or
                        <elcode>xsl:sort</elcode>
                        or <elcode>xsl:context-item</elcode> or
                        <elcode>xsl:on-completion</elcode> element is removed from the
                        tree, regardless of any <code>xml:space</code> attributes.</p>
                  </item>
                  <item>
                     <p>Any <termref def="dt-whitespace-text-node">whitespace text
                        node</termref> whose immediate preceding-sibling node is an
                        <elcode>xsl:catch</elcode>
                        element is removed from the
                        tree, regardless of any <code>xml:space</code> attributes.</p>
                  </item>
               </olist>
               <p>
                  <error spec="XT" type="static" class="SE" code="0260">
                     <p>Within an <termref def="dt-xslt-element">XSLT element</termref> that is
                        <rfc2119>required</rfc2119> to be empty, any content other than comments or
                        processing instructions, including any <termref def="dt-whitespace-text-node">whitespace text node</termref> preserved using the
                        <code>xml:space="preserve"</code> attribute, is a <termref def="dt-static-error">static error</termref>.</p>
                  </error>
               </p>
               <note>
                  <p>Using <code>xml:space="preserve"</code> in parts of the stylesheet that contain
                     <termref def="dt-sequence-constructor">sequence constructors</termref> will
                     cause whitespace text nodes in that part of the
                     stylesheet to be copied to the result of the sequence constructor.
                     When the result of the sequence constructor is used to form the content of an
                     element, this can cause errors if such text nodes are followed by attribute nodes
                     generated using <elcode>xsl:attribute</elcode>.</p>
               </note>
               <note>
                  <p>If an <code>xml:space</code> attribute is specified on a <termref def="dt-literal-result-element">literal result element</termref>, it will be
                     copied to the result tree in the same way as any other attribute.</p>
               </note>
            </div3>
            
            <div3 id="xsl-note-elements" diff="add" at="2023-02-16">
               <head>The <code>xsl:note</code> element</head>
               <p>An <elcode>xsl:note</elcode> element may appear anywhere in the stylesheet, except as the outermost element.</p>
               <?element xsl:note?>
               <p>The element may have any attributes and any children, subject only to rules imposed by
                  other specifications such as the XML specification. The XSLT processor discards <elcode>xsl:note</elcode>
                  elements at an early stage of processing, without performing any validation, as described
               in <specref ref="stylesheet-stripping"/>.</p>
               <p>An <elcode>xsl:note</elcode> element is typically used for documentation. The format of this documentation
               is not prescribed here: it might be free text, or XHTML, or some custom vocabulary understood by a free-standing
               documentation generator.</p>
               <p>An <elcode>xsl:note</elcode> element might also be used for “commenting out” XSLT declarations or instructions.</p>
               
               <note>
                  <p>A number of documentation processors have been produced for use with XSLT, and the general convention has
                     been to use <termref def="dt-data-element">user-defined data elements</termref> for this purpose. This
                     approach has its drawbacks:</p>
                  <ulist>
                     <item><p>Annotations can only appear at the top level of the stylesheet (between declarations, but not
                     within declarations). <termref def="dt-extension-instruction">Extension instructions</termref>
                     can also potentially be used as annotations, but this abuses their intended purpose and may create an unwanted 
                     dependency on a specific processor.</p></item>
                     <item><p>Annotations require a custom namespace to be declared, typically on the <elcode>xsl:stylesheet</elcode>
                     element, and this namespace becomes part of the static context for all expressions within the stylesheet,
                     thus changing (if only very slightly) the semantics of the stylesheet code. This is true even
                     if the namespace is excluded from the result tree by means of an <code>[xsl:]exclude-result-prefixes</code>
                        attribute.</p></item>
                  </ulist>
               </note>
               
               <p>Implementations <rfc2119>must not</rfc2119> interpret the contents of an <elcode>xsl:note</elcode> element
               to modify the behavior of the stylesheet in any way, whether or not the resulting behavior remains conformant
               with this specification.</p>
               
               <note>
                  <p>For example, <elcode>xsl:note</elcode> elements must not be used to provide processor-specific performance
                     hints. There are better mechanisms for this, such as <termref def="dt-data-element">user-defined data elements</termref>
                  and <termref def="dt-extension-attribute">extension attributes</termref>.</p>
               </note>
            </div3>

            <div3 id="conditional-inclusion">
               <head>Conditional Element Inclusion</head>
               <p>Any element in the XSLT namespace may have a <code>use-when</code> attribute whose
                  value is an XPath expression that can be evaluated statically. 
                  A <termref def="dt-literal-result-element">literal result element</termref>, or
                  any other element within a <termref def="dt-stylesheet-module">stylesheet
                     module</termref> that is not in the XSLT namespace, may similarly carry an
                  <code>xsl:use-when</code> attribute.      
                  If the attribute is
                  present and the <xtermref spec="XP40" ref="dt-ebv">effective boolean
                     value</xtermref> of the expression is <code>false</code>, then the element, together with
                  all the nodes having that element as an ancestor, is effectively excluded from the
                     <termref def="dt-stylesheet-module">stylesheet module</termref>. When a node is
                  effectively excluded from a stylesheet module the stylesheet module has the same
                  effect as if the node were not there. Among other things this means that no static
                  or dynamic errors will be reported in respect of the element and its contents,
                  other than errors in the <code>use-when</code> attribute itself.</p>
               <note>
                  <p>This does not apply to XML parsing or validation errors, which will be reported
                     in the usual way. It also does not apply to attributes that are necessarily
                     processed before <code>[xsl:]use-when</code>, examples being
                        <code>xml:space</code> and <code>[xsl:]xpath-default-namespace</code>.</p>
               </note>
              
               <p>If the <elcode>xsl:package</elcode>, 
               <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element
                  itself is effectively excluded, the effect is to exclude all the children of the
                     <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element, but
                  not the <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element
                  or its attributes.</p>
               <note>
                  <p>This allows all the declarations that depend on the same condition to be
                     included in one stylesheet module, and for their inclusion or exclusion to be
                     controlled by a single <code>use-when</code> attribute at the level of the
                     module.</p>
               </note>
               <p>Conditional element exclusion happens after stripping of whitespace text nodes
                  from the stylesheet, as described in <specref ref="stylesheet-stripping"/>.</p>
               <p>The XPath expression used as the value of the
                     <code>xsl:use-when</code> attribute follows the rules for <termref def="dt-static-expression">static expressions</termref>, including the rules for handling errors.</p>

               <p>The use of <code>[xsl:]use-when</code> is illustrated in the following
                  examples.</p>
               <example>
                  <head>Using Conditional Exclusion to Achieve Portability</head>
                  <p>This example demonstrates the use of the <code>use-when</code> attribute to
                     achieve portability of a stylesheet across schema-aware and non-schema-aware
                     processors.</p>
                  <eg xml:space="preserve" role="xslt-declarations">&lt;xsl:import-schema schema-location="http://example.com/schema"
              use-when="system-property('xsl:is-schema-aware')='yes'"/&gt;

&lt;xsl:template match="/" 
              use-when="system-property('xsl:is-schema-aware')='yes'" 
              priority="2"&gt;
  &lt;xsl:result-document validation="strict"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;</eg>
                  <p>The effect of these declarations is that a non-schema-aware processor ignores
                     the <elcode>xsl:import-schema</elcode> declaration and the first template rule,
                     and therefore generates no errors in respect of the schema-related constructs
                     in these declarations.</p>
               </example>
               <example>
                  <head>Including Variant Stylesheet Modules</head>
                  <p>This example includes different stylesheet modules depending on which XSLT
                     processor is in use.</p>
                  <eg xml:space="preserve" role="xslt-declarations">&lt;xsl:include href="module-A.xsl" 
     use-when="system-property('xsl:vendor')='vendor-A'"/&gt;
&lt;xsl:include href="module-B.xsl" 
     use-when="system-property('xsl:vendor')='vendor-B'"/&gt;</eg>
               </example>
            </div3>
            <div3 id="shadow-attributes">
               <head>Shadow Attributes</head>
               
               <p>When a no-namespace attribute name <var>N</var> is permitted to appear on an element
                  in the <termref def="dt-xslt-namespace"/> (provided that <var>N</var> does not start with an underscore), 
                  then a value <var>V</var> can be supplied for <var>N</var> in one of two ways:
               </p>
               
               <ulist>
                  <item><p>The conventional way is for an attribute node with name <var>N</var> and value <var>V</var> to appear 
                     in the XDM representation of the element node in the stylesheet tree.
                  </p></item>
                  <item><p>As an alternative, a shadow attribute may be supplied allowing the value <var>V</var> 
                     to be statically computed during the preprocessing phase. The shadow attribute has a name 
                     that is the same as the name <var>N</var> prefixed with an underscore, and the value of 
                     the shadow attribute is a <termref def="dt-value-template"/> in which all expressions enclosed between 
                     curly braces must be <termref def="dt-static-expression">static
                        expressions</termref>. The value <var>V</var> is the result of 
                     evaluating the value template. If a shadow attribute is present, then any attribute node with name
                     <var>N</var> (sharing the same parent element) is ignored.
                  </p></item>
               </ulist>
               
               <p>For example, an <elcode>xsl:include</elcode> element might be written:</p>
               <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:include _href="common{$VERSION}.xsl"/&gt;</eg>
               <p>allowing the stylesheet to include a specific version of a library module based on
                  the value of a <termref def="dt-static-parameter"/>.</p>
               <p>Similarly, a <termref def="dt-mode"/> might be declared like this:</p>
               <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:param name="streamable" as="xs:boolean" 
                  required="yes" static="yes"/&gt;
&lt;xsl:mode _streamable="{$streamable}" on-no-match="shallow-skip"/&gt;</eg>
               <p>this allowing the streamability of the mode to be controlled using a <termref def="dt-static-parameter"/>
                  (Note: this example relies on the fact that the
                        <code>streamable</code> attribute accepts a boolean value, which means that
                     the values <code>true</code> and <code>false</code> are accepted as synonyms of
                        <code>yes</code> and <code>no</code>).</p>
               <p>This mechanism applies to all attributes in the stylesheet where the attribute
                  name is in no namespace and the name of the parent element is in the <termref def="dt-xslt-namespace"/>. This includes attributes that have static
                  significance such as the <code>use-when</code> attribute, the <code>version</code>
                  attribute, and the <code>static</code> attribute on <elcode>xsl:variable</elcode>.
                  The mechanism does not apply to shadow attributes (that is, it is not possible to
                  invoke two stages of preprocessing by using two leading underscores). It does not
                  apply to attributes of literal result elements, nor to attributes in a namespace
                  such as the XML or XSLT namespace, nor to namespace declarations.</p>
             
               <note>
                  <p>If a shadow attribute and its corresponding target attribute are both present in
                     the stylesheet, the non-shadow attribute is ignored.
                     This may be useful to make stylesheet code compatible across XSLT versions; an
                     XSLT 2.0 processor operating in forwards compatible mode will ignore shadow
                     attributes, and will require the target attribute to be valid.</p>
               </note>
               <note>
                  <p>The statement that the non-shadow attribute is
                     ignored extends to error detection: it is not an error if the non-shadow
                     attribute has an invalid value. However, this is not reflected in the schema
                     for XSLT stylesheets, so validation using this schema may report errors in such
                     cases.</p>
               </note>
               <note>
                  <p>An attribute whose name begins with an underscore is
                  treated specially only when it appears on an element in the XSLT namespace. On a 
                  <termref def="dt-literal-result-element"/>, it is treated in the same way as any other attribute (that is,
                     its <termref def="dt-effective-value"/> is copied to the result tree). On an
                     <termref def="dt-extension-instruction"/> or
                  <termref def="dt-data-element"/>, as with other attributes
                  on these elements, its meaning is entirely <termref def="dt-implementation-defined"/>.</p>
               </note>

               <example>
                  <head>Using Shadow Attributes to Parameterize XPath Default Namespace</head>
                  <p>Although it is not usually considered good practice, it sometimes happens that
                     variants or versions of an XML vocabulary exist in which the same local names
                     are used, but in different namespaces. There is then a requirement to write
                     code that will process source documents in a variety of different
                     namespaces.</p>

                  <p>It is possible to define a static stylesheet parameter containing the target
                     namespace, for example:</p>

                  <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:param name="NS" as="xs:string" static="yes" 
                          select="'http://example.com/ns/one'"/&gt;</eg>
                  <p>And this can then be used to set the default namespace for XPath
                     expressions:</p>
                  <eg role="non-xml" xml:space="preserve">_xpath-default-namespace="{$NS}"</eg>
                  <p>However, it is not possible to put this shadow attribute on the
                        <elcode>xsl:stylesheet</elcode> or <elcode>xsl:package</elcode> element of
                     the principal stylesheet module, because at that point the variable
                        <code>$NS</code> is not in scope. A workaround is to create a stub
                     stylesheet module which contains nothing but the static parameter declaration
                     and an <elcode>xsl:include</elcode> of the stylesheet module containing the
                     real logic. The static stylesheet parameter will then be in scope on the
                        <elcode>xsl:stylesheet</elcode> element of the included stylesheet module,
                     and the shadow attribute <code>_xpath-default-namespace="{$NS}"</code> can
                     therefore appear on this <elcode>xsl:stylesheet</elcode> element.</p>
               </example>

               <example>
                  <head>Using Shadow Attributes to Parameterize Selection of Elements</head>
                  <p>The following stylesheet produces a report giving information about selected
                     employees. The predicate defining which employees are to be included in the
                     report is supplied (as a string containing an XPath expression) in a static
                     stylesheet parameter:</p>
                  <eg role="xslt-declaration xmlns:local='local'" xml:space="preserve">
&lt;xsl:param name="filter" static="yes"
           as="xs:string" select="'true()'"/&gt;
&lt;xsl:function name="local:filter" as="xs:boolean"&gt;
   &lt;xsl:param name="e" as="element(employee)"/&gt;
   &lt;xsl:sequence _select="$e/({$filter})"/&gt;
&lt;/xsl:function&gt;
&lt;xsl:template match="/"&gt;
   &lt;report&gt;
      &lt;xsl:apply-templates mode="report" select="//employee[local:filter(.)]"/&gt;
   &lt;/report&gt;
&lt;/xsl:template&gt;</eg>
                  <p>If the supplied value of the filter parameter is, say <code>location =
                        "UK"</code>, then the report will cover employees based in the UK.</p>
                  <note>
                     <p>The stylesheet function <code>local:filter</code> is used here in preference
                        to direct use of the supplied predicate within the <code>select</code>
                        attribute of the <elcode>xsl:apply-templates</elcode> instruction because it
                        reduces exposure to code injection attacks. It does not necessarily
                        eliminate all such risks, however. For example, it would be possible for a
                        caller to supply an expression that never terminates, thus creating a
                        denial-of-service risk.</p>
                  </note>
               </example>


            </div3>
         </div2>
         <div2 id="built-in-types">
            <head>Built-in Types</head>

            <p>Every XSLT 4.0 processor includes the following
               named type definitions in the <termref def="dt-in-scope-schema-component">in-scope
                  schema components</termref>:</p>
            <ulist>
               <item>
                  <p>
                     All built-in types defined in <bibref ref="xmlschema-2"/>, including <code>xs:anyType</code> and
                           <code>xs:anySimpleType</code>.</p>
               </item>

               <item>
                  <p>The following types defined in <bibref ref="xpath-30"/>:
                        <code>xs:yearMonthDuration</code>, <code>xs:dayTimeDuration</code>,
                        <code>xs:anyAtomicType</code>, <code>xs:untyped</code>, and
                        <code>xs:untypedAtomic</code>.</p>
               </item>
            </ulist>

            <p>XSLT 4.0 processors <rfc2119>may</rfc2119> optionally include types
               defined in XSD 1.1 (see <bibref ref="xmlschema11-1"/>). XSD 1.1 adopts the types
                  <code>xs:yearMonthDuration</code>, <code>xs:dayTimeDuration</code>, and
                  <code>xs:anyAtomicType</code> previously defined in XPath 2.0, and adds one new
               type: <code>xs:dateTimeStamp</code>. XSD 1.1 also allows implementers to define
               additional primitive types, and XSLT 4.0 permits such types to be supported by an
               XSLT processor.</p>

            <p>A <termref def="dt-schema-aware-xslt-processor">schema-aware XSLT processor</termref>
               additionally supports:</p>
            <ulist>
               
               <item>
                  <p>User-defined types, and element and attribute declarations, that are imported
                     using an <elcode>xsl:import-schema</elcode> declaration as described in
                        <specref ref="import-schema"/>. These may include both simple and complex
                     types.</p>
               </item>
            </ulist>
            <note>
               <p>The names that are imported from the XML Schema namespace do not include all the
                  names of top-level types defined in either the Schema for Schema Documents or the
                  Schema for Schema Documents (Datatypes). The Schema for Schema Documents, as well
                  as defining built-in types such as <code>xs:integer</code> and
                     <code>xs:double</code>, also defines types that are intended for use only
                  within that schema, such as <code>xs:derivationControl</code>. A <termref def="dt-stylesheet">stylesheet</termref> that is designed to process XML Schema
                  documents as its input or output may import the Schema for Schema Documents.</p>
            </note>
            <p>An implementation may define mechanisms that allow additional <termref def="dt-schema-component">schema components</termref> to be added to the <termref def="dt-in-scope-schema-component">in-scope schema components</termref> for the
               stylesheet. For example, the mechanisms used to define <termref def="dt-extension-function">extension functions</termref> (see <specref ref="extension-functions"/>) may also be used to import the types used in the
               interface to such functions.</p>
            <imp-def-feature id="idf-ext-importtypes">An implementation may define mechanisms, above
               and beyond <elcode>xsl:import-schema</elcode>, that allow <termref def="dt-schema-component">schema components</termref> such as type definitions to
               be made available within a stylesheet.</imp-def-feature>
            <p>These <termref def="dt-schema-component">schema components</termref> are the only
               ones that may be referenced in XPath expressions within the stylesheet, or in the
                  <code>[xsl:]type</code> and <code>as</code> attributes of those elements that
               permit these attributes.</p>
            
         </div2>
         <div2 id="import-schema">
            <head>Importing Schema Components</head>
            <note>
               <p>The facilities described in this section are not available with a <termref def="dt-basic-xslt-processor">basic XSLT processor</termref>. They require a
                     <termref def="dt-schema-aware-xslt-processor">schema-aware XSLT
                     processor</termref>, as described in <specref ref="conformance"/>.</p>
            </note>
            <?element xsl:import-schema?>
            <p>The <elcode>xsl:import-schema</elcode> declaration is used to identify <termref def="dt-schema-component">schema components</termref> (that is, top-level type
               definitions and top-level element and attribute declarations) that need to be
               available statically, that is, before any source document is available. Names of such
               components used statically within the <termref def="dt-stylesheet">stylesheet</termref> must refer to an <termref def="dt-in-scope-schema-component">in-scope schema component</termref>, which means they must either be built-in
               types as defined in <specref ref="built-in-types"/>, or they must be imported using
               an <elcode>xsl:import-schema</elcode> declaration.</p>
            <p>The <elcode>xsl:import-schema</elcode> declaration identifies a namespace containing
               the names of the components to be imported (or indicates that components whose names
               are in no namespace are to be imported). The effect is that the names of top-level
               element and attribute declarations and type definitions from this namespace (or
               non-namespace) become available for use within XPath expressions in the <termref def="dt-package">package</termref>, and within
               other stylesheet constructs such as the <code>type</code> and <code>as</code>
               attributes of various <termref def="dt-xslt-element">XSLT elements</termref>.</p>
            <p>The same schema components are available in all stylesheet modules
                  within the <termref def="dt-declaring-package">declaring
                     package</termref>; importing components in one stylesheet module makes
               them available throughout the <termref def="dt-package">package</termref>.</p>
            <p>The schema components imported into different <termref def="dt-package">packages</termref> within a <termref def="dt-stylesheet">stylesheet</termref> must be consistent. Specifically, it is not permitted to use
               the same name in the same XSD symbol space to refer to different schema components
               within different packages; and the union of the schema components imported into the
               packages of a stylesheet must constitute a valid schema (as well as the set of schema
               components imported into each package forming a valid schema in its own right).</p>
            <p>The <code>namespace</code> and <code>schema-location</code> attributes are both
               optional.</p>
            <!--Text replaced by erratum E9 change 1"-->
            <p>If the <elcode>xsl:import-schema</elcode> element contains an <code>xs:schema</code>
               element, then the <code>schema-location</code> attribute <rfc2119>must</rfc2119> be
               absent, and one of the following <rfc2119>must</rfc2119> be true:</p>
            <ulist>
               <item>
                  <p>the <code>namespace</code> attribute of the <elcode>xsl:import-schema</elcode>
                     element and the <code>targetNamespace</code> attribute of the
                        <code>xs:schema</code> element are both absent (indicating a no-namespace
                     schema), or</p>
               </item>
               <item>
                  <p>the <code>namespace</code> attribute of the <elcode>xsl:import-schema</elcode>
                     element and the <code>targetNamespace</code> attribute of the
                        <code>xs:schema</code> element are both present and both have the same
                     value, or</p>
               </item>
               <item>
                  <p>the <code>namespace</code> attribute of the <elcode>xsl:import-schema</elcode>
                     element is absent and the <code>targetNamespace</code> attribute of the
                        <code>xs:schema</code> element is present, in which case the target
                     namespace is as given on the <code>xs:schema</code> element.</p>
               </item>
            </ulist>
            <!--End of text replaced by erratum E9-->
            <p>
               <error spec="XT" type="static" class="SE" code="0215">
                  <p>It is a <termref def="dt-static-error">static error</termref> if an
                        <elcode>xsl:import-schema</elcode> element that contains an
                        <code>xs:schema</code> element has a <code>schema-location</code> attribute,
                     or if it has a <code>namespace</code> attribute that conflicts with the target
                     namespace of the contained schema.</p>
               </error>
            </p>
            <p>If two <elcode>xsl:import-schema</elcode> declarations specify the same namespace, or
               if both specify no namespace, then only the one with highest <termref def="dt-import-precedence">import precedence</termref> is used. If this leaves
               more than one, then all the declarations at the highest import precedence are used
               (which may cause conflicts, as described below).</p>
            <p>After discarding any <elcode>xsl:import-schema</elcode> declarations under the above
               rule, the effect of the remaining <elcode>xsl:import-schema</elcode> declarations is
               defined in terms of a hypothetical document called the synthetic schema document,
               which is constructed as follows. The synthetic schema document defines an arbitrary
               target namespace that is different from any namespace actually used by the
               application, and it contains <code>xs:import</code> elements corresponding
               one-for-one with the <elcode>xsl:import-schema</elcode> declarations in the <termref def="dt-stylesheet">stylesheet</termref>, with the following correspondence:</p>
            <ulist>
               <item>
                  <p>The <code>namespace</code> attribute of the <code>xs:import</code> element is
                     copied from the <code>namespace</code> attribute of the
                        <elcode>xsl:import-schema</elcode> declaration if it is explicitly present,
                     or is implied by the <code>targetNamespace</code> attribute of a contained
                        <code>xs:schema</code> element, and is absent if it is absent.</p>
               </item>
               <item>
                  <p>The <code>schemaLocation</code> attribute of the <code>xs:import</code> element
                     is copied from the <code>schema-location</code> attribute of the
                        <elcode>xsl:import-schema</elcode> declaration if present, and is absent if
                     it is absent. If there is a contained <code>xs:schema</code> element, the
                     effective value of the <code>schemaLocation</code> attribute is a URI
                     referencing a document containing a copy of the <code>xs:schema</code>
                     element.</p>
               </item>
               <item>
                  <p>The base URI of the <code>xs:import</code> element is the same as the base URI
                     of the <elcode>xsl:import-schema</elcode> declaration.</p>
               </item>
            </ulist>
            <p>The schema components included in the <termref def="dt-in-scope-schema-component">in-scope schema components</termref> (that is, the components whose names are
               available for use within the stylesheet) are the top-level element and attribute
               declarations and type definitions that are available for reference within the
               synthetic schema document. See <bibref ref="xmlschema-1"/> (section 4.2.3,
                  <emph>References to schema components across namespaces</emph>).</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0220">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the synthetic
                     schema document does not satisfy the constraints described in <bibref ref="xmlschema-1"/> (section 5.1, <emph>Errors in Schema Construction and
                        Structure</emph>). This includes, without loss of generality, conflicts such
                     as multiple definitions of the same name.</p>
               </error>
            </p>
            <note>
               <p>The synthetic schema document does not need to be constructed by a real
                  implementation. It is purely a mechanism for defining the semantics of
                     <elcode>xsl:import-schema</elcode> in terms of rules that already exist within
                  the XML Schema specification. In particular, it implicitly defines the rules that
                  determine whether the set of <elcode>xsl:import-schema</elcode> declarations are
                  mutually consistent.</p>
               <p>These rules do not cause names to be imported transitively. The fact that a name
                  is available for reference within a schema document A does not of itself make the
                  name available for reference in a stylesheet that imports the target namespace of
                  schema document A. (See <bibref ref="xmlschema-1"/> section 3.15.3, Constraints on
                  XML Representations of Schemas.) The stylesheet must import all the namespaces
                  containing names that it actually references.</p>
               <p>The <code>namespace</code> attribute indicates that a schema for the given
                  namespace is required by the <termref def="dt-stylesheet">stylesheet</termref>.
                  This information may be enough on its own to enable an implementation to locate
                  the required schema components. The <code>namespace</code> attribute may be
                  omitted to indicate that a schema for names in no namespace is being imported. The
                  zero-length string is not a valid namespace URI, and is therefore not a valid
                  value for the <code>namespace</code> attribute.</p>
               <p>The <code>schema-location</code> attribute is a <termref def="dt-uri-reference">URI Reference</termref> that gives a hint indicating where a schema document
                  or other resource containing the required definitions may be found. It is likely
                  that a <termref def="dt-schema-aware-xslt-processor">schema-aware XSLT
                     processor</termref> will be able to process a schema document found at this
                  location.</p>
               <p>The XML Schema specification gives implementations flexibility in how to handle
                  multiple imports for the same namespace. Multiple imports do not cause errors if
                  the definitions do not conflict.</p>
               <p>A consequence of these rules is that it is not intrinsically an error if no schema
                  document can be located for a namespace identified in an
                     <elcode>xsl:import-schema</elcode> declaration. This will cause an error only
                  if it results in the stylesheet containing references to names that have not been
                  imported.</p>
               <p>An inline schema document (using an <code>xs:schema</code> element as a child of
                  the <code>xsl:import-schema</code> element) has the same status as an external
                  schema document, in the sense that it acts as a hint for a source of schema
                  components in the relevant namespace. To ensure that the inline schema document is
                  always used, it is advisable to use a target namespace that is unique to this
                  schema document.</p>
            </note>
            <p>The use of a namespace in an <elcode>xsl:import-schema</elcode> declaration does not
               by itself associate any namespace prefix with the namespace. If names from the
               namespace are used within the stylesheet module then a namespace declaration must be
               included in the stylesheet module, in the usual way.</p>
            <example>
               <head>An Inline Schema Document</head>
               <p>The following example shows an inline schema document. This declares a simple type
                     <code>local:yes-no</code>, which the stylesheet then uses in the declaration of
                  a variable.</p>
               <p>The example assumes the namespace declaration
                     <code>xmlns:local="http://example.com/ns/yes-no"</code>
               </p>
               <eg xml:space="preserve" role="xslt-declarations">&lt;xsl:import-schema&gt;
  &lt;xs:schema targetNamespace="http://example.com/ns/yes-no"
             xmlns:xs="http://www.w3.org/2001/XMLSchema"
             xmlns:local="http://example.com/ns/yes-no"&gt;
    &lt;xs:simpleType name="yes-no"&gt;
      &lt;xs:restriction base="xs:string"&gt;
        &lt;xs:enumeration value="yes"/&gt;
        &lt;xs:enumeration value="no"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:schema&gt;
&lt;/xsl:import-schema&gt;

&lt;xsl:variable name="condition" select="local:yes-no('yes')" 
                               as="local:yes-no"/&gt;
</eg>
            </example>
            <p>There are two built-in functions
                  (<xfunction>analyze-string</xfunction> and <function>json-to-xml</function>) whose
               result is an XML structure for which a schema is defined. The namespace for these
               schema definitions is (in both cases) <code>http://www.w3.org/2005/xpath-functions</code>. Schema
               components for these namespaces are available for reference within the stylesheet if
               and only if an <elcode>xsl:import-schema</elcode> declaration is present referencing
               this namespace. If such a declaration is present, then the schema that is
               imported is the schema defined in the specification of these functions: the <code>schemaLocation</code>
               attribute has no effect.</p>
         </div2>
      </div1>
      <div1 id="data-model">
         <head>Data Model</head>
         <p>The data model used by XSLT is the XPath 3.0 and XQuery
               3.0 data model (XDM), as defined in <bibref ref="xpath-datamodel-30"/>. XSLT
            operates on source, result and stylesheet documents using the same data model.</p>
         <p>This section elaborates on some particular features of XDM as it is used by XSLT:</p>
         <p>The rules in <specref ref="stylesheet-stripping"/> and <specref ref="strip"/> make use
            of the concept of a whitespace text node.</p>
         <p>
            <termdef id="dt-whitespace-text-node" term="whitespace text node">A <term>whitespace
                  text node</term> is a text node whose content consists entirely of whitespace
               characters (that is, #x09, #x0A, #x0D, or #x20).</termdef>
         </p>
         <note>
            <p>Features of a source XML document that are not represented in the XDM tree will have
               no effect on the operation of an XSLT stylesheet. Examples of such features are
               entity references, CDATA sections, character references, whitespace within element
               tags, and the choice of single or double quotes around attribute values.</p>
         </note>
         <div2 id="xml-versions">
            <head>XML Versions</head>
            <p>The XDM data model defined in <bibref ref="xpath-datamodel-30"/> is capable of
               representing either an XML 1.0 document (conforming to <bibref ref="REC-xml"/> and
                  <bibref ref="xml-names"/>) or an XML 1.1 document (conforming to <bibref ref="xml11"/> and <bibref ref="xml-names11"/>), and it makes no distinction
               between the two. In principle, therefore, XSLT 4.0
               can be used with either of these XML versions.</p>
            <p>Construction of the XDM tree is outside the scope of this specification, so XSLT
                  4.0 places no formal requirements on an XSLT
               processor to accept input from either XML 1.0 documents or XML 1.1 documents or both.
               This specification does define a serialization capability (see <specref ref="serialization"/>), though from a conformance point of view it is an optional
               feature. Although facilities are described for serializing the XDM tree as either XML
               1.0 or XML 1.1 (and controlling the choice), there is again no formal requirement on
               an XSLT processor to support either or both of these XML versions as serialization
               targets.</p>
            <p>Because the XDM tree is the same whether the original document was XML 1.0 or XML
               1.1, the semantics of XSLT processing do not depend on the version of XML used by the
               original document. There is no reason in principle why all the input and output
               documents used in a single transformation must conform to the same version of
               XML.</p>
            <p>Some of the syntactic constructs in XSLT 4.0 and
                  XPath 3.0, for example the productions <xnt spec="XML" ref="Char">Char</xnt> and <xnt spec="Names" ref="NT-NCName">NCName</xnt>, are defined by reference to the XML and XML Namespaces
               specifications. There are slight variations between the XML 1.0 and XML 1.1 versions
               of these productions (and, indeed, between different
                  editions of XML 1.0). Implementations <rfc2119>may</rfc2119> support
                  any version; it is
                  <rfc2119>recommended</rfc2119> that an XSLT 4.0
               processor that implements the 1.1 versions <rfc2119>should</rfc2119> also provide a
               mode that supports the 1.0 versions. It is thus <termref def="dt-implementation-defined">implementation-defined</termref> which versions
               and editions of XML and XML Namespaces are supported by the implementation.</p>
            <note>
               <p>The specification referenced as <bibref ref="xml-names"/> was actually published
                  without a version number.</p>
            </note>
            <imp-def-feature id="idf-spec-xml">It is implementation-defined which versions and
               editions of XML and XML Namespaces (1.0 and/or 1.1) are supported.</imp-def-feature>
            <p>The current version of <bibref ref="xmlschema11-2"/> references the XML 1.1 specifications, but the previous version (<bibref ref="xmlschema-2"/>) (that is, XSD 1.0) remains in widespread use, and only
                  references XML 1.0. With processors lacking support for XSD 1.1,
               therefore, datatypes such as <code>xs:NCName</code> and <code>xs:ID</code> may be
               constrained by the XML 1.0 rules, and not allow the full range of values permitted by
               XML 1.1. It is <rfc2119>recommended</rfc2119> that implementers wishing to support
               XML 1.1 should consult <bibref ref="SCHEMA-AND-XML-1.1"/> for guidance.</p>
         </div2>
         <div2 id="xdm-versions">
            <head>XDM versions</head>
            <p diff="chg" at="2022-01-01">XSLT 4.0 <rfc2119>requires</rfc2119> a processor to support XDM 3.1 as defined in
                  <bibref ref="xpath-datamodel-31"/>.</p>
            <!--<p>A processor <rfc2119>may</rfc2119> also provide a user option to support XDM 3.1 as
               defined in <bibref ref="xpath-datamodel-31"/>, in which case it must do so as defined
               in <specref ref="xpath31-feature"/>.</p>
            <note>
               <p>The essential differences between XDM 3.0 (with the extensions defined in this
                  specification) and XDM 3.1 are that XDM 3.1 adds support for arrays, and for the
                     <code>xs:numeric</code> union type.</p>
            </note>-->
            <p>A processor <rfc2119>may</rfc2119> also provide a user option to support versions of
               XDM later than 3.1, in which case the way it does so is <termref def="dt-implementation-defined"/>.</p>


         </div2>
         
         <div2 id="preprocessing-source-docs">
            <head>Preprocessing Source Documents</head>
            
            <p>Source documents supplied as input to a transformation may be subject to preprocessing. 
               Two kinds of preprocessing are defined: stripping of type annotations (see <specref ref="stripping-annotations"/>), 
               and stripping of whitespace text nodes (see <specref ref="strip"/>).
            </p>
            <p>Stripping of type annotations happens before stripping of whitespace text nodes.
            </p>
            <p>The source documents to which this applies are as follows:
            </p>
            
            <ulist>
               <item><p>The document containing the <termref def="dt-global-context-item"/> if it is a node;</p></item>
            
               <item><p>Any documents containing a node present in the <termref def="dt-initial-match-selection"/>;</p></item>
            
               <item><p>Any document containing a node that is returned by the functions <function>document</function>, <xfunction>doc</xfunction>,
                  or <xfunction>collection</xfunction>;</p></item>
            
               <item><p>Any document read using <code>xsl:source-document</code>.</p></item> 
            </ulist>
            
            <note><p>This list excludes documents passed as the values of 
               <termref def="dt-stylesheet-parameter">stylesheet parameters</termref> or parameters 
               of the <termref def="dt-initial-named-template"/> or <termref def="dt-initial-function"/>, 
               trees created by functions such as <xfunction>parse-xml</xfunction>, <code>parse-xml-fragment</code>,
               <xfunction>analyze-string</xfunction>, or <function>json-to-xml</function>,
               and values returned from <termref def="dt-extension-function">extension
                  functions</termref>.
            </p></note>
            
            <p>If a node other than a document node is supplied (for example as the global context item), 
               then the preprocessing is applied to the entire document containing that node. If several nodes within the same 
               document are supplied (for example as nodes in the initial match selection, or as nodes returned by the 
               <xfunction>collection</xfunction> function), then the preprocessing is only applied to that document once.
               If a whitespace text node is supplied (for example as the global context item) and the rules cause this node
               to be stripped from its containing tree, then the behavior is as if this node had not been supplied 
               (which may cause an error, for example if a global context item is required.)
            </p>
            <p>The rules determining whether or not stripping of annotations and/or whitespace 
               happens are defined at the level of a <termref def="dt-package"/>. Declarations within a <termref def="dt-library-package"/> 
               only affect the handling of documents loaded using a call on the <function>document</function>, <xfunction>doc</xfunction>,
               or <xfunction>collection</xfunction> functions or an evaluation of an <elcode>xsl:source-document</elcode> instruction 
               appearing lexically within the same package. Declarations within the <termref def="dt-top-level-package"/> also affect the processing 
               of the <termref def="dt-global-context-item"/> and the <termref def="dt-initial-match-selection"/>.
            </p>
            <p>The semantics of the <function>document</function>, <xfunction>doc</xfunction>,
               and <xfunction>collection</xfunction> functions are formally defined in terms of mappings from URIs to document nodes 
               maintained within the dynamic context (see <specref ref="xpath-dynamic-context"/>). The effect of the 
               declarations that control stripping of type annotations 
               and whitespace is therefore to modify this mapping (so it now maps the URI to a stripped document). The modification 
               applies to the dynamic context for calls to these function appearing within a particular package; each package therefore 
               has a different set of mappings. This means that when two calls to the <xfunction>doc</xfunction> function appear in 
               different packages, specifying the same absolute URI, then in general different documents are returned. An implementation 
               <rfc2119>may</rfc2119> return the same document for two such calls if it is able to determine that the effect of the annotation 
               and whitespace stripping rules in both packages is the same.
            </p>
            <p>The effect of dynamic calls to the <function>document</function>, <xfunction>doc</xfunction>,
               and <xfunction>collection</xfunction> functions is defined in the same way as for other functions with dependencies on 
               the dynamic context. As described in <specref ref="additional-dynamic-context"/>, named function references 
               (such as <code>doc#1</code>) and calls on <xfunction>function-lookup</xfunction> (for example, <code>function-lookup("doc", 1)</code>) 
               are defined to retain the XPath static and dynamic context at the point of invocation as part of the closure of the 
               resulting function item, and to use this preserved context when a dynamic function call is subsequently made using the function item.
            </p>
            
            
            
         <div3 id="stripping-annotations">
            <head>Stripping Type Annotations from a Source Tree</head>
            <p>
               <termdef id="dt-type-annotation" term="type annotation">The term <term>type
                     annotation</term> is used in this specification to refer to the value returned
                  by the <code>dm:type-name</code> accessor of a node: see <xspecref spec="DM30" ref="dm-type-name"/>.</termdef>
            </p>
            <p>There is sometimes a requirement to write stylesheets that produce the same results
               whether or not the source documents have been validated against a schema. To achieve
               this, an option is provided to remove any <termref def="dt-type-annotation">type
                  annotations</termref> on element and attribute nodes in a <termref def="dt-source-tree">source tree</termref>, replacing them with an annotation of
                  <code>xs:untyped</code> in the case of element nodes, and
                  <code>xs:untypedAtomic</code> in the case of attribute nodes.</p>
            <p>Such stripping of <termref def="dt-type-annotation">type annotations</termref> can be
               requested by specifying <code>input-type-annotations="strip"</code> on the <elcode>xsl:package</elcode> element. This
               attribute has three permitted values: <code>strip</code>, <code>preserve</code>, and
                  <code>unspecified</code>. The default value is <code>unspecified</code>. 
            <phrase diff="add" at="2022-01-01">Specifying <code>unspecified</code> has the same effect
            as omitting the attribute [XSLT 3.0 Erratum E43, bug 30383].</phrase></p>

            <p>The <code>input-type-annotations</code> attribute may also
               be specified on the <elcode>xsl:stylesheet</elcode> element; if it is specified at
               this level then it must be consistent for all stylesheet modules within the same
               package.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0265">
                  <p> It is a <termref def="dt-static-error">static error</termref> if there is a
                        <termref def="dt-stylesheet-module">stylesheet module</termref> in a
                        <termref def="dt-package">package</termref> that specifies
                        <code>input-type-annotations="strip"</code> and another <termref def="dt-stylesheet-module">stylesheet module</termref> that specifies
                        <code>input-type-annotations="preserve"</code>, or if a stylesheet module specifies the value
                           <code>strip</code> or <code>preserve</code> and the same value is not
                        specified on the <elcode>xsl:package</elcode> element of the containing
                        package.</p>
               </error>
            </p>
            
            <p diff="add" at="2022-01-01">Type annotations are stripped from relevant source documents if 
               at least one <termref def="dt-stylesheet-module"/> in the <termref def="dt-stylesheet"/>
               specifies <code>input-type-annotations="strip"</code> on the <elcode>xsl:package</elcode>, 
               <elcode>xsl:stylesheet</elcode>, or <elcode>xsl:transform</elcode> element [XSLT 3.0 Erratum E43, bug 30383].</p>
            
            <p>When type annotations are stripped, the following changes are made to the source
               tree:</p>
            <ulist>
               <item>
                  <p>The type annotation of every element node is changed to <code>xs:untyped</code>
                  </p>
               </item>
               <item>
                  <p>The type annotation of every attribute node is changed to
                        <code>xs:untypedAtomic</code>
                  </p>
               </item>
               <item>
                  <p>The typed value of every element and attribute node is set to be the same as
                     its string value, as an instance of <code>xs:untypedAtomic</code>.</p>
               </item>
               <item>
                  <p>The <code>is-nilled</code> property of every element node is set to
                        <code>false</code>.</p>
               </item>
            </ulist>
            <p>The values of the <code>is-id</code> and <code>is-idrefs</code> properties are not
               changed.</p>
            <note>
               <p>Stripping <termref def="dt-type-annotation">type annotations</termref> does not
                  necessarily return the document to the state it would be in had validation not
                  taken place. In particular, any defaulted elements and attributes that were added
                  to the tree by the validation process will still be present, and elements and
                  attributes validated as IDs will still be accessible using the
                     <xfunction>id</xfunction> function.</p>
            </note>
         </div3>
         <div3 id="strip">
            <head>Stripping Whitespace from a Source Tree</head>
            <p>A <termref def="dt-source-tree">source tree</termref> supplied as input to the
               transformation process may contain <termref def="dt-whitespace-text-node">whitespace
                  text nodes</termref> that are of no interest, and that do not need to be retained
               by the transformation. Conceptually, an XSLT <termref def="dt-processor">processor</termref> makes a copy of the source tree from which unwanted <termref def="dt-whitespace-text-node">whitespace text nodes</termref> have been removed.
               This process is referred to as whitespace stripping. </p>
            

            

            <p>The stripping process takes as input a set of element names whose child <termref def="dt-whitespace-text-node">whitespace text nodes</termref> are to be preserved.
               The way in which this set of element names is established using the
                  <elcode>xsl:strip-space</elcode> and <elcode>xsl:preserve-space</elcode>
               declarations is described later in this section.</p>

            
            
            <p>The stripping process that applies for a particular
               <termref def="dt-package"/> is determined by the <elcode>xsl:strip-space</elcode>
               and <elcode>xsl:preserve-space</elcode> declarations within that package.</p>

            <p>A <termref def="dt-whitespace-text-node">whitespace text node</termref> is preserved
               if either of the following apply:</p>
            <ulist>
               <item>
                  <p>The element name of the parent of the text node is in the set of
                     whitespace-preserving element names.</p>
               </item>
               <item>
                  <p>An ancestor element of the text node has an <code>xml:space</code> attribute
                     with a value of <code>preserve</code>, and no closer ancestor element has
                        <code>xml:space</code> with a value of <code>default</code>.</p>
               </item>
            </ulist>
            <p>Otherwise, the <termref def="dt-whitespace-text-node">whitespace text node</termref>
               is stripped.</p>
            <p>The <code>xml:space</code> attributes are not removed from the tree.</p>
            
            
            <?element xsl:strip-space?>
            <?element xsl:preserve-space?>
            <p>The set of whitespace-preserving element names is specified by
                  <elcode>xsl:strip-space</elcode> and <elcode>xsl:preserve-space</elcode>
               <termref def="dt-declaration">declarations</termref>. Whether an element name is
               included in the set of whitespace-preserving names is determined by the best match
               among all the <elcode>xsl:strip-space</elcode> or <elcode>xsl:preserve-space</elcode>
               declarations: it is included if and only if there is no match or the best match is an
                  <elcode>xsl:preserve-space</elcode> element. The <elcode>xsl:strip-space</elcode>
               and <elcode>xsl:preserve-space</elcode> elements each have an <code>elements</code>
               attribute whose value is a whitespace-separated list of <xnt spec="XP40" ref="prod-xpath40-NameTest">NameTests</xnt>; an element name matches an
                  <elcode>xsl:strip-space</elcode> or <elcode>xsl:preserve-space</elcode> element if
               it matches one of the <xnt spec="XP40" ref="prod-xpath40-NameTest">NameTests</xnt>.
               An element matches a <xnt spec="XP40" ref="prod-xpath40-NameTest">NameTest</xnt> if
               and only if the <xnt spec="XP40" ref="prod-xpath40-NameTest">NameTest</xnt> would be
               true for the element as an XPath node test.</p>

            

            <p><!--bug 10097--><error spec="XT" type="static" class="SE" code="0270">
                  <p>It is a <termref def="dt-static-error">static error</termref> if within any <termref def="dt-package">package</termref> the same <xnt spec="XP40" ref="prod-xpath40-NameTest">NameTest</xnt> appears in both an
                        <elcode>xsl:strip-space</elcode> and an <elcode>xsl:preserve-space</elcode>
                     declaration if both have the same <termref def="dt-import-precedence">import
                        precedence</termref>. Two NameTests are considered the same if they match
                     the same set of names (which can be determined by comparing them after
                     expanding namespace prefixes to URIs).</p>
               </error></p>

            <p>Otherwise, when more than one
                  <elcode>xsl:strip-space</elcode> and <elcode>xsl:preserve-space</elcode> element
                  within the relevant <termref def="dt-package">package</termref> matches, the best matching element is determined by
               the best matching <xnt spec="XP40" ref="prod-xpath40-NameTest">NameTest</xnt>.
                  
               <!--bug 10097-->The rules are similar to those for
               <termref def="dt-template-rule">template rules</termref>:</p>
            <ulist>
               <item>
                  <p>First, any match with lower <termref def="dt-import-precedence">import
                        precedence</termref> than another match is ignored.</p>
               </item>
               <item>
                  <p>Next, any match that has a lower <termref def="dt-default-priority">default
                        priority</termref> than the <termref def="dt-default-priority">default
                        priority</termref> of another match is ignored.</p>
               </item>
               <item>
                  <p>If several matches have the same <termref def="dt-default-priority">default priority</termref> (which can only happen
                     if one of the NameTests takes the form <code>*:local</code> and the other takes
                     the form <code>prefix:*</code>), then the declaration that appears last in
                        <termref def="dt-declaration-order">declaration order</termref> is used.</p>
               </item>
            </ulist>
            

            <p>If an element in a source document has a <termref def="dt-type-annotation">type
                  annotation</termref> that is a simple type or a complex type with simple content,
               then any whitespace text nodes among its children are preserved, regardless of any
                  <elcode>xsl:strip-space</elcode> declarations. The reason for this is that
               stripping a whitespace text node from an element with simple content could make the
               element invalid: for example, it could cause the <code>minLength</code> facet to be
               violated.</p>
            <p>Stripping of <termref def="dt-type-annotation">type annotations</termref> happens
               before stripping of whitespace text nodes, so this situation will not occur if
                  <code>input-type-annotations="strip"</code> is specified.</p>
            <note>
               <p>In <bibref ref="xpath-datamodel-30"/>, processes are described for constructing an
                  XDM tree from an Infoset or from a PSVI. Those processes deal with whitespace
                  according to their own rules, and the provisions in this section apply to the
                  resulting tree. In practice this means that elements that are defined in a DTD or
                  a Schema to contain element-only content will have <termref def="dt-whitespace-text-node">whitespace text nodes</termref> stripped,
                  regardless of the <elcode>xsl:strip-space</elcode> and
                     <elcode>xsl:preserve-space</elcode> declarations in the stylesheet.</p>
               <p>However, source trees are not necessarily constructed using those processes;
                  indeed, they are not necessarily constructed by parsing XML documents. Nothing in
                  the XSLT specification constrains how the source tree is constructed, or what
                  happens to <termref def="dt-whitespace-text-node">whitespace text nodes</termref>
                  during its construction. The provisions in this section relate only to whitespace
                  text nodes that are present in the tree supplied as input to the XSLT processor.
                  The XSLT processor cannot preserve whitespace text nodes unless they were actually
                  present in the supplied tree.</p>
            </note>
         </div3>
         </div2>
         <div2 id="id-in-data-model">
            <head>Attribute Types and DTD Validation</head>
            <p>The mapping from the Infoset to the XDM data model, described in <bibref ref="xpath-datamodel-30"/>, does not retain attribute types. This means, for
               example, that an attribute described in the DTD as having attribute type
                  <code>NMTOKENS</code> will be annotated in the XDM tree as
                  <code>xs:untypedAtomic</code> rather than <code>xs:NMTOKENS</code>, and its typed
               value will consist of a single <code>xs:untypedAtomic</code> value rather than a
               sequence of <code>xs:NMTOKEN</code> values.</p>
            <p>Attributes with a DTD-derived type of ID, IDREF, or IDREFS will be marked in the XDM
               tree as having the <code>is-id</code> or <code>is-idrefs</code> properties. It is
               these properties, rather than any <termref def="dt-type-annotation">type
                  annotation</termref>, that are examined by the functions <xfunction>id</xfunction>
               and <xfunction>idref</xfunction> described in <bibref ref="xpath-functions-40"/>.</p>
         </div2>
         <div2 id="model-for-streaming">
            <head>Data Model for Streaming</head>
            <div3 id="streamed-documents">
               <head>Streamed Documents</head>
           
            <p>The data model for nodes in a document that is being streamed is no different from
               the standard XDM data model, in that it contains the same objects (nodes) with the
               same properties and relationships. The facilities for streaming do not change the
               data model; instead they impose rules that limit the ability of stylesheets to
               navigate the data model.</p>
            <p>A useful way to visualize streaming is to suppose that at any point in time, there is
               a current position in the streamed input document which may be the start or end of
               the document, the start or end tag of an element, or a text, comment, or processing
               instruction node. From this position, the stylesheet has access to the following
               information: </p>
            <ulist>
               <item>
                  <p>Properties intrinsic to the node, such as its name, its base URI, its type
                     annotation, and its <code>is-id</code> and <code>is-idref</code>
                     properties.</p>
               </item>
               <item>
                  <p>The ancestors of the node (but navigation downwards from the ancestors is not
                     permitted).</p>
               </item>
               <item>
                  <p>The attributes of the node, and the attributes of its ancestors. For each such
                     attribute, all the properties of the node including its string value and typed
                     value are available, but there are limitations that restrict navigation from
                     the attribute node to other nodes in the document.</p>
               </item>
               <item>
                  <p>The in-scope namespace bindings of the node.</p>
               </item>
               <item>
                  <p>In the case of attributes, text nodes, comments, and processing instructions,
                     the string value and typed value of the node.</p>
               </item>
               
               <item>
                  <p>In the case of element nodes, whether or not the element has children. This
                     information is obtained by calling the <xfunction>has-children</xfunction>
                     function. This implies that the processor performs look-ahead (limited to a
                     single token) to determine whether the start tag is immediately followed by a
                     matching end tag.</p>
               </item>
               <item>
                  <p>In the case of document nodes, details of unparsed entities in the document.
                     This information is obtained by calling the
                        <function>unparsed-entity-uri</function> and
                        <function>unparsed-entity-public-id</function> functions. A processor might
                     enable this by reading the DTD as soon as the document is opened. Since
                     comments and processing instructions that precede the DOCTYPE declaration are
                     available as children of the document node, this also implies that a streaming
                     processor needs sufficient memory to hold these comments and processing
                     instructions until the start tag of the first element is encountered.
                     Information about unparsed entities remains available for the duration of
                     processing, in the same way as attributes of ancestor elements.</p>
               </item>
            </ulist>
            <p>The children and other descendants of a node are not accessible except as a
               by-product of changing the current position in the document. The same applies to
               properties of an element or document node that require examination of the
               node’s descendants, that is, the string value and typed value. This is
               enforced by means of a rule that only one expression requiring downward navigation
               from a node is permitted.</p>


            <p>Information about the type of a node is in general
               considered a property intrinsic to the node, and is available without advancing the
               input stream. There is an exception for an expression of the form <code>(/) instance
                  of document-node(element(invoice))</code>. This is not guaranteed streamable,
               because it requires reading ahead to check that the document node has only one
               element child. However, a processor that knows that the parser delivering the
               document stream is only capable of delivering well-formed documents may use this
               knowledge (along with the limited look-ahead needed to get the name of the outermost
               element) to make this expression streamable.</p>

            <p>A streaming processor is not
                  required to read any more of the source document than is needed to
               generate correct stylesheet output. It is not required to read the full source
               document merely in order to satisfy the requirement imposed by the XML Recommendation
               that an XML Processor must report violations of well-formedness in the input.</p>

            <p>More detailed rules are defined in <specref ref="streamability"/>.</p>
            </div3>
            <div3 id="streaming-other-types">
               <head>Other Data Structures</head>
               
               <p diff="chg" at="2022-01-01">Maps and arrays were defined in XPath 3.1.</p>
               <p>Streaming facilities in this specification are, for the most part, relevant 
                  only to streamed processing of XML trees, and not to other structures such as 
                  sequences, maps and arrays, which will typically be held in memory unless 
                  the processor is capable of avoiding this.
               </p>
               <p>Maps, however, play an important role in enabling streamed applications
               to be written. For example, a map can be used as the data structure maintained
               by an accumulator (see <specref ref="accumulators"/>) to remember information
               that has been retrieved from a streamed document, given that it is not possible to
               revisit the same nodes later. There is also a special streamability rule for
               map constructor expressions (see <specref ref="maps-streaming"/>) that allows
               such an expression to make multiple downward selections in the streamed input
               document: for example one can write <code>map{'authors':data(author), 'editors':data(editor)}</code>,
               which gathers the values of these two elements, or sets of elements, from the input
               stream, regardless what order they appear in — even if they are interleaved.</p>
               
               <p>The rules for creating maps and arrays are designed to ensure that the 
                  entries in a map, and the members of an array, cannot contain nodes from 
                  a streamed document. This is achieved by the way in which the streamability 
                  properties of the relevant expressions and functions are defined.
               </p>
               <p>By contrast, sequences can and often do contain nodes from streamed documents, 
                  and a major purpose of the rules for streamability is to make this possible.
               </p>
            </div3>
         </div2>
         <div2 id="limits">
            <head>Limits</head>
            <p>The XDM data model (see <bibref ref="xpath-datamodel-30"/>) leaves it to the host
               language to define limits. This section describes the limits that apply to XSLT.</p>
            <p>Limits on some primitive datatypes are defined in <bibref ref="xmlschema-2"/>. Other
               limits, listed below, are <termref def="dt-implementation-defined">implementation-defined</termref>. Note that this does not necessarily mean that
               each limit must be a simple constant: it may vary depending on environmental factors
               such as available resources.</p>
            <imp-def-feature id="idf-defaults-limits">Limits on the value space of primitive
               datatypes, where not fixed by <bibref ref="xmlschema-2"/>, are
               implementation-defined.</imp-def-feature>
            <p>The following limits are <termref def="dt-implementation-defined">implementation-defined</termref>:</p>
            <olist>
               <item>
                  <p>For the <code>xs:decimal</code> type, the maximum number of decimal digits (the
                        <code>totalDigits</code> facet). This must be at least 18 digits. (Note,
                     however, that support for the full value range of <code>xs:unsignedLong</code>
                     requires 20 digits.) </p>
               </item>
               <item>
                  <p>For the types <code>xs:date</code>, <code>xs:time</code>,
                        <code>xs:dateTime</code>, <code>xs:gYear</code>, and
                        <code>xs:gYearMonth</code>: the range of values of the year component, which
                     must be at least +0001 to +9999; and the maximum number of fractional second
                     digits, which must be at least 3.</p>
               </item>
               <item>
                  <p>For the <code>xs:duration</code> type: the maximum absolute values of the
                     years, months, days, hours, minutes, and seconds components. </p>
               </item>
               <item>
                  <p>For the <code>xs:yearMonthDuration</code> type: the maximum absolute value,
                     expressed as an integer number of months.</p>
               </item>
               <item>
                  <p>For the <code>xs:dayTimeDuration</code> type: the maximum absolute value,
                     expressed as a decimal number of seconds.</p>
               </item>
               <item>
                  <p>For the types <code>xs:string</code>, <code>xs:hexBinary</code>,
                        <code>xs:base64Binary</code>, <code>xs:QName</code>, <code>xs:anyURI</code>,
                        <code>xs:NOTATION</code>, and types derived from them: the maximum length of
                     the value. </p>
               </item>
               <item>
                  <p>For sequences, the maximum number of items in a sequence.</p>
               </item>
            </olist>
         </div2>
         <div2 id="d-o-e-in-data-model">
            <head>Disable Output Escaping</head>
            <p>For backwards compatibility reasons, XSLT 4.0
               continues to support the <code>disable-output-escaping</code> feature introduced in
               XSLT 1.0. This is an optional feature and implementations are not
                  <rfc2119>required</rfc2119> to support it. A new facility, that of named <termref def="dt-character-map">character maps</termref> (see <specref ref="character-maps"/>) was introduced in XSLT 2.0. It provides
               similar capabilities to <code>disable-output-escaping</code>, but without distorting
               the data model.</p>
            <p>If an <termref def="dt-implementation">implementation</termref> supports the
                  <code>disable-output-escaping</code> attribute of <elcode>xsl:text</elcode> and
                  <elcode>xsl:value-of</elcode>, (see <specref ref="disable-output-escaping"/>),
               then the data model for trees constructed by the <termref def="dt-processor">processor</termref> is augmented with a boolean value representing the value of
               this property. This boolean value, however, can be set only within a <termref def="dt-final-result-tree">final result tree</termref> that is being passed to the
               serializer.</p>
            <p>Conceptually, each character in a text node on such a result tree has a boolean
               property indicating whether the serializer is to disable the normal rules for
               escaping of special characters (for example, outputting of <code>&amp;</code> as
                  <code>&amp;amp;</code>) in respect of this character.</p>
            <note>
               <p>In practice, the nodes in a <termref def="dt-final-result-tree">final result
                     tree</termref> will often be streamed directly from the XSLT processor to the
                  serializer. In such an implementation, <code>disable-output-escaping</code> can be
                  viewed not so much a property stored with nodes in the tree, but rather as
                  additional information passed across the interface between the XSLT processor and
                  the serializer.</p>
            </note>
         </div2>
      </div1>
      <div1 id="constructs">
         <head>Features of the XSLT Language</head>
         <div2 id="names">
            <head>Names</head>

            <div3 id="qname">
               <head>Qualified Names</head>
               <p>Many constructs appearing in a stylesheet, for example <termref def="dt-named-template">named templates</termref>, <termref def="dt-mode">modes</termref>, and <termref def="dt-attribute-set">attribute sets</termref>,
                  are named using a qualified name: this consists of a local name and an optional
                  namespace URI.</p>

               <p>In most cases where such names are written in a <termref def="dt-stylesheet">stylesheet</termref>, 
                  the syntax for expressing the name is given by the
                  production <xnt spec="XP40" ref="prod-xpath40-EQName">EQName</xnt> in the XPath
                  specification. In practice, this means that three forms are permitted:</p>

               <ulist>
                  <item>
                     <p>A simple <code>NCName</code> appearing on its own (without any prefix). This
                        represents the local name of the object. The interpretation of unprefixed
                        names is described below.</p>
                  </item>
                  <item>
                     <p>A <termref def="dt-lexical-qname">lexical QName</termref> written in the
                        form <code>NCName ":" NCName</code> where the first part is a namespace
                        prefix and the second part is the local name. The namespace part of the
                        object’s name is then derived from the prefix by examining the
                        in-scope namespace bindings of the element node in the stylesheet where the
                        name appears.</p>
                  </item>
                  <item>
                     <p>A <xnt spec="XP40" ref="prod-xpath40-URIQualifiedName">URIQualifiedName</xnt> in the form <code>"Q{" URI? "}" NCName</code>
                        where the two parts of the name, that is the namespace part and the local
                        part, both appear explicitly. If the URI part is omitted (for example
                           <code>Q{}local</code>), the resulting expanded QName is a QName whose
                        namespace part is absent.</p>
                  </item>
               </ulist>
               
               <p diff="add" at="2022-11-01">The rules for the use of these constructs generally permit
               leading and trailing whitespace, which is ignored.</p>

               <note>
                  <p>There are a few places where the third form, a URIQualifiedName, is not
                     permitted. These include the <code>name</code> attribute of
                        <elcode>xsl:element</elcode> and <elcode>xsl:attribute</elcode> (which have
                     a separate <code>namespace</code> attribute for the purpose), and constructs
                     defined by other specifications. For example, names appearing within an
                     embedded <code>xs:schema</code> element must follow the XSD rules.</p>
               </note>

               <p>
                  <termdef id="dt-expanded-qname" term="expanded QName">An <term>expanded
                        QName</term> is a value in the value space of the <code>xs:QName</code>
                     datatype as defined in the XDM data model (see <bibref ref="xpath-datamodel-30"/>): that is, a triple containing namespace prefix (optional), namespace URI
                     (optional), and local name. Two expanded QNames are equal if the namespace URIs
                     are the same (or both absent) and the local names are the same. The prefix
                     plays no part in the comparison, but is used only if the expanded QName needs
                     to be converted back to a string.</termdef>
               </p>

               <p><termdef id="dt-eqname" term="EQName">An <term>EQName</term> is a string
                     representing an <termref def="dt-expanded-qname">expanded QName</termref> where
                     the string, after removing leading and trailing whitespace, is in the form
                     defined by the <xnt spec="XP40" ref="prod-xpath40-EQName">EQName</xnt>
                     production in the XPath specification.</termdef></p>



               <p>
                  <termdef id="dt-lexical-qname" term="lexical QName">A <term>lexical QName</term>
                     is a string representing an <termref def="dt-expanded-qname">expanded
                        QName</termref> where the string, after removing leading and trailing
                     whitespace, is within the lexical space of the <code>xs:QName</code> datatype
                     as defined in XML Schema (see <bibref ref="xmlschema-2"/>): that is, a local
                     name optionally preceded by a namespace prefix and a colon.</termdef>
               </p>

               <p>Note that every <termref def="dt-lexical-qname">lexical QName</termref> is an
                     <termref def="dt-eqname">EQName</termref>, but the converse is not true.</p>


               <p>The following rules are used when interpreting a <termref def="dt-lexical-qname">lexical QName</termref>:</p>

               <olist>
                  <item>
                     <p>
                        <termdef id="dt-defining-element" term="defining element">A string in the
                           form of a lexical QName may occur as the value of an attribute node in a
                           stylesheet module, or within an XPath <termref def="dt-expression">expression</termref> contained in an attribute or text node within a stylesheet module, or as the
                           result of evaluating an XPath expression contained in such a node. The
                           element containing this attribute or
                              text node is referred to as the <term>defining element</term>
                           of the lexical QName.</termdef>
                     </p>
                  </item>

                  <item>
                     <p>If the lexical QName has a prefix, then the prefix is expanded into a URI
                        reference using the namespace declarations in effect on its <termref def="dt-defining-element">defining element</termref>. The <termref def="dt-expanded-qname">expanded QName</termref> consisting of the local
                        part of the name and the possibly null URI reference is used as the name of
                        the object. The default namespace of the defining element (see <xspecref spec="DM30" ref="ElementNode"/>) is <emph>not</emph> used for unprefixed
                        names.</p>
                     <p>
                        <error spec="XT" type="static" class="SE" code="0280">
                           <p>In the case of a prefixed <termref def="dt-lexical-qname">lexical
                                 QName</termref> used as the value (or as
                                 part of the value) of an attribute in the <termref def="dt-stylesheet">stylesheet</termref>, or appearing within an
                              XPath <termref def="dt-expression">expression</termref> in the
                              stylesheet, it is a <termref def="dt-static-error">static
                                 error</termref> if the <termref def="dt-defining-element">defining
                                 element</termref> has no namespace node whose name matches the
                              prefix of the <termref def="dt-lexical-qname">lexical
                              QName</termref>.</p>
                        </error>
                     </p>
                     <p>
                        <error spec="XT" type="dynamic" class="DE" code="0290">
                           <p>Where the result of evaluating an XPath expression (or an attribute
                              value template) is required to be a <termref def="dt-lexical-qname">lexical QName</termref>, or if it is permitted to be a <termref def="dt-lexical-qname">lexical QName</termref> and the actual value
                              takes the form of a <termref def="dt-lexical-qname">lexical
                                 QName</termref>, then unless otherwise specified it is a <termref def="dt-dynamic-error"> dynamic error</termref> if the value
                              has a prefix and the <termref def="dt-defining-element">defining
                                 element</termref> has no namespace node whose name matches that
                              prefix. This error <rfc2119>may</rfc2119> be signaled as a <termref def="dt-static-error">static error</termref> if the value of the
                              expression can be determined statically.</p>
                        </error>
                     </p>
                  </item>
                  <item>
                     <p>If the lexical QName has no prefix, then:</p>
                     <olist>
                        <item>
                           <p>In the case of an unprefixed QName used as a <code>NameTest</code>
                              within an XPath <termref def="dt-expression">expression</termref> (see
                                 <specref ref="expressions"/>), and in certain other contexts, the
                              namespace to be used in expanding the QName may be specified by means
                              of the <code>[xsl:]xpath-default-namespace</code> attribute, as
                              specified in <specref ref="unprefixed-qnames"/>.</p>
                        </item>

                        <item>
                           <p>If the name is in one of the following categories, then the default
                              namespace of the <termref def="dt-defining-element">defining
                                 element</termref> is used:</p>
                           <olist>
                              <item>
                                 <p>Where a QName is used to define the name of an element being
                                    constructed. This applies both to cases where the name is known
                                    statically (that is, the name of a literal result element) and
                                    to cases where it is computed dynamically (the value of the
                                       <code>name</code> attribute of the
                                       <elcode>xsl:element</elcode> instruction).</p>
                              </item>
                              <item>
                                 <p>The default namespace is used when expanding the first argument
                                    of the function <function>element-available</function>.</p>
                              </item>
                              <item>
                                 <p>The default namespace applies to any unqualified element names
                                    appearing in the <code>cdata-section-elements</code>
                                    or
                                          <code>suppress-indentation</code> attributes of
                                       <elcode>xsl:output</elcode> or
                                       <elcode>xsl:result-document</elcode>
                                 </p>
                              </item>
                           </olist>
                        </item>

                        <item>
                           <p>In all other cases, a <termref def="dt-lexical-qname">lexical
                                 QName</termref> with no prefix represents an <termref def="dt-expanded-qname">expanded QName</termref> in no namespace
                              (that is, an <code>xs:QName</code> value in which both the prefix and
                              the namespace URI are absent).</p>
                        </item>
                     </olist>
                  </item>


               </olist>
            </div3>
            <div3 id="unprefixed-qnames" diff="chg" at="2022-01-01">
               <head>Unprefixed Lexical QNames in Expressions and Patterns</head>
               
               
               <div4 id="unprefixed-element-names">
                  <head>Unprefixed Element Names</head>
               
               <p>The attribute <code>[xsl:]default-element-namespace</code> (see <specref ref="standard-attributes"/>) 
                  may be used on an element in the <termref def="dt-stylesheet">stylesheet</termref> to define the 
                  namespace that will be used for an unprefixed element name within an XPath expression, and
                  in certain other contexts listed below.</p>
               <p>The attribute <code>[xsl:]xpath-default-namespace</code> (which is retained for backwards
                  compatibility reasons) also has the same effect, but also affects unprefixed type names.</p>
               <p>The value of the attribute, in each case, is the namespace URI to be used.</p>
               <p>For any element <code>$E</code> in the <termref def="dt-stylesheet">stylesheet</termref>, there is an
                  effective value for the default element namespace, which is the value of the
                  XPath expression:</p>
                  <eg>string(($E/ancestor-or-self::node()/
     (self::xsl:*/@default-element-namespace 
        otherwise
      @xsl:default-element-namespace
        otherwise
      self::xsl:*/@xpath-default-namespace
        otherwise
      @xsl:xpath-default-namespace))[last()]).</eg>
               <note><p>That is, the default element namespace is the value of the <code>[xsl:]default-element-namespace</code> or
                  <code>[xsl:]xpath-default-namespace</code> attribute on that element or on the innermost
                  containing element that specifies such an attribute, or a zero-length string if
                  no containing element specifies such an attribute; and if both attributes are present
                  on the same element, then <code>[xsl:]default-element-namespace</code> wins.</p></note>
               
               <p>For any element in the <termref def="dt-stylesheet">stylesheet</termref>, the
                  effective value of the default element namespace determines the value of the <emph>default
                     namespace for element names</emph> in the static context of any XPath
                  expression contained in an attribute or text
                     node of that element (including XPath expressions in <termref def="dt-attribute-value-template">attribute value templates</termref>
                  and <termref def="dt-text-value-template">text value
                        templates</termref>). The effect of this is specified in <bibref ref="xpath-40"/>; in summary, it determines the namespace used for any
                  unprefixed element name appearing in a path expression or in the <termref def="dt-sequence-type"/>
                  production.</p>
               <p>The effective value of this attribute similarly applies to any of the following
                  constructs appearing within its scope:</p>
               <ulist>
                  <item>
                     <p>any unprefixed element name used in a <termref def="dt-pattern">pattern</termref>
                     </p>
                  </item>
                  <item>
                     <p>any unprefixed element name used in the <code>elements</code> attribute of
                        the <elcode>xsl:strip-space</elcode> or <elcode>xsl:preserve-space</elcode>
                        instructions</p>
                  </item>
                  <item>
                     <p>any unprefixed element name used in the <code>as</code>
                        attribute of an <termref def="dt-xslt-element">XSLT element</termref>
                     </p>
                  </item>
                  
               </ulist>
               <p>The <code>[xsl:]xpath-default-namespace</code> attribute <rfc2119>must</rfc2119>
                  be in the <termref def="dt-xslt-namespace">XSLT namespace</termref> if and only if
                  its parent element is <emph>not</emph> in the XSLT namespace.</p>
               <p>If the effective value of the attribute is a zero-length string, which will be the
                  case if it is explicitly set to a zero-length string or if it is not specified at
                  all, then an unprefixed element name or type name refers to a name that is in no
                  namespace. The default namespace of the parent element (see <xspecref spec="DM30" ref="ElementNode"/>) is <emph>not</emph> used.</p>
               </div4>
               
               <div4 id="unprefixed-type-names">
                  <head>Unprefixed Type Names</head>
                  
                  <p>The attribute <code>[xsl:]default-type-namespace</code> (see <specref ref="standard-attributes"/>) 
                     may be used on an element in the <termref def="dt-stylesheet">stylesheet</termref> to define the 
                     namespace that will be used for an unprefixed type name within an XPath expression, and
                     in certain other contexts listed below.</p>
                  <p>The attribute <code>[xsl:]xpath-default-namespace</code> (which is retained for backwards
                     compatibility reasons) also has the same effect, but also affects unprefixed element names.</p>
                  <p>The value of the attribute, in each case, is the namespace URI to be used.</p>
                  <p>For any element <code>$E</code> in the <termref def="dt-stylesheet">stylesheet</termref>, there is an
                     effective value for the default type namespace, which is the value of the
                     XPath expression:</p>
                  <eg>string(($E/ancestor-or-self::node()/
   (self::xsl:*/@default-type-namespace 
      otherwise
   @xsl:default-type-namespace
      otherwise
   self::xsl:*/@xpath-default-namespace
      otherwise
   @xsl:xpath-default-namespace))[last()]).</eg>
                  <note><p>That is, the default type namespace is the value of the <code>[xsl:]default-type-namespace</code> or
                     <code>[xsl:]xpath-default-namespace</code> attribute on that element or on the innermost
                     containing element that specifies such an attribute, or a zero-length string if
                     no containing element specifies such an attribute; and if both attributes are present
                     on the same element, then <code>[xsl:]default-type-namespace</code> wins.</p></note>
                  
                  <p>For any element in the <termref def="dt-stylesheet">stylesheet</termref>, the
                     <termref def="dt-effective-value"/> of the default type namespace determines the value of the <emph>default
                        namespace for type names</emph> in the static context of any XPath
                     expression contained in an attribute or text
                     node of that element (including XPath expressions in <termref def="dt-attribute-value-template">attribute value templates</termref>
                     and <termref def="dt-text-value-template">text value
                        templates</termref>). The effect of this is specified in <bibref ref="xpath-40"/>; in summary, it determines the namespace used for any
                     unprefixed element name appearing in a path expression or in the <termref def="dt-sequence-type"/>
                     production.</p>
                  <p>The <termref def="dt-effective-value"/> of this attribute similarly applies to any of the following
                     constructs appearing within its scope:</p>
                  <ulist>
                     <item>
                        <p>any unprefixed type name used in a <termref def="dt-pattern">pattern</termref>
                        </p>
                     </item>
                     <item>
                        <p>any unprefixed type name used in the <code>as</code> or <code>type</code>
                           attribute of an <termref def="dt-xslt-element">XSLT element</termref>
                        </p>
                     </item>
                     <item>
                        <p>any unprefixed type name used in the <code>xsl:type</code>
                           attribute of a <termref def="dt-literal-result-element"/>.
                        </p>
                     </item>
                     
                  </ulist>
                  
                  <p>If the <termref def="dt-effective-value"/> of the attribute is a zero-length string, which will be the
                     case if it is explicitly set to a zero-length string or if it is not specified at
                     all, then an unprefixed element name or type name refers to a name that is in no
                     namespace. The default namespace of the parent element (see <xspecref spec="DM30" ref="ElementNode"/>) 
                     is <emph>not</emph> used.</p>
                  
                  <note><p>In a stylesheet that does not import any schema, all type names used are likely
                  to be in the namespace <code>http://www.w3.org/2001/XMLSchema</code>, which is traditionally
                  bound to the prefix <code>xs</code>. In such a stylesheet, it makes sense to declare (on the
                     outermost <elcode>xsl:stylesheet</elcode> element) the attribute 
                     <code>default-type-namespace="http://www.w3.org/2001/XMLSchema"</code>. With this
                  declaration in place, variables and parameters can use type declarations such
                  as <code>as="integer"</code> rather than <code>as="xs:integer"</code>, thus eliminating the need
                  to declare this namespace.</p>
                  <p>Note however that the default namespace for types does not apply to the names of constructor
                  functions. In a function call such as <code>decimal(@price)</code> the rules for unprefixed
                  function names, not type names, apply.</p>
                  <p>In a stylesheet that imports a no-namespace schema, setting the default type namespace to
                     <code>http://www.w3.org/2001/XMLSchema</code> is still possible; but in this case user-defined
                  types in no namespace can only be referenced using the notation <code>Q{}my-type</code>.</p></note>
               </div4>
               <div4 id="unprefixed-function-names">
                  <head>Unprefixed Function Names</head>
                  <p>The interpretation of unprefixed function names is described in
                  <specref ref="resolving-function-names"/>.</p>
               </div4>
               <div4 id="other-unprefixed-names">
                  <head>Other Unprefixed Names</head>
                  <p>For other unprefixed names, for example variable
                     names, template names, mode names, or strings that are interpreted as <termref def="dt-lexical-qname">lexical QNames</termref> during stylesheet evaluation,
                     such as the <termref def="dt-effective-value">effective value</termref> of the
                     <code>name</code> attribute of <elcode>xsl:element</elcode> or the string
                     supplied as the first argument to the <function>key</function> function, any unprefixed
                  lexical QName is taken as being a no-namespace name.</p>
               </div4>
               
            </div3>
            <div3 id="reserved-namespaces">
               <head>Reserved Namespaces</head>
               <p>
                  <termdef id="dt-reserved-namespace" term="reserved namespace">The XSLT namespace,
                     together with certain other namespaces recognized by an XSLT processor, are
                     classified as <term>reserved namespaces</term> and <rfc2119>must</rfc2119> be
                     used only as specified in this and related specifications.</termdef> The
                  reserved namespaces are those listed below.</p>
               <ulist>
                  <item>
                     <p>The <termref def="dt-xslt-namespace">XSLT namespace</termref>, described in
                           <specref ref="xslt-namespace"/>, is reserved.</p>
                  </item>
                  <item>
                     <p>
                        <termdef id="dt-standard-function-namespace" term="standard function namespace">The <term>standard function
                              namespace</term>
                           <code>http://www.w3.org/2005/xpath-functions</code> is used for functions
                           in the function library defined in <bibref ref="xpath-functions-40"/> and
                           for standard functions defined in this specification.</termdef>
                     </p>
                  </item>
                  <item>
                     <p> The namespace
                           <code>http://www.w3.org/2005/xpath-functions/math</code> is used for
                        mathematical functions in the function library defined in <bibref ref="xpath-functions-30"/>. </p>
                  </item>
                  <item>
                     <p> The namespace
                           <code>http://www.w3.org/2005/xpath-functions/map</code> is used for
                        functions defined in this specification relating to the manipulation of
                           maps. </p>
                  </item>
                  <item>
                     <p> The namespace
                           <code>http://www.w3.org/2005/xpath-functions/array</code> is reserved for
                        use as described in <bibref ref="xpath-functions-31"/>.<phrase diff="del" at="2022-01-01"> The namespace is
                        reserved whether or not the processor actually supports XPath 3.1.</phrase></p>
                  </item>
                  <item>
                     <p>
                        <termdef id="xml-namespace" term="XML namespace">The <term>XML
                              namespace</term>, defined in <bibref ref="xml-names"/> as
                              <code>http://www.w3.org/XML/1998/namespace</code>, is used for
                           attributes such as <code>xml:lang</code>, <code>xml:space</code>, and
                              <code>xml:id</code>.</termdef>
                     </p>
                  </item>
                  <item>
                     <p><termdef id="dt-schema-namespace" term="schema namespace">The <term>schema
                              namespace</term>
                           <code>http://www.w3.org/2001/XMLSchema</code> is used as defined in
                              <bibref ref="xmlschema-1"/></termdef>. In a <termref def="dt-stylesheet">stylesheet</termref> this namespace may be used to
                        refer to built-in schema datatypes and to the constructor functions
                        associated with those datatypes.</p>
                  </item>
                  <item>
                     <p><termdef id="dt-schema-instance-namespace" term="schema instance namespace">The <term>schema instance namespace</term>
                           <code>http://www.w3.org/2001/XMLSchema-instance</code> is used as defined
                           in <bibref ref="xmlschema-1"/></termdef>. Attributes in this namespace,
                        if they appear in a <termref def="dt-stylesheet">stylesheet</termref>, are
                        treated by the XSLT processor in the same way as any other attributes.</p>
                  </item>
                  <item>
                     <p><termdef id="dt-standard-error-namespace" term="standard error namespace">The <term>standard error namespace</term>
                           <code>http://www.w3.org/2005/xqt-errors</code> is used for error codes
                           defined in this specification and related specifications. It is also used
                           for the names of certain predefined variables accessible within the scope
                           of an <elcode>xsl:catch</elcode> element.</termdef></p>
                  </item>
                  <item>
                     <p>The namespace <code>http://www.w3.org/2000/xmlns/</code> is reserved for use
                        as described in <bibref ref="xml-names"/>. No element or attribute node can
                        have a name in this namespace, and although the prefix <code>xmlns</code> is
                        implicitly bound to this namespace, no namespace node will ever define this
                        binding.</p>
                  </item>
               </ulist>
               
               <note>
                  <p>With the exception of the XML namespace, any of the above namespaces that are
                     used in a stylesheet must be explicitly declared with a namespace declaration.
                     Although conventional prefixes are used for these namespaces in this
                     specification, any prefix may be used in a user stylesheet.</p>
               </note>

               <p>Reserved namespaces may be used without restriction to refer to the names of
                  elements and attributes in source documents and result documents. As far as the
                  XSLT processor is concerned, reserved namespaces other than the XSLT namespace may
                  be used without restriction in the names of <termref def="dt-literal-result-element">literal result elements</termref> and <termref def="dt-data-element">user-defined data elements</termref>, and in the names of
                  attributes of literal result elements or of <termref def="dt-xslt-element">XSLT
                     elements</termref>: but other processors <rfc2119>may</rfc2119> impose
                  restrictions or attach special meaning to them. Reserved namespaces <rfc2119>must
                     not</rfc2119> be used, however, in the names of stylesheet-defined objects such
                  as <termref def="dt-variable">variables</termref> and <termref def="dt-stylesheet-function">stylesheet functions</termref>,
                     nor in the names of <termref def="dt-extension-function">extension functions</termref>
                     or <termref def="dt-extension-instruction">extension instructions</termref>.</p>
               
               <p>It is not an error to use a reserved namespace in the name of an 
                  <termref def="dt-extension-attribute">extension attribute</termref>: 
                  attributes such as <code>xml:space</code> and <code>xsi:type</code> 
                  fall into this category. XSLT processors <rfc2119>must not</rfc2119> reject such attributes, 
                  and <rfc2119>must not</rfc2119> attach any meaning to them other than any meaning 
                  defined by the relevant specification.</p>
               
               <p>
                  <error spec="XT" type="static" class="SE" code="0080">
                     <p>It is a <termref def="dt-static-error">static error</termref> to use a
                           <termref def="dt-reserved-namespace">reserved namespace</termref> in the
                        name of a <termref def="dt-named-template">named template</termref>, a
                           <termref def="dt-mode">mode</termref>, an <termref def="dt-attribute-set">attribute set</termref>, a <termref def="dt-key">key</termref>, a
                           <termref def="dt-decimal-format">decimal-format</termref>, a <termref def="dt-variable">variable</termref> or <termref def="dt-parameter">parameter</termref>, a <termref def="dt-stylesheet-function">stylesheet
                           function</termref>, a named <termref def="dt-output-definition">output
                           definition</termref>, an <termref def="dt-accumulator"/>, or a <termref def="dt-character-map">character map</termref><phrase>; except that the name
                              <code>xsl:initial-template</code> is permitted as a template
                           name.</phrase></p>
                  </error>
               </p>

               <note>
                  <p>The name <code>xsl:original</code> is used within <elcode>xsl:override</elcode>
                     to refer to a <termref def="dt-component"/> that is being overridden. Although
                     the name <code>xsl:original</code> is used to refer to the component, the
                     component has its own name, and no component ever has the name
                        <code>xsl:original</code>. </p>
               </note>

            </div3>
         </div2>


         <div2 id="expressions">
            <head>Expressions</head>
            <p>XSLT uses the expression language defined by <phrase>XPath 3.0</phrase>
               <bibref ref="xpath-30"/>. Expressions are used in XSLT for a variety of purposes
               including:</p>
            <ulist>
               <item>
                  <p>selecting nodes for processing;</p>
               </item>
               <item>
                  <p>specifying conditions for different ways of processing a node;</p>
               </item>
               <item>
                  <p>generating text to be inserted in a <termref def="dt-result-tree">result
                        tree</termref>.</p>
               </item>
            </ulist>
            <p>
               <termdef id="dt-expression" term="expression">Within this specification, the term
                     <term>XPath expression</term>, or simply <term>expression</term>, means a
                  string that matches the production <xnt spec="XP40" ref="prod-xpath40-Expr">Expr</xnt> 
                  defined in <bibref ref="xpath-30"/><phrase diff="del">, with the extensions defined in <specref ref="map"/></phrase>.</termdef>
            </p>
            <p diff="del" at="2022-01-01">If the processor implements the XPath 3.1 feature, then the definition of the production
                  <code>Expr</code> from XPath 3.1 is used.</p>
            <p diff="del" at="2022-01-01">If the processor is configured to use a version of XPath
               later than XPath 3.1, then the syntax of an XPath expression is <termref def="dt-implementation-defined"/>.</p>
            <p>An XPath expression may occur as the value of certain attributes on XSLT-defined
               elements, and also within curly brackets in <termref def="dt-attribute-value-template">attribute value templates</termref>
               and <termref def="dt-text-value-template">text value
                     templates</termref>.</p>
            <p>Except where <termref def="dt-forwards-compatible-behavior"/> is enabled (see
                  <specref ref="forwards"/>), it is a <termref def="dt-static-error">static
                  error</termref> if the value of such an attribute, <error.extra>an attribute
                  defined as containing an XPath <termref def="dt-expression">expression</termref>
               </error.extra> or the text between curly brackets in an <termref def="dt-attribute-value-template">attribute value template</termref>
               or <termref def="dt-text-value-template">text value
                     template</termref>, does not match the XPath production <xnt spec="XP40" ref="prod-xpath40-Expr">Expr</xnt>, or if it fails to satisfy other
               static constraints defined in the XPath specification, for example that all variable
               references <rfc2119>must</rfc2119> refer to <termref def="dt-variable">variables</termref> that are in scope. Error codes are defined in <bibref ref="xpath-30"/>.</p>
            <p>The transformation fails with a <termref def="dt-dynamic-error"> dynamic error</termref> if any XPath <termref def="dt-expression">expression</termref> is evaluated and raises a dynamic error.
               Error codes are defined in <bibref ref="xpath-30"/>.</p>
            <p>The transformation fails with a <termref def="dt-type-error">type error</termref> if
               an XPath <termref def="dt-expression">expression</termref> raises a type error, or if
               the result of evaluating the XPath <termref def="dt-expression">expression</termref>
               is evaluated and raises a type error, or if the XPath processor signals a type error
               during static analysis of an <termref def="dt-expression">expression</termref>. Error
               codes are defined in <bibref ref="xpath-30"/>.</p>
            <p>
               <termdef id="dt-required-type" term="required type">The context within a <termref def="dt-stylesheet">stylesheet</termref> where an XPath <termref def="dt-expression">expression</termref> appears may specify the <term>required
                     type</term> of the expression. The required type indicates the type of the
                  value that the expression is expected to return.</termdef> If no required type is
               specified, the expression may return any value: in effect, the required type is then
                  <code>item()*</code>. </p>
            

            <p diff="chg" at="2022-01-01">
               <termdef id="dt-coercion-rules" term="coercion rules"> When
                  used in this specification without further qualification, the term <term>coercion rules</term> 
                  means the coercion rules defined in <bibref ref="xpath-40"/>, applied with XPath 1.0 
                  compatibility mode set to <code>false</code>.</termdef>
            </p>
            
            <note diff="add" at="2022-01-01">
               <p>In earlier versions of this specification, these were referred to as the
               <term>function conversion rules.</term></p>
            </note>

            <note>
               <p> These are the rules defined in <bibref ref="xpath-40"/> for converting the
                  supplied argument of a function call to the required type of that argument, as
                  defined in the function signature. The same rules are used in XSLT for converting
                  the value of a variable to the declared type of the variable, or the result of
                  evaluating a function or template body to the declared type of the function or
                  template. They are also used when parameters are supplied to a template using
                     <elcode>xsl:with-param</elcode>. In all such cases, the rules that apply are
                  the XPath 4.0 rules without XPath 1.0 compatibility mode. The rules with XPath 1.0
                  compatibility mode set to <code>true</code> are used only for XPath function calls, and for the
                  operands of certain XPath operators. </p>
            </note>

            <p>This specification also invokes the XPath 3.0
               <termref def="dt-coercion-rules"/> to
               convert the result of evaluating an XSLT <termref def="dt-sequence-constructor">sequence constructor</termref> to a required type (for example, the sequence
               constructor enclosed in an <elcode>xsl:variable</elcode>,
                  <elcode>xsl:template</elcode>, or <elcode>xsl:function</elcode> element).</p>
            <p>Any <termref def="dt-dynamic-error">dynamic error</termref> or <termref def="dt-type-error">type error</termref> 
               that occurs when applying the <termref def="dt-coercion-rules"/> to convert
               a value to a required type results in the transformation failing, in the same way as
               if the error had occurred while evaluating an expression.</p>
            <note>
               <p>Note the distinction between the two kinds of error that may occur. Attempting to
                  convert an integer to a date is a type error, because such a conversion is never
                  possible. Type errors can be reported statically if they can be detected
                  statically, whether or not the construct in question is ever evaluated. Attempting
                  to convert the <phrase diff="chg" at="2022-01-01"><code>xs:untypedAtomic</code></phrase> value 
                  <code>2003-02-29</code> to a date is a dynamic error rather
                  than a type error, because the problem is with this particular value, not with its
                  type. Dynamic errors are reported only if the instructions or expressions that
                  cause them are actually evaluated. <phrase diff="add" at="2022-01-01">[XSLT 3.0 Erratum E21, bug 30236]</phrase></p>
            </note>

            <p>The XPath specification states that the host language must
               specify whether the XPath processor normalizes all line breaks on input, before
               parsing, and if it does so, whether it uses the rules of [XML 1.0] or [XML 1.1]. In
               the case of XSLT, all handling of line breaks is the responsibility of the XML parser
               (which may support either XML 1.0 or XML 1.1); the XSLT and XPath processors perform
               no further changes.</p>


            <note>
               <p>Most XPath expressions in a stylesheet appear within
                  XML attributes. They are therefore subject to XML line-ending normalization (for
                  example, a CRLF sequence is normalized to LF) and also to XML attribute-value
                  normalization, which replaces tabs and newlines by spaces. XPath expressions
                  appearing in text value templates, however (see <specref ref="text-value-templates"/>) are subject to line-ending normalization but not
                  attribute-value normalization. In both cases, normalization of whitespace can be
                  prevented by using character references such as <code>&amp;#x9;</code>.</p>
            </note>

         </div2>
         <div2 id="static-and-dynamic-context">
            <head>The Static and Dynamic Context</head>
            <p>XPath defines the concept of an <xtermref spec="XP40" ref="dt-expression-context">expression context</xtermref> which contains all the information that can affect
               the result of evaluating an <termref def="dt-expression">expression</termref>. The
               expression context has two parts, the <xtermref spec="XP40" ref="dt-static-context">static context</xtermref>, and the <xtermref spec="XP40" ref="dt-dynamic-context">dynamic context</xtermref>. The components that make up the expression context
               are defined in the XPath specification (see <xspecref spec="XP40" ref="context"/>).
               This section describes the way in which these components are initialized when an
               XPath expression is contained within an XSLT stylesheet.</p>
            
            <p diff="add" at="2022-01-01">
               This section does not apply to <termref def="dt-static-expression">static expressions</termref> 
               (whose context is defined in <specref ref="static-expression"/>), nor to XPath expressions 
               evaluated using <elcode>xsl:evaluate</elcode> (whose context is defined in 
               <specref ref="evaluate-dynamic-context"/>). [XSLT 3.0 Erratum E24, bug 30241]
            </p>
            <p>As well as providing values for the static and dynamic context components defined in
               the XPath specification, XSLT defines additional context components of its own. These
               context components are used by XSLT instructions (for example,
                  <elcode>xsl:next-match</elcode> and <elcode>xsl:apply-imports</elcode>), and also
               by the functions in the extended function library described in this
               specification.</p>
            <p>The following four sections describe:</p>
            <slist>
               <sitem>
                  <specref ref="static-context"/>
               </sitem>
               <sitem>
                  <specref ref="additional-static-context"/>
               </sitem>
               <sitem>
                  <specref ref="xpath-dynamic-context"/>
               </sitem>
               <sitem>
                  <specref ref="additional-dynamic-context"/>
               </sitem>
            </slist>
            <div3 id="static-context">
               <head>Initializing the Static Context</head>
               <p>The <xtermref spec="XP40" ref="dt-static-context">static context</xtermref> of an
                  XPath expression appearing in an XSLT stylesheet is initialized as follows. In
                  these rules, the term <term>containing element</term> means the element within the
                  stylesheet that is the parent of the attribute or text
                     node whose value contains the XPath expression in question, and the
                  term <term>enclosing element</term> means the containing element or any of its
                  ancestors.</p>
               <ulist>
                  <item>
                     <p>
                        <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref>
                        is set to <code>true</code> if and only if the containing element is processed with
                           <termref def="dt-xslt-10-behavior">XSLT 1.0 behavior</termref> (see
                           <specref ref="backwards"/>).</p>
                  </item>
                  <item>
                     <p>The <xtermref spec="XP40" ref="dt-static-namespaces">statically known
                           namespaces</xtermref> are the namespace declarations that are in scope
                        for the containing element.</p>
                  </item>
                  <item>
                     <p diff="chg" at="2022-01-01">The <xtermref spec="XP40" ref="dt-def-element-ns">default element
                           namespace</xtermref> is determined as described in
                        <specref ref="unprefixed-element-names"/>.</p>
                  </item>
                  <item>
                     <p diff="chg" at="2022-01-01">The <xtermref spec="XP40" ref="dt-def-type-ns">default type
                        namespace</xtermref> is determined as described in
                        <specref ref="unprefixed-type-names"/>..</p>
                  </item>
                  <item>
                     <p diff="chg" at="2022-11-25">The <xtermref ref="dt-default-function-namespace" 
                        spec="XP40">default function namespace</xtermref> is
                        <code>http://www.w3.org/2005/xpath-functions</code> (and cannot be changed).
                        The XSLT 4.0 specification refines the XPath 4.0 rules for resolving
                        function names as described in <specref ref="resolving-function-names"/>.</p>
                  </item>
                  <item>
                     <p>The <xtermref spec="XP40" ref="dt-issd">in-scope schema
                           definitions</xtermref> for the XPath expression are the same as the
                           <termref def="dt-in-scope-schema-component">in-scope schema
                           components</termref> for the <termref def="dt-stylesheet">stylesheet</termref>, and are as specified in <specref ref="built-in-types"/>.</p>
                  </item>
                  <item>
                     <p>The <xtermref spec="XP40" ref="dt-in-scope-variables">in-scope
                           variables</xtermref> are defined by the <termref def="dt-variable-binding-element">variable binding elements</termref>
                        that are in scope for the containing element (see <specref ref="variables-and-parameters"/>).</p>
                  </item>
                  <item>
                     <p>The <xtermref spec="XP40" ref="dt-context-item-static-type">context item
                           static type</xtermref> may be determined by an XSLT processor that
                        performs static type inferencing, using rules that are outside the scope of
                        this specification; if no static type inferencing is done, then the context
                        item static type for every XPath expression is <code>item()</code>. Note that some limited static type inferencing is
                           required in the case of a processor that performs streamability analysis:
                           see <specref ref="determining-static-type"/>.</p>
                  </item>
                  <item>
                     <p>The <xtermref spec="XP40" ref="dt-statically-known-function-definitions">statically known
                           function definitions</xtermref> are:</p>

                     <ulist>
                        <item>
                           <p>The functions defined in <bibref ref="xpath-functions-40"/> in
                              namespaces <code>http://www.w3.org/2005/xpath-functions</code> and
                                 <code>http://www.w3.org/2005/xpath-functions/math</code>;</p>
                        </item>
                        <item>
                           <p>The functions defined in this specification in namespaces
                                 <code>http://www.w3.org/2005/xpath-functions</code> and
                                 <code>http://www.w3.org/2005/xpath-functions/map</code>;</p>
                        </item>
                        <item>
                           <p>Constructor functions for all the simple types in the <xtermref spec="XP40" ref="dt-issd">in-scope schema definitions</xtermref>, including both built-in
                              types and user-defined types;</p>
                        </item>
                        <item>
                           <p>The <termref def="dt-stylesheet-function">stylesheet
                                 functions</termref> defined in the containing <termref def="dt-package"/>;</p>
                        </item>
                        <item>
                           <p>Stylesheet functions defined in used packages, subject to visibility:
                              see <specref ref="package-dependencies"/>;</p>
                        </item>
                        <item>
                           <p>any <termref def="dt-extension-function">extension functions</termref>
                              bound using <termref def="dt-implementation-defined">implementation-defined</termref> mechanisms (see <specref ref="extension"/>).</p>
                           <note>
                              <p>The term <termref def="dt-extension-function"/> includes both
                                 vendor-supplied and user-written extension functions.</p>
                           </note>
                        </item>
                     </ulist>

                     <note>
                        <p>It follows from the above that a conformant XSLT processor must implement
                           the entire library of functions defined in
                                 <bibref ref="xpath-functions-40"/> as well as those defined
                           in this specification.</p>
                     </note>
                  </item>
                  <item>
                     <p>The <xtermref spec="XP40" ref="dt-static-collations">statically known
                           collations</xtermref> are <termref def="dt-implementation-defined">implementation-defined</termref>, except that they <rfc2119>must</rfc2119> always include (a) the Unicode
                           codepoint collation, defined in <xspecref spec="FO40" ref="string-compare"/>, and (b) the family of UCA collations described
                           in <specref ref="uca-collations"/>.</p>

                  </item>
                  
                  <item>
                     <p><term>Static base URI</term>: In a conventional interpreted 
                        environment, the static base URI of an expression in the stylesheet is the base URI 
                        of the containing element in the stylesheet. The concept of the base URI of a node 
                        is defined in <xspecref spec="DM30" ref="dm-base-uri"/>.</p>
                        
                     <p>When stylesheets are executed in an environment where no source code is present
                        (for example, because the code of the stylesheet has been compiled and is distributed 
                        as executable object code), it is <rfc2119>recommended</rfc2119> (subject to operational
                        constraints such as security) that the static base URI used during stylesheet evaluation
                        should be the location from which the stylesheet was loaded for execution 
                        (its “deployed location”). This means, for example, that when the <xfunction>doc</xfunction>
                        or <function>document</function> functions are called with a relative URI, the required document
                        is by default located relative to the deployed location of the stylesheet.
                     </p>
                     
                     <p>Whether or not the stylesheet is executed directly from source code,
                     it is possible that no static base URI is available, for example because the code was supplied
                     as an anonymous input stream, or because security policies are set to prevent executable code discovering
                     the location from which it was loaded. If the static base URI is not known, the <xfunction>static-base-uri</xfunction>
                     function returns an empty sequence, and other operations that depend on the static base URI may fail with
                     a dynamic error.</p>
                     
                  </item>
                  <item>
                     <p>The set of <xtermref spec="XP40" ref="dt-known-docs">statically known
                           documents</xtermref> is <termref def="dt-implementation-defined">implementation-defined</termref>. </p>
                     <imp-def-feature id="idf-api-staticallyknowndocs">The <xtermref spec="XP40" ref="dt-known-docs">statically known documents</xtermref>, <xtermref spec="XP40" ref="dt-known-collections">statically known
                           collections</xtermref>, and the <xtermref spec="XP40" ref="dt-known-default-collection">statically known default collection
                           type</xtermref> are <termref def="dt-implementation-defined">implementation-defined</termref>.</imp-def-feature>
                  </item>
                  <item>
                     <p>The set of <xtermref spec="XP40" ref="dt-known-collections">statically known
                           collections</xtermref> is <termref def="dt-implementation-defined">implementation-defined</termref>. </p>

                  </item>
                  <item>
                     <p>The <xtermref spec="XP40" ref="dt-known-default-collection">statically known
                           default collection type</xtermref> is <termref def="dt-implementation-defined">implementation-defined</termref>. </p>

                  </item>
                  <item>
                     <p>The set of <xtermref spec="XP40" ref="dt-static-decimal-formats">statically
                           known decimal formats</xtermref> is the set of decimal formats defined by
                           <elcode>xsl:decimal-format</elcode> declarations in the stylesheet. </p>
                     <note diff="del" at="2022-01-01">
                        <p>XSLT 3.0 provides support for the <code>exponent-separator</code>
                           property which is added to the static context in XPath 3.1; when XSLT 3.0
                           is used with XPath 3.0, this property is ignored.</p>
                     </note>
                  </item>
               </ulist>

            </div3>
            <div3 id="resolving-function-names" diff="add" at="2022-01-01">
               <head>Resolving Function Names</head>
               <p diff="chg" at="2022-11-25">This section defines how function names appearing in XPath expressions and patterns
               are resolved. It refines the rules given in the XPath 4.0 specification, which rely
                  simply on looking up a function name and arity in the <xtermref ref="dt-static-context" spec="XP40"/>.
               The refinements are necessary to handle function overriding.</p>
               <p>The rules depend on whether or not the stylesheet module contains an
               <elcode>xsl:function-library</elcode> declaration: the following two sections describe
               these two cases.</p>
               <p>The name <code>xsl:original</code> is treated specially, as described in 
               <specref ref="refer-to-overridden"/>.</p>
               
               <div4 id="resolving-function-names-without-function-library">
                  <head>When no <elcode>xsl:function-library</elcode> is Declared</head>
                  <p>In the absence of an <elcode>xsl:function-library</elcode> declaration in the
                  containing module:</p>
                  <olist>
                     <item><p>A lexical QName with no prefix is treated as the local name of a function
                     in the namespace <code>http://www.w3.org/2005/xpath-functions</code>.</p></item>
                     <item><p>A lexical QName with a prefix is resolved by reference to the in-scope
                        namespaces of the <term>containing element</term>.</p></item>
                  </olist>
               </div4>
               
               <div4 id="resolving-function-names-with-function-library">
                  <head>When an <elcode>xsl:function-library</elcode> is Declared</head>
                  <p>A stylesheet module may contain at most one <elcode>xsl:function-library</elcode>
                     declaration. The <elcode>xsl:function-library</elcode> declaration affects the
                  resolution of all function names used in expressions and patterns within that stylesheet
                  module; it has no effect outside the containing module.</p>
                  <?element xsl:function-library?>
                  <?element xsl:function-namespace?>
                  
                  <p>Within the <elcode>xsl:function-library</elcode> declaration, each <elcode>xsl:function-namespace</elcode>
                  element defines a namespace that (typically) contains a number of functions, whose names are in that namespace.</p>
                  
                  <p>It is a static error [TBA] if there is more than one <elcode>xsl:function-library</elcode> declaration
                  within a <termref def="dt-stylesheet-module"/>.</p>
                  
                  <p>It is a static error [TBA] if two <elcode>xsl:function-namespace</elcode> elements within
                     an <elcode>xsl:function-library</elcode> declaration have the same value for the <code>uri</code> attribute.</p>
                  
                  <p>It is a static error [TBA] if two <elcode>xsl:function-namespace</elcode> elements within
                     an <elcode>xsl:function-library</elcode> declaration have the same value for the <code>prefix</code> attribute.</p>
                  
                  
                  <p>An unprefixed function name (together with the required arity) is resolved as follows:</p>
                  <olist>
                     <item><p>If exactly one of the <elcode>xsl:function-namespace</elcode> elements contains a function
                     name with the required local name and arity, and does not exclude that local name by listing it
                     in the <code>exclude</code> attribute, then that function is chosen.</p></item>
                     <item><p>Otherwise (if none of the <elcode>xsl:function-namespace</elcode> elements identifies
                     such a function, or if more than one does so), the name is unresolved and a static error is reported.</p></item>
                  </olist>
                  <p>A prefixed function name (together with the required arity) is resolved as follows:</p>
                  <olist>
                     <item><p>If the namespace prefix used in the lexical QName matches the value of the <code>prefix</code>
                        attribute of one of the <elcode>xsl:function-namespace</elcode> elements, then the local name
                        is expanded using that namespace URI.</p></item>
                     <item><p>Otherwise (if there is no matching <elcode>xsl:function-namespace</elcode> element), the name is 
                        resolved as if the <elcode>xsl:function-library</elcode> element were not present: see
                        <specref ref="resolving-function-names-without-function-library"/>.</p></item>
                  </olist>
                  <p>A function name used in the <code>name</code> attribute of an <elcode>xsl:function</elcode> declaration
                  must be prefixed, and is expanded using the rules above.</p>
                  <example>
                     <head>Example <code>xsl:function-library</code></head>
                     <p>The following example shows a function library that makes all the standard function namespaces
                     available:</p>
                     <eg><![CDATA[<xsl:function-library>
     <xsl:function-namespace prefix="fn" 
                             uri="http://www.w3.org/2005/xpath-functions"/> 
     <xsl:function-namespace prefix="math" 
                             uri="http://www.w3.org/2005/xpath-functions/math"/> 
     <xsl:function-namespace prefix="map" 
                             uri="http://www.w3.org/2005/xpath-functions/map"/>
     <xsl:function-namespace prefix="array" 
                             uri="http://www.w3.org/2005/xpath-functions/array"/>
     <xsl:function-namespace prefix="xs" 
                             uri="http://www.w3.org/2001/XMLSchema"/>
 </xsl:function-library>    
                        ]]></eg>
                     <p>Within a stylesheet module containing this declaration, functions from all these namespaces
                        can be referred to be local name alone, provided the local name and arity (in combination)
                        are unique. So it is possible to use <code>name()</code>
                     to refer to a function in the <code>fn</code> namespace, <code>sqrt($x)</code> to refer to a function
                     in the <code>math</code> namespace, and <code>integer($x)</code> to refer to a function in the
                     <code>xs</code> namespace. However, the function call <code>boolean($x)</code> would be an error,
                     because the reference is ambiguous: it could mean <code>fn:boolean($x)</code> or <code>xs:boolean($x)</code>.
                     To disambiguate the call, it is necessary to use the namespace prefix.</p>
                     
                     <p>It is not necessary, however, for the stylesheet to contain an XML namespace declaration that binds the
                     prefix; the binding in the <elcode>xsl:function-namespace</elcode> element suffices.</p>
                     
                     <p>An <elcode>xsl:function-library</elcode> element may include user-defined or vendor-defined function
                     namespaces as well as system-defined namespaces.</p>
                  </example>
                  <example>
                     <head>Excluding Selected Names</head>
                     <p>The following example modifies the above function library to exclude some functions 
                        that otherwise cause conflicts:</p>
                     <eg><![CDATA[<xsl:function-library>
     <xsl:function-namespace prefix="fn" 
                             uri="http://www.w3.org/2005/xpath-functions"/> 
     <xsl:function-namespace prefix="math" 
                             uri="http://www.w3.org/2005/xpath-functions/math"/> 
     <xsl:function-namespace prefix="map" 
                             uri="http://www.w3.org/2005/xpath-functions/map"
                             exclude="remove"/>
     <xsl:function-namespace prefix="array" 
                             uri="http://www.w3.org/2005/xpath-functions/array"
                             exclude="get put"/>
     <xsl:function-namespace prefix="xs" 
                             uri="http://www.w3.org/2001/XMLSchema"
                             exclude="boolean"/>
</xsl:function-library>    
                        ]]></eg>
                     <p>With the above declaration, it becomes possible to use the function call <code>remove($x, $n)</code>
                     to refer unambiguously to the <code>fn:remove</code> function, because the entry for the <code>map</code>
                     namespace explicitly excludes <code>map:remove</code>, which would otherwise cause an ambiguity.
                     Similarly, <code>boolean($x)</code> unambiguously refers to <code>fn:boolean</code>, and
                     <code>get($m, $k)</code> unambiguously refers to <code>map:get</code>.</p>
                     
                     <p>It would also be possible to write a stylesheet function <code>my:get</code> which calls
                     <code>map:get</code> or <code>array:get</code> as appropriate:</p>
                     <eg><![CDATA[<xsl:function name="my:get">
  <xsl:param name="target"/>
  <xsl:param name="key"/>
  <xsl:if test="$target instance of map(*)" 
          then="map:get($target, $key)"
          else="array:get($target, $key)"/>
</xsl:function>]]></eg>
                     <p>If the function library includes the <code>my</code> namespace, and if <code>map:get</code>
                        and <code>array:get</code> are excluded, then an unprefixed call on <code>get()</code> becomes possible.
                     A smart optimizer might even be able to decide at compile time which underlying function to call, if the type
                     of the first argument is known.</p>
                  </example>
                  <note>
                     <p>This construct has several motivating purposes:</p>
                     <ulist>
                        <item><p>Firstly, it improves code readability by reducing the need to qualify function names
                        with a namespace prefix when the local name is unambiguous. The expression <code>sin($x)+cos($y)</code>
                        is easier to read than <code>math:sin($x)+math:cos($y)</code>.</p></item>
                        <item><p>Secondly, it reduces the need to declare namespaces (using <code>xmlns:prefix="uri"</code>
                        declarations) that are needed only for the purpose of qualifying function names. This is useful
                        because a proliferation of such namespace declarations carries unwanted overheads. Even if the namespaces
                        are designated as <term>excluded namespaces</term> (see <specref ref="lre-namespaces"/>) they
                        still become part of the <xtermref spec="XP40" ref="dt-in-scope-namespaces"/> in the static context of every
                        XPath expression, which need to be carried around at run-time in a compiled stylesheet because they 
                        can be referenced at execution time (for example in a call of <xfunction>function-available</xfunction>)</p>
                        <p>Namespace bindings established using an <elcode>xsl:function-library</elcode> declaration impose less overhead
                        because they are used only when binding function names, and they are never needed at evaluation time.</p></item>
                        <item><p>Finally, stylesheet authors may consider that documenting the dependencies
                        of a stylesheet module makes the code more maintainable.</p></item>
                     </ulist>
                  </note>
                  <note>
                     <p>The rules take into account that new functions may be added to a namespace over time.
                     Adding a new function to one of the namespaces may introduce a conflict, but this conflict will always
                     result in a static error, it will never result in the wrong function being called. The conflict can
                     always be resolved by excluding the function that caused the conflict, thus limiting the scope of the changes needed
                     to handle this eventuality.</p>
                  </note>
                  <note>
                     <p>It is probably good practice for the <elcode>xsl:function-library</elcode> declaration to appear
                     near the start of a module, along with any <elcode>xsl:include</elcode> and <elcode>xsl:import</elcode>
                     declarations, but this is not a formal requirement. The declaration can appear anywhere in the module.</p>
                     
                     <p>Consider using XInclude, or DTD-defined entities, if you want to share an <elcode>xsl:function-library</elcode>
                     declaration between multiple modules.</p>
                  </note>
               </div4>
               
            </div3>
            
            <div3 id="additional-static-context">
               <head>Additional Static Context Components used by XSLT</head>
               <p>Some of the components of the XPath static context are used also by <termref def="dt-xslt-element">XSLT elements</termref>. For example, the
                     <elcode>xsl:sort</elcode> element makes use of the collations defined in the
                  static context, and attributes such as <code>type</code> and <code>as</code> may
                  reference types defined in the <termref def="dt-in-scope-schema-component">in-scope schema components</termref>.</p>
               <p>Many top-level declarations in a stylesheet, and attributes on the
                     <elcode>xsl:stylesheet</elcode> element, affect the behavior of instructions
                  within the stylesheet. Each of these constructs is described in its appropriate
                  place in this specification.</p>
               <p>A number of these constructs are of particular significance because they are used
                  by functions defined in XSLT, which are added to the library of functions
                  available for use in XPath expressions within the stylesheet. These are:</p>
               <ulist>
                  <item>
                     <p>The set of named keys, used by the <function>key</function> function</p>
                  </item>
                  
                  <item>
                     <p>The values of system properties, used by the
                           <function>system-property</function> function</p>
                  </item>
                  <item>
                     <p>The set of available instructions, used by the
                           <function>element-available</function> function</p>
                  </item>
               </ulist>
               <p>A dynamic function call clears the first of these
                  components: this means that a dynamic call to the <function>key</function>
                  function will always raise a dynamic error (the key name is unknown). The values
                  of system properties and the set of available instructions, by contrast, reflect
                  the capabilities and configuration of the processor rather than values specific to
                  the stylesheet code itself; the result of a dynamic call to
                     <function>system-property</function> or <function>element-available</function>
                  will reflect the information available to the processor at evaluation time.</p>
               <note>
                  <p>If these functions are called within a <termref def="dt-static-expression"/>, the results will reflect the capabilities and
                     configuration of the processor used to perform static analysis, while if they
                     are called elsewhere, the results should reflect the capabilities and
                     configuration of the processor used to perform dynamic evaluation, which might
                     give a different result. These calls should not be pre-evaluated at compile
                     time unless it is known that this will give the same result.</p>
               </note>
            </div3>
            <div3 id="xpath-dynamic-context">
               <head>Initializing the Dynamic Context</head>
               <p>For convenience, the dynamic context is described in two parts: the <termref def="dt-focus">focus</termref>, which represents the place in the source
                  document that is currently being processed, and a collection of additional context
                  variables.</p>
               <p>A number of functions specified in <bibref ref="xpath-functions-40"/> are defined
                  to be <xtermref spec="FO40" ref="dt-deterministic">deterministic</xtermref>,
                  meaning that if they are called twice during the same <xtermref spec="FO40" ref="execution-scope">execution scope</xtermref>, with the same arguments, then
                  they return the same results (see <xspecref spec="FO40" ref="terminology"/>). In
                  XSLT, the execution of a stylesheet defines the execution scope. This means, for
                  example, that if the function <xfunction>current-dateTime</xfunction> is called
                  repeatedly during a transformation, it produces the same result each time. By
                  implication, the components of the dynamic context on which these functions depend
                  are also stable for the duration of the transformation. Specifically, the
                  following components defined in <xspecref spec="XP40" ref="eval_context"/> must be
                  stable: <emph>function implementations</emph>, <emph>current dateTime</emph>,
                     <emph>implicit timezone</emph>, <emph>available documents</emph>,
                     <emph>available collections</emph>, and <emph>default collection</emph>. The
                  values of global variables and stylesheet parameters are also stable for the
                  duration of a transformation. The focus is <emph>not</emph> stable; the additional
                  dynamic context components defined in <specref ref="additional-dynamic-context"/>
                  are also <emph>not</emph> stable.</p>
               <p>As specified in <bibref ref="xpath-functions-40"/>, implementations may provide
                  user options that relax the requirement for the <xfunction>doc</xfunction> and
                     <xfunction>collection</xfunction> functions (and therefore, by implication, the
                     <function>document</function> function) to return stable results. By default,
                  however, the functions must be stable. The manner in which such user options are
                  provided, if at all, is <termref def="dt-implementation-defined">implementation-defined</termref>.</p>
               <imp-def-feature id="idf-api-stability">Implementations may provide user options that
                  relax the requirement for the <xfunction>doc</xfunction> and
                     <xfunction>collection</xfunction> functions (and therefore, by implication, the
                     <function>document</function> function) to return stable results. The manner in
                  which such user options are provided, if at all, is <termref def="dt-implementation-defined"/>. </imp-def-feature>
               <p>XPath expressions contained in <code>[xsl:]use-when</code> attributes are not
                  considered to be evaluated “during the transformation” as defined above. For
                  details see <specref ref="conditional-inclusion"/>.</p>

               <p><termdef id="dt-absent" term="absent">A component of the context
                     that has no value is said to be <term>absent</term>.</termdef> This is a
                  distinguishable state, and is not the same as having the empty sequence as its
                  value.</p>

               <div4 id="focus">
                  <head>Maintaining Position: the Focus</head>
                  <p>
                     <termdef id="dt-focus" term="focus">When a <termref def="dt-sequence-constructor">sequence constructor</termref> is
                        evaluated, the <termref def="dt-processor">processor</termref> keeps track
                        of which items are being processed by means of a set of implicit variables
                        referred to collectively as the <term>focus</term>.</termdef> More
                     specifically, the focus consists of the following three values:</p>
                  <ulist>
                     <item>
                        <p><termdef id="dt-context-item" term="context item">The <term>context
                                 item</term> is the item currently being processed. An item (see
                                 <bibref ref="xpath-datamodel-30"/>) is either an atomic value (such
                              as an integer, date, or string), a node, or
                                 a function item. It changes whenever instructions such as
                                 <elcode>xsl:apply-templates</elcode> and
                                 <elcode>xsl:for-each</elcode> are used to process a sequence of
                              items; each item in such a sequence becomes the context item while
                              that item is being processed.</termdef> The context item is returned
                           by the XPath <termref def="dt-expression">expression</termref>
                           <code>.</code> (dot).</p>
                     </item>
                     <item>
                        <p><termdef id="dt-context-position" term="context position">The
                                 <term>context position</term> is the position of the context item
                              within the sequence of items currently being processed. It changes
                              whenever the context item changes. When an instruction such as
                                 <elcode>xsl:apply-templates</elcode> or
                                 <elcode>xsl:for-each</elcode> is used to process a sequence of
                              items, the first item in the sequence is processed with a context
                              position of 1, the second item with a context position of 2, and so
                              on.</termdef> The context position is returned by the XPath <termref def="dt-expression">expression</termref>
                           <code>position()</code>.</p>
                     </item>
                     <item>
                        <p><termdef id="dt-context-size" term="context size">The <term>context
                                 size</term> is the number of items in the sequence of items
                              currently being processed. It changes whenever instructions such as
                                 <elcode>xsl:apply-templates</elcode> and
                                 <elcode>xsl:for-each</elcode> are used to process a sequence of
                              items; during the processing of each one of those items, the context
                              size is set to the count of the number of items in the sequence (or
                              equivalently, the position of the last item in the
                              sequence).</termdef> The context size is returned by the XPath
                              <termref def="dt-expression">expression</termref>
                           <code>last()</code>.</p>
                     </item>
                  </ulist>
                  <p>
                     <termdef id="dt-context-node" term="context node">If the <termref def="dt-context-item">context item</termref> is a node (as distinct from
                        an atomic value such as an integer), then it is also referred to as the
                           <term>context node</term>. The context node is not an independent
                        variable, it changes whenever the context item changes. When the context
                        item is an atomic value or a function
                           item, there is no context node.</termdef> The context node is
                     returned by the XPath <termref def="dt-expression">expression</termref>
                     <code>self::node()</code>, and it is used as the starting node for all relative
                     path expressions.</p>
                  <p>Where the containing element of an XPath expression is an <termref def="dt-instruction">instruction</termref> or a <termref def="dt-literal-result-element">literal result element</termref>, the
                     initial context item, context position, and context size for the XPath <termref def="dt-expression">expression</termref> are the same as the <termref def="dt-context-item">context item</termref>, <termref def="dt-context-position">context position</termref>, and <termref def="dt-context-size">context size</termref> for the evaluation of the
                     containing instruction or literal result element.</p>
                  <p>The context item for evaluating global
                        variables <phrase diff="add" at="2022-01-01">declared</phrase>
                     in the <termref def="dt-top-level-package"/> is set to the <termref def="dt-global-context-item"/>
                        supplied when the transformation is invoked (see <specref ref="initiating"/>).
                     <phrase diff="add" at="2022-01-01">For global variables declared in a </phrase> <termref def="dt-library-package">library
                           package</termref>, the context item <phrase diff="del" at="2022-01-01">for evaluating global variables</phrase> is
                     <termref def="dt-absent"/>. <phrase diff="add" at="2022-01-01">[XSLT 3.0 Erratum E7, bug 30179].</phrase></p>
                  <p>For an XPath expression contained in a <termref def="dt-value-template"/>, the initial context item, context position, and
                     context size for the XPath <termref def="dt-expression">expression</termref>
                     are the same as the <termref def="dt-context-item">context item</termref>,
                        <termref def="dt-context-position">context position</termref>, and <termref def="dt-context-size">context size</termref> for the evaluation of the
                     containing <termref def="dt-sequence-constructor"/>.</p>
                  <p>In other cases (for example, where the containing element is
                        <elcode>xsl:sort</elcode>, <elcode>xsl:with-param</elcode>, or
                        <elcode>xsl:key</elcode>), the rules are given in the specification of the
                     containing element.</p>
                  <p>The <function>current</function> function can be used within any XPath <termref def="dt-expression">expression</termref> to select the item that was
                     supplied as the context item to the XPath expression by the XSLT processor.
                     Unlike <code>.</code> (dot) this is unaffected by changes to the context item
                     that occur within the XPath expression. The <function>current</function>
                     function is described in <specref ref="func-current"/>.</p>
                  <p>On completion of an instruction that changes the <termref def="dt-focus">focus</termref> (such as <elcode>xsl:apply-templates</elcode> or
                        <elcode>xsl:for-each</elcode>), the focus reverts to its previous value.</p>
                  <p>When a <termref def="dt-stylesheet-function">stylesheet function</termref> is
                     called, the focus within the body of the function is initially <termref def="dt-absent">absent</termref>.</p>
                  <p>When the focus is <termref def="dt-absent">absent</termref>, evaluation of any
                        <termref def="dt-expression">expression</termref> that references the
                     context item, context position, or context size results in a <termref def="dt-dynamic-error">
                        dynamic error</termref>
                     <xerrorref spec="XP40" class="DY" code="0002"/></p>
                  <p>The description above gives an outline of the way the <termref def="dt-focus">focus</termref> works. Detailed rules for the effect of each instruction
                     are given separately with the description of that instruction. In the absence
                     of specific rules, an instruction uses the same focus as its parent
                     instruction. </p>
                  <p>
                     <termdef id="dt-singleton-focus" term="singleton focus">A <term>singleton
                           focus</term> based on an item <var>J</var> has the <termref def="dt-context-item">context item</termref> (and
                           therefore the <termref def="dt-context-node">context node</termref>, if
                              <var>J</var> is a node) set to <var>J</var>, and the <termref def="dt-context-position">context position</termref> and <termref def="dt-context-size">context size</termref> both set to 1
                        (one).</termdef>
                  </p>
               </div4>

               <div4 id="evaluation-context">
                  <head>Other Components of the XPath Dynamic Context</head>
                  <p>The previous section explained how the <termref def="dt-focus">focus</termref>
                     for an XPath expression appearing in an XSLT stylesheet is initialized. This
                     section explains how the other components of the <xtermref spec="XP40" ref="dt-dynamic-context">dynamic context</xtermref> of an XPath expression
                     are initialized.</p>
                  <ulist>
                     <item>
                        <p>The <xtermref spec="XP40" ref="dt-variable-values">dynamic
                              variables</xtermref> are the current values of the in-scope <termref def="dt-variable-binding-element">variable binding
                           elements</termref>.</p>
                     </item>
                     <item>
                        <p diff="chg" at="2022-11-25">The <xtermref spec="XP40" ref="dt-dynamically-known-function-definitions">dynamically known function definitions</xtermref>
                        (representing the functions accessible using <function>function-available</function> or <xfunction>function-lookup</xfunction>)
                           include all the functions available in the static context, and may also include an additional 
                           <termref def="dt-implementation-defined"/> set of functions that are available dynamically but not statically.
                        </p>
                        <note><p>This set therefore includes some functions that are not available for
                        dynamic calling using <elcode>xsl:evaluate</elcode>, for example <termref def="dt-stylesheet-function">stylesheet functions</termref>
                        whose visibility is private, and XSLT-defined functions such as <function>current</function> and <function>key</function>.</p></note>
                        <note><p>The rule that all functions present in the static context must always be present in 
                           the dynamic context is a consistency constraint. The effect of violating a consistency constraint is 
                           <termref def="dt-implementation-defined"/>: it does not necessarily lead to an error. 
                           For example, if the version of a used package that is available
                           at evaluation time does not include all public user-defined functions that were available in the version that was
                           used at analysis time, then a processor <rfc2119>may</rfc2119> recover by signaling an error only if the function
                           is actually called. Conversely, if the evaluation-time version of the package includes additional public functions, these <rfc2119>may</rfc2119>
                        be included in the dynamic context even though they were absent from the static context. 
                        Dynamic calling of functions using <xfunction>function-lookup</xfunction>
                        may therefore be an effective strategy for coping with variations between versions of a library package on which a stylesheet
                        depends.</p></note>
                     </item>
                     
                     <item>
                        <p>The <xtermref spec="XP40" ref="dt-def-collation">default
                           collation</xtermref> is defined by the value of the
                           <code>[xsl:]default-collation</code> attribute on the innermost enclosing
                           element that has such an attribute. For details, see <specref ref="default-collation-attribute"/>.</p>
                        <p>
                           <termdef id="dt-default-collation" term="default collation">In this
                              specification the term <term>default collation</term> means the collation
                              that is used by XPath operators such as <code>eq</code> and
                              <code>lt</code> appearing in XPath expressions within the
                              stylesheet.</termdef>
                        </p>
                        <p>This collation is also used by default when comparing strings in the
                           evaluation of the <elcode>xsl:key</elcode> and
                           <elcode>xsl:for-each-group</elcode> elements. This <rfc2119>may</rfc2119>
                           also (but need not necessarily) be the same as the default collation used
                           for <elcode>xsl:sort</elcode> elements within the stylesheet. Collations
                           used by <elcode>xsl:sort</elcode> are described in <specref ref="collating-sequences"/>.</p>
                        
                        <note diff="add" at="2023-05-19"><p>The default collation is usually known
                        statically. One notable exception is when the function call <code>default-collation()</code>
                        appears in the the initializing expression of an optional <elcode>xsl:function</elcode> parameter,
                           for example:</p>
                           <eg><![CDATA[<xsl:function name="f:myfunc">
  <xsl:param name="collation" required="no" select="default-collation()"/>
</xsl:function>]]></eg>
                           <p>In this situation the call on <code>default-collation()</code> returns the default
                              collation from the context of the function call, which may differ from the default
                              collation of the function declaration.
                        </p></note>
                     </item>
                     
                     <item>
                        <p>The <xtermref spec="XP40" ref="dt-known-docs">available
                              documents</xtermref> are defined as part of the XPath 3.0 dynamic context to support the
                              <xfunction>doc</xfunction> function, but this component is also
                           referenced by the similar XSLT <function>document</function> function:
                           see <specref ref="func-document"/>. This variable defines a mapping
                           between URIs passed to the <xfunction>doc</xfunction> or
                              <function>document</function> function and the document nodes that are
                           returned.</p>
                        <p>The mapping from URIs to document nodes is
                           affected by <elcode>xsl:strip-space</elcode> declarations and by the
                              <code>input-type-annotations</code> attribute, and may therefore vary
                           from one package to another.</p>
                        <note>
                           <p>Defining this as part of the evaluation context is a formal way of
                              specifying that the way in which URIs get turned into document nodes
                              is outside the control of the language specification, and depends
                              entirely on the run-time environment in which the transformation takes
                              place.</p>
                        </note>
                        <p>The XSLT-defined <function>document</function> function allows the use of
                           URI references containing fragment identifiers. The interpretation of a
                           fragment identifier depends on the media type of the resource
                           representation. Therefore, the information supplied in <xtermref spec="XP40" ref="dt-known-docs">available documents</xtermref> for
                           XSLT processing must provide not only a mapping from URIs to document
                           nodes as required by XPath, but also a mapping from URIs to media
                           types.</p>
                     </item>                    
                     <item>
                        <p>All other aspects of the dynamic context (for example,
                           the current date and time, the implicit timezone, the default language, calendar, and place,
                           the available documents, text resources, and collections, and the default collection<phrase diff="del" at="2022-01-01"> — details
                           vary slightly between XPath 3.0 and XPath 3.1</phrase>) are <termref def="dt-implementation-defined"/>,
                        and do not change in the course of a single transformation, except to the extent that they
                        <rfc2119>may</rfc2119> be different from one <termref def="dt-package"/> to another.</p>
                     </item>
                  </ulist>
               </div4>
            </div3>
            <div3 id="additional-dynamic-context">
               <head>Additional Dynamic Context Components used by XSLT</head>
               <p>In addition to the values that make up the <termref def="dt-focus">focus</termref>, an XSLT processor maintains a number of other dynamic context
                  components that reflect aspects of the evaluation context. These components are
                  fully described in the sections of the specification that maintain and use them.
                  They are:</p>
               <ulist>
                  <item>
                     <p>The <termref def="dt-current-template-rule">current template rule</termref>,
                        which is the <termref def="dt-template-rule">template rule</termref> most
                        recently invoked by an <elcode>xsl:apply-templates</elcode>,
                           <elcode>xsl:apply-imports</elcode>, or <elcode>xsl:next-match</elcode>
                        instruction: see <specref ref="apply-imports"/>; </p>
                  </item>
                  <item>
                     <p>The <termref def="dt-current-mode">current mode</termref>, which is the
                           <termref def="dt-mode">mode</termref> set by the most recent call of
                           <elcode>xsl:apply-templates</elcode> (for a full definition see <specref ref="modes"/>);</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-current-group">current group</termref> and <termref def="dt-current-grouping-key">current grouping key</termref>, which
                        provide information about the collection of items currently being processed
                        by an <elcode>xsl:for-each-group</elcode>
                        
                        instruction: see <specref ref="func-current-group"/> and <specref ref="func-current-grouping-key"/>;</p>
                     <note>
                        <p>In XSLT 3.0 the initial value of these two properties is “absent”, which
                           means that any reference to their values causes a dynamic error.
                           Previously, the initial value was an empty sequence. </p>
                     </note>
                  </item>
                  <item>
                     <p>The <termref def="dt-current-merge-group"/> and <termref def="dt-current-merge-key"/>, which provide information about the
                        collection of items currently being processed by an
                           <elcode>xsl:merge</elcode> instruction.</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-current-captured-substrings">current captured
                           substrings</termref>: this is a sequence of strings, which is maintained
                        when a string is matched against a regular expression using the
                           <elcode>xsl:analyze-string</elcode> instruction, and which is accessible
                        using the <function>regex-group</function> function: see <specref ref="func-regex-group"/>.</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-output-state">output state</termref>: this is a flag
                        whose two possible values are <termref def="dt-final-output-state">final
                           output state</termref> and <termref def="dt-temporary-output-state">temporary output state</termref>.  The initial setting when the stylesheet is invoked by executing a
                           template is <termref def="dt-final-output-state">final output
                           state</termref>, and it is switched to <termref def="dt-temporary-output-state">temporary output state</termref> by
                        instructions such as <elcode>xsl:variable</elcode>. For more details, see
                           <specref ref="result-document-restrictions"/>.</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-current-output-uri">current output URI</termref>: this
                        is the URI associated with the result tree to which instructions are
                        currently writing. The current output URI is initially the same as the
                           <termref def="dt-base-output-uri"/>. During the evaluation of an
                           <elcode>xsl:result-document</elcode> instruction, the current output URI
                        is set to the absolute URI identified by the <code>href</code> attribute of
                        that instruction.</p>
                  </item>

               </ulist>
               <p>The following non-normative table summarizes the initial state of each of the
                  components in the evaluation context, and the instructions which cause the state
                  of the component to change.</p>



               <table class="data">
                  <caption>Components of the Dynamic Evaluation Context</caption>
                  <thead>
                     <tr>
                        <th align="left" rowspan="1" colspan="1">Component</th>
                        <th align="left" rowspan="1" colspan="1">Initial Setting</th>
                        <th align="left" rowspan="1" colspan="1">Set by</th>
                        <th align="left" rowspan="1" colspan="1">Cleared by</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-focus">focus</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">See <specref ref="initiating"/>.</td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:apply-templates</elcode>, <elcode>xsl:for-each</elcode>,
                              <elcode>xsl:for-each-group</elcode>,
                              <elcode>xsl:analyze-string</elcode>, evaluation of <termref def="dt-pattern">patterns</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">Calls to <termref def="dt-stylesheet-function">stylesheet
                              functions</termref>
                        </td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-template-rule">current template rule</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">If apply-templates invocation is used
                           (see <specref ref="invoking-initial-mode"/>), then for each item in the 
                           <termref def="dt-initial-match-selection"/>, the <termref def="dt-current-template-rule"/>
                           is initially set to the template rule chosen for processing that item. Otherwise,
                           <termref def="dt-absent"/>.
                        </td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>,
                              <elcode>xsl:next-match</elcode>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">See <specref ref="apply-imports"/>.
                           <!--<elcode>xsl:for-each</elcode>, <elcode>xsl:for-each-group</elcode>,
                              <elcode>xsl:analyze-string</elcode>, 
                           <elcode>xsl:iterate</elcode>, <elcode>xsl:source-document</elcode>,
                                 <elcode>xsl:merge</elcode>, <elcode>xsl:evaluate</elcode>;
                           <phrase diff="chg" at="T-bug29716"><elcode>xsl:copy</elcode> if there
                           is a <code>select</code> attribute</phrase>; <elcode>xsl:call-template</elcode>
                           if the relevant named template has <code>xsl:context-item use="absent"</code>;
                            <phrase diff="chg" at="Q-bug23631">calls to <termref
                                 def="dt-stylesheet-function">stylesheet functions</termref>; and
                              dynamic function calls</phrase>. Also cleared while evaluating global
                           variables or default values of stylesheet parameters, <phrase diff="add"
                              at="M"><termref def="dt-pattern">patterns</termref></phrase>, and the
                           sequence constructors contained in <elcode>xsl:key</elcode> and
                              <elcode>xsl:sort</elcode>.--></td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-mode">current mode</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">the initial <termref def="dt-mode">mode</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:apply-templates</elcode>
                        </td>
                        <!--Text replaced by erratum E19 change 1"-->
                        <td valign="top" rowspan="1" colspan="1">Calls to <termref def="dt-stylesheet-function">stylesheet
                              functions</termref>. Also cleared while evaluating global
                           variables and stylesheet parameters, <termref def="dt-pattern">patterns</termref>, and the sequence
                           constructor contained in <elcode>xsl:key</elcode> or
                              <elcode>xsl:sort</elcode>. Clearing the current mode causes the
                           current mode to be set to the default (unnamed) mode.</td>
                        <!--End of text replaced by erratum E19-->
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-group">current group</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">absent</td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:for-each-group</elcode>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">See <specref ref="func-current-group"/>.</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-grouping-key">current grouping key</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">absent</td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:for-each-group</elcode>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">See <specref ref="func-current-grouping-key"/>.</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-merge-group">current merge group</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">absent</td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:merge</elcode>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">See <specref ref="func-current-merge-group"/>.</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-merge-key">current merge key</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1"><phrase>absent</phrase></td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:merge</elcode>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">See <specref ref="func-current-merge-key"/>.</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-captured-substrings">current captured
                              substrings</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">empty sequence</td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:matching-substring</elcode>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:non-matching-substring</elcode>; Calls to <termref def="dt-stylesheet-function">stylesheet functions</termref>, dynamic function calls,
                              evaluation of global variables, stylesheet
                              parameters, and <termref def="dt-pattern">patterns</termref>
                        </td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-output-state">output state</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-final-output-state">final output state</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">Set to <termref def="dt-temporary-output-state">temporary
                              output state</termref> by instructions such as
                              <elcode>xsl:variable</elcode>, <elcode>xsl:attribute</elcode>, etc.,
                           and by calls on <termref def="dt-stylesheet-function">stylesheet
                              functions</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">None</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-output-uri">current output URI</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-base-output-uri">base output URI</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1"><elcode>xsl:result-document</elcode></td>
                        <td valign="top" rowspan="1" colspan="1">Calls to <termref def="dt-stylesheet-function">stylesheet
                              functions</termref>, dynamic function calls, evaluation of <termref def="dt-global-variable">global variables</termref>, <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>, and
                              <termref def="dt-pattern">patterns</termref>.</td>

                     </tr>

                  </tbody>
               </table>
               <p><termdef id="dt-initial-setting" term="initial setting">The <term>initial setting</term> of a component of the dynamic context is used
                     when evaluating <termref def="dt-global-variable">global variables</termref>
                     and <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>,
                     when evaluating the <code>use</code> and <code>match</code> attributes of
                        <elcode>xsl:key</elcode>, and when evaluating the <code>initial-value</code> of
                        <elcode>xsl:accumulator</elcode> and the <code>select</code> expressions or
                     contained sequence constructors of
                     <elcode>xsl:accumulator-rule</elcode></termdef>.</p>
               <p><termdef id="dt-non-contextual-function-call" term="non-contextual function call">The term <term>non-contextual function
                        call</term> is used to refer to function calls that do not pass the dynamic
                     context to the called function. This includes all calls on <termref def="dt-stylesheet-function">stylesheet functions</termref> and all
                        <xtermref spec="XP40" ref="dt-dynamic-function-invocation">dynamic function
                        invocations</xtermref>, (that is calls to function items as permitted by
                     XPath 3.0). It excludes calls to some
                        functions in the namespace
                           <code>http://www.w3.org/2005/xpath-functions</code>, in
                     particular those that explicitly depend on the context, such as the
                        <function>current-group</function> and <function>regex-group</function>
                     functions. It is <termref def="dt-implementation-defined">implementation-defined</termref> whether, and under what circumstances,
                     calls to <termref def="dt-extension-function">extension functions</termref> are
                     non-contextual.</termdef></p>
               <imp-def-feature id="id-ext-accesstoconttext">The availability of dynamic context
                  information within <termref def="dt-extension-function">extension
                     functions</termref> is <termref def="dt-implementation-defined">implementation-defined</termref>.</imp-def-feature>

               <p>Named function references (such as <code>position#0</code>) and
                  calls on <xfunction>function-lookup</xfunction> (for example,
                     <code>function-lookup("position", 0)</code>) are defined to retain the XPath
                  static and dynamic context at the point of invocation as part of the closure of
                  the resulting function item, and to use this preserved context when a dynamic
                  function call is subsequently made using the function item. This rule does not
                  extend to the XSLT extensions to the dynamic context defined in this section. If a
                  dynamic function call is made that depends on the XSLT part of the dynamic context
                  (for example, <code>regex-group#1(2)</code>), then the relevant components of the
                  context are cleared as described in the table above. </p>
               
            </div3>
         </div2>

         

         <div2 id="patterns">
            <head>Patterns</head>

            <p>In XSLT 4.0, patterns can match any kind of item: atomic values and
               function items as well as nodes.</p>

            <p>A <termref def="dt-template-rule">template rule</termref> identifies the items to which it applies by means of a pattern. As
               well as being used in template rules, patterns are used for numbering (see <specref ref="number"/>), for grouping (see <specref ref="grouping"/>), and for declaring
                  <termref def="dt-key">keys</termref> (see <specref ref="key"/>).</p>
            <p><termdef id="dt-pattern" term="pattern">A <term>pattern</term> specifies a set of
                  conditions on an item. An item that satisfies the conditions matches the pattern; an
                     item that does not satisfy the conditions
                  does not match the pattern.</termdef></p>

            <p diff="chg" at="2022-01-01">There are three kinds of pattern: <termref def="dt-predicate-pattern">predicate patterns</termref>, 
               <termref def="dt-type-pattern">type patterns</termref>,
               and <termref def="dt-node-pattern">node patterns</termref>:</p>

            <ulist diff="chg" at="2022-01-01">
               <item>
                  <p><termdef id="dt-predicate-pattern" term="predicate pattern">A <term>predicate pattern</term> is written as
                           <code>.</code> (dot) followed by zero or more predicates in square
                        brackets, and it matches any item for which each of the predicates evaluates
                        to <code>true</code>.</termdef></p>
                  <p>A predicate pattern <code>.[P1][P2]...</code> can be regarded as an abbreviation
                     for the type pattern <code>type(item())[P1][P2]...</code>.</p>
               </item>
               <item>
                  <p><termdef id="dt-type-pattern" term="type pattern">A <term>type pattern</term> can be written as
                     <code>type(T)</code> (where <var>T</var> is an <xnt spec="XP40" ref="prod-xpath40-ItemType">ItemType</xnt>
                     followed by zero or more predicates in square
                     brackets, and it matches any item of type <var>T</var> which each of the predicates evaluates
                     to <code>true</code>.</termdef></p>
                  <p>For convenience, if <var>T</var> takes the form <code>record(F1, F2, ...)</code>, then the pattern can be abbrevated.</p>
                  <p>The detailed semantics are given in <specref ref="pattern-semantics"/>. This construct can be used to match items of any
                     kind (nodes, atomic values, and function items). For example, the pattern
                     <code>.[starts-with(., '$')]</code> matches any string that starts with the
                     character <code>$</code>, or a node whose atomized value starts with 
                     <code>$</code>. This example shows a predicate pattern with a single
                     predicate, but the grammar allows any number of predicates (zero or more).</p>
               </item>
               <item>
                  <p><termdef id="dt-node-pattern" term="node pattern">A <term>node pattern</term> uses a subset of
                        the syntax for path expressions, and is defined to match a node if the
                        corresponding path expression would select the node. Node patterns may
                        also be formed by combining other patterns using union, intersection, and
                        difference operators.</termdef></p>
                  <p>The syntax for node patterns
                        (<code>UnionExprP</code> in the grammar:
                        see <specref ref="pattern-syntax"/>) is a subset of the syntax for
                        <termref def="dt-expression">expressions</termref>. Node patterns are
                        used only for matching nodes; an item other than a node will never match a
                           node pattern.
                     As explained in detail below, a node matches a node pattern if the node can be selected by
                     deriving an equivalent expression, and evaluating this expression with respect
                     to some possible context.</p>
               </item>
            </ulist>





            




            <note>
               <p>The specification uses the phrases <emph>an item matches a pattern</emph> and
                     <emph>a pattern matches an item</emph> interchangeably. They are equivalent: an
                  item matches a pattern if and only if the pattern matches the item.</p>
            </note>
            <div3 id="pattern-examples">
               <head>Examples of Patterns</head>
               <example id="pattern-examples-1">
                  <head>Patterns</head>
                  <p>Here are some examples of patterns:</p>
                  <ulist>
                     <item>
                        <p><emph>Predicate Patterns:</emph></p>
                        <olist>
                           <item>
                              <p><code>.</code> matches any item.</p>
                           </item>
                           <item>
                              <p><code>.[. castable as xs:date]</code> matches any item
                                 that can be successfully cast to <code>xs:date</code>: for example,
                              an <code>xs:date</code> or <code>xs:dateTime</code> value, or a string
                              in the lexical form of a date, or a node whose typed value is an <code>xs:date</code>
                              or a string in the form of a date.</p>
                           </item>
                           <item>
                              <p><code>.[string() => matches('^[0-9]$')]</code> matches any
                                 item whose string value is a sequence of digits.</p>
                           </item>
                           <item>
                              <p><code>.[. castable as xs:date][xs:date(.) le current-date()]</code> matches any
                                 item that is castable to <code>xs:date</code> provided that the result of casting
                                 the value to <code>xs:date</code> is a date in the past.</p>
                           </item>
                        </olist>
                     </item>
                     <item diff="add" at="2022-01-01">
                        <p><emph>Type Patterns</emph></p>
                        <olist>
                           <item>
                              <p><code>type(item())</code> matches any item.</p>
                           </item>
                           <item>
                              <p><code>type(node())</code> matches any node.
                                 (Note the distinction from the pattern <code>node()</code>.)</p>
                           </item>
                           <item>
                              <p><code>type(xs:date)</code> matches any
                                 atomic value of type <code>xs:date</code> (or a type derived by
                                 restriction from <code>xs:date</code>).</p>
                           </item>
                           <item>
                              <p><code>type(xs:date)[. gt current-date()]</code> matches any date in
                                 the future.</p>
                           </item>
                           <item>
                              <p><code>type(xs:string)[starts-with(., 'e')]</code> matches any <code>xs:string</code>
                                 value that starts with the letter <code>e</code>. Note there is no type conversion; the pattern
                              will not match an <code>xs:untypedAtomic</code> or <code>xs:anyURI</code> value,
                              nor will it match any node.</p>
                           </item>
                           <item>
                              <p><code>type(function(*))</code> matches any
                                 function item.</p>
                           </item>
                           <item>
                              <p><code>type(function($x as xs:integer) as xs:boolean)[.(42)]</code> matches any function that
                                 accepts an <code>xs:integer</code> argument and returns a boolean result, provided
                                 that the result of calling the function with the argument value <code>42</code> is <code>true</code>.</p>
                           </item>
                           <item>
                              <p><code>union(xs:date, xs:dateTime, xs:time)</code> matches any atomic value
                                 that is an instance of <code>xs:date</code>, <code>xs:dateTime</code>, or <code>xs:time</code>.</p>
                           </item>
                           <item>
                              <p><code>enum("red", "green", "blue")</code> matches any one of the three strings
                                 <code>"red"</code>, <code>"green"</code>, or <code>"blue"</code>.</p>
                           </item>
                           <item>
                              <p><code>record(first, last, *)[?location = 'UK']</code> matches any map whose keys include the strings <code>"first"</code>
                                 and <code>"last"</code>, and that also has an entry with key <code>"location"</code> whose
                              value is <code>"UK"</code>.</p>
                           </item>
                           <item>
                              <p><code>record(longitude, latitude)</code> matches any map with two entries whose keys are the strings <code>"longitude"</code>
                                 and <code>"latitude"</code>.</p>
                           </item>
                           <item>
                              <p><code>array(xs:integer)[array:size(.) eq 4]</code> matches any array of four integers.</p>
                           </item>
                           <item>
                              <p><code>array(record(first, last, *))</code> matches any array of maps where each map
                                 contains entries with keys <code>"first"</code> and <code>"last"</code>. (Note that
                              this includes the empty array).</p>
                           </item>
                           <item>
                              <p><code>array(record(first, last, *))[array:size(.) gt 0]</code> matches any non-empty array of maps where each map
                                 contains entries with keys <code>"first"</code> and <code>"last"</code>. </p>
                           </item>
                           <item>
                              <p><code>type(complex)</code> matches any value that is an instance of the item type declared in an <elcode>xsl:item-type</elcode>
                                 declaration with name <code>"complex"</code></p>
                           </item>
                           <item>
                              <p><code>type(complex)[?i eq 0]</code> matches any value that is an instance of the item type declared in an <elcode>xsl:item-type</elcode>
                                 declaration with name <code>"complex"</code> and that is a map with an entry having key <code>i</code> and value zero.</p>
                           </item>
                        </olist>
                     </item>
                     <item>
                        <p><emph>Node Patterns</emph></p>
                        <olist><item>
                           <p><code>*</code> matches any element.</p>
                        </item>
                        <item>
                           <p><code>para</code> matches any <code>para</code> element.</p>
                        </item>
                        <item>
                           <p><code>chapter|appendix</code> matches any <code>chapter</code> element
                              and any <code>appendix</code> element.</p>
                        </item>
                           <item diff="add" at="2022-12-13">
                              <p><code>child::(chapter|appendix)</code> matches any <code>chapter</code> element
                                 and any <code>appendix</code> element. Note that although the <code>child</code> axis
                              is explicitly written, an element can match even though it has no parent.</p>
                           </item>
                        <item>
                           <p><code>olist/entry</code> matches any <code>entry</code> element with an
                              <code>olist</code> parent.</p>
                        </item>
                        <item>
                           <p><code>appendix//para</code> matches any <code>para</code> element with an
                              <code>appendix</code> ancestor element.</p>
                        </item>
                           <item diff="add" at="2022-12-13">
                              <p><code>appendix/descendant::(para|table)</code> matches any <code>para</code> 
                                 or <code>table</code>element with an
                                 <code>appendix</code> ancestor element.</p>
                           </item>
                        <item>
                           <p><code>schema-element(us:address)</code> matches any element that is
                              annotated as an instance of the type defined by the schema element
                              declaration <code>us:address</code>, and whose name is either
                              <code>us:address</code> or the name of another element in its
                              substitution group. </p>
                        </item>
                        <item>
                           <p><code>attribute(*, xs:date)</code> matches any attribute annotated as
                              being of type <code>xs:date</code>.</p>
                        </item>
                        <item>
                           <p><code>/</code> matches a document node.</p>
                        </item>
                        <item>
                           <p><code>document-node()</code> matches a document node.</p>
                        </item>
                        <item>
                           <p><code>document-node(schema-element(my:invoice))</code> matches the
                              document node of a document whose document element is named
                              <code>my:invoice</code> and matches the type defined by the global
                              element declaration <code>my:invoice</code>.</p>
                        </item>
                        <item>
                           <p><code>text()</code> matches any text node.</p>
                        </item>
                        <item>
                           <p><code>namespace-node()</code> matches any namespace
                              node.</p>
                        </item>
                        <item>
                           <p><code>node()</code> matches any node other than an attribute node,
                              namespace node, or document node.</p>
                        </item>
                        <item>
                           <p><code>id("W33")</code> matches the element with unique ID
                              <code>W33</code>. </p>
                        </item>
                        <item>
                           <p><code>para[1]</code> matches any <code>para</code> element that is the
                              first <code>para</code> child element of its parent. It also matches a
                              parentless <code>para</code> element.</p>
                        </item>
                        <item>
                           <p><code>//para</code> matches any <code>para</code> element in a tree that is rooted at a document node.</p>
                        </item>
                        <item>
                           <p><code>bullet[position() mod 2 = 0]</code> matches any <code>bullet</code>
                              element that is an even-numbered <code>bullet</code> child of its
                              parent.</p>
                        </item>
                           
                        <item>
                           <p><code>div[@class="appendix"]//p</code> matches any <code>p</code> element
                              with a <code>div</code> ancestor element that has a <code>class</code>
                              attribute with value <code>appendix</code>. </p>
                        </item>
                        <item>
                           <p><code>@class</code> matches any <code>class</code> attribute
                              (<emph>not</emph> any element that has a <code>class</code>
                              attribute).</p>
                        </item>
                           <item diff="add" at="2022-12-13">
                              <p><code>@(class|type|kind)</code> matches any attribute named <code>class</code> 
                                 or <code>type</code> or <code>kind</code>.</p>
                           </item>
                        <item>
                           <p><code>@*</code> matches any attribute node.</p>
                        </item>
                        <item>
                           <p><code>$xyz</code> matches any node that is present in
                              the value of the variable <code>$xyz</code>.</p>
                        </item>
                        <item>
                           <p><code>$xyz//*</code> matches any element that is a
                              descendant of a node that is present in the value of the variable
                              <code>$xyz</code>.</p>
                        </item>
                        <item>
                           <p><code>doc('product.xml')//*</code> matches any element
                              within the document whose document URI is <code>product.xml</code>.</p>
                        </item>
                    </olist>
                 </item>
                  </ulist>       
                  
               </example>
            </div3>
            <div3 id="pattern-syntax">
               <head>Syntax of Patterns</head>
               <p>
                  <error spec="XT" type="static" class="SE" code="0340">
                     <p>Where an attribute is defined to contain a <termref def="dt-pattern">pattern</termref>, it is a <termref def="dt-static-error">static
                           error</termref> if the pattern does not match the production <nt def="Pattern40">Pattern40</nt>.</p>
                  </error></p>
               <p>The grammar for patterns uses the notation defined in <xspecref spec="XP40" ref="EBNFNotation">Notation</xspecref>. </p>
               <p>The lexical rules for patterns are the same as the lexical rules
                  for XPath expressions, as defined in <xspecref spec="XP40" ref="lexical-structure">Lexical structure</xspecref>. Comments are permitted between tokens, using the
                  syntax <code>(: ... :)</code>. All other provisions of the XPath grammar apply
                  where relevant, for example the rules for whitespace handling and
                  extra-grammatical constraints.</p>
               
               <scrap headstyle="show" id="Patterns-scrap" diff="add" at="2022-01-01">
                  <head></head>
                  
                  <prodrecap ref="Pattern40" id="Pattern40"/>
                  <prodrecap ref="PredicatePattern" id="PredicatePattern"/>
                  <prodrecap ref="TypePattern" id="TypePattern"/>
                  <prodrecap ref="NodePattern" id="NodePattern"/>
               </scrap>
               
               <p diff="add" at="2022-01-01">Patterns fall into three groups:</p>
               
               <ulist diff="add" at="2022-01-01">
                  <item><p>A <code>PredicatePattern</code> matches items according to conditions that the item must
                  satisfy: for example <code>.[. castable as xs:integer]</code> matches any value (it might
                  be an atomic value, a node, or an array) that is castable as an integer.</p></item>
                  <item><p>A <code>TypePattern</code> matches items according to their type. For example
                  <code>type(xs:integer)</code> matches an atomic value that is an instance of <code>xs:integer</code>,
                  while <code>record(longitude, latitude)</code> matches a map that has exactly two entries, with
                  keys <code>"longitude"</code> and <code>"latitude"</code></p></item>
                  <item><p>A <code>NodePattern</code> matches nodes in a tree, typically by specifying a path that
                  can be used to locate the nodes: for example <code>order</code> matches an element node
                  named <code>order</code>, while <code>billing-address/city</code> matches an element named <code>city</code>
                  whose parent node is an element named <code>billing-address</code>.</p></item>
               </ulist>
               
               <p diff="add" at="2022-01-01">The following sections define the rules for each of these groups.</p>
               
               <div4 id="predicate-patterns">
                  <head>Predicate Patterns</head>
                  
                  <scrap headstyle="show" id="PredicatePatterns-scrap">
                     <head></head>
                     <prodrecap ref="PredicatePattern"/>
                     <prodrecap ref="PredicateList" id="PredicateList"/>
                  </scrap>
                  
                  <p>A <nt def="PredicatePattern">PredicatePattern</nt>
                     <var>PP</var> matches an item <var>J</var> if and only if the XPath expression taking
                     the same form as <var>PP</var> returns a non-empty sequence when evaluated with a
                     <termref def="dt-singleton-focus"/> based on <var>J</var>.</p>
                  
                  
                  
                  <note>
                     <p>The pattern <code>.</code>, which is a <code>PredicatePattern</code> with an
                        empty <xnt spec="XP40" ref="prod-xpath40-PredicateList">PredicateList</xnt>,
                        matches every item.</p>
                     <p>A predicate with the numeric value 1 (one) always matches, and a predicate with
                        any other numeric value never matches. Numeric predicates in a
                        <code>PredicatePattern</code> are therefore not useful, but are defined this
                        way in the interests of consistency with XPath.</p>
                  </note>
                  
                  <p diff="add" at="2022-01-01">For example, the pattern <code>.[contains(., "XSLT")]</code>
                  matches any item whose typed value contains <code>"XSLT"</code> as a substring. 
                  It matches values such as the string <code>"XSLT Transformations"</code>, the
                     <code>xs:anyURI</code> value
                     <code>http://www.w3.org/TR/XSLT</code>, the attribute node 
                     <code>class="XSD XSLT XPath"</code>, and the singleton array <code>["XSLT 4.0"]</code>.</p>
                  
               </div4>
               
               <div4 id="type-patterns" diff="add" at="2022-01-01">
                  <head>Type Patterns</head>
                  
                  <scrap headstyle="show" id="TypePatterns-scrap">
                     <head></head>
                     <prodrecap ref="TypePattern"/>
                     <prodrecap ref="WrappedItemTest" id="WrappedItemTest"/>
                     <prodrecap ref="AnyItemTest" id="AnyItemTest"/>
                     <prodrecap ref="FunctionTest" id="FunctionTest"/>
                     <prodrecap ref="MapTest" id="MapTest"/>
                     <prodrecap ref="ArrayTest" id="ArrayTest"/>
                     <prodrecap ref="RecordTest" id="RecordTest"/>
                     <prodrecap ref="FieldDeclaration" id="FieldDeclaration"/>
                     <prodrecap ref="FieldName" id="FieldName"/>
                     <prodrecap ref="ExtensibleFlag" id="ExtensibleFlag"/>
                     <prodrecap ref="EnumerationType" id="EnumerationType"/>
                     <prodrecap ref="NamedItemType" id="NamedItemType"/>
                     <prodrecap ref="PredicateList"/>
                  </scrap>
                  
      
                  
                  <p>A type pattern tests whether an item matches a given item type, optionally qualified
                  with one or more predicates that the value must also satisfy.</p>
                  
                  <p>The general-purpose construct <code>type(ItemType)</code> allows any <code>ItemType</code>
                  to be used in a pattern. Where syntactic constraints permit, many <code>ItemTypes</code> can 
                     also be used directly: for example
                  <code>type(item())</code> can be abbreviated as <code>item()</code>.</p>
                  <p>For example:</p>
                  <ulist>
                     <item><p><code>type(integer)</code> matches any instance of
                        <code>xs:integer</code></p></item>
                     <item><p><code>type(integer)[. gt 0]</code> matches
                        any positive integer.</p></item>
                     <item><p><code>union(string, untypedAtomic)[matches(., '[0-9]+')]</code> matches
                        any instance of <code>xs:string</code> or <code>xs:untypedAtomic</code> that
                        contains a sequence of decimal digits.</p></item>
                     <item><p><code>type(node())</code> matches any node. (This is not the same as the pattern
                        <code>node()</code>, which for historical reasons only matches  element, text, comment, 
                        and processing instruction nodes).</p></item>
                  </ulist>
                  <note><p>The above examples assume the declaration 
                     <code>default-type-namespace="http://www.w3.org/2001/XMLSchema"</code>.</p></note>
                  
                  <p>More formally, an item <var>$J</var> matches a pattern <code>type(T)[P1][P2][P3]</code> if
                  the XPath expression <code>$J instance of T and exists($J[P1][P2]P3])</code> is true.</p>
                  
                  <note><p>As with predicate patterns, numeric predicates are allowed, but serve no useful purpose.</p></note>
                  
                  
                  
                  <p>A pattern written as <code>record(A, B, C)</code> is an abbreviation for <code>type(record(A, B, C))</code>
                     (retaining any predicates). For example, the pattern <code>record(first, last, *)[?first eq "Sharon"]</code>
                  matches any map having entries with the string-valued keys <code>"first"</code> and <code>"last"</code>,
                     where the entry for the key <code>"first"</code> is equal to the string <code>"Sharon"</code>.</p>
                  
                  <note>
                     <p>The item type in a pattern can be any <code>ItemType</code>, but patterns that match
                        nodes can usually be expressed more economically
                        as a <code>NodeTest</code>: for example <code>match="type(element(PERSON))"</code> has the same meaning as
                        <code>match="element(PERSON)"</code>, which in turn is usually abbreviated to <code>match="PERSON"</code>.</p>
                     <p>Although <code>match="type(element(PERSON))"</code> matches exactly the same items as
                     <code>match="PERSON"</code>, the priority relative to other template rules (in the absence of an explicit
                     <code>priority</code> attribute) may be different.</p>
                  </note>
                  
               </div4>
               
               <div4 id="node-patterns">
                  <head>Node Patterns</head>
               

               <scrap id="NodePatterns-scrap">
                  <head></head>

                  <prodrecap ref="NodePattern"/>
                  <prodrecap ref="UnionExprP" id="UnionExprP"/>
                  <prodrecap ref="IntersectExceptExprP" id="IntersectExceptExprP"/>
                  <prodrecap ref="PathExprP" id="PathExprP"/>
                  <prodrecap ref="RootedPath" id="RootedPath"/>
                  <prodrecap ref="FunctionCallP" id="FunctionCallP"/>
                  <prodrecap ref="OuterFunctionName" id="OuterFunctionName"/>
                  <prodrecap ref="ArgumentListP" id="ArgumentListP"/>
                  <prodrecap ref="ArgumentP" id="ArgumentP"/>
                  <prodrecap ref="RelativePathExprP" id="RelativePathExprP"/>
                  <prodrecap ref="StepExprP" id="StepExprP"/>
                  <prodrecap ref="PostfixExprP" id="PostfixExprP"/>
                  <prodrecap ref="ParenthesizedExprP" id="ParenthesizedExprP"/>
                  <prodrecap ref="AxisStepP" id="AxisStepP"/>
                  <prodrecap ref="ForwardStepP" id="ForwardStepP"/>
                  <prodrecap ref="ForwardAxisP" id="ForwardAxisP"/>


               </scrap>
               
               <p>Node Patterns are used to match XDM nodes.</p>

               <p>The names of these constructs are chosen to align with the XPath 3.0 grammar.
                  Constructs whose names are suffixed with <code>P</code> are restricted forms of
                  the corresponding XPath 3.0 construct without the suffix. Constructs labeled with
                  the suffix “XP40” are defined in <bibref ref="xpath-40"/>.</p>

               <p diff="del" at="2022-01-01">Where the XSLT 3.0 processor implements the XPath 3.1 feature, the definitions that apply to constructs labeled
                  with the suffix “XP30” are those in [XPath 3.1]</p>


               <p>In a <nt def="FunctionCallP">FunctionCallP</nt>, the
                     <code>EQName</code> used for the function name must have local part
                     <code>doc</code>, <code>id</code>, <code>element-with-id</code>,
                     <code>key</code>, or
                     <code>root</code>, and must use the <termref def="dt-standard-function-namespace"/> either explicitly or implicitly.</p>

               <p>In the case of a call to the
                     <xfunction>root</xfunction> function, the argument list must be empty: that is,
                  only the zero-arity form of the function is allowed.</p>

               <note>
                  <p>As with XPath expressions, the pattern <code>/ union /*</code> can be parsed in
                     two different ways, and the chosen interpretation is to treat
                        <code>union</code> as an element name rather than as an operator. The other
                     interpretation can be achieved by writing <code>(/) union (/*)</code></p>
               </note>
                  <note diff="add" at="E">
                     <p>A peculiarity of this grammar is that <code>doc('a.xml')/(id('abc'))</code> is a 
                        valid pattern, while <code>doc('a.xml')/id('abc')</code> is not: the <code>/</code> 
                        operator must be followed either by a parenthesized expression, or by an axis step.</p>
                  </note>
            </div4>
            <div4 id="pattern-semantics">
               <head>The Meaning of a Node Pattern</head>
               <p>The meaning of a node pattern is defined formally as follows, where “if” is to be read
                  as “if and only if”.</p>

               
  

               <p>The pattern is converted to an <termref def="dt-expression">expression</termref>, called the <term>equivalent expression</term>. The
                  equivalent expression to a <nt def="Pattern40">Pattern</nt> is the XPath
                  expression that takes the same lexical form as the <code>Pattern</code> as
                  written, with the following adjustment:</p>
               <ulist>
                  
                  <item>
                     <p>If any <code>PathExprP</code> in the
                              <code>Pattern</code> is a <code>RelativePathExprP</code>, then the
                           first <code>StepExprP</code>
                           <var>PS</var> of this <code>RelativePathExprP</code> is adjusted
                        to allow it to match a parentless element, attribute, or namespace node. The
                        adjustment depends on the axis used in this step, whether it appears
                        explicitly or implicitly (according to the rules of <xspecref spec="XP40" ref="abbrev"/>), and is made as follows:</p>
                     <olist>
                        <item>
                           <p>If the <code>NodeTest</code> in <var>PS</var> is
                                 <code>document-node()</code> (optionally with arguments), and if no
                              explicit axis is specified, then the axis in step <var>PS</var> is
                              taken as <code>self</code> rather than <code>child</code>.</p>
                        </item>
                        <item>
                           <p>If <var>PS</var> uses the child axis (explicitly or implicitly), and
                              if the <code>NodeTest</code> in <var>PS</var> is not
                                 <code>document-node()</code> (optionally with arguments), then the
                              axis in step <var>PS</var> is replaced by <code>child-or-top</code>,
                              which is defined as follows. If the context node is a parentless
                              element, comment, processing-instruction, or text node then the
                                 <code>child-or-top</code> axis selects the context node; otherwise
                              it selects the children of the context node. It is a forwards axis
                              whose principal node kind is element.</p>
                        </item>
                        <item>
                           <p>If <var>PS</var> uses the attribute axis (explicitly or implicitly),
                              then the axis in step <var>PS</var> is replaced by
                                 <code>attribute-or-top</code>, which is defined as follows. If the
                              context node is an attribute node with no parent, then the
                                 <code>attribute-or-top</code> axis selects the context node;
                              otherwise it selects the attributes of the context node. It is a
                              forwards axis whose principal node kind is attribute.</p>
                        </item>
                        <item>
                           <p>If <var>PS</var> uses the namespace axis (explicitly or implicitly), then the axis in step
                                 <var>PS</var> is replaced by <code>namespace-or-top</code>, which
                              is defined as follows. If the context node is a namespace node with no
                              parent, then the <code>namespace-or-top</code> axis selects the
                              context node; otherwise it selects the namespace nodes of the context
                              node. It is a forwards axis whose principal node kind is
                              namespace.</p>

                        </item>
                     </olist>
                     <p>The axes <code>child-or-top</code>, <code>attribute-or-top</code>, and
                           <code>namespace-or-top</code> are introduced only for definitional
                        purposes. They cannot be used explicitly in a user-written pattern or
                        expression.</p>
                     <note>
                        <p>The purpose of this adjustment is to ensure that a pattern such as
                              <code>person</code> matches any element named <code>person</code>,
                           even if it has no parent; and similarly, that the pattern
                              <code>@width</code> matches any attribute named <code>width</code>,
                           even a parentless attribute. The rule also ensures that a pattern using a
                              <code>NodeTest</code> of the form <code>document-node(...)</code>
                           matches a document node. The pattern <code>node()</code> will match any
                           element, text node, comment, or processing instruction, whether or not it
                           has a parent. For backwards compatibility reasons, the pattern
                              <code>node()</code>, when used without an explicit axis, does not
                           match document nodes, attribute nodes, or namespace nodes. The rules are
                           also phrased to ensure that positional patterns of the form
                              <code>para[1]</code> continue to count nodes relative to their parent,
                           if they have one. To match any node at all,
                              XSLT 4.0 allows the pattern <code>.[. instance of node()]</code> to be
                              used.</p>
                     </note>

                  </item>
               </ulist>

               <p>The meaning of the pattern is then defined in terms of the semantics of the
                  equivalent expression, denoted below as <code>EE</code>.</p>

               <p>Specifically, an item <var>N</var> matches a pattern <var>P</var> if  the following applies, where
                     <code>EE</code> is the <term>equivalent expression</term> to <var>P</var>:</p>
               <olist>

                  <item>
                     <p><var>N</var> is a node, and the result of evaluating the expression
                           <code>root(.)//(EE)</code> with a <termref def="dt-singleton-focus">singleton focus</termref> based on <var>N</var> is a sequence that
                        includes the node <var>N</var>
                     </p>
                  </item>
                  
               </olist>

               <p>If a pattern appears in an attribute of an element that
                     is processed with <termref def="dt-xslt-10-behavior">XSLT 1.0
                        behavior</termref> (see <specref ref="backwards"/>), then the
                  semantics of the pattern are defined on the basis that the equivalent XPath
                  expression is evaluated with <termref def="dt-xpath-compat-mode">XPath 1.0
                     compatibility mode</termref> set to <code>true</code>.</p>


               <example>
                  <head>The Semantics of Node Patterns</head>
                  <p>The <termref def="dt-node-pattern"/>
                     <code>p</code> matches any <code>p</code> element, because a <code>p</code>
                     element will always be present in the result of evaluating the <termref def="dt-expression">expression</termref>
                     <code>root(.)//(child-or-top::p)</code>. Similarly, <code>/</code> matches a
                     document node, and only a document node, because the result of the <termref def="dt-expression">expression</termref>
                     <code>root(.)//(/)</code> returns the root node of the tree containing the
                     context node if and only if it is a document node.</p>
                  <p>The <termref def="dt-node-pattern"/>
                     <code>node()</code> matches all nodes selected by the expression
                        <code>root(.)//(child-or-top::node())</code>, that is, all element, text,
                     comment, and processing instruction nodes, whether or not they have a parent.
                     It does not match attribute or namespace nodes because the expression does not
                     select nodes using the attribute or namespace axes. It does not match document
                     nodes because for backwards compatibility reasons the <code>child-or-top</code>
                     axis does not match a document node.</p>
                  <note diff="add" at="2022-01-01">
                     <p>The pattern <code>type(node())</code> matches all nodes.</p>
                  </note>
                  <p>The <termref def="dt-node-pattern"/>
                     <code>$V</code> matches all nodes selected by the expression
                        <code>root(.)//($V)</code>, that is, all nodes in the value of $V (which
                     will typically be a global variable, though when the pattern is used in
                     contexts such as the <elcode>xsl:number</elcode> or
                        <elcode>xsl:for-each-group</elcode> instructions, it can also be a local
                     variable).</p>
                  <p>The <termref def="dt-node-pattern"/>
                     <code>doc('product.xml')//product</code> matches all nodes selected by the
                     expression <code>root(.)//(doc('product.xml')//product)</code>, that is, all
                        <code>product</code> elements in the document whose URI is
                        <code>product.xml</code>.</p>
                  <p>The <termref def="dt-node-pattern"/>
                     <code>root(.)/self::E</code> matches an <code>E</code> element that is the root
                     of a tree (that is, an <code>E</code> element with no parent node).</p>
               </example>
               <p>Although the semantics of <termref def="dt-node-pattern">node patterns</termref> are
                  specified formally in terms of expression evaluation, it is possible to understand
                  pattern matching using a different model. A <termref def="dt-node-pattern"/> such as
                     <code>book/chapter/section</code> can be examined from right to left. A node
                  will only match this pattern if it is a <code>section</code> element; and then,
                  only if its parent is a <code>chapter</code>; and then, only if the parent of that
                     <code>chapter</code> is a <code>book</code>. When the pattern uses the
                     <code>//</code> operator, one can still read it from right to left, but this
                  time testing the ancestors of a node rather than its parent. For example
                     <code>appendix//section</code> matches every <code>section</code> element that
                  has an ancestor <code>appendix</code> element.</p>
               <p>The formal definition, however, is useful for understanding the meaning of a
                  pattern such as <code>para[1]</code>. This matches any node selected by the
                  expression <code>root(.)//(child-or-top::para[1])</code>: that is, any
                     <code>para</code> element that is the first <code>para</code> child of its
                  parent, or a <code>para</code> element that has no parent.</p>
               <note>
                  <p>An implementation, of course, may use any algorithm it wishes for evaluating
                     patterns, so long as the result corresponds with the formal definition above.
                     An implementation that followed the formal definition by evaluating the
                     equivalent expression and then testing the membership of a specific node in the
                     result would probably be very inefficient.</p>
               </note>
               <note diff="chg" at="A2022-03-04">
                  <p>Patterns using the <code>intersect</code> and <code>except</code> operators
                  do not always have the intuitive meaning: in particular, it is not always the case
                  that a node matches <code>A except B</code> if it matches <code>A</code> but does
                  not match <code>B</code>.</p>
                  <p>For example, consider the pattern <code>para except appendix//para</code>.
                  This expands to <code>root(.)/descendant-or-self::node()/(child::para except child::appendix//para)</code>.
                  Since for a given parent node, the results of <code>child::para</code> and <code>child::appendix</code>
                  are disjoint, the right-hand operand of <code>except</code> has no effect.</p>
                  <p>The effect of matching all paragraphs except those within an appendix can be achieved 
                     using the pattern <code>para except //appendix//para</code>; alternatively, use
                   <code>para[not(ancestor::appendix)]</code>.</p>
                  <p>Simpler patterns such as <code>@* except @code</code> generally have the expected effect;
                  the complications arise mainly when non-trivial relative paths are used.</p>
               </note>
            </div4>
            </div3>
            <div3 id="pattern-errors">
               <head>Errors in Patterns</head>
               <p>A <termref def="dt-dynamic-error">dynamic error</termref> or <termref def="dt-type-error">type error</termref> that occurs during the evaluation of a
                     <termref def="dt-pattern">pattern</termref> against a particular item has the effect that the item being tested is
                  treated as not matching the pattern. The error does not cause the transformation
                  to fail, and cannot be caught by a try/catch expression surrounding the
                  instruction that causes the pattern to be evaluated.</p>
               <note>
                  <p>The reason for this provision is that it is difficult for the stylesheet author
                     to predict which predicates in a pattern will actually be evaluated. In the
                     case of match patterns in template rules, it is not even possible to predict
                     which patterns will be evaluated against a particular node.</p>
                  <p>There is a risk that ignoring errors in this way may make programming mistakes
                     harder to debug. Implementations may mitigate this by providing warnings or
                     other diagnostics when evaluation of a pattern triggers an error condition.</p>
                  <p>Static errors in patterns, including dynamic and type errors that are signaled
                     statically as permitted by the specification, are reported in the normal way
                     and cause the transformation to fail.</p>
               </note>
               <p>The requirement to detect and report a <termref def="dt-circularity"/> as a dynamic error overrides this rule.</p>


            </div3>
            
         </div2>
         <div2 id="named-item-types" diff="add" at="2022-01-01">
            <head>Defining Named Item Types</head>
            
            <?element xsl:item-type?>
            
            <p>An <elcode>xsl:item-type</elcode> declaration associates a name with an item type, and allows the type
            to be referenced by name throughout the stylesheet package.</p>
            <example id="e-item-type-complex">
               <p>The following example declares a named item type for complex numbers, and uses it in a variable
               declaration and two function declarations.</p>
               <eg><![CDATA[<xsl:item-type name="cx:complex" as="record(r as xs:double, i as xs:double)"/>

<xsl:variable name="i" as="cx:complex" select="cx:number(0, 1)"/>

<xsl:function name="cx:number" as="cx:complex">
  <xsl:param name="r" as="xs:double"/>
  <xsl:param name="i" as="xs:double"/>
  <xsl:sequence select="map{'r':$r, 'i':$i}"/>
</xsl:function>

<xsl:function name="cx:add" as="cx:complex">
  <xsl:param name="x" as="cx:complex"/>
  <xsl:param name="y" as="cx:complex"/>
  <xsl:sequence select="cx:number($x?r + $y?r, $x?i + $y?i)"/>
</xsl:function>
                  ]]></eg>
            </example>
            <p>Using named item types makes the stylesheet more readable, and improves potential for change: a change
            to the way complex numbers are implemented in this example is less likely to affect users of the function
            library. However, named item types do not provide true encapsulation or information hiding; users of the 
            function library can still treat complex numbers as raw maps if they wish.</p>
            <p>The <elcode>xsl:item-type</elcode> declaration adds an entry to the 
               <xtermref spec="XP40" ref="dt-type-alias"/>
            component of the static context for XPath expressions, and also becomes available for use wherever
            XSLT allows an <code>ItemType</code> to appear.</p>
            <p>The scope of a named item type is the <termref def="dt-package"/> in which it is declared. If it
            is declared with <code>visibility="final"</code> then it also becomes available for use in using
            packages. Named item types cannot be overridden in a using package, so the only permitted values for
            <code>visibility</code> are <code>private</code> and <code>final</code>.</p>
            <p>The name of the item type is the expanded name formed by resolving the <code>name</code> attribute.
            A lexical QName with no prefix is treated as a no-namespace name.</p>
            <p>If two <elcode>xsl:item-type</elcode> declarations in a <termref def="dt-package"/> have the same
            name, then the one with higher <termref def="dt-import-precedence"/> is used. </p>
            <p><error spec="XT" type="static" class="SE" code="9ZZZ">
               <p>It is a <termref def="dt-static-error">static error</termref> if a package contains two 
                  <elcode>xsl:item-type</elcode>
                  declarations having the same <termref def="dt-import-precedence">import
                     precedence</termref>, unless there is another definition of the same
                  item type with higher import precedence.</p>
            </error></p>
            <p>TODO: add named item types to xsl:accept and xsl:expose. Clarify that when a function or variable
            is exported to a different package, its declared type/signature uses the expanded form of any named
            item type; there is no requirement for the using package to know the named item types. But it becomes
            easier to use the exposed variables and functions if the names of the types are exposed too.</p>
         </div2>
         <div2 id="defining-decimal-format">
            <head>Defining a Decimal Format</head>
            
            <p>The definition of the <xfunction>format-number</xfunction> function
               is now in <bibref ref="xpath-functions-40"/>. This section is a specification of
               the <elcode>xsl:decimal-format</elcode> declaration, which provides the context for
               this function when used in an XSLT stylesheet.</p>
            
            <?element xsl:decimal-format?>
            <p>The <elcode>xsl:decimal-format</elcode> element sets the
               <term>statically known decimal formats</term> component of the static context
               for XPath expressions, which controls the interpretation of a <termref def="dt-picture-string">picture string</termref> used by the
               <xfunction>format-number</xfunction> function.</p>
            <p><termdef id="dt-picture-string" term="picture string">The <term>picture string</term>
               is the string supplied as the second argument of the
               <xfunction>format-number</xfunction> function.</termdef>
            </p>
            
            <p>A <termref def="dt-package">package</termref> may
               contain multiple <elcode>xsl:decimal-format</elcode> declarations and may include or
               import <termref def="dt-stylesheet-module">stylesheet modules</termref> that also
               contain <elcode>xsl:decimal-format</elcode> declarations. The name of an
               <elcode>xsl:decimal-format</elcode> declaration is the value of its
               <code>name</code> attribute, if any.</p>
            <p>
               <termdef id="dt-decimal-format" term="decimal format">All the
                  <elcode>xsl:decimal-format</elcode> declarations in a package that share the same name are grouped into a named
                  <term>decimal format</term>; those that have no name are grouped into a single
                  unnamed decimal format.</termdef>
            </p>
            
            <p> The attributes of the <elcode>xsl:decimal-format</elcode>
               declaration define the value of the corresponding property in the relevant decimal
               format in the <xtermref spec="XP40" ref="dt-static-decimal-formats">statically known
                  decimal formats</xtermref> component of the static context for all XPath
               expressions in the package. The attribute names used in the XSLT 4.0 syntax are the
               same as the property names used in the definition of the static context. </p>
            
            
            
            <p diff="del" at="2022-01-01"> The <code>exponent-separator</code> attribute is provided
               for use with XPath 3.1. It has no effect when used with XPath 3.0. </p>
            
            
            
            <p>The scope of an <elcode>xsl:decimal-format</elcode> name is the
               package in which it is declared; the name is available for use only in calls to
               <xfunction>format-number</xfunction> that appear within the same package.</p>
            
            <p>If a <termref def="dt-package">package</termref> does not contain a declaration of
               the unnamed decimal format, a declaration equivalent to an
               <elcode>xsl:decimal-format</elcode> element with no attributes is implied.</p>
            <p>The attributes of the <elcode>xsl:decimal-format</elcode> declaration establish
               values for a number of variables used as input to the algorithm followed by the
               <xfunction>format-number</xfunction> function. An outline of the purpose of each
               attribute is given below; however, the definitive explanations are given as part of the specification of
               <xfunction>format-number</xfunction>.</p>
            <p>For any named <termref def="dt-decimal-format">decimal format</termref>, the
               <termref def="dt-effective-value"/> of each attribute is taken from an
               <elcode>xsl:decimal-format</elcode> declaration that has that name, and that
               specifies an explicit value for the required attribute. If there is no such
               declaration, the default value of the attribute is used. If there is more than one
               such declaration, the one with highest <termref def="dt-import-precedence">import
                  precedence</termref> is used.</p>
            <p>For any unnamed <termref def="dt-decimal-format">decimal format</termref>, the
               <termref def="dt-effective-value"/> of each attribute is taken from an
               <elcode>xsl:decimal-format</elcode> declaration that is unnamed, and that
               specifies an explicit value for the required attribute. If there is no such
               declaration, the default value of the attribute is used. If there is more than one
               such declaration, the one with highest <termref def="dt-import-precedence">import
                  precedence</termref> is used.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="1290">
                  <p>It is a <termref def="dt-static-error">static error</termref> if a named or
                     unnamed <termref def="dt-decimal-format">decimal format</termref> contains two
                     conflicting values for the same attribute in different
                     <elcode>xsl:decimal-format</elcode> declarations having the same <termref def="dt-import-precedence">import precedence</termref>, unless there is
                     another definition of the same attribute with higher import precedence.</p>
               </error>
            </p>
            <p>The following attributes control the interpretation of characters in the 
               <termref def="dt-picture-string">picture string</termref> supplied to the
               <xfunction>format-number</xfunction> function, and also specify characters that
               may appear in the result of formatting the number. In each case the value
               <rfc2119>must</rfc2119> be a single character <errorref class="SE" code="0020"/>.</p>
            <ulist>
               <item>
                  <p>
                     <code>decimal-separator</code> specifies the character used to separate the
                     integer part from the fractional part of the formatted number; the default
                     value is the period character (<code>.</code>)</p>
               </item>
               <item>
                  <p diff="add" at="2023-07-04">
                     <code>exponent-separator</code> specifies the character used to separate the
                     mantissa from the exponent in scientific notation; the default value is the 
                     character <code>"e"</code>.</p>
               </item>   
               <item>
                  <p>
                     <code>grouping-separator</code> specifies the character typically used as a
                     thousands separator; the default value is the comma character
                     (<code>,</code>)</p>
               </item>
               <item>
                  <p>
                     <code>percent</code> specifies the character used to indicate that the number
                     is represented as a per-hundred fraction; the default value is the percent
                     character (<code>%</code>)</p>
               </item>
               <item>
                  <p>
                     <code>per-mille</code> specifies the character used to indicate that the number
                     is represented as a per-thousand fraction; the default value is the Unicode
                     per-mille character (#x2030)</p>
               </item>
               <item>
                  <p>
                     <code>zero-digit</code> specifies the character used to represent the digit
                     zero; the default value is the Western digit zero (<code>0</code>). This
                     character <rfc2119>must</rfc2119> be a digit (category <code>Nd</code> in the
                     Unicode property database), and it <rfc2119>must</rfc2119> have the numeric
                     value zero. This attribute implicitly defines the Unicode character that is
                     used to represent each of the values 0 to 9 in the final result string: Unicode
                     is organized so that each set of decimal digits forms a contiguous block of
                     characters in numerical sequence.</p>
               </item>
            </ulist>
            <p>
               <error spec="XT" type="static" class="SE" code="1295">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the character
                     specified in the <code>zero-digit</code> attribute is not a digit or is a digit
                     that does not have the numeric value zero. </p>
               </error>
            </p>
            <p>The following attributes control the interpretation of characters in the <termref def="dt-picture-string">picture string</termref> supplied to the
               <xfunction>format-number</xfunction> function. In each case the value
               <rfc2119>must</rfc2119> be a single character <errorref class="SE" code="0020"/>.</p>
            <ulist>
               <item>
                  <p>
                     <code>digit</code> specifies the character used in the <termref def="dt-picture-string">picture string</termref> as a place-holder for an
                     optional digit; the default value is the number sign character
                     (<code>#</code>)</p>
               </item>
               <item>
                  <p>
                     <code>pattern-separator</code> specifies the character used to separate
                     positive and negative sub-pictures in a <termref def="dt-picture-string">picture string</termref>; the default value is the semi-colon character
                     (<code>;</code>)</p>
               </item>
            </ulist>
            <p>The following attributes specify characters or strings that may appear in the result
               of formatting the number:</p>
            <ulist>
               <item>
                  <p>
                     <code>infinity</code> specifies the string used to represent the
                     <code>xs:double</code> value <code>INF</code>; the default value is the
                     string <code>Infinity</code>
                  </p>
               </item>
               <item>
                  <p>
                     <code>NaN</code> specifies the string used to represent the
                     <code>xs:double</code> value <code>NaN</code> (not-a-number); the default
                     value is the string <code>NaN</code>
                  </p>
               </item>
               <item>
                  <p>
                     <code>minus-sign</code> specifies the character used to signal a negative
                     number; the default value is the hyphen-minus character (<code>-</code>, #x2D).
                     The value <rfc2119>must</rfc2119> be a single character.</p>
               </item>
            </ulist>
            <p>
               <error spec="XT" type="static" class="SE" code="1300">
                  <p>It is a <termref def="dt-static-error">static error</termref> if, for any named
                     or unnamed decimal format, the variables representing characters used in a
                     <termref def="dt-picture-string">picture string</termref> do not each have
                     distinct values. These variables are <var>decimal-separator-sign</var>,
                     <var>grouping-sign</var>, <var>percent-sign</var>,
                     <var>per-mille-sign</var>, <var>digit-zero-sign</var>, <var>digit-sign</var>,
                     and <var>pattern-separator-sign</var>.</p>
               </error>
            </p>
            <p>Every (named or unnamed) decimal format defined in a <termref def="dt-stylesheet">package</termref> is added to the <xtermref spec="XP40" ref="dt-static-decimal-formats">statically known decimal formats</xtermref> in the
               <xtermref spec="XP40" ref="dt-static-context">static context</xtermref> of every
               expression in the <termref def="dt-package">package</termref>, excluding expressions
               appearing in <code>[xsl:]use-when</code> attributes.</p>
            
         </div2>
         <div2 id="value-templates">
            <head>Value Templates</head>
            <p>The string value of an attribute or text node in the stylesheet may in particular
               circumstances contain embedded expressions enclosed between curly brackets.
               Attributes and text nodes that use (or are permitted to use) this mechanism are
               referred to respectively as <termref def="dt-attribute-value-template">attribute
                  value templates</termref> and <termref def="dt-text-value-template">text value
                  templates</termref>.</p>

            <p><termdef id="dt-value-template" term="value template">Collectively,
                  attribute value templates and text value templates are referred to as <term>value
                     templates</term>.</termdef></p>

            <p>A value template is a string consisting of an alternating sequence of fixed parts and
               variable parts:</p>
            <ulist>
               <item><p>A variable part consists of an optional XPath <termref def="dt-expression">expression</termref> enclosed in curly brackets (<code>{}</code>):
                  more specifically, a string conforming 
                     to the XPath production <code>Expr?</code>.</p>
                  <note>
                     <p>An expression within a variable part may contain an unescaped curly bracket within
                        a <xnt spec="XP40" ref="prod-xpath40-StringLiteral">StringLiteral</xnt> or within
                        a comment.</p>
                     <p>Currently no XPath expression starts with an opening curly
                        bracket, so the use of <code>{{</code> creates no ambiguity. If an enclosed
                        expression ends with a closing curly bracket, no whitespace is required between
                        this and the closing delimiter.</p>
                     <p>The fact that the expression is optional means that the
                     string contained between the curly brackets may be zero-length, may comprise whitespace
                     only, or may contain XPath comments. The effective value in this case is a zero-length
                     string, which is equivalent to omitting the variable part entirely, together with its 
                     curly-bracket delimiters. </p> 
                  </note>
               </item>
               <item><p>A fixed part
                  may contain any characters, except that a left curly bracket <rfc2119>must</rfc2119>
                  be written as <code>{{</code> and a right curly bracket <rfc2119>must</rfc2119> be
                  written as <code>}}</code>. </p></item>
            </ulist>
               
 
           
            <p>
               <error spec="XT" type="static" class="SE" code="0350">
                  <p>It is a <termref def="dt-static-error">static error</termref> if an unescaped
                     left curly bracket appears in a fixed part of a value template without a
                     matching right curly bracket.</p>
               </error>
            </p>
            <p>It is a <termref def="dt-static-error">static error</termref> if the string contained
               between matching curly brackets in a value template does not match the XPath
               production <xnt spec="XP40" ref="prod-xpath40-Expr">Expr?</xnt>, or if it contains
               other XPath static errors. The error is signaled using the appropriate XPath error
               code.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0370">
                  <p>It is a <termref def="dt-static-error">static error</termref> if an unescaped
                     right curly bracket occurs in a fixed part of a value template.</p>
               </error>
            </p>
            <p>The result of evaluating a
               value template is referred to as its <termref def="dt-effective-value"/>. The
               effective value is the string obtained by concatenating the expansions of the fixed
               and variable parts:</p>
            <ulist>
               <item>
                  <p>The expansion of a fixed part is obtained by replacing any double curly
                     brackets (<code>{{</code> or <code>}}</code>) by the corresponding single curly
                     bracket.</p>
               </item>
               <item>
                  <p>The expansion of a variable part is as follows:</p>
                  <ulist>
                     <item><p>If an expression is present, the result of evaluating the enclosed XPath
                        <termref def="dt-expression">expression</termref> and converting the
                        resulting value to a string. This conversion is done using the rules given in
                        <specref ref="constructing-simple-content"/>.</p></item>
                     <item><p>If the expression is omitted, a zero-length string.</p></item>
                  </ulist>
               </item>
            </ulist>

            <note>
               <p>This process can generate dynamic errors, for example if the sequence contains an
                  element with a complex content type (which cannot be atomized).</p>
            </note>

            <p>In the case of an attribute value template, the effective value becomes the string
               value of the new attribute node. In the case of a text value template, the effective
               value becomes the string value of the new text node.</p>




            <div3 id="attribute-value-templates">
               <head>Attribute Value Templates</head>
               <p>
                  <termdef id="dt-attribute-value-template" term="attribute value template">In an
                     attribute that is designated as an <term>attribute value template</term>, such
                     as an attribute of a <termref def="dt-literal-result-element">literal result
                        element</termref>, an <termref def="dt-expression">expression</termref> can
                     be used by surrounding the expression with curly brackets (<code>{}</code>),
                     following the general rules for <termref def="dt-value-template">value
                        templates</termref></termdef>.</p>

               <p>Curly brackets are not treated specially in an attribute value in an XSLT <termref def="dt-stylesheet">stylesheet</termref> unless the attribute is specifically
                  designated as one that permits an attribute value template; in an element syntax
                  summary, the value of such attributes is surrounded by curly brackets.</p>
               <note>
                  <p>Not all attributes are designated as attribute value templates. Attributes
                     whose value is an <termref def="dt-expression">expression</termref> or <termref def="dt-pattern">pattern</termref>, attributes of <termref def="dt-declaration">declaration</termref> elements and attributes that
                     refer to named XSLT objects are generally not designated as attribute value
                     templates (an exception is the <code>format</code> attribute of
                        <elcode>xsl:result-document</elcode>). Namespace declarations are not XDM
                     attribute nodes and are therefore never treated as attribute value
                     templates.</p>
               </note>


               <p>If the element containing the attribute is processed
                     with <termref def="dt-xslt-10-behavior">XSLT 1.0 behavior</termref>, then the
                     rules for converting the value of the expression to a string (given in <specref ref="value-templates"/>) are modified as follows. After <termref def="dt-atomization">atomizing</termref> the result of the expression, all
                     items other than the first item in the resulting sequence are discarded, and
                     the effective value is obtained by converting the first item in the sequence to
                     a string. If the atomized sequence is empty, the result is a zero-length
                     string.</p>

               <note>
                  <p>The above rule applies to attribute value templates but not
                     to text value templates, since the latter were not available in XSLT 1.0.</p>
               </note>

               <example>
                  <head>Attribute Value Templates</head>
                  <p>The following example creates an <code>img</code> result element from a
                        <code>photograph</code> element in the source; the value of the
                        <code>src</code> and <code>width</code> attributes are computed using XPath
                     expressions enclosed in attribute value templates:</p>
                  <eg xml:space="preserve" role="xslt-declarations">&lt;xsl:variable name="image-dir" select="'/images'"/&gt;

&lt;xsl:template match="photograph"&gt;
  &lt;img src="{$image-dir}/{href}" width="{size/@width}"/&gt;
&lt;/xsl:template&gt;</eg>
                  <p>With this source</p>
                  <eg xml:space="preserve" role="xml">&lt;photograph&gt;
  &lt;href&gt;headquarters.jpg&lt;/href&gt;
  &lt;size width="300"/&gt;
&lt;/photograph&gt;</eg>
                  <p>the result would be</p>
                  <eg xml:space="preserve" role="xml">&lt;img src="/images/headquarters.jpg" width="300"/&gt;</eg>
               </example>
               <example>
                  <head>Producing a Space-Separated List</head>
                  <p>The following example shows how the values in a sequence are output as a
                     space-separated list. The following literal result element:</p>
                  <eg xml:space="preserve" role="xml">&lt;temperature readings="{10.32, 5.50, 8.31}"/&gt;</eg>
                  <p>produces the output node:</p>
                  <eg xml:space="preserve" role="xml">&lt;temperature readings="10.32 5.5 8.31"/&gt;</eg>
               </example>
               <p>Curly brackets are <emph>not</emph> recognized recursively inside expressions.</p>
               <example>
                  <head>Curly Brackets cannot be Nested</head>
                  <p>For example:</p>
                  <eg role="error" xml:space="preserve">&lt;a href="#{id({@ref})/title}"/&gt;</eg>
                  <p>is <emph>not</emph> allowed. Instead, use simply:</p>
                  <eg xml:space="preserve" role="xml">&lt;a href="#{id(@ref)/title}"/&gt;</eg>
               </example>
            </div3>

            <div3 id="text-value-templates">
               <head>Text Value Templates</head>

               <p>The <termref def="dt-standard-attributes">standard attribute</termref>
                  <code>[xsl:]expand-text</code> may appear on any element in the stylesheet, and
                  determines whether descendant text nodes of that element are treated as text value
                  templates. A text node in the stylesheet is treated as a text value template if
                  (a) it is part of a <termref def="dt-sequence-constructor">sequence
                     constructor</termref>
                  or a child of an <elcode>xsl:text</elcode>
                     instruction, (b) there is an ancestor element with an
                     <code>[xsl:]expand-text</code> attribute, and (c) on the innermost ancestor
                  element that has such an attribute, the value of the attribute is
                  <code>yes</code>. The attribute is boolean and
                        <rfc2119>must</rfc2119> therefore take one of the values <code>yes</code>
                     (synonyms <code>true</code> or <code>1</code>) or <code>no</code> (synonyms
                        <code>false</code> or <code>0</code>). </p>

               <p>This section describes how text nodes  are processed when the <termref def="dt-effective-value"/> is
                     <code>yes</code>. Such text nodes are referred to as text value templates.</p>

               <p>
                  <termdef id="dt-text-value-template" term="text value template">In a text node
                     that is designated as a <term>text value template</term>, <termref def="dt-expression">expressions</termref> can be used by surrounding each
                     expression with curly brackets (<code>{}</code>).</termdef></p>

               <p>The rules for text value templates are given in <specref ref="value-templates"/>.
                  A text node 
                  whose value is a text value template results in the construction of a text node in
                  the result of the containing sequence
                     constructor or <elcode>xsl:text</elcode> instruction. The string value
                  of that text node is obtained by computing the <termref def="dt-effective-value"/> of the value
                  template.</p>

               <note>
                  

                  <p>The result of evaluating a text value template is a (possibly zero-length) text
                     node. This text node becomes part of the result of the containing sequence
                     constructor or <elcode>xsl:text</elcode> instruction, and is thereafter handled
                     exactly as if the value had appeared explicitly as a text node in the
                     stylesheet.</p>

                  <p>The way in which the effective value is computed does not depend on any
                        <code>separator</code> attribute on a containing
                        <elcode>xsl:value-of</elcode> or <elcode>xsl:attribute</elcode> instruction.
                     The <code>separator</code> attribute only affects how the text node is combined
                     with adjacent items in the result of the containing sequence constructor.</p>

                  <p>Fixed parts consisting entirely of whitespace are significant and are handled
                     in the same way as any other fixed part. This is different from the default
                     treatment of “boundary space” in XQuery.</p>


               </note>



               <example>
                  <head>Using a text value template to construct message output</head>
                  <eg role="xslt-instructions" xml:space="preserve">&lt;xsl:variable name="id" select="'A123'"/&gt;
&lt;xsl:variable name="step" select="5"/&gt;
&lt;xsl:message expand-text="yes"
     &gt;Processing id={$id}, step={$step}&lt;/xsl:message&gt;
</eg>
                  <p>This will typically output the message text <code>Processing id=A123,
                        step=5</code>.</p>
               </example>

               <example>
                  <head>Using a text value template to define the result of a function</head>
                  <eg role="xslt-declaration xmlns:f='f'" xml:space="preserve">&lt;xsl:function name="f:sum" expand-text="yes" as="xs:integer"&gt;
&lt;xsl:param name="x" as="xs:integer"/&gt;
&lt;xsl:param name="y" as="xs:integer"/&gt;
  {$x + $y}
&lt;/xsl:function&gt;</eg>
                  <p>Note that although this is a very readable way of expressing the computation
                     performed by the function, the semantics are somewhat complex, and this could
                     mean that execution is inefficient. The function computes the value of <code>$x
                        + $y</code> as an integer, and then constructs a text node containing the
                     string representation of this integer (preceded and followed by whitespace).
                     Because the declared result type of the function is <code>xs:integer</code>,
                     this text node is then atomized, giving an <code>xs:untypedAtomic</code> value,
                     and the <code>xs:untypedAtomic</code> value is then cast to an
                        <code>xs:integer</code>.</p>
               </example>

               <note>
                  <p>The main motivations for adding text value templates to the XSLT language are
                     firstly, to make it easier to construct parameterized text in contexts such as
                        <elcode>xsl:value-of</elcode> and <elcode>xsl:message</elcode>, and
                     secondly, to allow use of complex multi-line XPath expressions where
                     maintaining correct indentation is important for readability. The fact that XML
                     processors are required to normalize whitespace in attribute values means that
                     writing such expressions within a <code>select</code> attribute is not
                     ideal.</p>

                  <p>The facility is only present if enabled using the
                        <code>[xsl:]expand-text</code> attribute. This is partly for backwards
                     compatibility, and partly to avoid creating difficulties when constructing
                     content that is rich in curly brackets, for example JavaScript code or CSS
                     style sheets.</p>
               </note>




            </div3>
         </div2>
         <div2 id="sequence-constructors">
            <head>Sequence Constructors</head>
            <p>
               <termdef id="dt-sequence-constructor" term="sequence constructor">A <term>sequence
                     constructor</term> is a sequence of zero or more sibling nodes in the <termref def="dt-stylesheet">stylesheet</termref> that can be evaluated to return a
                  sequence of nodes, atomic values, and function
                     items. The way that the resulting sequence is used depends on the
                  containing instruction.</termdef>
            </p>
            <p>Many <termref def="dt-xslt-element">XSLT elements</termref>, and also <termref def="dt-literal-result-element">literal result elements</termref>, are defined to
               take a <termref def="dt-sequence-constructor"/> as their content.</p>

            <p>Four kinds of nodes may be encountered in a sequence constructor:</p>
            <olist>
               <item>
                  <p> A <emph>Text node</emph> appearing in the <termref def="dt-stylesheet">stylesheet</termref> (if it has not been removed in the process of
                     whitespace stripping: see <specref ref="stylesheet-stripping"/>) is processed as follows:</p>
                  <olist>
                     <item>
                        <p>if the <termref def="dt-effective-value"/> of the standard attribute
                              <code>[xsl:]expand-text</code> is <code>no</code>, or in the absence
                           of this attribute, the text node in the stylesheet is copied to create a
                           new parentless text node in the result of the sequence constructor.</p>
                        
                     </item>
                     <item>
                        <p>Otherwise (the <termref def="dt-effective-value"/> of <code>[xsl:]expand-text</code> is
                              <code>yes</code>), the text node in the stylesheet is processed as
                           described in <specref ref="text-value-templates"/>.</p>
                     </item>
                  </olist>
               </item>
               <item>
                  <p> A <termref def="dt-literal-result-element">literal result element</termref> is
                     evaluated to create a new parentless element node, having the same <termref def="dt-expanded-qname">expanded QName</termref> as the literal result
                     element: see <specref ref="literal-result-element"/>. </p>
               </item>
               <item>
                  <p>An XSLT <termref def="dt-instruction">instruction</termref> produces a sequence
                     of zero, one, or more items as its result. For most XSLT instructions, these
                     items are nodes, but some instructions (such
                        as
                     <elcode>xsl:sequence</elcode> and <elcode>xsl:copy-of</elcode>) can also
                     produce atomic values or function items.
                     Several instructions, such as <elcode>xsl:element</elcode>, return a newly
                     constructed parentless node (which may have its own attributes, namespaces,
                     children, and other descendants). Other instructions, such as
                        <elcode>xsl:if</elcode>, pass on the items produced by their own nested
                     sequence constructors. The <elcode>xsl:sequence</elcode> instruction may return
                     atomic values, function items, or existing
                     nodes.</p>
               </item>
               <item>
                  <p> An <termref def="dt-extension-instruction"/> (see <specref ref="extension-instruction"/>) also produces a sequence of items as its
                     result.</p>
               </item>
            </olist>
            <p><termdef id="dt-immediate-result" term="immediate result">The result of evaluating
               a <termref def="dt-sequence-constructor"/> is the sequence
               of items formed by concatenating the results of evaluating each of the nodes in the
               sequence constructor, retaining order. This is 
                  referred to as the <term>immediate result</term>
            of the sequence constructor.</termdef></p>
            <p>However:</p>
            <ulist>
               <item>
                  <p>For the effect of the <elcode>xsl:fallback</elcode> instruction, see <specref ref="fallback"/>.</p>
               </item>
               <item>
                  <p>For the effect of the <elcode>xsl:on-empty</elcode> and
                        <elcode>xsl:on-non-empty</elcode> instructions, see <specref ref="conditional-content-construction"/>.</p>
               </item>
            </ulist>
            <p>The way that <termref def="dt-immediate-result"/> of a <termref def="dt-sequence-constructor"/> 
               is used depends on the containing element in the stylesheet, and is specified in the rules 
               for that element. It is typically one of the following:</p>
            <ulist>
               <item>
                  <p>The <termref def="dt-immediate-result"/> may be bound to a <termref def="dt-variable"/> or 
                     delivered as the result of a <termref def="dt-stylesheet-function"/>.
                     In this case the <code>as</code> attribute of the containing <elcode>xsl:variable</elcode>
                     or <elcode>xsl:function</elcode> element may be used to declare its required type, 
                     and the <termref def="dt-immediate-result"/> is then converted to the required type 
                     by applying the <termref def="dt-coercion-rules"/>.</p>
                     
                     <note>
                        <ulist>
                           <item><p>In the absence of an <code>as</code> attribute, the result of a 
                              function is the <termref def="dt-immediate-result"/> of the sequence constructor; 
                              but the value of a variable (for backwards compatibility reasons) is a document node 
                              whose content is formed by applying the rules in <specref ref="constructing-complex-content"/> 
                              to the <termref def="dt-immediate-result"/>.
                           </p></item>
                           <item><p>The coercion rules do not merge adjacent text nodes 
                              or insert separators between adjacent items. This means it is often inappropriate 
                              to use <elcode>xsl:value-of</elcode> in the body of <elcode>xsl:variable</elcode> or 
                              <elcode>xsl:function</elcode>, especially when the intent is to return an atomic result. 
                              The <elcode>xsl:sequence</elcode> instruction is designed for this purpose, and 
                              is usually a better choice.
                           </p></item>
                           <item><p>The result of a function, or the value of a variable, may contain nodes 
                              (such as elements, attributes, and text nodes) that are not attached to any parent node 
                              in a <termref def="dt-result-tree"/>.  The semantics of XPath expressions when applied to parentless nodes 
                              are well-defined; however, such expressions should be used with care. For example, 
                              the expression <code>/</code> causes a type error if the root of the tree containing 
                              the context node is not a document node.
                           </p></item>
                           <item><p>Parentless attribute nodes require particular care because they have no
                              namespace nodes associated with them. A parentless attribute node is not
                              permitted to contain namespace-sensitive content (for example, a QName or an
                              XPath expression) because there is no information enabling the prefix to be
                              resolved to a namespace URI. Parentless attributes can be useful in an
                              application (for example, they provide an alternative to the use of
                              attribute sets: see <specref ref="attribute-sets"/>) but they need to be
                              handled with care.</p></item>
                        </ulist>
                     </note>
      
               </item>
               <item>
                  <p>The sequence may be returned as the result of the containing element. This
                     happens, for example, when 
                     the element containing the
                     sequence constructor is 
                        <elcode>xsl:break</elcode>,
                        <elcode>xsl:catch</elcode>, 
                        <elcode>xsl:fallback</elcode>, <elcode>xsl:for-each</elcode>,
                        <elcode>xsl:for-each-group</elcode>, <elcode>xsl:fork</elcode>, <elcode>xsl:if</elcode>, <elcode>xsl:iterate</elcode>,
                        <elcode>xsl:matching-substring</elcode>, 
                        <elcode>xsl:non-matching-substring</elcode>, <elcode>xsl:on-completion</elcode>,
                        <elcode>xsl:otherwise</elcode>, <elcode>xsl:perform-sort</elcode>,
                        <elcode>xsl:sequence</elcode>, <elcode>xsl:try</elcode>, or <elcode>xsl:when</elcode>. </p>
               </item>
               <item>
                  <p>The sequence may be used to construct the content of a new element or document
                     node. This happens when the sequence constructor appears as the content of a
                        <termref def="dt-literal-result-element">literal result element</termref>,
                     or of one of the instructions <elcode>xsl:copy</elcode>,
                        <elcode>xsl:element</elcode>, <elcode>xsl:document</elcode>,
                        <elcode>xsl:result-document</elcode>, <elcode>xsl:assert</elcode>, or <elcode>xsl:message</elcode>.
                     It also happens when the sequence constructor is contained in one of the
                     elements <elcode>xsl:variable</elcode>, <elcode>xsl:param</elcode>, or
                        <elcode>xsl:with-param</elcode>,  when this instruction has no
                        <code>as</code> attribute. For details, see <specref ref="constructing-complex-content"/>.</p>
               </item>
               <item>
                  <p>The sequence may be used to construct the <termref def="dt-string-value">string
                        value</termref> of an attribute node, text node, namespace node, comment
                     node, or processing instruction node. This happens when the sequence
                     constructor is contained in one of the elements <elcode>xsl:attribute</elcode>,
                        <elcode>xsl:value-of</elcode>, <elcode>xsl:namespace</elcode>,
                        <elcode>xsl:comment</elcode>, or
                     <elcode>xsl:processing-instruction</elcode>. For details, see <specref ref="constructing-simple-content"/>.</p>
               </item>
            </ulist>
            

            <div3 id="constructing-complex-content">
               <head>Constructing Complex Content</head>
               
               <p>Many instructions, for example <elcode>xsl:copy</elcode>, <elcode>xsl:element</elcode>, 
                  <elcode>xsl:document</elcode>, <elcode>xsl:result-document</elcode>, and 
                  <termref def="dt-literal-result-element">literal result elements</termref>, 
                  create a new parent node, and evaluate a <termref def="dt-sequence-constructor"/> 
                  forming the content of the instruction to create the attributes, 
                  namespaces, and children of the new parent node. The <termref def="dt-immediate-result"/> 
                  of the sequence constructor is processed to create the content of the new parent 
                  node as described in this section.</p>

               <p>When constructing the content of an element, the <code>inherit-namespaces</code>
                  attribute of the <elcode>xsl:element</elcode> or <elcode>xsl:copy</elcode>
                  instruction, or the <code>xsl:inherit-namespaces</code> property of the literal
                  result element, determines whether namespace nodes are to be inherited. The effect
                  of this attribute is described in the rules that follow.</p>
               <p>The <termref def="dt-immediate-result"/> of the <termref def="dt-sequence-constructor"/>
                  is processed as follows (applying the rules in the order they are listed):</p>
               <olist>
                  <item>
                     <p>The containing instruction may generate attribute nodes and/or namespace
                        nodes, as specified in the rules for the individual instruction. For
                        example, these nodes may be produced by expanding an
                           <code>[xsl:]use-attribute-sets</code> attribute, or by expanding the
                        attributes of a <termref def="dt-literal-result-element">literal result
                           element</termref>. Any such nodes are prepended to the 
                        <termref def="dt-immediate-result"/> of the <termref def="dt-sequence-constructor"/>.</p>
                  </item>
                  <item>
                     <p>Any array item in the sequence (see <specref ref="arrays"/>)
                     is replaced by its members, recursively. This is equivalent to applying
                     the <xfunction spec="FO40">array:flatten</xfunction> function defined in 
                     <bibref ref="xpath-functions-31"/>.</p>
                     <note diff="del" at="2022-01-01"><p>This situation only arises if the XPath 3.1 feature is implemented.
                     Note that if the array contains nodes, this operation leaves the nodes in the sequence: they
                     are not <termref def="dt-atomization">atomized</termref>.</p></note>
                  </item>
                  <item>
                     <p>Any atomic value in the sequence is cast to a string.</p>
                     <note>
                        <p>Casting from <code>xs:QName</code> or <code>xs:NOTATION</code> to
                              <code>xs:string</code> always succeeds, because these values retain a
                           prefix for this purpose. However, there is no guarantee that the prefix
                           used will always be meaningful in the context where the resulting string
                           is used.</p>
                     </note>
                  </item>
                  <item>
                     <p>Any consecutive sequence of strings in the sequence is converted
                        to a single text node, whose <termref def="dt-string-value">string
                           value</termref> contains the content of each of the strings in turn, with
                        a single space (#x20) used as a separator between successive strings.</p>
                  </item>
                  <item>
                     <p>Any document node within the sequence is replaced by a sequence
                        containing each of its children, in document order.</p>
                  </item>
                  <item>
                     <p>Zero-length text nodes within the sequence are removed.</p>
                  </item>
                  <item>
                     <p>Adjacent text nodes within the sequence are merged into a single text
                        node.</p>
                  </item>
                  <item>
                     <p>Invalid items in the sequence are
                        detected as follows.</p>
                     <p>
                        <error spec="XT" type="dynamic" class="DE" code="0410">
                           <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the 
                              sequence used to construct the content of an element node contains a
                              namespace node or attribute node that is preceded in the sequence by a
                              node that is neither a namespace node nor an attribute node.</p>
                        </error>
                     </p>
                     <p>
                        <error spec="XT" type="dynamic" class="DE" code="0420">
                           <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the 
                              sequence used to construct the content of a document node contains a
                              namespace node or attribute node.</p>
                        </error>
                     </p>
                     <p>
                        <error spec="XT" type="dynamic" class="DE" code="0430">
                           <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the 
                              sequence contains two or more namespace nodes having the same name but
                              different <termref def="dt-string-value">string values</termref> (that
                              is, namespace nodes that map the same prefix to different namespace
                              URIs).</p>
                        </error>
                     </p>
                     <p>
                        <error spec="XT" type="dynamic" class="DE" code="0440">
                           <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the 
                              sequence contains a namespace node with no name and the element node
                              being constructed has a null namespace URI (that is, it is an error to
                              define a default namespace when the element is in no namespace). </p>
                        </error>
                     </p>
                     <p diff="add" at="E">
                        <error spec="XT" type="type" class="DE" code="0450">
                           <p>It is a <termref def="dt-type-error">type error</termref> if the result
                              sequence contains a function item. </p>
                        </error>
                     </p>
                     <note diff="add" at="E">
                        <p>The error code reflects the fact that this error was at one time classified 
                           as a dynamic error rather than a type error. [XSLT 3.0 Erratum E17, bug 30223].</p>
                     </note>
                  </item>
                  <item>
                     <p>If the sequence contains two or more namespace nodes with the same
                        name (or no name) and the same <termref def="dt-string-value">string
                           value</termref> (that is, two namespace nodes mapping the same prefix to
                        the same namespace URI), then all but one of the duplicate nodes are
                        discarded.</p>
                     <note>
                        <p>Since the order of namespace nodes is <termref def="dt-implementation-dependent">implementation-dependent</termref>,
                           it is not significant which of the duplicates is retained.</p>
                     </note>
                  </item>
                  <item>
                     <!--Text replaced by erratum E10 change 1"-->
                     <p>If an attribute <var>A</var> in the sequence has the same name as
                        another attribute <var>B</var> that appears later in the sequence,
                        then attribute <var>A</var> is discarded from the sequence. Before
                        discarding attribute <var>A</var>, the processor <rfc2119>may</rfc2119>
                        signal any <termref def="dt-type-error">type errors</termref> that would be
                        signaled if attribute <var>B</var> were not present. </p>
                     <!--End of text replaced by erratum E10-->
                  </item>
                  <item>
                     <p>Each node in the resulting sequence is attached as a namespace, attribute,
                        or child of the newly constructed element or document node. Conceptually
                        this involves making a deep copy of the node; in practice, however, copying
                        the node will only be necessary if the existing node can be referenced
                        independently of the parent to which it is being attached. When copying an
                        element or processing instruction node, its base URI property is changed to
                        be the same as that of its new parent, unless it has an
                           <code>xml:base</code> attribute (see <bibref ref="xmlbase"/>) that
                        overrides this. If the copied element has an <code>xml:base</code>
                        attribute, its base URI is the value of that attribute, resolved (if it is
                        relative) against the base URI of the new parent node.</p>
                     <p>Except for the handling of base URI, the copying
                        of a node follows the rules of the <elcode>xsl:copy-of</elcode> instruction
                        with attributes <code>copy-namespaces="yes" copy-accumulators="no"
                           validation="preserve"</code>.</p>
                     <note>
                        <p>This has the consequence that the type annotation and the values of the
                              <code>nilled</code>, <code>is-id</code>, and <code>is-idrefs</code>
                           properties are retained. However, if the node under construction (the new
                           parent of the node being copied) uses a validation mode other than
                              <code>preserve</code>, this will be transient: the values will be
                           recomputed when the new parent node is validated.</p>
                     </note>
                  </item>
                  <item>
                     <p>If the newly constructed node is an element node, then namespace fixup is
                        applied to this node, as described in <specref ref="namespace-fixup"/>.</p>
                  </item>
                  <item>
                     <p>If the newly constructed node is an element node, and if namespaces are
                        inherited, then each namespace node of the newly constructed element
                        (including any produced as a result of the namespace fixup process) is
                        copied to each descendant element of the newly constructed element, unless
                        that element or an intermediate element already has a namespace node with
                        the same name (or absence of a name) or that descendant element or an
                        intermediate element is in no namespace and the namespace node has no
                        name.</p>
                  </item>
               </olist>
               <example>
                  <head>A Sequence Constructor for Complex Content</head>
                  <p>Consider the following stylesheet fragment:</p>
                  <eg xml:space="preserve" role="xslt-instruction">&lt;td&gt;
  &lt;xsl:attribute name="valign"&gt;top&lt;/xsl:attribute&gt;
  &lt;xsl:value-of select="@description"/&gt;
&lt;/td&gt;</eg>
                  <p>This fragment consists of a literal result element <code>td</code>, containing
                     a sequence constructor that consists of two instructions:
                        <elcode>xsl:attribute</elcode> and <elcode>xsl:value-of</elcode>. The
                     sequence constructor is evaluated to produce a sequence of two nodes: a
                     parentless attribute node, and a parentless text node. The <code>td</code>
                     instruction causes a <code>td</code> element to be created; the new attribute
                     therefore becomes an attribute of the new <code>td</code> element, while the
                     text node created by the <elcode>xsl:value-of</elcode> instruction becomes a
                     child of the <code>td</code> element (unless it is zero-length, in which case
                     it is discarded).</p>
               </example>
               <example>
                  <head>Space Separators in Element Content</head>
                  <p>Consider the following stylesheet fragment:</p>
                  <eg xml:space="preserve" role="xslt-instruction">&lt;doc&gt;
  &lt;e&gt;&lt;xsl:sequence select="1 to 5"/&gt;&lt;/e&gt;
  &lt;f&gt;
    &lt;xsl:for-each select="1 to 5"&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/f&gt;
&lt;/doc&gt;</eg>
                  <p>This produces the output (when indented):</p>
                  <eg xml:space="preserve" role="xml">&lt;doc&gt;
  &lt;e&gt;1 2 3 4 5&lt;/e&gt;
  &lt;f&gt;12345&lt;/f&gt;
&lt;/doc&gt;</eg>
                  <p>The difference between the two cases is that for the <code>e</code> element,
                     the sequence constructor generates a sequence of five atomic values, which are
                     therefore separated by spaces. For the <code>f</code> element, the content is a
                     sequence of five text nodes, which are concatenated without space
                     separation.</p>
                  <p>It is important to be aware of the distinction between
                        <elcode>xsl:sequence</elcode>, which returns the value of its
                        <code>select</code> expression unchanged, and <elcode>xsl:value-of</elcode>,
                     which constructs a text node.</p>
               </example>
            </div3>
            <div3 id="constructing-simple-content">
               <head>Constructing Simple Content</head>
               <p>The instructions <elcode>xsl:attribute</elcode>, <elcode>xsl:comment</elcode>,
                     <elcode>xsl:processing-instruction</elcode>, <elcode>xsl:namespace</elcode>,
                  and <elcode>xsl:value-of</elcode> all create nodes that cannot have children.
                  Specifically, the <elcode>xsl:attribute</elcode> instruction creates an attribute
                  node, <elcode>xsl:comment</elcode> creates a comment node,
                     <elcode>xsl:processing-instruction</elcode> creates a processing instruction
                  node, <elcode>xsl:namespace</elcode> creates a namespace node, and
                     <elcode>xsl:value-of</elcode> creates a text node. The string value of the new
                  node is constructed using either the <code>select</code> attribute of the
                  instruction, or the <termref def="dt-sequence-constructor">sequence
                     constructor</termref> that forms the content of the instruction. The
                     <code>select</code> attribute allows the content to be specified by means of an
                  XPath expression, while the sequence constructor allows it to be specified by
                  means of a sequence of XSLT instructions. The <code>select</code> attribute or
                  sequence constructor is evaluated to produce a result sequence, and the <termref def="dt-string-value">string value</termref> of the new node is derived from
                  this result sequence according to the rules below.</p>
               <p>These rules are also used to compute the <termref def="dt-effective-value">effective value</termref> of a <termref def="dt-value-template">value template</termref>. In this case the
                  sequence being processed is the result of evaluating an XPath expression enclosed
                  between curly brackets, and the separator is a single space character.</p>
               <olist>
                  <item>
                     <p>Zero-length text nodes in the sequence are discarded.</p>
                  </item>
                  <item>
                     <p>Adjacent text nodes in the sequence are merged into a single text node.</p>
                  </item>
                  <item>
                     <p>The sequence is <termref def="dt-atomization">atomized</termref>
                        (which may cause a dynamic error).</p>
                  </item>
                  <item>
                     <p>Every value in the atomized sequence is cast to a string.</p>
                  </item>
                  <item>
                     <p>The strings within the resulting sequence are concatenated, with a (possibly
                        zero-length) separator inserted between successive strings. The default
                        separator depends on the containing instruction; except where
                        otherwise specified, it is a single space.</p>
                     
                     <p>In the case of <elcode>xsl:attribute</elcode>
                        and <elcode>xsl:value-of</elcode>, the default separator is a single space
                     when the <code>select</code> attribute is used, or a zero-length string otherwise; 
                     a different separator can be specified
                        using the <code>separator</code> attribute of the instruction.</p>
                        <p>In the case of <elcode>xsl:comment</elcode>,
                        <elcode>xsl:processing-instruction</elcode>, and
                           <elcode>xsl:namespace</elcode>, and when expanding a <termref def="dt-value-template">value
                        template</termref>, the default separator cannot be changed.</p>
                  </item>
                  <item>
                     <p>In the case of <elcode>xsl:processing-instruction</elcode>, any leading
                        spaces in the resulting string are removed.</p>
                  </item>
                  <item>
                     <p>The resulting string forms the <termref def="dt-string-value">string
                           value</termref> of the new attribute, namespace, comment,
                        processing-instruction, or text node.</p>
                  </item>
               </olist>
               <example>
                  <head>Space Separators in Attribute Content</head>
                  <p>Consider the following stylesheet fragment:</p>
                  <eg xml:space="preserve" role="xslt-instruction">&lt;doc&gt;
  &lt;xsl:attribute name="e" select="1 to 5"/&gt;
  &lt;xsl:attribute name="f"&gt;
    &lt;xsl:for-each select="1 to 5"&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="g" expand-text="yes"&gt;{1 to 5}&lt;/xsl:attribute&gt;
&lt;/doc&gt;</eg>
                  <p>This produces the output:</p>
                  <eg xml:space="preserve" role="xml">&lt;doc e="1 2 3 4 5" f="12345" g="1 2 3 4 5"/&gt;</eg>
                  <p>The difference between the three cases is as follows. For the
                        <code>e</code> attribute, the sequence constructor generates a sequence of
                     five atomic values, which are therefore separated by spaces. For the
                        <code>f</code> attribute, the content is supplied as a sequence of five text
                     nodes, which are concatenated without space separation. For the <code>g</code>
                     attribute, the <termref def="dt-text-value-template"/> constructs a text node
                     using the rules for constructing simple content, which insert space separators
                     between atomic values; the text node is then atomized to form the value of the
                     attribute.</p>
                  <p>Specifying <code>separator=""</code> on the first
                        <elcode>xsl:attribute</elcode> instruction would cause the attribute value
                     to be <code>e="12345"</code>. A <code>separator</code> attribute on the second
                        <elcode>xsl:attribute</elcode> instruction would have no effect, since the
                     separator only affects the way adjacent atomic values are handled: separators
                     are never inserted between adjacent text nodes. A
                           <code>separator</code> on the third <elcode>xsl:attribute</elcode>
                        instruction would also have no effect, because text value templates are
                        evaluated without regard to the containing instruction.</p>
               </example>
               <note>
                  <p>If an attribute value template contains a sequence of fixed and variable parts,
                     no additional whitespace is inserted between the expansions of the fixed and
                     variable parts. For example, the <termref def="dt-effective-value">effective
                        value</termref> of the attribute <code>a="chapters{4 to 6}"</code> is
                        <code>a="chapters4 5 6"</code>.</p>
               </note>
            </div3>
            <div3 id="namespace-fixup">
               <head>Namespace Fixup</head>
               <p>In a tree supplied to or constructed by an XSLT processor, the constraints
                  relating to namespace nodes that are specified in <bibref ref="xpath-datamodel-30"/>
                  <rfc2119>must</rfc2119> be satisfied. For example:</p>
               <ulist>
                  <item>
                     <p>If an element node has an <termref def="dt-expanded-qname">expanded
                           QName</termref> with a non-null namespace URI, then that element node
                           <rfc2119>must</rfc2119> have at least one namespace node whose <termref def="dt-string-value">string value</termref> is the same as that
                        namespace URI.</p>
                  </item>
                  <item>
                     <p>If an element node has an attribute node whose <termref def="dt-expanded-qname">expanded QName</termref> has a non-null namespace
                        URI, then the element <rfc2119>must</rfc2119> have at least one namespace
                        node whose <termref def="dt-string-value">string value</termref> is the same
                        as that namespace URI and whose name is non-empty.</p>
                  </item>
                  <item>
                     <p>Every element <rfc2119>must</rfc2119> have a namespace node whose <termref def="dt-expanded-qname">expanded QName</termref> has local-part
                           <code>xml</code> and whose <termref def="dt-string-value">string
                           value</termref> is <code>http://www.w3.org/XML/1998/namespace</code>. The
                        namespace prefix <code>xml</code>
                        <rfc2119>must</rfc2119> not be associated with any other namespace URI, and
                        the namespace URI <code>http://www.w3.org/XML/1998/namespace</code>
                        <rfc2119>must</rfc2119> not be associated with any other prefix.</p>
                  </item>
                  <item>
                     <!--Text replaced by erratum E6 change 7"-->
                     <p>A namespace node <rfc2119>must not</rfc2119> have the name
                           <code>xmlns</code> or the string value
                           <code>http://www.w3.org/2000/xmlns/</code>.</p>
                     <!--End of text replaced by erratum E6-->
                  </item>
               </ulist>
               <p>
                  <termdef id="dt-namespace-fixup" term="namespace fixup">The rules for the
                     individual XSLT instructions that construct a <termref def="dt-result-tree">result tree</termref> (see <specref ref="creating-new-nodes"/>) prescribe
                     some of the situations in which namespace nodes are written to the tree. These
                     rules, however, are not sufficient to ensure that the prescribed constraints
                     are always satisfied. The XSLT processor <rfc2119>must</rfc2119> therefore add
                     additional namespace nodes to satisfy these constraints. This process is
                     referred to as <term>namespace fixup</term>.</termdef>
               </p>
               <p>The actual namespace nodes that are added to the tree by the namespace fixup
                  process are <termref def="dt-implementation-dependent">implementation-dependent</termref>, provided firstly, that at the end of the
                  process the above constraints <rfc2119>must</rfc2119> all be satisfied, and
                  secondly, that a namespace node <rfc2119>must not</rfc2119> be added to the tree
                  unless the namespace node is necessary either to satisfy these constraints, or to
                  enable the tree to be serialized using the original namespace prefixes from the
                  source document or <termref def="dt-stylesheet">stylesheet</termref>.</p>
               <p>Namespace fixup <rfc2119>must not</rfc2119> result in an element having multiple
                  namespace nodes with the same name.</p>
               <p>Namespace fixup <rfc2119>may</rfc2119>, if necessary to resolve conflicts, change
                  the namespace prefix contained in the QName value that holds the name of an
                  element or attribute node. This includes the option to add or remove a prefix.
                  However, namespace fixup <rfc2119>must not</rfc2119> change the prefix component
                  contained in a value of type <code>xs:QName</code> or <code>xs:NOTATION</code>
                  that forms the typed value of an element or attribute node.</p>
               <note>
                  <p>Namespace fixup is not used to create namespace declarations for
                        <code>xs:QName</code> or <code>xs:NOTATION</code> values appearing in the
                     content of an element or attribute.</p>
                  <p>Where values acquire such types as the result of validation, namespace fixup
                     does not come into play, because namespace fixup happens before validation: in
                     this situation, it is the user’s responsibility to ensure that the
                     element being validated has the required namespace nodes to enable validation
                     to succeed.</p>
                  <p>Where existing elements are copied along with their existing <termref def="dt-type-annotation">type annotations</termref>
                        (<code>validation="preserve"</code>) the rules require that existing
                     namespace nodes are also copied, so that any namespace-sensitive values remain
                     valid.</p>
                  <p>Where existing attributes are copied along with their existing type
                     annotations, the rules of the XDM data model require that a parentless
                     attribute node cannot contain a namespace-sensitive typed value; this means
                     that it is an error to copy an attribute using
                        <code>validation="preserve"</code> if it contains namespace-sensitive
                     content.</p>
               </note>
               <p>Namespace fixup is applied to every element that is constructed using a <termref def="dt-literal-result-element">literal result element</termref>, or one of the
                  instructions <elcode>xsl:element</elcode>, <elcode>xsl:copy</elcode>, or
                     <elcode>xsl:copy-of</elcode>. An implementation is not
                     <rfc2119>required</rfc2119> to perform namespace fixup for elements in any
                  source document, that is, for a document in the <termref def="dt-initial-match-selection"/>, documents loaded using the
                     <function>document</function>, <xfunction>doc</xfunction> or
                     <xfunction>collection</xfunction> function, documents supplied as the value of
                  a <termref def="dt-stylesheet-parameter">stylesheet parameter</termref>, or
                  documents returned by an <termref def="dt-extension-function">extension
                     function</termref> or <termref def="dt-extension-instruction">extension
                     instruction</termref>.</p>
               <note>
                  <p>A source document (an input document, a document returned by the
                        <function>document</function>, <xfunction>doc</xfunction> or
                        <xfunction>collection</xfunction> functions, a document returned by an
                     extension function or extension instruction, or a document supplied as a
                     stylesheet parameter) is required to satisfy the constraints described in
                        <bibref ref="xpath-datamodel-30"/>, including the constraints imposed by the
                     namespace fixup process. The effect of supplying a pseudo-document that does
                     not meet these constraints is <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p>
               </note>
               <p>In an Infoset (see <bibref ref="xml-infoset"/>) created from a document conforming
                  to <bibref ref="xml-names"/>, it will always be true that if a parent element has
                  an in-scope namespace with a non-empty namespace prefix, then its child elements
                  will also have an in-scope namespace with the same namespace prefix, though
                  possibly with a different namespace URI. This constraint is removed in <bibref ref="xml-names11"/>. XSLT 4.0 supports the
                  creation of result trees that do not satisfy this constraint: the namespace fixup
                  process does not add a namespace node to an element merely because its parent node
                  in the <termref def="dt-result-tree">result tree</termref> has such a namespace
                  node. However, the process of constructing the children of a new element, which is
                  described in <specref ref="constructing-complex-content"/>, does cause the
                  namespaces of a parent element to be inherited by its children unless this is
                  prevented using <code>[xsl:]inherit-namespaces="no"</code> on the instruction that
                  creates the parent element.</p>
               <note>
                  <p>This has implications on serialization, defined in <bibref ref="xslt-xquery-serialization-30"/>. It means that it is possible to create
                        <termref def="dt-final-result-tree">final result trees</termref> that cannot
                     be faithfully serialized as XML 1.0 documents. When such a result tree is
                     serialized as XML 1.0, namespace declarations written for the parent element
                     will be inherited by its child elements as if the corresponding namespace nodes
                     were present on the child element, except in the case of the default namespace,
                     which can be undeclared using the construct <code>xmlns=""</code>. When the
                     same result tree is serialized as XML 1.1, however, it is possible to undeclare
                     any namespace on the child element (for example, <code>xmlns:foo=""</code>) to
                     prevent this inheritance taking place.</p>
               </note>
            </div3>
         </div2>
         <div2 id="uri-references">
            <head>URI References</head>
            <p>
               <termdef id="dt-uri-reference" term="URI Reference">Within this specification, the
                  term <term>URI Reference</term>, unless otherwise stated, refers to a string in
                  the lexical space of the <code>xs:anyURI</code> datatype as defined in <bibref ref="xmlschema-2"/>.</termdef> Note that this is a wider definition than that
               in <bibref ref="RFC3986"/>: in particular, it is designed to accommodate
               Internationalized Resource Identifiers (IRIs) as described in <bibref ref="RFC3987"/>, and thus allows the use of non-ASCII characters without escaping.</p>
            <p>URI References are used in XSLT with three main roles:</p>
            <ulist>
               <item>
                  <p>As namespace URIs</p>
               </item>
               <item>
                  <p>As collation URIs</p>
               </item>
               <item>
                  <p>As identifiers for resources such as stylesheet modules; these resources are
                     typically accessible using a protocol such as HTTP. Examples of such
                     identifiers are the URIs used in the <code>href</code> attributes of
                        <elcode>xsl:import</elcode>, <elcode>xsl:include</elcode>, and
                        <elcode>xsl:result-document</elcode>.</p>
               </item>
            </ulist>
            <p>The rules for namespace URIs are given in <bibref ref="xml-names"/> and <bibref ref="xml-names11"/>. Those specifications deprecate the use of relative URI
                  references as namespace URIs.</p>
            <p>The rules for collation URIs are given in <xspecref spec="FO40" ref="collations"/>.</p>
            <p>URI references used to identify external resources must conform to the same rules as
               the locator attribute (<code>href</code>) defined in section 5.4 of <bibref ref="xlink"/>. If the URI reference is relative, then it is resolved (unless
               otherwise specified) against the base URI of the containing element node, according
               to the rules of <bibref ref="RFC3986"/>, after first escaping all characters that
               need to be escaped to make it a valid RFC3986 URI reference. (But a relative URI
                  reference in the <code>href</code> attribute of
                  <elcode>xsl:result-document</elcode> is resolved against the <termref def="dt-base-output-uri">Base Output URI</termref>.)</p>
            <p>Other URI references appearing in an XSLT stylesheet document, for example the system
               identifiers of external entities or the value of the <code>xml:base</code> attribute,
               must follow the rules in their respective specifications.</p>
            <p><!--bug 17595-->The base URI of an element node in the stylesheet
               is determined as defined in <xspecref spec="DM30" ref="dm-base-uri"/>. Some
               implementations may allow the output of the static analysis phase of stylesheet
               processing (a “compiled stylesheet”) to be evaluated in a different location from
               that where static analysis took place. Furthermore, stylesheet authors may in such
               cases wish to avoid exposing the location of resources that are private to the
               development environment. If the base URI of an element in the stylesheet is defined
               by an absolute URI appearing in an <code>xml:base</code> attribute within the
               stylesheet, this value <rfc2119>must</rfc2119> be used as the static base URI. In
               other cases where processing depends on the static base URI of a stylesheet module,
               implementations <rfc2119>may</rfc2119> use different values for the static base URI
               during static analysis and during dynamic evaluation (for example, an implementation
                  <rfc2119>may</rfc2119> use different base URIs for resolving
                  <elcode>xsl:import</elcode> module references and for resolving a relative
               reference used as an argument to the <xfunction>doc</xfunction> function). In such
               cases an implementation <rfc2119>must</rfc2119> document how the static base URI is
               computed for each situation in which it is required. </p>

         </div2>
      </div1>
      <div1 id="rules">
         <head>Template Rules</head>
         <p>Template rules define the processing that can be applied to items that match a particular <termref def="dt-pattern">pattern</termref>.</p>
         <div2 id="defining-templates">
            <head>Defining Templates</head>
            <?element xsl:template?>
            <p>
               <termdef id="dt-template" term="template">An <elcode>xsl:template</elcode>
                  declaration defines a <term>template</term>, which contains a <termref def="dt-sequence-constructor">sequence constructor</termref>;
                  this sequence constructor is evaluated to determine
                     the result of the template. A template can serve either as a <termref def="dt-template-rule">template rule</termref>, invoked by matching items against a <termref def="dt-pattern">pattern</termref>, or as a <termref def="dt-named-template">named
                     template</termref>, invoked explicitly by name. It is also possible for the
                  same template to serve in both capacities.</termdef>
            </p>
            <p>
               <error spec="XT" type="static" class="SE" code="0500">
                  <p>An <elcode>xsl:template</elcode> element <rfc2119>must</rfc2119> have either a
                        <code>match</code> attribute or a <code>name</code> attribute, or both. An
                        <elcode>xsl:template</elcode> element that has no <code>match</code>
                     attribute <rfc2119>must</rfc2119> have no <code>mode</code> attribute and no
                        <code>priority</code> attribute. An
                           <elcode>xsl:template</elcode> element that has no <code>name</code>
                        attribute <rfc2119>must</rfc2119> have no <code>visibility</code>
                        attribute.</p>
               </error>
            </p>
            <p>If an <elcode>xsl:template</elcode> element has a <code>match</code> attribute, then
               it is a <termref def="dt-template-rule">template rule</termref>. If it has a
                  <code>name</code> attribute, then it is a <termref def="dt-named-template">named
                  template</termref>.</p>
            <p>A <termref def="dt-template">template</termref> may be invoked in a number of ways,
               depending on whether it is a <termref def="dt-template-rule">template rule</termref>,
               a <termref def="dt-named-template">named template</termref>, or both. The result of
               invoking the template is the result of evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref> contained in the
                  <elcode>xsl:template</elcode> element (see <specref ref="sequence-constructors"/>).</p>

            <p>For details of the optional <elcode>xsl:context-item</elcode> child
               element, see <specref ref="declaring-context-item"/>.</p>


            <p>If an <code>as</code> attribute of the <elcode>xsl:template</elcode> element is
               present, the <code>as</code> attribute defines the required type of the result. The
               result of evaluating the <termref def="dt-sequence-constructor">sequence
                  constructor</termref> is then converted to the required type using the 
               <termref def="dt-coercion-rules"/>. If no
                  <code>as</code> attribute is specified, the default value is <code>item()*</code>,
               which permits any value. No conversion then takes place.</p>
            <p>
               <error spec="XT" type="type" class="TE" code="0505">
                  <p>It is a <termref def="dt-type-error">type error</termref> if the result of
                     evaluating the <termref def="dt-sequence-constructor">sequence
                        constructor</termref> cannot be converted to the required type.</p>
               </error>
            </p>

            <p>If the <code>visibility</code> attribute is present with the value
                  <code>abstract</code> then (a) the <termref def="dt-sequence-constructor"/>
               defining the template body <rfc2119>must</rfc2119> be empty: that is, the only
               permitted children are <elcode>xsl:context-item</elcode> and
                  <elcode>xsl:param</elcode>, and (b) there <rfc2119>must</rfc2119> be no
                  <code>match</code> attribute.</p>
            <!--<p diff="add" at="I">If the parent of the <elcode>xsl:template</elcode> element is an
                  <elcode>xsl:override</elcode> element, then there must be a <code>name</code>
               attribute and no <code>match</code> attribute, and the <termref def="dt-package"
                  >package</termref> that is the target of the containing
                  <elcode>xsl:use-package</elcode> element must contain among its <termref
                  def="dt-component">components</termref> a <termref def="dt-named-template">named
                  template</termref> whose <termref def="dt-symbolic-identifier">symbolic
                  identifier</termref> is the same as this named template, and which has a <termref
                  def="dt-compatible">compatible</termref> signature.</p>-->
            
            <p>If the parent of the <elcode>xsl:template</elcode> element is an
               <elcode>xsl:override</elcode> element, then either or both of the following conditions
               must be true:</p>
            <olist>
               <item><p>There is a <code>name</code> attribute, and the <termref def="dt-package">package</termref> identified by the containing
                  <elcode>xsl:use-package</elcode> element contains among its <termref def="dt-component">components</termref> a <termref def="dt-named-template">named
                        template</termref> whose <termref def="dt-symbolic-identifier">symbolic
                           identifier</termref> is the same as that of this named template, and which has a <termref def="dt-compatible">compatible</termref> signature.</p></item>
               <item><p>Both the following conditions are true:</p>
                  <olist>
                     <item><p>There is a <code>match</code> attribute.</p></item>
                     <item><p>The value of the <code>mode</code> attribute,
                        or in its absence the string <code>#default</code>,
                        is a whitespace-separated sequence of tokens in which each token satisfies
                        one of the following conditions:</p>
                        <olist>
                           <item><p>The token is an EQName representing the name of a mode that is exposed,
                           with visibility equal to <code>public</code>, by the package identified by the containing
                           <elcode>xsl:use-package</elcode> element.</p></item>
                           <item><p>The token is <code>#default</code>, and there is an ancestor-or-self element with
                              a <code>default-mode</code> attribute whose value is an EQName representing the name of a mode that is exposed,
                              with visibility equal to <code>public</code>, by the package identified by the containing
                              <elcode>xsl:use-package</elcode> element.</p></item>
                        </olist>
                     </item>
                  </olist>
                  <note><p>The token <code>#unnamed</code> is not allowed because the unnamed mode never has public visibility. 
                     The token <code>#all</code> is not allowed because its intended meaning would not be obvious.
                  </p></note>
               </item>
            </olist>
         </div2>
         <div2 id="defining-template-rules">
            <head>Defining Template Rules</head>
            <p>This section describes <termref def="dt-template-rule">template rules</termref>.
                  <termref def="dt-named-template">Named templates</termref> are described in
                  <specref ref="named-templates"/>.</p>
            <p>A <termref def="dt-template-rule">template rule</termref> is specified using the
                  <elcode>xsl:template</elcode> element with a <code>match</code> attribute. The
                  <code>match</code> attribute is a <nt def="Pattern40">Pattern</nt> that identifies
               the items to which the rule applies. The result of
               applying the template rule is the result of evaluating the sequence constructor
               contained in the <elcode>xsl:template</elcode> element, with the matching item used as the <termref def="dt-context-item">context item</termref>.</p>
            <example>
               <head>A Simple Template Rule</head>
               <p>For example, an XML document might contain:</p>
               <eg xml:space="preserve" role="xml">This is an &lt;emph&gt;important&lt;/emph&gt; point.</eg>
               <p>The following <termref def="dt-template-rule">template rule</termref> matches
                     <code>emph</code> elements and produces a <code>fo:wrapper</code> element with
                  a <code>font-weight</code> property of <code>bold</code>.</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="emph"&gt;
  &lt;fo:wrapper font-weight="bold" 
              xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:wrapper&gt;
&lt;/xsl:template&gt;
</eg>
            </example>
            <p>A <termref def="dt-template-rule">template rule</termref> is evaluated when an
                  <elcode>xsl:apply-templates</elcode> instruction selects an item that matches the pattern specified in the <code>match</code>
               attribute. The <elcode>xsl:apply-templates</elcode> instruction is described in the
               next section. If several template rules match a selected item, only one of them is evaluated, as described in <specref ref="conflict"/>.</p>
         </div2>
         <div2 id="applying-templates">
            <head>Applying Template Rules</head>
            <?element xsl:apply-templates?>
            <p>The <elcode>xsl:apply-templates</elcode> instruction takes as input a sequence of
                  items (typically nodes in a <termref def="dt-source-tree">source tree</termref>), and produces as output a sequence of
               items; these will often be nodes to be added to a <termref def="dt-result-tree">result tree</termref>.</p>
            <p>If the instruction has one or more <elcode>xsl:sort</elcode> children, then the input
               sequence is sorted as described in <specref ref="sorting"/>. The result of this sort
               is referred to below as the <term>sorted sequence</term>; if there are no
                  <elcode>xsl:sort</elcode> elements, then the sorted sequence is the same as the
               input sequence.</p>
            <p>Each item in the input sequence is processed by
               finding a <termref def="dt-template-rule">template rule</termref> whose <termref def="dt-pattern">pattern</termref> matches that item. If there is more than one such template rule, the best among them
               is chosen, using rules described in <specref ref="conflict"/>. If there is no
               template rule whose pattern matches the item, a
               built-in template rule is used (see <specref ref="built-in-rule"/>). The chosen
               template rule is evaluated. The rule that matches the <var>N</var>th item in the sorted sequence is evaluated with that
                  item as the <termref def="dt-context-item">context item</termref>, with <var>N</var> as the <termref def="dt-context-position">context position</termref>, and with the length of the
               sorted sequence as the <termref def="dt-context-size">context size</termref>. Each
               template rule that is evaluated produces a sequence of items as its result. The
               resulting sequences (one for each item in the
               sorted sequence) are then concatenated, to form a single sequence. They are
               concatenated retaining the order of the items in
               the sorted sequence. The final concatenated sequence forms the result of the
                  <elcode>xsl:apply-templates</elcode> instruction. </p>
            <example>
               <head>Applying Template Rules</head>
               <p>Suppose the source document is as follows:</p>
               <eg xml:space="preserve" role="xml">&lt;message&gt;Proceed &lt;emph&gt;at once&lt;/emph&gt; to the exit!&lt;/message&gt;</eg>
               <p>This can be processed using the two template rules shown below.</p>
               <eg xml:space="preserve" role="xslt-declarations">&lt;xsl:template match="message"&gt;
  &lt;p&gt;
    &lt;xsl:apply-templates select="child::node()"/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="emph"&gt;
  &lt;b&gt;
    &lt;xsl:apply-templates select="child::node()"/&gt;
  &lt;/b&gt;
&lt;/xsl:template&gt;</eg>
               <p>There is no template rule for the document node; the built-in template rule for
                  this node will cause the <code>message</code> element to be processed. The
                  template rule for the <code>message</code> element causes a <code>p</code> element
                  to be written to the <termref def="dt-result-tree">result tree</termref>; the
                  contents of this <code>p</code> element are constructed as the result of the
                     <elcode>xsl:apply-templates</elcode> instruction. This instruction selects the
                  three child nodes of the <code>message</code> element (a text node containing the
                  value <code>Proceed </code>, an <code>emph</code> element node, and a text node
                  containing the value <code> to the exit!</code>). The two text nodes are
                  processed using the built-in template rule for text nodes, which returns a copy of
                  the text node. The <code>emph</code> element is processed using the explicit
                  template rule that specifies <code>match="emph"</code>.</p>
               <p>When the <code>emph</code> element is processed, this template rule constructs a
                     <code>b</code> element. The contents of the <code>b</code> element are
                  constructed by means of another <elcode>xsl:apply-templates</elcode> instruction,
                  which in this case selects a single node (the text node containing the value
                     <code>at once</code>). This is again processed using the built-in template
                  rule for text nodes, which returns a copy of the text node.</p>
               <p>The final result of the <code>match="message"</code> template rule thus consists
                  of a <code>p</code> element node with three children: a text node containing the
                  value <code>Proceed </code>, a <code>b</code> element that is the parent of a
                  text node containing the value <code>at once</code>, and a text node containing
                  the value <code> to the exit!</code>. This <termref def="dt-result-tree">result
                     tree</termref> might be serialized as:</p>
               <eg xml:space="preserve" role="xml">&lt;p&gt;Proceed &lt;b&gt;at once&lt;/b&gt; to the exit!&lt;/p&gt;</eg>
            </example>
            <p>The default value of the <code>select</code> attribute is <code>child::node()</code>,
               which causes all the children of the context node to be processed.</p>
            <p>
               <error spec="XT" type="type" class="TE" code="0510">
                  <p>It is a <termref def="dt-type-error">type error</termref> if an
                        <elcode>xsl:apply-templates</elcode> instruction with no <code>select</code>
                     attribute is evaluated when the <termref def="dt-context-item">context
                        item</termref> is not a node. </p>
               </error>
            </p>
            <p>A <code>select</code> attribute can be used to process items selected by an expression instead of processing all children. The
               value of the <code>select</code> attribute is an <termref def="dt-expression">expression</termref>. </p>
            
            
            <example>
               <head>Applying Templates to Selected Nodes</head>
               <p>The following example processes all of the <code>given-name</code> children of the
                     <code>author</code> elements that are children of
                  <code>author-group</code>:</p>
               <eg xml:space="preserve" role="xslt-declaration xmlns:fo='fo'">&lt;xsl:template match="author-group"&gt;
  &lt;fo:wrapper&gt;
    &lt;xsl:apply-templates select="author/given-name"/&gt;
  &lt;/fo:wrapper&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <example>
               <head>Applying Templates to Nodes that are not Descendants</head>
               <p>It is also possible to process elements that are not descendants of the context
                  node. This example assumes that a <code>department</code> element has
                     <code>group</code> children and <code>employee</code> descendants. It finds an
                  employee’s department and then processes the <code>group</code> children of
                  the <code>department</code>.</p>
               <eg xml:space="preserve" role="xslt-declaration xmlns:fo='fo'">&lt;xsl:template match="employee"&gt;
  &lt;fo:block&gt;
    Employee &lt;xsl:apply-templates select="name"/&gt; belongs to group
    &lt;xsl:apply-templates select="ancestor::department/group"/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <example>
               <head>Matching Nodes by Schema-Defined Types</head>
               <p>It is possible to write template rules that are matched according to the
                  schema-defined type of an element or attribute. The following example applies
                  different formatting to the children of an element depending on their type:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="product"&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/*" priority="3"&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;xsl:value-of select="name()"/&gt;&lt;/td&gt;
    &lt;td&gt;&lt;xsl:next-match/&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/element(*, xs:decimal) | 
                     product/element(*, xs:double)" priority="2"&gt;  
  &lt;xsl:value-of select="format-number(xs:double(.), '#,###0.00')"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/element(*, xs:date)" priority="2"&gt;
  &lt;xsl:value-of select="format-date(., '[Mn] [D], [Y]')"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/*" priority="1.5"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;</eg>
               <p>The <elcode>xsl:next-match</elcode> instruction is described in <specref ref="apply-imports"/>.</p>
            </example>
            <example>
               <head>Re-ordering Elements in the Result Tree</head>
               <p>Multiple <elcode>xsl:apply-templates</elcode> elements can be used within a single
                  template to do simple reordering. The following example creates two HTML tables.
                  The first table is filled with domestic sales while the second table is filled
                  with foreign sales.</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="product"&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="sales/domestic"/&gt;
  &lt;/table&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="sales/foreign"/&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <example>
               <head>Processing Recursive Structures</head>
               <p>It is possible for there to be two matching descendants where one is a descendant
                  of the other. This case is not treated specially: both descendants will be
                  processed as usual.</p>
               <p> For example, given a source document</p>
               <eg xml:space="preserve" role="xml">&lt;doc&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/doc&gt;</eg>
               <p>the rule</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="doc"&gt;
  &lt;xsl:apply-templates select=".//div"/&gt;
&lt;/xsl:template&gt;</eg>
               <p>will process both the outer <code>div</code> and inner <code>div</code>
                  elements.</p>
               <p>This means that if the template rule for the <code>div</code> element processes
                  its own children, then these grandchildren will be processed more than once, which
                  is probably not what is required. The solution is to process one level at a time
                  in a recursive descent, by using <code>select="div"</code> in place of
                     <code>select=".//div"</code>
               </p>
            </example>
            <example>
               <head>Applying Templates to Atomic Values</head>
               <p>This example reads a non-XML text file and processes it line-by-line, applying
                  different template rules based on the content of each line:</p>
               <eg xml:space="preserve" role="xslt-declarations" diff="chg" at="2022-01-01">&lt;xsl:template name="main"&gt;
  &lt;xsl:apply-templates select="unparsed-text-lines('input.txt')"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="type(xs:string)[starts-with(., '==')]"&gt;
  &lt;h2&gt;&lt;xsl:value-of select="replace(., '==', '')"/&gt;&lt;/h2&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="type(xs:string)[starts-with(., '::')]"&gt;
  &lt;p class="indent"&gt;&lt;xsl:value-of select="replace(., '::', '')"/&gt;&lt;/p&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="type(xs:string)"&gt;
  &lt;p class="body"&gt;&lt;xsl:value-of select="."/&gt;&lt;/p&gt;
&lt;/xsl:template&gt;

</eg>
            </example>
            <example>
               <head>Applying Templates to JSON Documents</head>
               <p>This example reads a JSON data file and formats it as XHTML.</p>
               <p>It takes the following JSON data as input:</p>
               <eg>[
  { "Title": "Computer Architecture",
    "Authors": ["Enid Blyton"]
    "Category": "Computers",
    "Price": 42.60
  },
  { "Title": "How to Win Elections",
    "Authors": ["Donald Trump", "Boris Johnson"],
    "Category": "Politics",
    "Price": 56.00
  },
  {  "Title": "How to Explore Outer Space with Binoculars",
     "Authors: ["Bruce Betts", "Erica Colon"]
     "Category": "Science",
     "Price": 10.40
  }
]</eg>
               <p>The following template rules are used. The settings <code>expand-text="yes"</code> 
                  and <code>default-type-namespace="http://www.w3.org/2001/XMLSchema"</code> are assumed:</p>
               <eg><![CDATA[
<xsl:item-type name="book" as="record(Title, Authors, Category, *)"/>                  
<xsl:template name="xsl:initial-template">
  <xsl:apply-templates select="parse-json('input.json')"/>
</xsl:template>  
<xsl:template match="array(book)">
  <h1>Christmas Book Selection</h1>
  <table>
    <thead>
       <tr>
         <th>Title</th>
         <th>Authors</th>
         <th>Category</th>
         <th>Price</th>
       </tr>
    </thead>
    <tbody>
      <xsl:apply-templates select="?*"/>
    </tbody>
  </table>
</xsl:template>
<xsl:template match="type(book)">
  <tr>
    <td>{?Title}</td>
    <td>{?Authors?* => string-join(", ")}</td>
    <td>{?Category}</td>
    <td>${?Price}</td>
  </tr>
</xsl:template>  
]]></eg>
            </example>
            <note>
               <p>The <elcode>xsl:apply-templates</elcode> instruction is most commonly used to
                  process nodes that are descendants of the context node. Such use of
                     <elcode>xsl:apply-templates</elcode> cannot result in non-terminating
                  processing loops. However, when <elcode>xsl:apply-templates</elcode> is used to
                  process elements that are not descendants of the context node, the possibility
                  arises of non-terminating loops. For example,</p>
               <eg role="error" xml:space="preserve">&lt;xsl:template match="foo"&gt;
  &lt;xsl:apply-templates select="."/&gt;
&lt;/xsl:template&gt;</eg>
               <p>Implementations may be able to detect such loops in some cases, but the
                  possibility exists that a <termref def="dt-stylesheet">stylesheet</termref> may
                  enter a non-terminating loop that an implementation is unable to detect. This may
                  present a denial of service security risk.</p>
            </note>
         </div2>
         <div2 id="apply-templates-separator" diff="add" at="2022-01-01">
            <head>The <code>separator</code> attribute</head>
            
            <p>If the <code>separator</code> attribute of <elcode>xsl:apply-templates</elcode>
               is present, then its <termref def="dt-effective-value"/>
               is inserted, as a text node, into the output sequence, immediately after the results of processing each item in the sorted
               sequence other than the last.</p>
            <p>For example, if the <code>ARTICLE</code> element has a number of element children named <code>AUTHOR</code>,
               the following code will produce a sorted, comma-separated list of authors:</p>
            <eg><![CDATA[
<xsl:template match="ARTICLE">
  <article>
     ...
     <xsl:text>Author(s): </xsl:text>
     <xsl:apply-templates select="AUTHOR" separator=", ">
       <xsl:sort select="LAST-NAME"/>
       <xsl:sort select="FIRST-NAME"/>
     </xsl:apply-templates>
     ...
  </article>
</xsl:template>
<xsl:template match="AUTHOR" expand-text="yes">
  <xsl:text>{FIRST-NAME} {LAST-NAME}</xsl:text>
</xsl:template>  
 ]]></eg>
            
            <p>The node identity of any text nodes that are inserted is <termref def="dt-implementation-dependent"/>. Specifically,
               it is not defined whether all the text nodes inserted in the course of one evaluation of the instruction are identical
               to each other, nor whether they are identical to the text nodes inserted in the course of another evaluation of this
               instruction, nor whether they are identical to any other parentless text nodes having the same string value.</p>
            <p>If the separator is a zero-length string, then a zero-length text node is inserted into the sequence. (If the
               sequence is used for constructing the value of a node, then zero-length text nodes will be discarded: see
               <specref ref="constructing-simple-content"/> and <specref ref="constructing-complex-content"/>.)</p>
         </div2>
         <!--<div2 id="template-test" diff="add" at="2022-01-01">
            <head>The <code>test</code> Attribute</head>
            <p>If a template rule has a <code>test</code> attribute, then its value is an <termref def="dt-expression"/>,
               and the template rule is a candidate for evaluation only if the <code>test</code> condition is true.
               The <code>test</code> condition has access to the values of all the parameters declared in the called template,
               both tunnel and non-tunnel parameters.</p>
            <p>This mechanism allows the applicability of a template rule to be depend not only on the match pattern applied
               to the item selected for processing, but also on the context in which the evaluation takes place.
               It is especially useful when processing structures derived from JSON (maps and arrays), because unlike
               nodes, there is no parent or ancestor axis that can be used in the <code>match</code> pattern
               to examine items in the enclosing tree.</p>
            <example id="e-template-test-conditions">
            <p>For example, consider the JSON structure:</p>
            <eg>
{ "order": {
    "shipping-address": {
         "first-line": "10 Downing Street",
         "second-line": "Westminster",
         "city": "London",
         "postcode": "SW1A 2AA"
   },
   "billing-address": {
         "first-line": "Buckingham Palace",
         "city": "London",
         "postcode": "SW1A 1AA"
   }
}
            </eg>
            <p>The two addresses can both be matched with the pattern <code>match="record(first-line, city, postcode, *)"</code>,
               but if they are to be handled using different template rules, then it is difficult to write match patterns
               that distinguish them, because the pattern cannot refer to ancestor information in the tree. This can be solved
               by having the calling code set a tunnel parameter <code>$address-role</code> to <code>"shipping"</code> or
               <code>"billing"</code>, and using the attributes <code>test="$address-role='shipping'"</code> and 
               <code>test="$address-role='billing'"</code> respectively on the two template rules.</p>
            </example>
            <p>The expression in the <code>test</code> condition is evaluated as follows:</p>
            <olist>
               <item><p>The static context includes all variables listed in the body of the template rule using
               <elcode>xsl:param</elcode> with <code>tunnel="yes"</code>. It also includes all visible global variables
                  (unless shadowed by a tunnel parameter) and all stylesheet functions.</p></item>
               <item><p>The dynamic context includes all the values for the global variables and the values
               for tunnel parameters, including those set by the calling instruction (such as <code>xsl:apply-templates</code>)
               as well as any that are carried over from outer callers.</p></item>
               <item><p>The focus for evaluation is absent. In particular, the <code>test</code> expression does
               not have access to the item that is being matched.</p></item>
               <item><p>The available documents, available text resources, available collections, and available URI
               collections are all empty.</p></item>
            </olist>
            <p>If the test condition evaluates to <code>false</code>, or if evaluation fails, then the template rule is not a candidate
            for matching.</p>
            <note>
               <p>When an <elcode>xsl:apply-templates</elcode> instruction selects multiple items for processing, the values
               of tunnel parameters will be the same for each one, and the set of eligible template rules will therefore
               also be the same for each one. The <code>test</code> conditions therefore do not need to be re-evaluated
               for each item being processed.</p>
            </note>
            <p>When an <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode> instruction is evaluated,
            the values of tunnel parameters may change, and the set of eligible template rules may therefore also change.</p>
         </div2>-->
            
        
         <div2 id="conflict">
            <head>Conflict Resolution for Template Rules</head>
            <p>It is possible for a selected item to match more
               than one <termref def="dt-template-rule">template rule</termref> with a given
                  <termref def="dt-mode">mode</termref>
               <var>M</var>. When this happens, only one template rule is evaluated for the item. The template rule to be used is determined as
               follows:</p>
            <olist>
               <item>
                  <p>First, only the matching template rule or rules with the highest <termref def="dt-import-precedence">import precedence</termref> are considered. Other
                     matching template rules with lower precedence are eliminated from
                     consideration.</p>
               </item>
               <item>
                  <p>Next, of the remaining matching rules, only those with the highest priority are
                     considered. Other matching template rules with lower priority are eliminated
                     from consideration.</p>
                  <p><termdef term="priority" id="dt-priority">The <term>priority</term> of a
                        template rule is specified by the <code>priority</code> attribute on the
                           <elcode>xsl:template</elcode> declaration. If no priority is specified
                        explicitly for a template rule, its <termref def="dt-default-priority">default priority</termref> is used, as defined in <specref ref="default-priority"/>.</termdef></p>
                  <p>
                     <error spec="XT" type="static" class="SE" code="0530">
                        <p>The value of the <code>priority</code> attribute <error.extra> of the
                                 <elcode>xsl:template</elcode> element</error.extra>
                           <rfc2119>must</rfc2119> conform to the rules for the
                              <code>xs:decimal</code> type defined in <bibref ref="xmlschema-2"/>.
                           Negative values are permitted.</p>
                     </error>
                  </p>

               </item>
               <item diff="add" at="2023-03-15">
                  <p>Next, if each of the remaining matching rules has a match pattern in the form of a 
                     <nt def="TypePattern">TypePattern</nt>, then this set of rules (call it <var>R</var>)
                     is examined as follows:
                  </p>
                  <olist>
                     <item><p>A <nt def="TypePattern">TypePattern</nt> comprises an <code>ItemType</code>
                     and a possibly empty set of predicates.</p>
                     </item>
                     <item><p>Any rule in <var>R</var> whose <code>ItemType</code> is a strict supertype of 
                     the <code>ItemType</code> of another rule in <var>R</var> is discarded. A type <var>T</var>
                     is a strict supertype of another type <var>U</var> if <var>U</var> is a 
                        <xtermref ref="dt-subtype" spec="XP40">subtype</xtermref> of <var>T</var> and
                        <var>T</var> is not a 
                        <xtermref ref="dt-subtype" spec="XP40">subtype</xtermref> of <var>U</var>.
                     </p></item>
                     <item><p>If there is a rule <var>P</var> in <var>R</var> whose <code>ItemType</code> is the same type as 
                        the <code>ItemType</code> of another rule <var>Q</var> in <var>R</var>, and if <var>Q</var> 
                        has one or more predicates while <var>P</var> has none, then <var>P</var> is discarded. A type <var>T</var>
                        is the same type as another type <var>U</var> if <var>T</var> is a 
                        <xtermref ref="dt-subtype" spec="XP40">subtype</xtermref> of <var>U</var> and
                        <var>U</var> is a 
                        <xtermref ref="dt-subtype" spec="XP40">subtype</xtermref> of <var>T</var>.
                     </p></item>
                     <item><p>If this process leaves a single rule, then that rule is chosen.</p></item>
                  </olist>
                  <note>
                     <p>For example, this means that the pattern <code>type(xs:integer)</code> is chosen
                  in preference to <code>type(xs:decimal)</code> which in turn is chosen in preference
                  to <code>type(item())</code>; it also means that <code>type(xs:integer)[. gt 0]</code>
                  is chosen in preference to <code>type(xs:integer)</code>.</p>
                     <p>Similarly, the pattern <code>record(longitude, latitude, altitude)</code> will be
                        chosen in preference to the pattern <code>record(longitude, latitude, *)</code></p>
                  </note>
               </item>

               <item>
                  <p>If this leaves more than one matching template rule, then:</p>
                  <olist>
                     <item>
                        <p>If the <termref def="dt-mode">mode</termref>
                           <var>M</var> has an <elcode>xsl:mode</elcode> declaration, and the
                           attribute value <code>on-multiple-match="fail"</code> is specified in the
                           mode declaration, a dynamic error is signaled. The error is treated as
                           occurring in the <elcode>xsl:apply-templates</elcode> instruction, and
                           can be recovered by wrapping that instruction in an
                              <elcode>xsl:try</elcode> instruction.</p>
                        <p>
                           <error spec="XT" type="dynamic" class="DE" code="0540">
                              <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the
                                 conflict resolution algorithm for template rules leaves more than
                                 one matching template rule  when the
                                    declaration of the relevant <termref def="dt-mode">mode</termref> has an <code>on-multiple-match</code>
                                    attribute with the value <code>fail</code>.</p>
                           </error></p>
                     </item>
                     <item>
                        <p>Otherwise, of the matching template rules that remain, the one that
                           occurs last in <termref def="dt-declaration-order">declaration
                              order</termref> is used.</p>
                     </item>
                  </olist>

                  <note>
                     <p>This was a recoverable error in XSLT 2.0, meaning that it was
                        implementation-defined whether the error was signaled, or whether the
                        ambiguity was resolved by taking the last matching rule in declaration
                        order.  In XSLT 3.0 this situation is not an error unless the
                        attribute value <code>on-multiple-match="fail"</code> is specified in the
                        mode declaration. It is also possible to request warnings when this
                        condition arises, by means of the attribute <code>warning-on-multiple-match="yes"</code>. </p>
                  </note>

               </item>
            </olist>

         </div2>
         <div2 id="default-priority">
            <head>Default Priority for Template Rules</head>
            <p><termdef id="dt-default-priority" term="default priority">If no <code>priority</code>
                  attribute is specified on an <elcode>xsl:template</elcode> element, a
                     <term>default priority</term> is computed, based on the syntax of the <termref def="dt-pattern">pattern</termref> supplied in the <code>match</code>
                  attribute.</termdef> The rules are as follows. </p>
            <olist>
               <item>
                  <p>If the top-level pattern is a <nt def="ParenthesizedExprP">ParenthesizedExprP</nt> then the outer parentheses are effectively
                     stripped; these rules are applied recursively to the <nt def="UnionExprP">UnionExprP</nt> contained in the <nt def="ParenthesizedExprP">ParenthesizedExprP</nt>.</p>
               </item>
               <item>
                  <p>If the top-level pattern is a <nt def="UnionExprP">UnionExprP</nt> consisting
                     of multiple alternatives separated by <code>|</code> or <code>union</code>,
                     then the template rule is treated equivalently to a set of template rules, one
                     for each alternative. For example, a rule with <code>match="a|b"</code> is treated
                     as if there were one rule with <code>match="a"</code> and another with <code>match="b"</code>.
                     These template rules are adjacent to each
                        other in declaration order, and the declaration order within this set of
                        template rules (which affects the result of <elcode>xsl:next-match</elcode>
                        if the alternatives have the same default priority) is the order of
                        alternatives in the <nt def="UnionExprP">UnionExprP</nt>.</p>
                  <p diff="add" at="2022-12-13">Similarly, if the top-level pattern takes the form
                     of a <xnt spec="XP40" ref="UnionNodeTest">UnionNodeTest</xnt> preceded by
                     an axis name or abbreviation, it is treated equivalently to a set of template rules, one
                     for each alternative. For example, a rule with <code>match="@(a|b)"</code> is treated
                     as if there were one rule with <code>match="@a"</code> and another with <code>match="@b"</code> </p>
                  <note>
                     <p>The splitting of a template rule into multiple rules occurs only if there is
                        no explicit <code>priority</code> attribute.</p>
                  </note>
               </item>
               <item>
                  <p>If the top-level pattern is an <nt def="IntersectExceptExprP">IntersectExceptExprP</nt> containing two or more <nt def="PathExprP">PathExprP</nt> operands separated by <code>intersect</code> or
                        <code>except</code> operators, then the priority of the pattern is that of
                     the first <nt def="PathExprP">PathExprP</nt>. </p>
               </item>
               <item>
                  <p>If the pattern is a <nt def="PredicatePattern">PredicatePattern</nt> then its priority is 1 (one), unless the <xnt spec="XP40" ref="prod-xpath40-PredicateList">PredicateList</xnt> is empty,
                     in which case the priority is −1 (minus one).</p>
                  
                  
               </item>
               


               <item>
                  <p>If the pattern is a <nt def="PathExprP">PathExprP</nt> taking the form
                        <code>/</code>, then the priority is −0.5 (minus 0.5).</p>
               </item>
               <item>
                  <p>If the pattern is a <nt def="PathExprP">PathExprP</nt> taking the form of an
                        <termref def="dt-eqname">EQName</termref> optionally preceded by a <nt def="ForwardAxisP">ForwardAxisP</nt> or has the form
                        <code>processing-instruction(</code>
                     <xnt spec="XP40" ref="prod-xpath40-StringLiteral">StringLiteral</xnt>
                     <code>)</code> or <code>processing-instruction(</code>
                     <xnt spec="Names" ref="NT-NCName">NCName</xnt>
                     <code>)</code> optionally preceded by a <nt def="ForwardAxisP">ForwardAxisP</nt>, then the priority is 0 (zero).</p>
               </item>
               <item>
                  <p>If the pattern is a <nt def="PathExprP">PathExprP</nt> taking the form of an
                        <xnt spec="XP40" ref="prod-xpath40-ElementTest">ElementTest</xnt> or <xnt spec="XP40" ref="prod-xpath40-AttributeTest">AttributeTest</xnt>, optionally
                     preceded by a <nt def="ForwardAxisP">ForwardAxisP</nt>, then the priority is as
                     shown in the table below. In this table, the symbols <var>E</var>,
                     <var>A</var>, and <var>T</var> represent an arbitrary element name, attribute
                     name, and type name respectively, while the symbol <code>*</code> represents
                     itself. The presence or absence of the symbol <code>?</code> following a type
                     name does not affect the priority.</p>
                  <table class="data">
                     <caption>Default Priority of Patterns</caption>
                     <thead>
                        <tr>
                           <th rowspan="1" colspan="1">Format</th>
                           <th rowspan="1" colspan="1">Priority</th>
                           <th rowspan="1" colspan="1">Notes</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>element()</code>
                           </td>
                           <td rowspan="1" colspan="1">−0.5</td>
                           <td rowspan="1" colspan="1">(equivalent to <code>*</code>)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>element(*)</code>
                           </td>
                           <td rowspan="1" colspan="1">−0.5</td>
                           <td rowspan="1" colspan="1">(equivalent to <code>*</code>)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>attribute()</code>
                           </td>
                           <td rowspan="1" colspan="1">−0.5</td>
                           <td rowspan="1" colspan="1">(equivalent to <code>@*</code>)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>attribute(*)</code>
                           </td>
                           <td rowspan="1" colspan="1">−0.5</td>
                           <td rowspan="1" colspan="1">(equivalent to <code>@*</code>)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>element(<var>E</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0</td>
                           <td rowspan="1" colspan="1">(equivalent to E)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>element(*,<var>T</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0</td>
                           <td rowspan="1" colspan="1">(matches by type only)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>attribute(<var>A</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0</td>
                           <td rowspan="1" colspan="1">(equivalent to <code>@A</code>)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>attribute(*,<var>T</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0</td>
                           <td rowspan="1" colspan="1">(matches by type only)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>element(<var>E</var>,<var>T</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0.25</td>
                           <td rowspan="1" colspan="1">(matches by name and type)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>schema-element(<var>E</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0.25</td>
                           <td rowspan="1" colspan="1">(matches by substitution group and type)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>attribute(<var>A</var>,<var>T</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0.25</td>
                           <td rowspan="1" colspan="1">(matches by name and type)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>schema-attribute(<var>A</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0.25</td>
                           <td rowspan="1" colspan="1">(matches by name and type)</td>
                        </tr>
                     </tbody>
                  </table>
               </item>
               <item>
                  <p>If the pattern is a <nt def="PathExprP">PathExprP</nt> taking the form of a
                        <xnt spec="XP40" ref="prod-xpath40-DocumentTest">DocumentTest</xnt>, then if
                     it includes no <xnt spec="XP40" ref="prod-xpath40-ElementTest">ElementTest</xnt> or <xnt spec="XP40" ref="prod-xpath40-SchemaElementTest">SchemaElementTest</xnt> the priority is −0.5. If it does include an
                        <xnt spec="XP40" ref="prod-xpath40-ElementTest">ElementTest</xnt> or <xnt spec="XP40" ref="prod-xpath40-SchemaElementTest">SchemaElementTest</xnt>,
                     then the priority is the same as the priority of that <xnt spec="XP40" ref="prod-xpath40-ElementTest">ElementTest</xnt> or <xnt spec="XP40" ref="prod-xpath40-SchemaElementTest">SchemaElementTest</xnt>, computed
                     according to the table above.</p>
               </item>
               <item>
                  <p>If the pattern is a <nt def="PathExprP">PathExprP</nt> taking the form of an
                        <xnt spec="Names" ref="NT-NCName">NCName</xnt><code>:*</code><phrase diff="add" at="2022-01-01">, 
                           <xnt spec="XP40" ref="prod-xpath40-BracedURILiteral"/>*,</phrase> or
                        <code>*:</code><xnt spec="Names" ref="NT-NCName">NCName</xnt>, optionally
                     preceded by a <nt def="ForwardAxisP">ForwardAxisP</nt>, then the priority is
                     −0.25. <phrase diff="add" at="2022-01-01">[XSLT 3.0 Erratum E37, bug 30375].</phrase></p>
               </item>
              
               <item>
                  <p>If the pattern is a <nt def="PathExprP">PathExprP</nt> taking the form of any
                     other <xnt spec="XP40" ref="prod-xpath40-NodeTest">NodeTest</xnt>, optionally
                     preceded by a <nt def="ForwardAxisP">ForwardAxisP</nt>, then the priority is
                     −0.5.</p>
               </item>
               <item>
                  <p diff="add" at="2023-03-15">If the pattern is a <nt def="TypePattern">TypePattern</nt>, then the priority
                  is 0 (zero).</p></item>
               <item>
                  <p>In all other cases, the priority is +0.5.</p>
               </item>
            </olist>
            <note>
               <p>In many cases this means that highly selective patterns have higher priority than
                  less selective patterns. The most common kind of pattern (a pattern that tests for
                  a node of a particular kind, with a particular <termref def="dt-expanded-qname">expanded QName</termref> or a particular type) has priority 0. The next less
                  specific kind of pattern (a pattern that tests for a node of a particular kind and
                  an <termref def="dt-expanded-qname">expanded QName</termref> with a particular
                  namespace URI) has priority −0.25. Patterns less specific than this
                  (patterns that just test for nodes of a given kind) have priority −0.5.
                  Patterns that specify both the name and the required type have a priority of
                  +0.25, putting them above patterns that only specify the name <emph>or</emph> the
                  type. Patterns more specific than this, for example patterns that include
                  predicates or that specify the ancestry of the required node, have priority
                  0.5.</p>
               
               <p>However, it is not invariably true that a more selective pattern has higher
                  priority than a less selective pattern. For example, the priority of the pattern
                     <code>node()[self::*]</code> is higher than that of the pattern
                     <code>salary</code>. Similarly, the patterns <code>attribute(*,
                     xs:decimal)</code> and <code>attribute(*, xs:short)</code> have the same
                  priority, despite the fact that the latter pattern matches a subset of the nodes
                  matched by the former. Therefore, to achieve clarity in a <termref def="dt-stylesheet">stylesheet</termref> it is good practice to allocate
                  explicit priorities.</p>
               
            </note>

         </div2>
         <div2 id="modes">
            <head>Modes</head>
            <p>
               <termdef id="dt-mode" term="mode"> A <term>mode</term> is a set of template rules;
                  when the <elcode>xsl:apply-templates</elcode> instruction selects a set of items
                  for processing, it identifies the rules to be used for processing those items by
                  nominating a mode, explicitly or implicitly.</termdef> Modes allow a node in a
                  <termref def="dt-source-tree">source tree</termref> (for example) to be processed
               multiple times, each time producing a different result. They also allow different
               sets of <termref def="dt-template-rule">template rules</termref> to be active when
               processing different trees, for example when processing documents loaded using the
                  <function>document</function> function (see <specref ref="func-document"/>). </p>
            <p>Modes are identified by an <termref def="dt-expanded-qname">expanded QName</termref>; in addition to any named modes, there is always one
               unnamed mode available. Whether a mode is named or unnamed, its properties
                  <rfc2119>may</rfc2119> be defined in an <elcode>xsl:mode</elcode> declaration. If
               a mode name is used (for example in an <elcode>xsl:template</elcode> declaration or
               an <elcode>xsl:apply-templates</elcode> instruction) and no declaration of that mode
               appears in the stylesheet, the mode is implicitly declared with default
               properties.</p>
            <div3 id="declaring-modes">
               <head>Declaring Modes</head>

               <?element xsl:mode?>



               <p>
                  <termdef id="dt-unnamed-mode" term="unnamed mode">The <term>unnamed mode</term> is the default mode used when no
                        <code>mode</code> attribute is specified on an
                        <elcode>xsl:apply-templates</elcode> instruction or
                        <elcode>xsl:template</elcode> declaration, unless a different default mode
                     has been specified using the <code>[xsl:]default-mode</code> attribute of a containing
                        element.</termdef>
               </p>
               <p>Every <termref def="dt-mode">mode</termref> other than the <termref def="dt-unnamed-mode">unnamed mode</termref> is identified by an <termref def="dt-expanded-qname">expanded QName</termref>.</p>
               <p>A <termref def="dt-stylesheet">stylesheet</termref> may contain multiple
                     <elcode>xsl:mode</elcode> declarations and may include or import <termref def="dt-stylesheet-module">stylesheet modules</termref> that also contain
                     <elcode>xsl:mode</elcode> declarations. The name of an
                     <elcode>xsl:mode</elcode> declaration is the value of its <code>name</code>
                  attribute, if any.</p>
               <p>
                  <termdef id="dt-mode-definition" term="mode definition">All the
                        <elcode>xsl:mode</elcode> declarations in a <termref def="dt-package"/> that share the same
                     name are grouped into a named <term>mode definition</term>; those that have no
                     name are grouped into a single unnamed mode definition.</termdef>
               </p>
               <p>The <code>declared-modes</code> attribute of
                     the <elcode>xsl:package</elcode> element determines whether implicit mode
                     declarations are allowed, as described in <specref ref="requiring-explicit-modes"/>. If the package allows implicit mode
                     declarations, then  if a <termref def="dt-stylesheet">stylesheet</termref> does not contain a declaration of the unnamed mode, a
                  declaration is implied equivalent to an <elcode>xsl:mode</elcode> element with
                     no attributes. Similarly, if there
                  is a mode that is named in an <elcode>xsl:template</elcode> or
                     <elcode>xsl:apply-templates</elcode> element, or in the <code>[xsl:]default-mode</code> attribute of a containing
                     element, and the <termref def="dt-stylesheet">stylesheet</termref>
                  does not contain a declaration of that mode, then a declaration is implied
                  comprising an <elcode>xsl:mode</elcode> element with a <code>name</code> attribute
                     equal to that mode name, plus the attribute
                        <code>visibility="private"</code>. </p>

               
               
               <p>The attributes of the <elcode>xsl:mode</elcode> declaration establish values for a
                  number of properties of a mode. The allowed values and meanings of the attributes
                  are given in the following table.</p>


               <table class="data">
                  <caption>Attributes of the <code>xsl:mode</code> Element</caption>
                  <thead>
                     <tr>
                        <th rowspan="1" colspan="1">Attribute</th>
                        <th rowspan="1" colspan="1">Values</th>
                        <th rowspan="1" colspan="1">Meaning</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">name</td>
                        <td valign="top" rowspan="1" colspan="1">An <termref def="dt-eqname">EQName</termref></td>
                        <td valign="top" rowspan="1" colspan="1">Specifies the name of the mode. If omitted, this
                              <elcode>xsl:mode</elcode> declaration provides properties of the
                              <termref def="dt-unnamed-mode">unnamed mode</termref></td>
                     </tr>
                     <tr diff="add" at="2022-01-01">
                        <td valign="top" rowspan="1" colspan="1">as</td>
                        <td valign="top" rowspan="1" colspan="1">A <code>SequenceType</code></td>
                        <td valign="top" rowspan="1" colspan="1">Declares the type of value returned by all
                           template rules in this mode. If any template rules in this mode declare their
                        return type using an <code>as</code> attribute on <elcode>xsl:template</elcode>,
                        the values must be consistent.</td>
                     </tr> 
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">streamable</td>
                        <td valign="top" rowspan="1" colspan="1"><code>yes</code> or <code>no</code> (default
                              <code>no</code>)</td>
                        <td valign="top" rowspan="1" colspan="1">Determines whether template rules in this mode are to be
                           capable of being processed using <termref def="dt-streaming"/>. If the
                           value <code>yes</code> is specified, then the body of any <termref def="dt-template-rule">template rule</termref> that uses this mode
                              <rfc2119>must</rfc2119> conform to the rules for streamable templates
                           given in <specref ref="streamable-templates"/>.</td>
                     </tr> 
                     
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">use-accumulators</td>
                        <td valign="top" rowspan="1" colspan="1">List of accumulator names, or <code>#all</code> (default is an empty list)</td>
                        <td valign="top" rowspan="1" colspan="1">Relevant only when this mode is the <termref def="dt-initial-mode"/>
                           of the transformation, determines which accumulators are applicable to documents
                           containing nodes in the <termref def="dt-initial-match-selection"/>. For
                        further details see <specref ref="applicability-of-accumulators"/>.</td> 
                     </tr>

                     <tr>
                        <td valign="top" rowspan="1" colspan="1">on-no-match</td>
                        <td valign="top" rowspan="1" colspan="1">One of <code>deep-copy</code>,
                                 <code>shallow-copy</code>, <code>deep-skip</code>,
                                 <code>shallow-skip</code>, <code>text-only-copy</code> or
                                 <code>fail</code> (default
                           <code>text-only-copy</code>)</td>
                        <td valign="top" rowspan="1" colspan="1">Determines selection of the built-in <termref def="dt-template-rule">template rules</termref> that are used to
                           process an item when an
                              <elcode>xsl:apply-templates</elcode> instruction selects an item that does not match any
                           user-written <termref def="dt-template-rule">template rule</termref> in
                           the <termref def="dt-stylesheet">stylesheet</termref>. For details, see
                              <specref ref="built-in-rule"/>.</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">on-multiple-match</td>
                        <td valign="top" rowspan="1" colspan="1">One of <code>fail</code> or <code>use-last</code> (default
                              <code>use-last</code>)</td>
                        <td valign="top" rowspan="1" colspan="1">Defines the action to be taken when
                              <elcode>xsl:apply-templates</elcode> is used in this mode and more
                           than one user-written <termref def="dt-template-rule">template
                              rule</termref> is available to process an item, each having the same <termref def="dt-import-precedence">import precedence</termref> and <termref def="dt-priority">priority</termref>. The value <code>fail</code>
                           indicates that it is a <termref def="dt-dynamic-error"> dynamic error</termref> if more
                           than one template rule matches an
                              item. The value <code>use-last</code> indicates that the
                           situation is not to be treated as an error (the last template in <termref def="dt-declaration-order">declaration order</termref> is the one that
                           is used). </td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">warning-on-no-match</td>
                        <td valign="top" rowspan="1" colspan="1">One of <code>yes</code> or <code>no</code>. The default is
                              <termref def="dt-implementation-defined"/>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">Requests the <termref def="dt-processor">processor</termref> to output (or not to output) a warning message in
                           the case where an <elcode>xsl:apply-templates</elcode> instruction
                           selects an item that matches
                           no user-written template rule. The form and destination of such warnings
                           is <termref def="dt-implementation-defined">implementation-defined</termref>. The processor
                              <rfc2119>may</rfc2119> ignore this attribute, for example if the
                           environment provides no suitable means of communicating with the user.
                        </td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">warning-on-multiple-match</td>
                        <td valign="top" rowspan="1" colspan="1">One of <code>yes</code> or <code>no</code>. The default is
                              <termref def="dt-implementation-defined"/>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">Requests the <termref def="dt-processor">processor</termref> to output a warning message in the case where an
                              <elcode>xsl:apply-templates</elcode> instruction selects an item that matches multiple
                           template rules having the same <termref def="dt-import-precedence">import
                              precedence</termref> and <termref def="dt-priority">priority</termref>. The form and destination of such warnings is
                              <termref def="dt-implementation-defined">implementation-defined</termref>. The processor
                              <rfc2119>may</rfc2119> ignore this attribute, for example if the
                           environment provides no suitable means of communicating with the
                           user.</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">typed</td>
                        <td valign="top" rowspan="1" colspan="1">One of <code>yes</code>, <code>no</code>,
                              <code>strict</code>, <code>lax</code>, or <code>unspecified</code>.
                           The default is <code>unspecified</code>.</td>
                        <td valign="top" rowspan="1" colspan="1">See <specref ref="xsl-mode-typed"/>.</td>

                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">visibility</td>
                        <td valign="top" rowspan="1" colspan="1">One of <code>public</code>, <code>private</code>, or
                              <code>final</code>. The default is <code>private</code>.</td>
                        <td valign="top" rowspan="1" colspan="1">See <specref ref="visibility"/>. If the mode is unnamed, that is, if the
                                 <code>name</code> attribute is absent, then the
                                 <code>visibility</code> attribute if present
                                 <rfc2119>must</rfc2119> have the value
                              <code>private</code>.<phrase diff="del" at="2022-11-25"> A named mode is not
                              eligible to be used as the <termref def="dt-initial-mode"/> if its
                              visibility is <code>private</code>.</phrase>
                           <ednote><edtext>See issue 270.</edtext></ednote></td>

                     </tr>

                  </tbody>

               </table>




               <imp-def-feature id="idf-err-warningonmatch">The default values for the
                     <code>warning-on-no-match</code> and <code>warning-on-multiple-match</code>
                  attributes of <elcode>xsl:mode</elcode> are <termref def="dt-implementation-defined"/>.</imp-def-feature>

               <imp-def-feature id="idf-err-matchmessages">The form of any warnings output when
                  there is no matching template rule, or when there are multiple matching template
                  rules, is <termref def="dt-implementation-defined"/>.</imp-def-feature>

               <p>
                  <termdef id="dt-streamable-mode" term="streamable mode">A <term>streamable
                        mode</term> is a <termref def="dt-mode">mode</termref> that is declared in
                     an <elcode>xsl:mode</elcode> declaration with the attribute
                        <code>streamable="yes"</code>.</termdef>
               </p>
               <p>For any named <termref def="dt-mode">mode</termref>, the <termref def="dt-effective-value"/> of each
                  attribute is taken from an <elcode>xsl:mode</elcode> declaration that has a
                  matching name in its <code>name</code> attribute, and that specifies an explicit
                  value for the required attribute. If there is
                     no such declaration, the default value of the attribute is used. If
                  there is more than one such declaration, the one with highest <termref def="dt-import-precedence">import precedence</termref> is used.</p>
               <p>For the <termref def="dt-unnamed-mode">unnamed mode</termref>, the <termref def="dt-effective-value"/>
                  of each attribute is taken from an <elcode>xsl:mode</elcode> declaration that has
                  no <code>name</code> attribute, and that specifies an explicit value for the
                  required attribute. If there is no such declaration, the default value of the
                  attribute is used. If there is more than one such declaration, the one with
                  highest <termref def="dt-import-precedence">import precedence</termref> is
                  used.</p>
               
               <p>
                  <error spec="XT" type="static" class="SE" code="0545">
                     <p>It is a <termref def="dt-static-error">static error</termref> if for any
                        named or unnamed <termref def="dt-mode">mode</termref>, a package explicitly specifies two conflicting
                        values for the same attribute in different <elcode>xsl:mode</elcode>
                        declarations having the same <termref def="dt-import-precedence">import
                           precedence</termref>, unless there is another definition of the same
                        attribute with higher import precedence. The attributes in question are the
                        attributes other than <code>name</code> on the <elcode>xsl:mode</elcode>
                           element.</p>
                  </error>
               </p>
               

               
            </div3>

            <div3 id="using-modes">
               <head>Using Modes</head>
               <p><termdef id="dt-applicable" term="applicable">A <termref def="dt-template-rule">template rule</termref> is <term>applicable</term> to one or more modes.
                     The modes to which it is applicable are defined by the <code>mode</code>
                     attribute of the <elcode>xsl:template</elcode> element. If the attribute is
                     omitted, then the template rule is applicable to the default mode specified in the <code>[xsl:]default-mode</code> attribute of the innermost containing
                           element that has such an attribute, which in turn defaults to
                        the <termref def="dt-unnamed-mode">unnamed mode</termref>. If the
                        <code>mode</code> attribute is present, then its value
                        <rfc2119>must</rfc2119> be a non-empty whitespace-separated list of tokens,
                     each of which defines a mode to which the template rule is
                     applicable.</termdef></p>

               <p>Each token in the <code>mode</code> attribute <rfc2119>must</rfc2119> be one of
                  the following:</p>
               <ulist>
                  <item>
                     <p>An <termref def="dt-eqname">EQName</termref>, which is expanded as described in <specref ref="qname"/> to define the name of the mode</p>
                  </item>
                  <item>
                     <p>The token <code>#default</code>, to indicate that the template rule is
                        applicable to the default mode that would apply if
                           the <code>mode</code> attribute were absent
                     </p>
                  </item>
                  <item>
                     <p>The token <code>#unnamed</code>, to indicate that the
                        template rule is applicable to the <termref def="dt-unnamed-mode">unnamed
                           mode</termref>
                     </p>
                  </item>
                  <item>
                     <p>The token <code>#all</code>, to indicate that the template rule is
                        applicable to all modes <phrase diff="chg" at="2022-01-01">other than <termref def="dt-enclosing-mode">enclosing modes</termref></phrase>
                        (specifically, to the unnamed mode and to every mode that is named explicitly or implicitly in an
                           <elcode>xsl:apply-templates</elcode> instruction  anywhere in
                        the stylesheet).</p>
                     <p diff="chg" at="2022-01-01">More specifically, when a template rule specifies <code>mode="#all"</code> this makes the
                        template rule <termref def="dt-applicable"/> to:</p>
                        <ulist>
                           <item><p>The unnamed mode.</p></item>
                           <item><p>Every mode, other than an <termref def="dt-enclosing-mode"/>, that is declared using an
                              <elcode>xsl:mode</elcode> declaration within the containing <termref def="dt-package"/>.</p></item>
                           <item><p>Every mode that is implicitly declared within the containing <termref def="dt-package"/>
                              by virtue of being referenced in an <elcode>xsl:template</elcode> or
                           <elcode>xsl:apply-templates</elcode> element.</p></item>
                        </ulist>
                        <p>The value <code>mode="#all"</code>
                        cannot be used on a template rule declared within an
                        <elcode>xsl:override</elcode> <phrase diff="add" at="2022-01-01">or <elcode>xsl:mode</elcode></phrase> element.</p>
                  </item>
               </ulist>

               <p></p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0550">
                     <p>It is a <termref def="dt-static-error">static error</termref> if the list of
                        modes <error.extra>in the <code>mode</code> attribute of
                              <elcode>xsl:template</elcode>
                        </error.extra> is empty, if the same token is included more than once in the
                        list, if the list contains an invalid token, or if the token
                           <code>#all</code> appears together with any other value.</p>
                  </error>
               </p>
               <p>
                  <error spec="XT" type="static" class="SE" code="3440">
                     <p>In the case of a <termref def="dt-template-rule"/> (that is, an
                           <elcode>xsl:template</elcode> element having a <code>match</code>
                        attribute) appearing as a child of <elcode>xsl:override</elcode>, it is a
                           <termref def="dt-static-error">static error</termref> if the list of
                        modes in the <code>mode</code> attribute contains <code>#all</code> or
                           <code>#unnamed</code>, or if it contains <code>#default</code> and the
                        default mode is the <termref def="dt-unnamed-mode"/>, or if the
                           <code>mode</code> attribute is omitted when the default mode is the
                           <termref def="dt-unnamed-mode"/>.</p>
                  </error>
               </p>
               <p>The <elcode>xsl:apply-templates</elcode> element also has an optional
                     <code>mode</code> attribute. The value of this attribute
                     <rfc2119>must</rfc2119> be one of the following:</p>
               <ulist>
                  <item>
                     <p>an <termref def="dt-eqname">EQName</termref>, which is expanded as described in <specref ref="qname"/> to define the name of a mode</p>
                  </item>
                  <item>
                     <p>the token <code>#default</code>, to indicate that the default mode for the <termref def="dt-stylesheet-module">stylesheet
                              module</termref>
                         is to be used</p>
                  </item>
                  <item>
                     <p>the token <code>#unnamed</code>, to indicate that the
                           <termref def="dt-unnamed-mode">unnamed mode</termref> is to be used</p>
                  </item>
                  <item>
                     <p>the token <code>#current</code>, to indicate that the <termref def="dt-current-mode">current mode</termref> is to be used</p>
                  </item>
               </ulist>

               <p>If the attribute is omitted, the default mode for the
                        <termref def="dt-stylesheet-module">stylesheet module</termref>
                   is used.</p>
               <p>When searching for a template rule to process each item selected by the <elcode>xsl:apply-templates</elcode>
                  instruction, only those template rules that are applicable to the selected mode
                  are considered.</p>
               <!--Text replaced by erratum E19 change 2"-->
               <p>
                  <termdef id="dt-current-mode" term="current mode">At any point in the processing
                     of a stylesheet, there is a <term>current mode</term>. When the transformation
                     is initiated, the current mode is the <termref def="dt-initial-mode"/>, as described in <specref ref="initiating"/>. Whenever an <elcode>xsl:apply-templates</elcode>
                     instruction is evaluated, the current mode becomes the mode selected by this
                     instruction.</termdef> When a <termref def="dt-non-contextual-function-call"/> is made, the current mode
                  is set to the <termref def="dt-unnamed-mode">unnamed mode</termref>. While
                  evaluating global variables and parameters, and the sequence constructor contained
                  in <elcode>xsl:key</elcode> or <elcode>xsl:sort</elcode>, the current mode is set
                  to the unnamed mode. No other instruction changes the current mode. The current
                  mode while evaluating an <termref def="dt-attribute-set">attribute set</termref>
                  is the same as the current mode of the caller. On completion of the
                     <elcode>xsl:apply-templates</elcode> instruction, or on return from a
                  stylesheet function call, the current mode reverts to its previous value. The
                  current mode is used when an <elcode>xsl:apply-templates</elcode> instruction uses
                  the syntax <code>mode="#current"</code>; it is also used by the
                     <elcode>xsl:apply-imports</elcode> and <elcode>xsl:next-match</elcode>
                  instructions (see <specref ref="apply-imports"/>).</p>
            </div3>
            <!--End of text replaced by erratum E19-->

            <div3 id="xsl-mode-typed">
               <head>Declaring the Type of Nodes Processed by a Mode</head>

               <p>Typically the template rules in a particular <termref def="dt-mode"/> will be
                  designed to process a specific kind of input document. The <code>typed</code>
                  attribute of <elcode>xsl:mode</elcode> gives the stylesheet author the opportunity
                  to provide information about this document to the processor. This information may
                  enable the processor to improve diagnostics or to optimize performance.</p>

               <p>The <code>typed</code> attribute of <elcode>xsl:mode</elcode> informs the
                  processor whether the nodes to be processed by template rules in this mode are to
                  be typed or untyped. </p>

               <ulist>
                  <item>
                     <p>If the value <code>yes</code> is specified (synonyms <code>true</code> or
                           <code>1</code>), then all nodes processed in this mode must be typed. A
                        dynamic error occurs if <elcode>xsl:apply-templates</elcode> in this mode
                        selects an element or attribute node whose <termref def="dt-type-annotation"/> is <code>xs:untyped</code> or <code>xs:untypedAtomic</code>. </p>
                  </item>
                  <item>
                     <p>If the value <code>no</code> is specified (synonyms <code>false</code> or
                           <code>0</code>), then all nodes processed in this mode must be untyped. A
                        dynamic error occurs if <elcode>xsl:apply-templates</elcode> in this mode
                        selects an element or attribute whose <termref def="dt-type-annotation"/> is
                        anything other than <code>xs:untyped</code> or
                        <code>xs:untypedAtomic</code>. </p>
                  </item>
                  <item>
                     <p>The value <code>strict</code> is equivalent to <code>yes</code>, with the
                        additional provision that in the match pattern of any template rule that is
                           <termref def="dt-applicable"/> to this mode, any <code>NameTest</code>
                        used in the <code>ForwardStepP</code> of the first <code>StepExprP</code> of
                        a <code>RelativePathExprP</code> is interpreted as follows:</p>

                     <ulist>
                        <item>
                           <p>If the <code>NameTest</code> is an <code>EQName</code>
                              <var>E</var>, and the principal node kind of the axis of this step is
                                 <code>Element</code>, then:</p>
                           <ulist>
                                 <item>
                                    <p>It is a static error if the in-scope schema declarations do
                                       not include a global element declaration for element name
                                          <var>E</var>
                                    </p>
                                 </item>
                                 <item>
                                    <p>When matching templates in this mode, the element name
                                          <var>E</var> appearing in this step is interpreted as
                                          <code>schema-element(E)</code>. (Informally, this means
                                       that it will only match an element if it has been validated
                                       against this element declaration). </p>
                                 </item>
                              </ulist>
                        </item>
                        <item>
                           <p>Otherwise (the <code>NameTest</code> is a wildcard or the principal
                              node kind is <code>Attribute</code> or <code>Namespace</code>), the
                              template matching proceeds as if the <code>typed</code> attribute were
                              absent. </p>
                        </item>
                     </ulist>

                  </item>
                  <item>
                     <p>The value <code>lax</code> is equivalent to <code>yes</code>, with the
                        additional provision that in the match pattern of any template rule that is
                           <termref def="dt-applicable"/> to this mode, any <code>NameTest</code>
                        used in the <code>ForwardStepP</code> of the first <code>StepExprP</code> of
                        a <code>RelativePathExprP</code> is interpreted as follows:</p>

                     <ulist>
                        <item>
                           <p>If the <code>NameTest</code> is an <code>EQName</code>
                              <var>E</var>, and the principal node kind of the axis of this step is
                                 <code>Element</code>, and the in-scope schema declarations include
                              a global element declaration for element name <var>E</var>, then:</p>
                           <ulist>

                                 <item>
                                    <p>When matching templates in this mode, the element name
                                          <var>E</var> appearing in this step is interpreted as
                                          <code>schema-element(E)</code>. (Informally, this means
                                       that it will only match an element if it has been validated
                                       against this element declaration). </p>
                                 </item>
                              </ulist>
                        </item>
                        <item>
                           <p>Otherwise (the <code>NameTest</code> is a wildcard, or the principal
                              node kind is <code>Attribute</code> or <code>Namespace</code>, or
                              there is no element declaration for <var>E</var>), the template
                              matching proceeds as if the <code>typed</code> attribute were absent.
                           </p>
                        </item>
                     </ulist>

                  </item>

               </ulist>

               <p>
                  <error spec="XT" type="type" class="TE" code="3100">
                     <p>It is a <termref def="dt-type-error">type error</termref> if an
                           <elcode>xsl:apply-templates</elcode> instruction in a particular
                           <code>mode</code> selects an element or attribute whose type is
                           <code>xs:untyped</code> or <code>xs:untypedAtomic</code> when the
                           <code>typed</code> attribute of that mode specifies the value
                           <code>yes</code>, <code>strict</code>, or <code>lax</code>.</p>
                  </error>
               </p>

               <p>
                  <error spec="XT" type="static" class="SE" code="3105">
                     <p>It is a <termref def="dt-static-error">static error</termref> if a template
                        rule applicable to a mode that is defined with <code>typed="strict"</code>
                        uses a match pattern that contains a <code>RelativePathExprP</code> whose
                        first <code>StepExprP</code> is an <code>AxisStepP</code> whose
                           <code>ForwardStepP</code> uses an axis whose principal node kind is
                           <code>Element</code> and whose <code>NodeTest</code> is an
                           <code>EQName</code> that does not correspond to the name of any global
                        element declaration in the <termref def="dt-in-scope-schema-component">in-scope schema components</termref>.</p>
                  </error>
               </p>

               <p>
                  <error spec="XT" type="type" class="TE" code="3110">
                     <p>It is a <termref def="dt-type-error">type error</termref> if an
                           <elcode>xsl:apply-templates</elcode> instruction in a particular
                           <code>mode</code> selects an element or attribute whose type is anything
                        other than <code>xs:untyped</code> or <code>xs:untypedAtomic</code> when the
                           <code>typed</code> attribute of that mode specifies the value
                           <code>no</code>.</p>
                  </error>
               </p>


            </div3>
            
            <div3 id="mode-result-type" diff="add" at="2022-01-01">
               <head>Declaring the result type of a mode</head>
               <p>Traditionally, template rules have most commonly been used to construct XDM nodes, and the <elcode>xsl:apply-templates</elcode>
               instruction has been used to add nodes to a result tree. However, it is also possible to use template rules to produce
               other kinds of value, for example strings, booleans, or maps. For the <elcode>xsl:apply-templates</elcode> 
               instruction to be useful, it will generally be the case that all template rules in a mode produce the same kind
               of value: for example, if one rule delivers a boolean, then the other rules will also deliver a boolean.</p>
               
               <p>XSLT 4.0 therefore allows the result type of the template rules in a mode to be declared using the <code>as</code>
               attribute on the <elcode>xsl:mode</elcode> declaration. If this is absent, it defaults to <code>item()*</code>.
               The presence of an <code>as</code> attribute on a mode provides useful documentation and consistency checking,
               and enables the XSLT processor to infer a static type for an <elcode>xsl:apply-templates</elcode> instruction,
               which can be useful for optimization.</p>
               
               <p>If a template rule <var>R</var> is <termref def="dt-applicable"/> to a mode <var>M</var>, 
                  and <var>M</var> is declared with an <code>as</code> attribute whose value is the <code>SequenceType</code> 
                  <var>T</var>, then:</p>
               
               <ulist>
                  <item><p>If <code>R</code> has an <code>as</code> attribute, the <code>SequenceType</code> <var>S</var> declared
                     by <var>R</var> must be a subtype of <var>T</var>,
                  according to the relationship <code>subtype(S, T)</code> defined in <xspecref spec="XP40" ref="id-seqtype-subtype"/>.</p></item>
                  <item><p>If <code>R</code> has no <code>as</code> attribute, then it is treated as if it had an <code>as</code>
                     attribute set to <var>T</var>. If <code>R</code> is applicable
                     to more than one mode, then the implicit <code>SequenceType</code> inferred for any one of these modes
                     must be consistent with the <code>SequenceType</code> declared on all the other modes to which <code>R</code>
                  is applicable: for example, if <var>is</var> applicable to modes <var>M1</var> and <var>M2</var>, and if
                  <var>M1</var> declares a result type of <code>element(A)</code>, then a static error occurs if 
                     <code>element(A)</code> is not a subtype of the (explicit or implicit) result type for mode <var>M2</var>.</p>
                  <note><p>In practice this means that if a template rule is applicable to more than one mode (including
                  the case <code>mode="#all"</code>), then either (a) all those modes should have the same declared result type,
                  or (b) the template rule should declare an explicit result type that is compatible with each one of the relevant modes.</p></note>
                  <p>TODO: define the error code.</p></item>
               </ulist>
            </div3>
            
            <div3 id="enclosing-modes" diff="add" at="2022-01-01">
               <head>Enclosing Modes</head>
               <p><termdef id="dt-enclosing-mode" term="enclosing mode">A mode declared by
                  an <elcode>xsl:mode</elcode> declaration that has one or more contained <elcode>xsl:template</elcode>
                  declarations is referred to as an <term>enclosing mode</term>.</termdef></p>
               <p>An enclosing mode ensures that all the template rules for a mode are together in one place, which
               makes it easier for someone reading the stylesheet to establish what is going to happen when an
               <elcode>xsl:apply-templates</elcode> instruction in that mode is evaluated.</p>
               <p>An enclosing mode <rfc2119>must</rfc2119> satisfy the following rules:</p>
               <olist>
                  <item><p>The mode must have a name.</p></item>
                  <item><p>Every contained <elcode>xsl:template</elcode> element must have a <code>match</code>
                  attribute and no <code>name</code> attribute.</p></item>
                  <item><p>Every contained <elcode>xsl:template</elcode> element must have no <code>mode</code>
                  attribute: the template is implicitly <termref def="dt-applicable"/> only to the containing mode.</p></item>
                  <item><p>An <elcode>xsl:mode</elcode> declaration with one or more <elcode>xsl:template</elcode>
                  children effectively has a <code>default-mode</code> attribute whose value is the mode’s name;
                     it must not have a <code>default-mode</code> attribute with any other value.</p>
                  <note><p>This means that <elcode>xsl:apply-templates</elcode> instructions within the template
                  rules of the enclosing mode default to using the enclosing mode.</p></note></item>
                  <item><p>No <elcode>xsl:template</elcode> that is in the same <phrase diff="chg" at="2022-11-01"><termref def="dt-package"/></phrase>
                     as the containing mode, but not declared within the containing mode, may be <termref def="dt-applicable"/>
                  to the containing mode.</p>
                   
                  <note><p>Template rules in an enclosing mode may, however, be overridden within an 
                     <elcode>xsl:override</elcode> element in a using <termref def="dt-package"/>.</p></note></item>
                  <item><p>There must be no other <elcode>xsl:mode</elcode> declaration in the containing <termref def="dt-package"/>
                  having the same name and the same <termref def="dt-import-precedence"/>.</p></item>
               </olist>
               
               <p>These rules give rise to the following error conditions:</p>
               
               <p><error spec="XT" type="static" class="SE" code="4005">
                  <p>It is a <termref def="dt-static-error">static error</termref> if an <elcode>xsl:mode</elcode>
                     declaration with one or more <elcode>xsl:template</elcode> children has no <code>name</code>
                     attribute.</p>
               </error></p>
               <p><error spec="XT" type="static" class="SE" code="4010">
                  <p>It is a <termref def="dt-static-error">static error</termref> if an <elcode>xsl:mode</elcode>
                     declaration has a child <elcode>xsl:template</elcode> element with a <code>name</code> attribute,
                     with a <code>mode</code> attribute, or with no <code>match</code> attribute.</p>
               </error></p>
               <p><error spec="XT" type="static" class="SE" code="4015">
                  <p>It is a <termref def="dt-static-error">static error</termref> if an <elcode>xsl:mode</elcode>
                     declaration having one or more child <elcode>xsl:template</elcode> elements has a <code>default-mode</code>
                     attribute whose value differs from its <code>name</code> attribute, or if any of those child <elcode>xsl:template</elcode> 
                     elements has a <code>default-mode</code> attribute that differs from the <code>name</code> attribute
                     of the <elcode>xsl:mode</elcode> declaration.</p>
               </error></p>
               <p><error spec="XT" type="static" class="SE" code="4020">
                  <p>It is a <termref def="dt-static-error">static error</termref> if a
                     <termref def="dt-package"/> contains both (a) an <elcode>xsl:mode</elcode>
                     declaration having one or more child <elcode>xsl:template</elcode> elements, and (b) 
                     an <elcode>xsl:template</elcode> declaration that is not
                     one of those children but that references that <elcode>xsl:mode</elcode> declaration in its
                     <code>mode</code> attribute.</p>
               </error></p>
               <p><error spec="XT" type="static" class="SE" code="4025">
                  <p>It is a <termref def="dt-static-error">static error</termref> if a
                     <termref def="dt-package"/> contains (a) an <elcode>xsl:mode</elcode>
                     declaration having one or more child <elcode>xsl:template</elcode> elements, and (b) 
                     a second <elcode>xsl:mode</elcode> declaration having the same name and the same
                     <termref def="dt-import-precedence"/>.</p>
               </error></p>
               
               <example>
                  <head>An Enclosing Mode</head>
                  <p>The following mode might be used for formatting of numbers appearing in text:</p>
                  <eg role="xslt-declaration"><![CDATA[
<xsl:mode name="numbers-in-text" as="xs:string" visibility="final">
  <xsl:template match="type(xs:integer)[. gt 0 and . lt 21]">
    <xsl:number value="." format="w"/>
  </xsl:template>
  <xsl:template match="type(xs:integer)[. lt 10000]">
    <xsl:number value="." format="1"/>
  </xsl:template>
  <xsl:template match="type(xs:integer)">
    <xsl:number value="." format="1" grouping-separator="," grouping-size="3"/>
  </xsl:template>  
</xsl:mode>
                     ]]></eg>
               </example>
               
            </div3>

            <div3 id="streamable-templates">
               <head>Streamable Templates</head>
               <p>A template rule that is <termref def="dt-applicable"/> to a mode <var>M</var> is <termref def="dt-guaranteed-streamable"/> if and only if all the following conditions
                  are satisfied:</p>
               <olist>
                  <item>
                     <p>Mode <var>M</var> is declared in an <elcode>xsl:mode</elcode> declaration
                        that specifies <code>streamable="yes"</code>.</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-pattern">pattern</termref> defined in the
                           <code>match</code> attribute of the <elcode>xsl:template</elcode> element
                           is a <termref def="dt-motionless"/>
                        pattern as defined in <specref ref="classifying-patterns"/>.</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-sweep"/> of the <termref def="dt-sequence-constructor"/> forming the body of the <elcode>xsl:template</elcode> element is either
                           <termref def="dt-motionless"/> or <termref def="dt-consuming"/>.</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-type-adjusted-posture-and-sweep">type-adjusted
                           posture</termref> of the <termref def="dt-sequence-constructor"/> forming
                        the body of the <elcode>xsl:template</elcode> element, with respect to the
                           <termref def="dt-utype"/> that corresponds to the declared return type of
                        the template (defaulting to <code>item()*</code>), is <termref def="dt-grounded"/>.</p>

                     <note>
                        <p>This means that either (a) the sequence constructor is grounded as
                           written (that is, it does not return streamed nodes), or (b) it
                           effectively becomes grounded because the declared result type of the
                           template is atomic, leading to implicit atomization of the result.</p>
                     </note>
                  </item>
                  
                  <item>
                     <p>Every <termref def="dt-expression">expression</termref> and contained
                           <termref def="dt-sequence-constructor"/> in a contained
                           <elcode>xsl:param</elcode> element (the construct that provides the
                        default value of the parameter) is
                        <termref def="dt-motionless"/>.</p>
                  </item>

               </olist>

               <p>Specifying <code>streamable="yes"</code> on an
                     <elcode>xsl:mode</elcode> declaration declares an intent that every template
                  rule <phrase diff="chg" at="2022-01-01">to which that mode is <termref def="dt-applicable"/></phrase> 
                  (explicitly or implicitly, including by specifying
                     <code>#all</code>), should be streamable,
                     either because it is <termref def="dt-guaranteed-streamable"/>, or because it
                     takes advantage of streamability extensions offered by a particular
                     processor. The consequences of declaring the mode to be streamable
                  when there is such a template rule that is not guaranteed streamable depend on the
                  conformance level of the processor, and are explained in <specref ref="streamability-guarantees"/>.</p>

               <p>Processing of a document using streamable templates may be
                  initiated using code such as the following, where <code>S</code> is a mode
                  declared with <code>streamable="yes"</code>:</p>
               <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:source-document streamable="yes" href="bigdoc.xml"&gt;
  &lt;xsl:apply-templates mode="S"/&gt;
&lt;/xsl:source-document&gt;</eg>

               <p>Alternatively, streamed processing may be initiated by invoking
                  the transformation with an <termref def="dt-initial-mode"/> declared as
                  streamable, while supplying the <termref def="dt-initial-match-selection"/> (in an <termref def="dt-implementation-defined"/> way) as a streamed document.</p>

               <imp-def-feature id="idf-api-streaming">Streamed processing may be initiated by
                  invoking the transformation with an <termref def="dt-initial-mode"/> declared as
                  streamable, while supplying the <termref def="dt-initial-match-selection"/> (in an <termref def="dt-implementation-defined"/> way) as a streamed
                  document.</imp-def-feature>

               <note>
                  <p>Invoking a streamable template using the construct
                        <code>&lt;xsl:apply-templates select="doc('bigdoc.xml')"/&gt;</code> does
                     not ensure streamed processing. As always, processors may use streamed
                     processing if they are able to do so, but when the <xfunction>doc</xfunction>
                     or <function>document</function> functions are used, processors are obliged to
                     ensure that the results are deterministic, which may be difficult to reconcile
                     with streaming (if the same document is read twice, the results must be
                     identical). The use of <elcode>xsl:source-document</elcode> 
                     with <code>streamable="yes"</code>
                     does not offer the same guarantees of determinism.</p>
               </note>

               <p>For an example of processing a collection of documents by use of the function
                     <xfunction>uri-collection</xfunction> in conjunction with
                     <elcode>xsl:source-document</elcode>, see <specref ref="stream-examples"/>.</p>

            </div3>

         </div2>



         <div2 id="built-in-rule">
            <head>Built-in Template Rules</head>
            <p>When an item is
               selected by <elcode>xsl:apply-templates</elcode> and there is no user-specified
                  <termref def="dt-template-rule">template rule</termref> in the <termref def="dt-stylesheet">stylesheet</termref> that can be used to process that item, then a built-in template rule is
               evaluated instead. </p>
            <p>The built-in <termref def="dt-template-rule">template rules</termref> have lower
                  <termref def="dt-import-precedence">import precedence</termref> than all other
               template rules. Thus, the stylesheet author can override a built-in template rule by
               including an explicit template rule.</p>
            <p>There are six sets of built-in template rules available. The set
               that is chosen is a property of the <termref def="dt-mode">mode</termref> selected by
               the <elcode>xsl:apply-templates</elcode> instruction. This property is set using the
                  <code>on-no-match</code> attribute of the <elcode>xsl:mode</elcode> declaration,
               which takes one of the six values <code>deep-copy</code>, <code>shallow-copy</code>,
                  <code>deep-skip</code>, <code>shallow-skip</code>, <code>text-only-copy</code>, or
                  <code>fail</code>, the default being <code>text-only-copy</code>. The effect of
               these six sets of built-in template rules is explained in the following
               subsections.</p>
            <div3 id="built-in-templates-text-only-copy">
               <head>Built-in Templates: Text-only Copy</head>
               <p>The effect of processing a
                     tree using a <termref def="dt-mode">mode</termref> that specifies
                        <code>on-no-match="text-only-copy"</code> is that the textual
                  content of the source document is retained while losing the markup, except where
                  explicit template rules dictate otherwise. When an element is encountered for
                  which there is no explicit <termref def="dt-template-rule">template
                  rule</termref>, the processing continues with the children of that element. Text
                  nodes are copied to the output.</p>
               <p>The built-in rule for document nodes and element nodes is equivalent to calling
                     <elcode>xsl:apply-templates</elcode> with no <code>select</code> attribute, and
                  with the <code>mode</code> attribute set to <code>#current</code>. If the built-in
                  rule was invoked with parameters, those parameters are passed on in the implicit
                     <elcode>xsl:apply-templates</elcode> instruction.</p>
               <p>This is equivalent to the following in the case where
                  there are no parameters:</p>

               <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:template match="document-node()|element()" mode="M"&gt;
  &lt;xsl:apply-templates mode="#current"/&gt;
&lt;/xsl:template&gt;</eg>

               <p>The built-in <termref def="dt-template-rule">template
                     rule</termref> for text and attribute nodes returns a text node containing the
                     <termref def="dt-string-value">string value</termref> of the context node. It
                  is effectively:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="text()|@*" mode="M"&gt;
  &lt;xsl:value-of select="string(.)"/&gt;
&lt;/xsl:template&gt;</eg>
               <note>
                  <p>This text node may have a string value that is zero-length.</p>
               </note>
               <p>The built-in <termref def="dt-template-rule">template
                     rule</termref> for atomic values returns a
                  text node containing the value. It is effectively:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match=".[. instance of xs:anyAtomicType]" mode="M"&gt;
  &lt;xsl:value-of select="string(.)"/&gt;
&lt;/xsl:template&gt;</eg>
               <note>
                  <p>This text node may have a string value that is zero-length.</p>
               </note>
               <p>The built-in <termref def="dt-template-rule">template
                     rule</termref> for processing instructions, comments, and namespace nodes does
                  nothing (it returns the empty sequence).</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template 
   match="processing-instruction()|comment()|namespace-node()" 
   mode="M"/&gt;</eg>
               <p>The built-in <termref def="dt-template-rule">template
                     rule</termref> for functions (including
                     maps) does nothing (it returns the empty sequence).</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template 
   match=".[. instance of function(*)]" 
   mode="M"/&gt;</eg>
               
               
               <p>The built-in <termref def="dt-template-rule"/> for
               arrays (see <specref ref="arrays"/>) is to apply templates to the members of the array.
               It is equivalent to invoking <elcode>xsl:apply-templates</elcode> with the <code>select</code>
               attribute set to <code>?*</code> (which selects the members of the array), and with the 
                  <code>mode</code> attribute set to <code>#current</code>. If the built-in
                  rule was invoked with parameters, those parameters are passed on in the implicit
                  <elcode>xsl:apply-templates</elcode> instruction.</p>
               <p>This is equivalent to the following in the case where
                  there are no parameters:</p>
               
               <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:template match=".[. instance of array(*)]" mode="M"&gt;
  &lt;xsl:apply-templates mode="#current" select="?*"/&gt;
&lt;/xsl:template&gt;</eg>
               <p>The following example illustrates the use of built-in template rules when there
                  are parameters.</p>
               <example>
                  <head>Using a Built-In Template Rule</head>
                  <p>Suppose the stylesheet contains the following instruction:</p>
                  <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:apply-templates select="title" mode="M"&gt;
  &lt;xsl:with-param name="init" select="10"/&gt;
&lt;/xsl:apply-templates&gt;</eg>
                  <p>If there is no explicit template rule that matches the <code>title</code>
                     element, then the following implicit rule is used:</p>
                  <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="title" mode="M"&gt;
  &lt;xsl:param name="init"/&gt;
  &lt;xsl:apply-templates mode="#current"&gt;
    &lt;xsl:with-param name="init" select="$init"/&gt;
  &lt;/xsl:apply-templates&gt;
&lt;/xsl:template&gt;</eg>
               </example>
            </div3>

            <div3 id="built-in-templates-deep-copy">
               <head>Built-in Templates: Deep Copy</head>
               <p>The effect of processing a tree using a
                        <termref def="dt-mode">mode</termref> that specifies
                        <code>on-no-match="deep-copy"</code> is that an unmatched element
                  in the source tree is copied unchanged to the output, together with its entire
                  subtree. Other unmatched items are also copied unchanged. The subtree is copied
                  unconditionally, without attempting to match nodes in the subtree against template
                  rules.</p>
               <p>When this default action is selected for a mode <var>M</var>, all items (nodes, atomic values, and functions, including maps and arrays) are processed
                  using a template rule that is equivalent to the following:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="." mode="M"&gt;
  &lt;xsl:copy-of select="." validation="preserve"/&gt;
&lt;/xsl:template&gt;</eg>
            </div3>
            <div3 id="built-in-templates-shallow-copy">
               <head>Built-in Templates: Shallow Copy</head>
               <p>The effect of processing a tree using a
                        <termref def="dt-mode">mode</termref> that specifies
                        <code>on-no-match="shallow-copy"</code> is that the source tree is
                  copied unchanged to the output, except for nodes where different processing is
                  specified using an explicit <termref def="dt-template-rule">template
                     rule</termref>.</p>
               <p>When this default action is selected for a mode <var>M</var>, all items (nodes, atomic values, and functions, including maps and arrays) are processed
                  using a template rule that is equivalent to the following, except that all
                  parameters supplied in <elcode>xsl:with-param</elcode> elements are passed on
                  implicitly to the called templates:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="." mode="M"&gt;
  &lt;xsl:copy validation="preserve"&gt;
    &lt;xsl:apply-templates select="@*" mode="M"/&gt;
    &lt;xsl:apply-templates select="node()" mode="M"/&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;</eg>
               <p>This rule is often referred to as the <emph>identity template</emph>, though it
                  should be noted that it does not preserve node identity.</p>
               <note>
                  <p>This rule differs from the traditional identity template rule by using two
                        <elcode>xsl:apply-templates</elcode> instructions, one to process the
                     attributes and one to process the children. The only observable difference from
                     the traditional <code>select="node() | @*"</code> is that with two separate
                     instructions, the value of <code>position()</code> in the called templates
                     forms one sequence starting at 1 for the attributes, and a new sequence
                     starting at 1 for the children.</p>
                  
               </note>
               <example>
                  <head>Modified Identity Transformation</head>
                  <p>The following stylesheet transforms an input document by deleting all elements
                     named <code>note</code>, together with their attributes and descendants:</p>
                  <eg xml:space="preserve" role="xslt-document">&lt;xsl:stylesheet version="3.0"
     xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
				  
&lt;xsl:mode on-no-match="shallow-copy" streamable="true"/&gt;

&lt;xsl:template match="note"&gt;
  &lt;!-- no action --&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg>
               </example>

            </div3>
            <div3 id="built-in-templates-deep-skip">
               <head>Built-in Templates: Deep Skip</head>
               <p>The effect of processing a tree using a <termref def="dt-mode">mode</termref> that specifies
                     <code>on-no-match="deep-skip"</code> is that where no explicit template rule is
                  specified for an element, that element and all its descendants are ignored, and
                  are not copied to the result tree.</p>
               <p>The effect of choosing <code>on-no-match="deep-skip"</code> is as follows:</p>

               <ulist>
                  <item>
                     <p>The built-in rule for document nodes is equivalent to calling
                           <elcode>xsl:apply-templates</elcode> with no <code>select</code>
                        attribute, and with the <code>mode</code> attribute set to
                           <code>#current</code>. If the built-in rule was invoked with parameters,
                        those parameters are passed on in the implicit
                           <elcode>xsl:apply-templates</elcode> instruction.</p>
                     <p>In the case where there are no parameters, this
                        is equivalent to the following rule:</p>
                     <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="document-node()" mode="M"&gt;
  &lt;xsl:apply-templates mode="#current"/&gt;
&lt;/xsl:template&gt;</eg>
                  </item>
                  <item>
                     <p>The built-in rule for all items other than document nodes (that is, for all other kinds of node, as well as atomic
                           values and functions, including
                              maps and  and arrays) is to do nothing, that is, to return an empty
                        sequence (without applying templates to any children or ancestors).</p>
                     <p>This is equivalent to the following rule:</p>
                     <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:template match="." mode="M"/&gt;</eg>
                  </item>
               </ulist>

            </div3>
            <div3 id="built-in-templates-shallow-skip">
               <head>Built-in Templates: Shallow Skip</head>
               <p>The effect of processing a tree using a
                        <termref def="dt-mode">mode</termref> that specifies
                        <code>on-no-match="shallow-skip"</code> is to drop both the textual
                  content and the markup from the result document, except where there is an explicit
                  user-written <termref def="dt-template-rule">template rule</termref> that dictates
                  otherwise.</p>

               <p>The built-in rule for document nodes and element nodes  applies templates (in the current mode) first to the node’s
                     attributes and then to its children. If the built-in rule was invoked
                  with parameters, those parameters are passed on in the implicit
                     <elcode>xsl:apply-templates</elcode>
                  instructions.</p>

               <p>In the case where there are no parameters, this is
                  equivalent to the following rule:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="document-node()|element()" mode="M"&gt;
  &lt;xsl:apply-templates select="@*" mode="#current"/&gt;
  &lt;xsl:apply-templates mode="#current"/&gt;
&lt;/xsl:template&gt;</eg>


               <p>The built-in template rule for all other kinds of node, and for atomic values and
                  functions (including maps, but not arrays) is empty:
                  that is, when the item is matched, the built-in template rule returns an empty
                  sequence.</p>

               <p>This is equivalent to the following rule:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="." mode="M"/&gt;</eg>

               <p>The built-in <termref def="dt-template-rule"/> for
                  arrays (see <specref ref="arrays"/>) is to apply templates to the members of the array.
                  It is equivalent to invoking <elcode>xsl:apply-templates</elcode> with the <code>select</code>
                  attribute set to <code>?*</code> (which selects the members of the array), and with the 
                  <code>mode</code> attribute set to <code>#current</code>. If the built-in
                  rule was invoked with parameters, those parameters are passed on in the implicit
                  <elcode>xsl:apply-templates</elcode> instruction.</p>
               <p>This is equivalent to the following in the case where
                  there are no parameters:</p>
               
               <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:template match=".[. instance of array(*)]" mode="M"&gt;
  &lt;xsl:apply-templates mode="#current" select="?*"/&gt;
&lt;/xsl:template&gt;</eg>

            </div3>
            <div3 id="built-in-templates-fail">
               <head>Built-in Templates: Fail</head>
               <p>The effect of choosing <code>on-no-match="fail"</code> for a
                     <termref def="dt-mode">mode</termref> is that every item selected in an <elcode>xsl:apply-templates</elcode> instruction
                  must be matched by an explicit user-written <termref def="dt-template-rule">template rule</termref>.</p>
               <p>The built-in template rule is effectively: </p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="." mode="M"&gt;
  &lt;xsl:message terminate="yes" error-code="err:XTDE0555"/&gt;
&lt;/xsl:template&gt;</eg>
               <p>with an <termref def="dt-implementation-dependent"/> message body.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="0555">
                     <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if
                           <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>
                        or <elcode>xsl:next-match</elcode> is used to process 
                        <phrase diff="chg" at="2022-01-01">an item</phrase> using a mode
                        whose declaration specifies <code>on-no-match="fail"</code> when there is no
                           <termref def="dt-template-rule"/> in the <termref def="dt-stylesheet"/>
                        whose match pattern matches that <phrase diff="chg" at="2022-01-01">item</phrase>. </p>
                  </error>
               </p>
            </div3>
         </div2>
         <div2 id="apply-imports">
            <head>Overriding Template Rules</head>
            <?element xsl:apply-imports?>
            <?element xsl:next-match?>
            <p>A <termref def="dt-template-rule">template rule</termref> that is being used to
               override another template rule (see <specref ref="conflict"/>) can use the
                  <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode> instruction
               to invoke the overridden template rule. The <elcode>xsl:apply-imports</elcode>
               instruction only considers template rules in imported stylesheet modules; the
                  <elcode>xsl:next-match</elcode> instruction considers all other template rules of
               lower <termref def="dt-import-precedence">import precedence</termref> and/or
               priority, and also declarations of the same
                  precedence and priority that appear earlier in <termref def="dt-declaration-order"/>. Both instructions will invoke the built-in template rule for the
                  context item (see <specref ref="built-in-rule"/>) if no other template rule is found.</p>
            <p>
               <termdef id="dt-current-template-rule" term="current template rule">At any point in
                  the processing of a <termref def="dt-stylesheet">stylesheet</termref>, there may
                  be a <term>current template rule</term>. Whenever a <termref def="dt-template-rule">template rule</termref> is chosen as a result of
                  evaluating <elcode>xsl:apply-templates</elcode>,
                     <elcode>xsl:apply-imports</elcode>, or <elcode>xsl:next-match</elcode>, the
                  template rule becomes the current template rule for the evaluation of the rule’s
                  sequence constructor.</termdef>
             </p>
            
            <p>
               The <termref def="dt-current-template-rule"/> is cleared (becomes <termref def="dt-absent"/>)
                  by any instruction that evaluates an operand with changed focus. It is therefore cleared
                  when evaluating <termref def="dt-instruction">instructions</termref> contained within:
            </p>
            
            <ulist>
               <item><p><elcode>xsl:for-each</elcode></p></item>
               <item><p><elcode>xsl:for-each-group</elcode></p></item>
               <item><p><elcode>xsl:analyze-string</elcode></p></item>
               <item><p><elcode>xsl:iterate</elcode></p></item>
               <item><p><elcode>xsl:source-document</elcode></p></item>
               <item><p><elcode>xsl:merge</elcode></p></item>
               <item><p><elcode>xsl:sort</elcode></p></item>
               <item><p><elcode>xsl:key</elcode></p></item>
               <item><p><elcode>xsl:copy</elcode> if and only if there is a <code>select</code> attribute</p></item>
               <item><p>A global <elcode>xsl:variable</elcode> or <elcode>xsl:param</elcode></p></item>
               <item><p><elcode>xsl:function</elcode></p></item>
               <item><p><elcode>xsl:template</elcode> if and only if the called template specifies <code>&lt;xsl:context-item use="absent"/&gt;</code></p></item>              
            </ulist>
 
            <note>
               <p>The current template rule is not affected by invoking named attribute sets (see <specref ref="attribute-sets"/>), or named templates (see <specref ref="named-templates"/>) unless <code>&lt;xsl:context-item use="absent"/&gt;</code> is specified. 
                  While evaluating a <termref def="dt-global-variable">global variable</termref> or the default value of a <termref def="dt-stylesheet-parameter">stylesheet parameter</termref> (see <specref ref="global-variables"/>) the current template rule is <termref def="dt-absent"/>.</p>
            </note>
            
               <p>These rules ensure that when <elcode>xsl:apply-imports</elcode> or
                     <elcode>xsl:next-match</elcode> is called, the <termref def="dt-context-item">context item</termref> is the same as when the current template rule was
                     invoked.</p>
            
            <p> Both <elcode>xsl:apply-imports</elcode> and <elcode>xsl:next-match</elcode> search
               for a <termref def="dt-template-rule">template rule</termref> that matches the
                  <termref def="dt-context-item">context
                  item</termref>, and that is applicable to the <termref def="dt-current-mode">current mode</termref> (see <specref ref="modes"/>). In
               choosing a template rule, they use the usual criteria such as the priority and
                  <termref def="dt-import-precedence">import precedence</termref> of the template
               rules, but they consider as candidates only a subset of the template rules in the
                  <termref def="dt-stylesheet">stylesheet</termref>. This subset differs between the
               two instructions:</p>
            <ulist>
               <item>
                  <p>The <elcode>xsl:apply-imports</elcode> instruction considers as candidates only
                     those template rules contained in <termref def="dt-stylesheet-level">stylesheet
                        levels</termref> that are descendants in the <termref def="dt-import-tree">import tree</termref> of the <termref def="dt-stylesheet-level">stylesheet
                        level</termref> that contains the <termref def="dt-current-template-rule">current template rule</termref>.</p>
                  <note>
                     <p>This is <emph>not</emph> the same as saying that the search considers all
                        template rules whose import precedence is lower than that of the current
                        template rule.</p>
                  </note>
                  <p><error spec="XT" type="static" class="SE" code="3460">
                        <p>It is a <termref def="dt-static-error"/> if an
                              <elcode>xsl:apply-imports</elcode> element appears in a <termref def="dt-template-rule"/> declared within an
                              <elcode>xsl:override</elcode> element. (To invoke the template rule
                           that is being overridden, <elcode>xsl:next-match</elcode> should
                           therefore be used.)</p>
                     </error></p>
               </item>
               <item>
                  <p>The <elcode>xsl:next-match</elcode> instruction considers as candidates all
                     those template rules that come after the <termref def="dt-current-template-rule">current template rule</termref> in the
                     ordering of template rules implied by the conflict resolution rules given in
                        <specref ref="conflict"/>. That is, it considers all template rules with
                     lower <termref def="dt-import-precedence">import precedence</termref> than the
                        <termref def="dt-current-template-rule">current template rule</termref>,
                     plus the template rules that are at the same import precedence that have lower
                     priority than the current template rule, plus
                        the template rules with the same import precedence and priority
                     that occur before the current template rule in <termref def="dt-declaration-order">declaration order</termref>.</p>
                  <note>
                     <p>As explained in <specref ref="conflict"/>, a template rule with no <code>priority</code>
                           attribute, whose match pattern contains multiple alternatives
                        separated by <code>|</code>, is treated equivalently to a set of template
                        rules, one for each alternative. This means that where the same item matches more than one alternative, it is possible for an <elcode>xsl:next-match</elcode>
                        instruction to cause the current template rule to be invoked recursively.
                        This situation does not occur when the template rule has an explicit priority.</p>
                  </note>
                  <note>
                     <p>Because a template rule declared as a child of <elcode>xsl:override</elcode>
                        has higher precedence than any template rule declared in the used package
                        (see <specref ref="modes-and-packages"/>), the effect of
                           <elcode>xsl:next-match</elcode> within such a template rule is to
                        consider as candidates first any other template rules for the same mode within the
                        same <elcode>xsl:use-package</elcode> element (taking into account explicit and implicit
                        priority, and document order, in the usual way), and then all template rules in
                        the used package.</p>
                  </note>
               </item>
            </ulist>
            
            <p>If a matching template rule <var>R</var> is found, then the result
               of the <elcode>xsl:next-match</elcode> or <elcode>xsl:apply-imports</elcode> instruction is the 
               result of invoking <var>R</var>, with the values of parameters being set using the child
               <elcode>xsl:with-param</elcode> elements as described in <specref ref="with-param"/>. 
               The template rule <var>R</var> is evaluated with the same <termref def="dt-focus"/> as the <elcode>xsl:next-match</elcode> 
               or <elcode>xsl:apply-imports</elcode> instruction. The <termref def="dt-current-template-rule"/>
               changes to be <var>R</var>. The <termref def="dt-current-mode"/> does not change. 
            </p>
            <note><p>In the case where the current template rule <var>T</var> is 
               declared within an <elcode>xsl:override</elcode> element in a using package <var>P</var>, while 
               the selected rule <var>R</var> is declared within a different package <var>Q</var>, and where 
               the current mode is <var>M/P</var> (mode <var>M</var> in package <var>P</var>), the effect 
               is that the current mode for evaluation of <var>R</var> 
               remains <var>M/P</var> rather than reverting to its corresponding mode <var>M/Q</var> 
               (mode <var>M</var> in package <var>Q</var>). 
               If <var>R</var> contains an <elcode>xsl:apply-templates</elcode> instruction that uses
               <code>mode="#current"</code>, then the set of template rules considered by this instruction 
               will therefore include any overriding template rules declared in <var>P</var> as well as the original 
               rules declared in <var>Q</var>.
            </p></note>
            
            <p>If no matching template rule is found that satisfies these criteria, the built-in
               template rule for the context item is used (see
                  <specref ref="built-in-rule"/>).</p>
            <p>An <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode> instruction
               may use <elcode>xsl:with-param</elcode> child elements to pass parameters to the
               chosen <termref def="dt-template-rule">template rule</termref> (see <specref ref="with-param"/>). It also passes on any <termref def="dt-tunnel-parameter">tunnel parameters</termref> as described in <specref ref="tunnel-params"/>.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0560">
                  <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if
                        <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode> is
                     evaluated when the <termref def="dt-current-template-rule">current template
                        rule</termref> is <termref def="dt-absent"/>.</p>
               </error>
            </p>
            <example>
               <head>Using <elcode>xsl:apply-imports</elcode>
               </head>
               <p>For example, suppose the stylesheet <code>doc.xsl</code> contains a <termref def="dt-template-rule">template rule</termref> for <code>example</code>
                  elements:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="example"&gt;
  &lt;pre&gt;&lt;xsl:apply-templates/&gt;&lt;/pre&gt;
&lt;/xsl:template&gt;</eg>
               <p>Another stylesheet could import <code>doc.xsl</code> and modify the treatment of
                     <code>example</code> elements as follows:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:import href="doc.xsl"/&gt;

&lt;xsl:template match="example"&gt;
  &lt;div style="border: solid red"&gt;
     &lt;xsl:apply-imports/&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;</eg>
               <p>The combined effect would be to transform an <code>example</code> into an element
                  of the form:</p>
               <eg xml:space="preserve" role="xml">&lt;div style="border: solid red"&gt;&lt;pre&gt;...&lt;/pre&gt;&lt;/div&gt;</eg>
            </example>
            <p>An <elcode>xsl:fallback</elcode> instruction appearing as a child of an
                  <elcode>xsl:next-match</elcode> instruction is ignored by an XSLT 2.0 or 3.0 processor, but can be used to define fallback
               behavior when the stylesheet is processed by an XSLT 1.0 processor with forwards
               compatible behavior.</p>
         </div2>
         <div2 id="parameters-to-template-rules">
            <head>Passing Parameters to Template Rules</head>
            <p>A template rule may have parameters. The parameters are declared in the body of the
               template using <elcode>xsl:param</elcode> elements, as described in <specref ref="parameters"/>.</p>

            <p>Values for these parameters may be supplied in the calling
                  <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>, or
                  <elcode>xsl:next-match</elcode> instruction by means of
                  <elcode>xsl:with-param</elcode> elements appearing as children of the calling
               instruction. The <termref def="dt-expanded-qname">expanded QName</termref>
               represented by the <code>name</code> attribute of the <elcode>xsl:with-param</elcode>
               element must match the <termref def="dt-expanded-qname">expanded QName</termref>
               represented by the <code>name</code> attribute of the corresponding
                  <elcode>xsl:param</elcode> element. </p>



            <p>It is not an error for these instructions to supply a parameter that does not match
               any parameter declared in the template rule that is invoked; unneeded parameter
               values are simply ignored.</p>

            <p>A parameter may be declared as a <termref def="dt-tunnel-parameter">tunnel
                  parameter</termref> by specifying <code>tunnel="yes"</code> in the
                  <elcode>xsl:param</elcode> declaration; in this case the caller must supply the
               value as a tunnel parameter by specifying <code>tunnel="yes"</code> in the
               corresponding <elcode>xsl:with-param</elcode> element. Tunnel parameters differ from
               ordinary template parameters in that they are passed transparently through multiple
               template invocations. They are fully described in <specref ref="tunnel-params"/>.</p>

         </div2>
      </div1>
      <div1 id="repetition">
         <head>Repetition</head>
         <p>XSLT offers two constructs for processing each <phrase diff="chg">entry in a collection</phrase>:
               <elcode>xsl:for-each</elcode> and <elcode>xsl:iterate</elcode>.</p>
         <p diff="add" at="2022-01-01">Both instructions can be used to process the items in a sequence, the
         elements in an array, or the entries in a map. Arrays and maps are processed by reducing them
         to a sequence of items, so in what follows, the terms <term>item</term> and <term>sequence</term> 
         are used generically.</p>
         <p>The main difference between the two constructs is that with
               <elcode>xsl:for-each</elcode>, the processing applied to each item in the sequence is
            independent of the processing applied to any other item; this means that the items may
            be processed in any order or in parallel, though the order of the output sequence is
            well defined and corresponds to the order of the input (sorted if so requested). By
            contrast, with <elcode>xsl:iterate</elcode>, the processing is explicitly sequential:
            while one item is being processed, values may be computed which are then available for
            use while the next item is being processed. This makes <elcode>xsl:iterate</elcode>
            suitable for tasks such as creating a running total over a sequence of financial
            transactions.</p>
         <p>A further difference is that <elcode>xsl:for-each</elcode> permits
            sorting of the input sequence, while <elcode>xsl:iterate</elcode> does not.</p>
         <div2 id="for-each">
            <head>The <code>xsl:for-each</code> instruction</head>
            <?element xsl:for-each?>
            <p diff="del" at="2022-11-01">The attributes <code>select</code>, <code>array</code>, and <code>map</code>
            are mutually exclusive: exactly one of these three attributes must be present.</p>
            <p diff="del" at="2022-11-01">Specifying <code>array="EXPR"</code> is equivalent to specifying
            <code>select="array:for-each(EXPR, function($x){map{'value':$x})?*</code>. That is, it maps the
            elements of an input array to a sequence of items, each item being a map having a single entry, whose
            key is the string <code>value</code> and whose corresponding value is the relevant element of the
            array. Within the contained sequence constructor, the current array element can be refered to
            as <code>?value</code>.</p>
            <p diff="del" at="2022-11-01">Specifying <code>map="EXPR"</code> is equivalent to specifying
               <code>select="map:for-each(EXPR, function($k, $v){map{'key':$k, 'value':$v})</code>. That is, it maps the
               key-value entries of an input map to a sequence of items (in undefined order), each item being a map having 
               two entries, one entry holding the key, and the other holding the value. 
               Within the contained sequence constructor, the key and value of the current entry in the input map
               can be refered to as <code>?key</code> and <code>?value</code> respectively.</p>
            <p>The <elcode>xsl:for-each</elcode> instruction processes each  in a sequence of
               items, evaluating the <termref def="dt-sequence-constructor">sequence
                  constructor</termref> within the <elcode>xsl:for-each</elcode> instruction once
               for each item in that sequence.</p>
            <p> The <code>select</code> attribute is <rfc2119>required</rfc2119>; it contains an
                  <termref def="dt-expression">expression</termref> which is evaluated to produce a
               sequence, called the input sequence. If there is an <elcode>xsl:sort</elcode> element
               present (see <specref ref="sorting"/>) the input sequence is sorted to produce a
               sorted sequence. Otherwise, the sorted sequence is the same as the input
               sequence.</p>
            <p>The <elcode>xsl:for-each</elcode> instruction contains a <termref def="dt-sequence-constructor">sequence constructor</termref>. The <termref def="dt-sequence-constructor">sequence constructor</termref> is evaluated once for
               each item in the sorted sequence, with the <termref def="dt-focus">focus</termref>
               set as follows:</p>
            <ulist>
               <item>
                  <p>The <termref def="dt-context-item">context item</termref> is the item being
                     processed. 
                  </p>
               </item>
               <item>
                  <p>The <termref def="dt-context-position">context position</termref> is the
                     position of this item in the sorted sequence.</p>
               </item>
               <item>
                  <p>The <termref def="dt-context-size">context size</termref> is the size of the
                     sorted sequence (which is the same as the size of the input sequence).</p>
               </item>
            </ulist>
            <p> For each item in the input sequence, evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref> produces a sequence
               of items (see <specref ref="sequence-constructors"/>). These output sequences are
               concatenated; if item <var>Q</var> follows item <var>P</var> in the sorted sequence,
               then the result of evaluating the sequence constructor with <var>Q</var> as the
               context item is concatenated after the result of evaluating the sequence constructor
               with <var>P</var> as the context item. The result of the
                  <elcode>xsl:for-each</elcode> instruction is the concatenated sequence of
               items.</p>
            
            <example>
               <head>Using <elcode>xsl:for-each</elcode> to process a sequence</head>
               <p>For example, given an XML document with this structure</p>
               <eg xml:space="preserve" role="xml">&lt;customers&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
&lt;/customers&gt;</eg>
               <p>the following would create an HTML document containing a table with a row for each
                     <code>customer</code> element</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="/"&gt;
  &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;Customers&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;table&gt;
	 &lt;tbody&gt;
	  &lt;xsl:for-each select="customers/customer"&gt;
	    &lt;tr&gt;
	      &lt;th&gt;
           &lt;xsl:apply-templates select="name"/&gt;
	      &lt;/th&gt;
	      &lt;xsl:for-each select="order"&gt;
           &lt;td&gt;
             &lt;xsl:apply-templates/&gt;
           &lt;/td&gt;
	      &lt;/xsl:for-each&gt;
	    &lt;/tr&gt;
	  &lt;/xsl:for-each&gt;
	&lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <example diff="chg" at="2022-11-01">
               <head>Using <elcode>xsl:for-each</elcode> to process an array</head>
               <p>Consider a JSON document of the form:</p>
               <eg>[
  { "city": "London", "latitude": 51.5099, "longitude": -0.1181 },
  { "city": "Paris",  "latitude": 48.8647, "longitude": 2.3488 },
  { "city": "Berlin", "latitude": 52.5200, "longitude": 13.4049 }                  
]</eg>
            <p>The following code processes this array to produce an XML representation of the same information. The
               cities are sorted by name:</p>
               <eg><![CDATA[<xsl:for-each select="json-doc('input.json')?*">
   <xsl:sort select="?city"/>
   <city number="{position()}" 
         name="{?city}" 
         latitude="{?latitude}" 
         longitude="{?longitude}"/>
</xsl:for-each>]]></eg>
               <p>In this example it is possible to use the expression <code>$array?*</code> to convert an array to a sequence.
               This works because the members of the array are all single items. In the more general case (a member
               of the array might be an empty sequence, corresponding to the JSON value <code>null</code>, or it
               might be a sequence containing several items), <phrase diff="chg" at="2023-04-04">the function <code>array:members</code> can be
               used to deliver the contents of the array as a sequence of <emph>value records</emph>. This is 
               illustrated in the next example.</phrase></p>
            </example>
            <example diff="chg" at="2022-11-01">
               <head>Using <elcode>xsl:for-each</elcode> to process an array containing nulls</head>
               <p>Consider a JSON document of the form:</p>
               <eg>[
   { "city": "London", "data": [12.3, 15.6, null, 18.2] },
   { "city": "Paris",  "data": [7.9, 19.1, 23.0, null] },
   { "city": "Berlin", "data": [5.6, null, 14.6, 9.5] }                  
]</eg>
               <p>The requirement is to convert this to the following XML:</p>
               <eg><![CDATA[<cities>
  <city name="London" Q1="12.3" Q2="15.6" Q3="" Q4="18.2"/>
  <city name="Paris" Q1="7.9" Q2="19.1" Q3="23.0" Q4=""/>
  <city name="Berlin" Q1="5.6" Q2="" Q3="14.6" Q4="9.5"/>
</cities>]]></eg>
               <p>The following code achieves this transformation:</p>
               <eg><![CDATA[<xsl:for-each select="json-doc('input.json')?*">
   <city name="{?city}">
     <xsl:for-each select="array:members(?data)">
       <xsl:attribute name="Q{position()}" select="?value"/>
     </xsl:for-each>
   </city>  
</xsl:for-each>]]></eg>
               <p>In this example the expression <code>$array?*</code> cannot be used on the inner arrays
                  because JSON nulls (which translate to an empty sequence in XDM) would be lost. Instead
                  the function <xfunction>array:members</xfunction> is used to create a sequence of
                  value records: a non-null entry is represented by a value such as <code>map{'value':12.3}</code>,
                  while a null entry would be <code>map{'value':()}</code>.</p>

            </example>
            <example diff="add" at="2022-11-01">
               <head>Using <elcode>xsl:for-each</elcode> to process a map</head>
               <p>Consider a JSON document of the form:</p>
               <eg>{
  "London": {"latitude": 51.5099, "longitude": -0.1181 },
  "Paris":  {"latitude": 48.8647, "longitude": 2.3488 },
  "Berlin": {"latitude": 52.5200, "longitude": 13.4049 }                  
}</eg>
               <p>The following code processes this map to produce an XML representation of the same information. The
                  cities are sorted by name:</p>
               <eg><![CDATA[<xsl:for-each select="map:key-value-pairs(json-doc('input.json'))">
   <xsl:sort select="?key"/>
   <city number="{position()}" 
         name="{?key}" 
         latitude="{?value?latitude}" 
         longitude="{?value?longitude}"/>
</xsl:for-each>]]></eg>
               <p>In this example the map is decomposed to a sequence of key-value pairs, each represented as
               a map with two entries, <code>"key"</code> and <code>"value"</code>, which can be accessed using
               the lookup expressions <code>?key</code> and <code>?value</code>.</p>
            </example>
            <div3 id="for-each-separator" diff="add" at="2022-01-01">
               <head>The <code>separator</code> attribute</head>
            
            <p>If the <code>separator</code> attribute is present, then its <termref def="dt-effective-value"/>
               is inserted, as a text node, into the output sequence, immediately after the results of processing each item in the sorted
               sequence other than the last.</p>
            <p>For example, the following instruction:</p>
            <eg><![CDATA[
<xsl:for-each select="6, 3, 9" separator="|">
   <xsl:sort select="."/>
   <xsl:sequence select="., .+1"/>
</xsl:for-each>]]></eg>
            <p>produces a sequence comprising, in order: the integer 3, the integer 4, a text node with string value <code>"|"</code>,
               the integer 6, the integer 7, another text node with string value <code>"|"</code>,
            the integer 9, and the integer 10.</p>
            <p>The node identity of any text nodes that are inserted is <termref def="dt-implementation-dependent"/>. Specifically,
            it is not defined whether all the text nodes inserted in the course of one evaluation of the instruction are identical
            to each other, nor whether they are identical to the text nodes inserted in the course of another evaluation of this
            instruction, nor whether they are identical to any other parentless text nodes having the same string value.</p>
            <p>If the separator is a zero-length string, then a zero-length text node is inserted into the sequence. (If the
            sequence is used for constructing the value of a node, then zero-length text nodes will be discarded: see
               <specref ref="constructing-simple-content"/> and <specref ref="constructing-complex-content"/>.)</p>
            </div3>
         </div2>
         <div2 id="iterate">
            <head>The <code>xsl:iterate</code> Instruction</head>
            
            <p>The <code>xsl:iterate</code> instruction processes the items in a sequence
            in order; unlike <code>xsl:for-each</code>, the result of processing one item can affect the way that
            subsequent items are processed.</p>
            
            <p diff="add" at="2022-01-01">As with <code>xsl:for-each</code>, the instruction is extended in XSLT 4.0 to allow maps and arrays
            to be processed.</p>
            
            <?element xsl:iterate?>
            <?element xsl:next-iteration?>
            <?element xsl:break?>
            <?element xsl:on-completion?>
            <p diff="del" at="2022-01-01">The attributes <code>select</code>, <code>array</code>, and <code>map</code>
               are mutually exclusive: exactly one of these three attributes must be present.</p>
            <p diff="del" at="2022-01-01">Specifying <code>array="EXPR"</code> is equivalent to specifying
               <code>select="array:for-each(EXPR, function($x){map{'value':$x})?*</code>. That is, it maps the
               elements of an input array to a sequence of items, each item being a map having a single entry, whose
               key is the string <code>value</code> and whose corresponding value is the relevant element of the
               array. Within the contained sequence constructor, the current array element can be refered to
               as <code>?value</code>.</p>
            <p diff="del" at="2022-01-01">Specifying <code>map="EXPR"</code> is equivalent to specifying
               <code>select="map:for-each(EXPR, function($k, $v){map{'key':$k, 'value':$v})</code>. That is, it maps the
               key-value entries of an input map to a sequence of items (in undefined order), each item being a map having 
               two entries, one entry holding the key, and the other holding the value. 
               Within the contained sequence constructor, the key and value of the current entry in the input map
               can be refered to as <code>?key</code> and <code>?value</code> respectively.</p>
            
            
            <p>The <code>select</code> attribute contains an
                  <termref def="dt-expression">expression</termref> which is evaluated to produce a
               sequence, called the input sequence.</p>
            <p>The <termref def="dt-sequence-constructor"/> contained in the
                  <elcode>xsl:iterate</elcode> instruction is evaluated once for each item in the
               input sequence, in order, or until the loop exits by evaluating an
                  <elcode>xsl:break</elcode> instruction, whichever is earlier. Within the <termref def="dt-sequence-constructor">sequence constructor</termref> that forms the body
               of the <elcode>xsl:iterate</elcode> instruction, the <termref def="dt-context-item">context item</termref> is set to each item from the value of the
                  <code>select</code> expression in turn; the <termref def="dt-context-position">context position</termref> reflects the position of this item in the input
               sequence, and the <termref def="dt-context-size">context size</termref> is the number
               of items in the input sequence (which may be greater than the number of iterations,
               if the loop exits prematurely using <elcode>xsl:break</elcode>).</p>
            <note>
               <p>If <elcode>xsl:iterate</elcode> is used in conjunction with
                     <elcode>xsl:source-document</elcode> to achieve streaming, calls on the function
                     <xfunction>last</xfunction> will be disallowed. </p>
            </note>

            <p>The <elcode>xsl:break</elcode> and
                  <elcode>xsl:on-completion</elcode> elements may have either a <code>select</code>
               attribute or a non-empty contained <termref def="dt-sequence-constructor"/> but not
               both. The effect of the element in both cases is obtained by evaluating the
                  <code>select</code> expression if present or the contained sequence constructor
               otherwise; if neither is present, the value is an empty sequence.</p>
            
            <note>
               <p>The <elcode>xsl:on-completion</elcode> element appears before other children
                  of <elcode>xsl:iterate</elcode>
                  to ensure that variables declared in the sequence constructor are not in scope
                  within <elcode>xsl:on-completion</elcode>, since such variables do not have a
                  defined value within <elcode>xsl:on-completion</elcode> especially in the case
                  where the value of the <code>select</code> attribute is an empty sequence.</p>
            </note>

            <p>The effect of <elcode>xsl:next-iteration</elcode> is to cause the iteration to
               continue by processing the next item in the input sequence, potentially with
               different values for the iteration parameters. The effect of
                  <elcode>xsl:break</elcode> is to cause the iteration to finish, whether or not all
               the items in the input sequence have been processed. In both cases the affected
               iteration is the one controlled by the innermost ancestor
                  <elcode>xsl:iterate</elcode> element.</p>
            <p>The instructions <elcode>xsl:next-iteration</elcode> and <elcode>xsl:break</elcode>
               are allowed only as descendants of an <elcode>xsl:iterate</elcode> instruction, and
               only in a <termref def="dt-tail-position">tail position</termref> within the <termref def="dt-sequence-constructor">sequence constructor</termref> forming the body of
               the <elcode>xsl:iterate</elcode> instruction. </p>

            <p>
               <termdef id="dt-tail-position" term="tail position" open="true">An <termref def="dt-instruction">instruction</termref>
                  <var>J</var> is in a <term>tail position</term> within a <termref def="dt-sequence-constructor">sequence constructor</termref>
                  <var>SC</var> if it satisfies one of the following conditions:</termdef></p>

            <ulist>
               <item>
                  <p><var>J</var> is the last instruction in <var>SC</var>, ignoring any
                        <elcode>xsl:fallback</elcode> instructions.</p>
               </item>
               <item>
                  <p><var>J</var> is in a <termref def="dt-tail-position">tail position</termref>
                     within the sequence constructor that forms the body of an
                        <elcode>xsl:if</elcode> instruction that is itself in a <termref def="dt-tail-position">tail position</termref> within <var>SC</var>.</p>
               </item>
               <item>
                  <p><var>J</var> is in a <termref def="dt-tail-position">tail position</termref>
                     within the sequence constructor that forms the body of an
                        <elcode>xsl:when</elcode> or <elcode>xsl:otherwise</elcode> branch of an
                        <elcode>xsl:choose</elcode> instruction that is itself in a <termref def="dt-tail-position">tail position</termref> within <var>SC</var>.</p>
               </item>

               <item>
                  <p><var>J</var> is in a <termref def="dt-tail-position">tail position</termref>
                     within the sequence constructor that forms the body of an
                        <elcode>xsl:try</elcode> instruction that is itself in a <termref def="dt-tail-position">tail position</termref> within <var>SC</var> (that
                     is, it is immediately followed by an <elcode>xsl:catch</elcode> element,
                     ignoring any <elcode>xsl:fallback</elcode> elements).</p>
               </item>
               <item>
                  <p><var>J</var> is in a <termref def="dt-tail-position">tail position</termref>
                     within the sequence constructor that forms the body of an
                        <elcode>xsl:catch</elcode> element within an <elcode>xsl:try</elcode>
                     instruction that is itself in a <termref def="dt-tail-position">tail
                        position</termref> within <var>SC</var>.</p>
               </item>
            </ulist>
            <p role="closetermdef"/>

            <p>
               <error spec="XT" type="static" class="SE" code="3120">
                  <p>It is a <termref def="dt-static-error">static error</termref> if an
                        <elcode>xsl:break</elcode> or <elcode>xsl:next-iteration</elcode> element
                     appears other than in a <termref def="dt-tail-position">tail position</termref>
                     within the <termref def="dt-sequence-constructor">sequence
                        constructor</termref> forming the body of an <elcode>xsl:iterate</elcode>
                     instruction.</p>
               </error>
            </p>

            <p>
               <error spec="XT" type="static" class="SE" code="3125">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the
                        <code>select</code> attribute of <elcode>xsl:break</elcode> or
                        <elcode>xsl:on-completion</elcode> is present and the instruction has
                     children.</p>
               </error>
            </p>

            <p>
               <error spec="XT" type="static" class="SE" code="3130">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the
                        <code>name</code> attribute of an <elcode>xsl:with-param</elcode> child of
                     an <elcode>xsl:next-iteration</elcode> element does not match the
                        <code>name</code> attribute of an <elcode>xsl:param</elcode> child of the
                        innermost containing
                        <elcode>xsl:iterate</elcode> instruction.</p>
               </error>
            </p>

            <p>Parameter names in <elcode>xsl:with-param</elcode> must be unique: <errorref spec="XT" class="SE" code="0670"/>.</p>

            <p>The result of the <elcode>xsl:iterate</elcode> instruction is the concatenation of
               the sequences that result from the repeated evaluation of the contained <termref def="dt-sequence-constructor">sequence constructor</termref>, followed by the
               sequence that results from evaluating the <elcode>xsl:break</elcode> or
                  <elcode>xsl:on-completion</elcode> element if any.</p>
            <p>Any <elcode>xsl:param</elcode> element that appears as a child of
                  <elcode>xsl:iterate</elcode> declares a parameter whose value may vary from one
               iteration to the next. The initial value of the parameter is the value obtained
               according to the rules given in <specref ref="variable-values"/>. The dynamic context
               for evaluating the initial value of an <elcode>xsl:param</elcode> element is the same
               as the dynamic context for evaluating the <code>select</code> expression of the
                  <elcode>xsl:iterate</elcode> instruction (the context item is thus
                  <emph>not</emph> the first item in the input sequence).</p>
            <p>On the first iteration a parameter always takes its initial value (which may depend
               on variables or other aspects of the dynamic context). Subsequently:</p>
            <ulist>
               <item>
                  <p>If an <elcode>xsl:next-iteration</elcode> instruction is evaluated, then
                     parameter values for processing the next item in the input sequence can be set
                     in the <elcode>xsl:with-param</elcode> children of that instruction; in the
                     absence of an <elcode>xsl:with-param</elcode> element that names a particular
                     parameter, that parameter will retain its value from the previous
                     iteration.</p>
               </item>
               <item>
                  <p>If an <elcode>xsl:break</elcode> instruction is evaluated, no further items in
                     the input sequence are processed.</p>
               </item>
               <item>
                  <p>If neither an <elcode>xsl:next-iteration</elcode> nor an
                        <elcode>xsl:break</elcode> instruction is evaluated, then the next item in
                     the input sequence is processed using parameter values that are unchanged from
                     the previous iteration.</p>
               </item>
            </ulist>


            <p>The <elcode>xsl:next-iteration</elcode> instruction contributes nothing to the result
               sequence (technically, it returns an empty sequence). The instruction supplies
               parameter values for the next iteration, which are evaluated according to the rules
               given in <specref ref="with-param"/>; if there are no further items in the input
               sequence then it supplies parameter values for use while evaluating the body of the
                  <elcode>xsl:on-completion</elcode> element if any.</p>
            <p>The <elcode>xsl:break</elcode> instruction indicates that the iteration should
               terminate without processing any remaining items from the input sequence. The <code>select</code> expression or  contained sequence
               constructor is evaluated using the same context item, position, and size as the
                  <elcode>xsl:break</elcode> instruction itself, and the result is appended to the
               result of the <elcode>xsl:iterate</elcode> instruction as a whole.</p>
            <p>If neither an <elcode>xsl:next-iteration</elcode> nor an <elcode>xsl:break</elcode>
               instruction is evaluated, the next item in the input sequence is processed with
               parameter values unchanged from the previous iteration; if there are no further items
               in the input sequence, the iteration terminates.</p>
            <p>The optional <elcode>xsl:on-completion</elcode> element (which is not technically an
                  <termref def="dt-instruction">instruction</termref> and is not technically part of
               the <termref def="dt-sequence-constructor"/>) is evaluated when the input sequence is
               exhausted. It is not evaluated if the evaluation is terminated using
                  <elcode>xsl:break</elcode>. During evaluation of its <code>select</code> expression or sequence constructor
               the context item, position, and size are <termref def="dt-absent">absent</termref>
               (that is, any reference to these values is an error). However, the values of the
               parameters to <elcode>xsl:iterate</elcode> are available, and take the values
               supplied by the <elcode>xsl:next-iteration</elcode> instruction evaluated while
               processing the last item in the sequence.</p>
            <p>If the input sequence is empty, then the result of the
                  <elcode>xsl:iterate</elcode> instruction is the result of evaluating the <code>select</code> attribute or <termref def="dt-sequence-constructor">sequence constructor</termref> forming the body of
               the <elcode>xsl:on-completion</elcode> element, using the initial values of the
                  <elcode>xsl:param</elcode> elements. If there is no
                  <elcode>xsl:on-completion</elcode> element, the result is an empty sequence.</p>

            <note>
               <p>Conceptually, <elcode>xsl:iterate</elcode> behaves like a tail-recursive function.
                  The <elcode>xsl:next-iteration</elcode> instruction then represents the recursive
                  call, supplying the tail of the input sequence as an implicit parameter. There are
                  two main reasons for providing the <elcode>xsl:iterate</elcode> instruction. One
                  is that many XSLT users find writing recursive functions to be a difficult skill,
                  and this construct promises to be easier to learn. The other is that recursive
                  function calls are difficult for an optimizer to analyze. Because
                     <elcode>xsl:iterate</elcode> is more constrained than a general-purpose
                  head-tail recursive function, it should be more amenable to optimization. In
                  particular, when the instruction is used in conjunction with
                     <elcode>xsl:source-document</elcode>, it is designed to make it easy for the
                  implementation to use streaming techniques, processing the nodes in an input
                  document sequentially as they are read, without building the entire document tree
                  in memory.</p>
            </note>

            <p>The examples below use <elcode>xsl:iterate</elcode> in conjunction with the
                  <elcode>xsl:source-document</elcode> instruction. This is not the only way of using
                  <elcode>xsl:iterate</elcode>, but it illustrates the way in which the two features
               can be combined to achieve streaming of a large input document.</p>



            <example>
               <head>Using <elcode>xsl:iterate</elcode> to Compute Cumulative Totals</head>
               <p>Suppose that the input XML document has this structure</p>
               <eg xml:space="preserve" role="xml">&lt;transactions&gt;
  &lt;transaction date="2008-09-01" value="12.00"/&gt;
  &lt;transaction date="2008-09-01" value="8.00"/&gt;
  &lt;transaction date="2008-09-02" value="-2.00"/&gt;
  &lt;transaction date="2008-09-02" value="5.00"/&gt;
&lt;/transactions&gt;</eg>
               <p>and that the requirement is to transform this to:</p>
               <eg xml:space="preserve" role="xml">&lt;account&gt;
  &lt;balance date="2008-09-01" value="12.00"/&gt;
  &lt;balance date="2008-09-01" value="20.00"/&gt;
  &lt;balance date="2008-09-02" value="18.00"/&gt;
  &lt;balance date="2008-09-02" value="23.00"/&gt;
&lt;/account&gt;</eg>
               <p>This can be achieved using the following code, which is designed to process the
                  transaction file using streaming:</p>
               <eg xml:space="preserve" role="xslt-fragment">&lt;account&gt;
  &lt;xsl:source-document streamable="yes" href="transactions.xml"&gt;
    &lt;xsl:iterate select="transactions/transaction"&gt;
      &lt;xsl:param name="balance" select="0.00" as="xs:decimal"/&gt;
      &lt;xsl:variable name="newBalance" 
                    select="$balance + xs:decimal(@value)"/&gt;
      &lt;balance date="{@date}" value="{format-number($newBalance, '0.00')}"/&gt;
      &lt;xsl:next-iteration&gt;
        &lt;xsl:with-param name="balance" select="$newBalance"/&gt;
      &lt;/xsl:next-iteration&gt;
    &lt;/xsl:iterate&gt;
  &lt;/xsl:source-document&gt;
&lt;/account&gt;</eg>
               <p>The following example modifies this by only outputting the information for the
                  first day’s transactions:</p>
               <eg xml:space="preserve" role="xslt-fragment">&lt;account&gt;
  &lt;xsl:source-document streamable="yes" href="transactions.xml"&gt;
    &lt;xsl:iterate select="transactions/transaction"&gt;
      &lt;xsl:param name="balance" select="0.00" as="xs:decimal"/&gt;
      &lt;xsl:param name="prevDate" select="()" as="xs:date?"/&gt;
      &lt;xsl:variable name="newBalance" 
                    select="$balance + xs:decimal(@value)"/&gt;
      &lt;xsl:variable name="thisDate" 
                    select="xs:date(@date)"/&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="empty($prevDate) or $thisDate eq $prevDate"&gt;
          &lt;balance date="{$thisDate}" 
                   value="{format-number($newBalance, '0.00')}"/&gt;
          &lt;xsl:next-iteration&gt;
            &lt;xsl:with-param name="balance" select="$newBalance"/&gt;
            &lt;xsl:with-param name="prevDate" select="$thisDate"/&gt;
          &lt;/xsl:next-iteration&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:break/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/xsl:iterate&gt;
  &lt;/xsl:source-document&gt;
&lt;/account&gt;</eg>
               <p>The following code outputs the balance only at the end of each day, together with
                  the final balance:</p>
               <eg xml:space="preserve" role="xslt-fragment">&lt;account&gt;
  &lt;xsl:source-document streamable="yes" href="transactions.xml"&gt;
    &lt;xsl:iterate select="transactions/transaction"&gt;
      &lt;xsl:param name="balance" select="0.00" as="xs:decimal"/&gt;
      &lt;xsl:param name="prevDate" select="()" as="xs:date?"/&gt;
      &lt;xsl:on-completion&gt;
        &lt;balance date="{$prevDate}" 
                 value="{format-number($balance, '0.00')}"/&gt;
      &lt;/xsl:on-completion&gt;     
      &lt;xsl:variable name="newBalance" 
                    select="$balance + xs:decimal(@value)"/&gt;
      &lt;xsl:variable name="thisDate" select="xs:date(@date)"/&gt;
      &lt;xsl:if test="exists($prevDate) and $thisDate ne $prevDate"&gt;
        &lt;balance date="{$prevDate}" 
                 value="{format-number($balance, '0.00')}"/&gt;
      &lt;/xsl:if&gt;
      &lt;xsl:next-iteration&gt;
        &lt;xsl:with-param name="balance" select="$newBalance"/&gt;
        &lt;xsl:with-param name="prevDate" select="$thisDate"/&gt;
      &lt;/xsl:next-iteration&gt;     
    &lt;/xsl:iterate&gt;
  &lt;/xsl:source-document&gt;
&lt;/account&gt;</eg>
               <p>If the sequence of transactions is empty, this code outputs a single element:
                     <code>&lt;balance date="" value="0.00"/&gt;</code>.</p>
            </example>
            <example>
               <head>Collecting Multiple Values in a Single Pass</head>
               <p>Problem: Given a sequence of <code>employee</code> elements, find the employees
                  having the highest and lowest salary, while processing each employee only
                  once.</p>
               <p>Solution:</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:source-document streamable="yes" href="si-iterate-035.xml"&gt;
            &lt;xsl:iterate select="employees/employee"&gt;
                &lt;xsl:param name="highest" as="element(employee)*"/&gt;
                &lt;xsl:param name="lowest" as="element(employee)*"/&gt;
                &lt;xsl:on-completion&gt;
                    &lt;highest-paid-employees&gt;
                        &lt;xsl:value-of select="$highest/name"/&gt;
                    &lt;/highest-paid-employees&gt;
                    &lt;lowest-paid-employees&gt;
                        &lt;xsl:value-of select="$lowest/name"/&gt;
                    &lt;/lowest-paid-employees&gt;  
                &lt;/xsl:on-completion&gt;
                &lt;xsl:variable name="this" select="copy-of()"/&gt;
                &lt;xsl:variable name="is-new-highest" as="xs:boolean"
                    select="empty($highest[@salary ge current()/@salary])"/&gt;
                &lt;xsl:variable name="is-equal-highest" as="xs:boolean" 
                    select="exists($highest[@salary eq current()/@salary])"/&gt; 
                &lt;xsl:variable name="is-new-lowest" as="xs:boolean" 
                    select="empty($lowest[@salary le current()/@salary])"/&gt;
                &lt;xsl:variable name="is-equal-lowest" as="xs:boolean" 
                    select="exists($lowest[@salary eq current()/@salary])"/&gt; 
                &lt;xsl:variable name="new-highest-set" as="element(employee)*"
                    select="if ($is-new-highest) then $this
                    else if ($is-equal-highest) then ($highest, $this)
                    else $highest"/&gt;
                &lt;xsl:variable name="new-lowest-set" as="element(employee)*"
                    select="if ($is-new-lowest) then $this
                    else if ($is-equal-lowest) then ($lowest, $this)
                    else $lowest"/&gt;
                &lt;xsl:next-iteration&gt;
                    &lt;xsl:with-param name="highest" select="$new-highest-set"/&gt;
                    &lt;xsl:with-param name="lowest" select="$new-lowest-set"/&gt;
                &lt;/xsl:next-iteration&gt;
            &lt;/xsl:iterate&gt;
        &lt;/xsl:source-document&gt;</eg>
               <p>If the input sequence is empty, this code outputs an empty
                     <code>highest-paid-employees</code> element and an empty
                     <code>lowest-paid-employees</code> element.</p>
            </example>
            <example>
               <head>Processing the Last Item in a Sequence Specially</head>
               <p>When streaming, it is not possible to determine whether the item being processed
                  is the last in a sequence without reading ahead. The <xfunction>last</xfunction>
                  function therefore cannot be used in <termref def="dt-guaranteed-streamable"/>
                  code. The <elcode>xsl:iterate</elcode> instruction provides a solution to this
                  problem.</p>
               <p>Problem: render the last paragraph in a section in some special way, for example
                  by using bold face. (The actual rendition is achieved by processing the paragraph
                  with mode <code>last-para</code>.)</p>
               <p>The solution uses <elcode>xsl:iterate</elcode>
                  together with the <function>copy-of</function>
                     function to maintain a one-element look-ahead by explicit coding:</p>
               <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:template match="section" mode="streaming"&gt;
   &lt;xsl:iterate select="para"&gt;
     &lt;xsl:param name="prev" select="()" as="element(para)?"/&gt;
     &lt;xsl:on-completion&gt;
       &lt;xsl:apply-templates select="$prev" mode="last-para"/&gt;      
     &lt;/xsl:on-completion&gt;
     &lt;xsl:if test="$prev"&gt;
       &lt;xsl:apply-templates select="$prev"/&gt;
     &lt;/xsl:if&gt;
     &lt;xsl:next-iteration&gt;
       &lt;xsl:with-param name="prev" select="copy-of(.)"/&gt;
     &lt;/xsl:next-iteration&gt;
   &lt;/xsl:iterate&gt;
 &lt;/xsl:template&gt;</eg>

            </example>
            <example diff="add" at="2022-01-01">
               <head>Processing an array using <code>xsl:iterate</code></head>
               <p>Consider the following JSON document representing transactions in a bank account:</p>
               <eg>[
   {"date":"2008-09-01", credit:12.00},
   {"date":"2008-09-01", credit:8.00},
   {"date":"2008-09-02", debit:2.00},
   {"date":"2008-09-02", credit:12.00}
]</eg>
               <p>The following code converts this to an XML representation that includes a running balance:</p>
               <eg><![CDATA[<xsl:iterate select="json-doc('account.json') => array:members()">
   <xsl:param name="balance" as="xs:decimal" select="0"/>               
   <xsl:variable name="delta" select="?value?credit otherwise -?value?debit"/>               
   <entry date="{?value?date}"
          amount="{$delta}"
          balance="{$balance + $delta}"/>
   <xsl:next-iteration>
      <xsl:with-param name="balance" select="$balance + $delta"/>
   </xsl:next-iteration>   
</xsl:iterate>]]></eg>
               <p>Using <code>array:members()</code> in this way makes it possible to process any array, including one whose members
               are arbitrary sequences rather than single items. In this particular case, if it is known that the JSON array
               will not contain any <code>null</code> entries, or if any <code>null</code> entries are to be ignored,
                  it becomes possible to simplify the code as follows:</p>
               <eg><![CDATA[<xsl:iterate select="json-doc('account.json')?*">
   <xsl:param name="balance" as="xs:decimal" select="0"/>               
   <xsl:variable name="delta" select="?credit otherwise -?debit"/>               
   <entry date="{?date}"
          amount="{$delta}"
          balance="{$balance + $delta}"/>
   <xsl:next-iteration>
      <xsl:with-param name="balance" select="$balance + $delta"/>
   </xsl:next-iteration>   
</xsl:iterate>]]></eg>
            </example>
         </div2>
      </div1>
      <div1 id="conditionals">
         <head>Conditional Processing</head>
         <p>There are several instructions in XSLT that support conditional processing:
               <elcode>xsl:if</elcode>, <elcode>xsl:choose</elcode><phrase diff="add" at="2022-01-01">, and <elcode>xsl:switch</elcode></phrase>. 
            The <elcode>xsl:if</elcode>
            instruction provides simple <phrase diff="chg" at="2022-11-01">if-then-else</phrase> conditionality; the <elcode>xsl:choose</elcode>
            instruction supports selection of one choice when there are several possibilities,
            <phrase diff="add" at="2022-01-01">and <elcode>xsl:switch</elcode> allows a branch to be selected based on the value of a given
         expression.</phrase></p>
         <p>XSLT 3.0 also supports <elcode>xsl:try</elcode> and
               <elcode>xsl:catch</elcode> which define conditional processing to handle <termref def="dt-dynamic-error">dynamic errors</termref>.</p>
         
         <note diff="add" at="2022-11-01"><p>XSLT offers a number of ways of expressing conditional logic.</p>
         <p>XSLT 1.0 offered the <elcode>xsl:if</elcode> instruction for cases where output was to be produced only if a condition was true,
         with <elcode>xsl:choose</elcode> available for multi-way branches where different output was to be produced under different
         input conditions. In addition, of course, XSLT 1.0 also offered the option of rule-based processing using templates and match patterns.</p>
            <p>XSLT 2.0 added the XPath conditional expression providing two-way branches for use at a finer-grained level where
            <elcode>xsl:choose</elcode> could be excessively verbose: it allowed constructs such as 
            <code>&lt;xsl:value-of select="if ($x) then 'red' else 'green'/></code> to be reduced from eight lines of code to one.</p>
            <p>XSLT 4.0 introduces the <code>then</code> and <code>else</code> attributes for <elcode>xsl:if</elcode>,
            which are particularly useful in contexts such as the body of an <elcode>xsl:function</elcode> declaration where
            the alternative results are conveniently evaluated using XPath expressions rather than XSLT instructions:
            for example a recursive function might have as its body the instruction 
               <code>&lt;xsl:if test="empty($seq)" then="1" else="head($seq) * my:f(tail($seq))"/></code>.
            The <code>select</code> attribute of <elcode>xsl:when</elcode> and <elcode>xsl:otherwise</elcode>
               is introduced for similar reasons: XSLT instructions
            are most useful when contructing node trees, whereas XPath expressions are more convenient when computing
            atomic values. Again, the main contribution of these enhancements is to reduce visual clutter, making
            the code more concise and more easily readable.</p>
            <p>The <elcode>xsl:switch</elcode> instruction is introduced in XSLT 4.0 as an alternative to <elcode>xsl:choose</elcode>
            for the common use case where the conditions test for multiple different values of some common expression. By avoiding
            repetition of the common expression whose value is being tested, the logic becomes self-explanatory both to the human reader
            of the code and to an optimizing compiler, making it easier to generate efficient branching code.</p>
            <p>Further conditional constructs are also under development for XPath 4.0. [TODO: elaborate on this when complete.]</p>
         </note>
         <div2 id="xsl-if">
            <head>Conditional Processing with <elcode>xsl:if</elcode>
            </head>
            <?element xsl:if?>
            <p>The <elcode>xsl:if</elcode> element has a mandatory <code>test</code> attribute,
               whose value is an <termref def="dt-expression">expression</termref>. The content is
               a <termref def="dt-sequence-constructor"/>.</p>
            <p diff="add" at="2022-01-01">If the <elcode>xsl:if</elcode> element has a <code>then</code> attribute, then it
               <rfc2119>must</rfc2119> have no children. That is, the <code>then</code> attribute and the
               contained sequence constructor are mutually exclusive.</p>
            <p>The result of the <elcode>xsl:if</elcode> instruction depends on the <xtermref
               spec="XP40" ref="dt-ebv">effective boolean value</xtermref> of the expression in
               the <code>test</code> attribute. The rules for determining the effective boolean
               value of an expression are given in <bibref ref="xpath-40"/>: they are the same as
               the rules used for XPath conditional expressions.</p>
            <p diff="add" at="2022-01-01">If the effective boolean value of the <termref def="dt-expression"
               >expression</termref> is <code>true</code>, then:</p>
            <ulist diff="add" at="2022-01-01">
               <item><p>If there is a <code>then</code> attribute, the expression in the <code>then</code>
                  attribute is evaluated, and the resulting value is returned as the result of the 
                  <elcode>xsl:if</elcode> instruction.</p></item>
               <item><p>If there is a non-empty sequence constructor, it is evaluated and the
                  resulting value is returned as the result of the 
                  <elcode>xsl:if</elcode> instruction.</p></item>
               <item><p>Otherwise, the result of the 
                  <elcode>xsl:if</elcode> instruction is an empty sequence.</p></item>
            </ulist>
            
            <p diff="add" at="2022-01-01">If the effective boolean value of the <code>test</code> <termref def="dt-expression"
               >expression</termref> is <code>false</code>, then:</p>
            <ulist diff="add" at="2022-01-01">
               <item><p>If there is an <code>else</code> attribute, the expression in the <code>else</code>
                  attribute is evaluated, and the resulting value is returned as the result of the 
                  <elcode>xsl:if</elcode> instruction.</p></item>
               <item><p>Otherwise, the result of the 
                  <elcode>xsl:if</elcode> instruction is an empty sequence.</p></item>
            </ulist>
            

            <p diff="add" at="2022-01-01">If the <code>test</code> expression has no effective boolean value (for example,
            if it is a sequence of several integers, or a map), then a <termref def="dt-dynamic-error"/> occurs. 
            (See <xerrorref spec="FO" class="RG" code="0006"/>.)</p>

            <note diff="add" at="2022-11-01">
               <p>The semantics of the <elcode>xsl:if</elcode> instruction are essentially equivalent to the semantics
               of the conditional expression in XPath: the construct <code>&lt;xsl:if test="C" then="X" else="Y"/></code>
                  can equivalently be written <code>&lt;xsl:sequence select="if (C) then X else Y"/></code>. The same
                  effect can also be achieved by writing 
                  <code>&lt;xsl:choose>&lt;xsl:when test="C" select="X"/>&lt;xsl:otherwise select="Y"/>&lt;/xsl:choose>.</code>
                  The choice of which of these constructs to use is a largely matter of personal style.
                  
               </p>
   
            </note>

            
            <example>
               <head>Using <elcode>xsl:if</elcode> to insert separators</head>
               <p>In the following example, the names in a group of names are formatted as a comma
                  separated list:</p>
               <eg xml:space="preserve" role="xslt-declaration"><![CDATA[<xsl:template match="namelist/name">
  <xsl:apply-templates/>
  <xsl:if test="not(position()=last())">, </xsl:if>
</xsl:template>]]></eg>
               <p diff="add" at="2022-11-01">This adds a comma after every item except the last. This can also be
                  expressed as:</p>
               <eg diff="add" at="2022-11-01" xml:space="preserve" role="xslt-declaration"><![CDATA[<xsl:template match="namelist/name">
  <xsl:if test="not(position()=1)">, </xsl:if>
  <xsl:apply-templates/> 
</xsl:template>]]></eg>
               <p diff="add" at="2022-11-01">which inserts a comma before every item except the first. (This formulation might
                  be more efficient, since determining whether an item is the last may involve look-ahead.)</p>
            </example>
            <example>
               <head>Using <elcode>xsl:if</elcode> as the body of a function</head>

               <p diff="add" at="2022-11-01">The following example shows the use of <elcode>xsl:if</elcode> to
                  deliver the result of a recursive function:</p>
               <eg xml:space="preserve" role="xslt-declaration" diff="chg" at="2022-01-01"><![CDATA[<xsl:function name="f:product" as="xs:double">
   <xsl:param name="in" as="xs:double*"/>
   <xsl:if test="empty($in)" then="1e0" else="head($in) * f:product(tail($in))"/>
</xsl:function>]]></eg>
            </example>
            
         </div2>
         <div2 id="xsl-choose">
            <head>Conditional Processing with <elcode>xsl:choose</elcode>
            </head>
            <?element xsl:choose?>
            <?element xsl:when?>
            <?element xsl:otherwise?>
            <p>The <elcode>xsl:choose</elcode> element selects one among a number of possible
               alternatives. It consists of a sequence of one or more <elcode>xsl:when</elcode>
               elements followed by an optional <elcode>xsl:otherwise</elcode> element. Each
               <elcode>xsl:when</elcode> element has <phrase diff="chg" at="2022-01-01">an</phrase> attribute, <code>test</code>, which
               specifies an <termref def="dt-expression">expression</termref> used as a condition.</p>
            <p diff="add" at="2022-01-01">The effective value of an <elcode>xsl:when</elcode> or <elcode>xsl:otherwise</elcode>
               branch may be supplied using either a <code>select</code> attribute or a contained
               <termref def="dt-sequence-constructor"/>. These are
               mutually exclusive: if the <code>select</code> attribute is present then the
               sequence constructor must be empty, and if the sequence constructor is non-empty
               then the <code>select</code> attribute must be absent 
               <phrase diff="add" at="2023-05-10"><errorref spec="XT" class="SE" code="3185"/></phrase>. 
               If the <code>select</code>
               attribute is absent and the sequence constructor is empty, then the
               effective value is an empty sequence.</p>
            <p>When an <elcode>xsl:choose</elcode> element is processed, each of the
               <elcode>xsl:when</elcode> elements is tested in turn (that is, in the order that
               the elements appear in the stylesheet), until one of the <elcode>xsl:when</elcode>
               elements is satisfied. If none of the <elcode>xsl:when</elcode> elements is
               satisfied, then the <elcode>xsl:otherwise</elcode> element is considered, as
               described below.</p>
            <p>An <elcode>xsl:when</elcode> element is satisfied if the <xtermref spec="XP40"
               ref="dt-ebv">effective boolean value</xtermref> of the <termref
                  def="dt-expression">expression</termref> in its <code>test</code> attribute is
               <code>true</code>. The rules for determining the effective boolean value of an
               expression are given in <bibref ref="xpath-30"/>: they are the same as the rules used
               for XPath conditional expressions.</p>
            <p>The <phrase diff="del" at="2022-01-01">content of the</phrase> first, and only the first, <elcode>xsl:when</elcode> element that
               is satisfied is evaluated, and the resulting sequence <phrase diff="add" at="2022-01-01">(that is,
                  the result of evaluating its <code>select</code> attribute or contained <termref def="dt-sequence-constructor"/> 
                  as appropriate)</phrase> is returned as the result of
               the <elcode>xsl:choose</elcode> instruction. If no <elcode>xsl:when</elcode> element
               is satisfied, the content of the <elcode>xsl:otherwise</elcode> element is evaluated,
               and the resulting sequence is returned as the result of the
               <elcode>xsl:choose</elcode> instruction. If no <elcode>xsl:when</elcode> element
               is satisfied, and no <elcode>xsl:otherwise</elcode> element is present, the result of
               the <elcode>xsl:choose</elcode> instruction is an empty sequence.</p>
            <p><phrase diff="chg" at="2022-01-01">The <code>select</code> expressions and sequence constructors of  
               <elcode>xsl:when</elcode> and
               <elcode>xsl:otherwise</elcode> instructions after the selected one are not evaluated.</phrase> 
               The <code>test</code>
               expressions for <elcode>xsl:when</elcode> instructions after the selected one are not
               evaluated.</p>
            <example>
               <head>Using <elcode>xsl:choose</elcode> for formatting a numbered list
               </head>
               <p>The following example enumerates items in an ordered list using arabic numerals,
                  letters, or roman numerals depending on the depth to which the ordered lists are
                  nested.</p>
               <eg xml:space="preserve" role="xslt-declaration xmlns:fo='fo'"><![CDATA[<xsl:template match="orderedlist/listitem">
  <fo:list-item indent-start='2pi'>
    <fo:list-item-label>
      <xsl:variable name="level"
                    select="count(ancestor::orderedlist) mod 3"/>
      <xsl:choose>
        <xsl:when test='$level=1'>
          <xsl:number format="i"/>
        </xsl:when>
        <xsl:when test='$level=2'>
          <xsl:number format="a"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:number format="1"/>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:text>. </xsl:text>
    </fo:list-item-label>
    <fo:list-item-body>
      <xsl:apply-templates/>
    </fo:list-item-body>
  </fo:list-item>
</xsl:template>]]></eg>
            </example>
            <example diff="add" at="2022-01-01">
               <head>Using the <code>select</code> attribute of <elcode>xsl:when</elcode> and <elcode>xsl:otherwise</elcode></head>
               <p>The following example is equivalent to the one above:</p>
               <eg xml:space="preserve" role="xslt-declaration xmlns:fo='fo'"><![CDATA[<xsl:template match="orderedlist/listitem">
  <fo:list-item indent-start='2pi'>
    <fo:list-item-label>
      <xsl:variable name="level"
                    select="count(ancestor::orderedlist) mod 3"/>
      <xsl:variable name="format" as="xs:string">
        <xsl:choose>
          <xsl:when test='$level=1' select="'i'"/>
          <xsl:when test='$level=2' select="'a'"/>
          <xsl:otherwise select="'1'"/>
        </xsl:choose>
      </xsl:variable>  
      <xsl:number format="{$format}"/>
      <xsl:text>. </xsl:text>
    </fo:list-item-label>
    <fo:list-item-body>
      <xsl:apply-templates/>
    </fo:list-item-body>
  </fo:list-item>
</xsl:template>]]></eg>
            </example>
            
         </div2>
         
         <div2 diff="add" at="2022-01-01" id="xsl-switch">
            <head>Conditional Processing with <elcode>xsl:switch</elcode>
            </head>
            <?element xsl:switch?>
            <?element xsl:when?>
            <?element xsl:otherwise?>
            <p>The <elcode>xsl:switch</elcode> element selects one among a number of possible
               alternatives. The <code>select</code> attribute of the <elcode>xsl:switch</elcode> element
               is evaluated to obtain an atomic value, which is compared with the values given by the
               <code>test</code> attributes of the <elcode>xsl:when</elcode> elements, in turn.</p>
            <p>The content of the <elcode>xsl:switch</elcode> element consists of a sequence of one or more <elcode>xsl:when</elcode>
               elements followed by an optional <elcode>xsl:otherwise</elcode> element. Each
               <elcode>xsl:when</elcode> element has <phrase diff="chg">an</phrase> attribute, <code>test</code>, which
               contains an <termref def="dt-expression">expression</termref>.</p>
            <p>The result of an <elcode>xsl:when</elcode> or <elcode>xsl:otherwise</elcode>
               branch may be supplied using either a <code>select</code> attribute or a contained
               <termref def="dt-sequence-constructor"/>. These are
               mutually exclusive: if the <code>select</code> attribute is present then the
               sequence constructor must be empty, and if the sequence constructor is non-empty
               then the <code>select</code> attribute must be absent. If the <code>select</code>
               attribute is absent and the sequence constructor is empty, then the
               result is an empty sequence.</p>
            <p>Any <elcode>xsl:fallback</elcode> children are ignored by an XSLT 4.0 processor, but
               can be used to define the recovery action to be taken by a processor for an earlier version of XSLT when
               operating with <termref def="dt-forwards-compatible-behavior"/>.</p>
            <p>An <elcode>xsl:switch</elcode> element is processed as follows:</p>
            <ulist>
               <item><p>The <code>select</code> expression of the <elcode>xsl:switch</elcode>
                  element is evaluated.</p></item>
               <item><p>The result of the evaluation is converted to a single atomic value
                  by applying the <termref def="dt-coercion-rules"/>; a type error occurs
                  if this conversion is not possible. This value is referred to below as the
                  <term>selector</term>.</p></item>
               <item><p>Each of the
                  <elcode>xsl:when</elcode> elements is tested in turn (that is, in the order that
                  the elements appear in the stylesheet), until one of the <elcode>xsl:when</elcode>
                  elements is satisfied. If none of the <elcode>xsl:when</elcode> elements is
                  satisfied, then the <elcode>xsl:otherwise</elcode> element is considered, as
                  described below.</p>
                  <p>An <elcode>xsl:when</elcode> element is tested by first evaluating its <code>test</code>
                     expression and converting the result to a sequence of atomic values
                     by applying the <termref def="dt-coercion-rules"/>, and then
                     comparing this sequence of atomic values with the <code>selector</code> value. The
                     comparison is performed using the rules of the XPath <code>=</code> operator,
                     using the default collation that is in scope for the <elcode>xsl:switch</elcode>
                     instruction.</p>
                  
                  
                  <p>An <elcode>xsl:when</elcode> element is satisfied if the result of this comparison is
                     <code>true</code>.</p></item>
               <item><p>The first, and only the first, <elcode>xsl:when</elcode> element that
                  is satisfied is evaluated, and the resulting sequence <phrase diff="add" at="2022-01-01">(that is,
                     the result of evaluating its <code>select</code> attribute or contained <termref def="dt-sequence-constructor"/> 
                     as appropriate)</phrase> is returned as the result of
                  the <elcode>xsl:switch</elcode> instruction. If no <elcode>xsl:when</elcode> element
                  is satisfied, the content of the <elcode>xsl:otherwise</elcode> element is evaluated,
                  and the resulting sequence is returned as the result of the
                  <elcode>xsl:switch</elcode> instruction. If no <elcode>xsl:when</elcode> element
                  is satisfied, and no <elcode>xsl:otherwise</elcode> element is present, the result of
                  the <elcode>xsl:switch</elcode> instruction is an empty sequence.</p></item>
               <item><p>The <code>select expressions</code> and sequence constructors of  
                  <elcode>xsl:when</elcode> and
                  <elcode>xsl:otherwise</elcode> instructions after the selected one are not evaluated. 
                  The <code>test</code>
                  expressions for <elcode>xsl:when</elcode> instructions after the selected one are not
                  evaluated.</p></item>
            </ulist>
            <note><p>There is no requirement that the values of <code>select</code> expressions
               should be literals, nor that the values should be distinct.</p></note>
            <example>
               <head>Using <elcode>xsl:switch</elcode> as a lookup table</head>
               <p>The following example shows a simple function to convert a month number to a month name:</p>
               <eg xml:space="preserve" role="xslt-declaration xmlns:fo='fo'"><![CDATA[<xsl:function name="f:month-name" as="xs:string">
    <xsl:param name="month-number" as="xs:integer"/>
    <xsl:switch select="$month-number">
      <xsl:when test="1" select="'January'"/>
      <xsl:when test="2" select="'February'"/>
      <xsl:when test="3" select="'March'"/>
      <xsl:when test="4" select="'April'"/>
      <xsl:when test="5" select="'May'"/>
      <xsl:when test="6" select="'June'"/>
      <xsl:when test="7" select="'July'"/>
      <xsl:when test="8" select="'August'"/>
      <xsl:when test="9" select="'September'"/>
      <xsl:when test="10" select="'October'"/>
      <xsl:when test="11" select="'November'"/>
      <xsl:when test="12" select="'December'"/>
      <xsl:otherwise select="error('Unknown month')"/>
    </xsl:switch>
  </xsl:function>]]></eg>
            </example>
            

            <example>
               <head>Using <elcode>xsl:switch</elcode> to return the number of days in the month</head>
               <p>This function returns the number of days in a month, returning an empty sequence 
                  if the supplied month is invalid.</p>
            <eg xml:space="preserve"><![CDATA[<xsl:function name="f:days-in-month" as="xs:integer?">
    <xsl:param name="month-number" as="xs:integer"/>
    <xsl:param name="leap-year" as="xs:boolean"/>
    <xsl:switch select="$month-number">
      <xsl:when test="1, 3, 5, 7, 8, 10, 12" select="31"/>
      <xsl:when test="4, 6, 9, 11" select="30"/>
      <xsl:when test="2">
         <xsl:if test="$leap-year" then="29" else="28"/>
      </xsl:when>
    </xsl:switch>
  </xsl:function>]]></eg>
  </example>
            
            
            
         </div2>

         <div2 id="try-catch">
            <head>Try/Catch</head>

            <p>The <elcode>xsl:try</elcode> instruction can be used to trap
               dynamic errors occurring within the expression it wraps; the recovery action if such
               errors occur is defined using a child <elcode>xsl:catch</elcode> element.</p>

            <?element xsl:try?>
            <note>
               <p>Because a sequence constructor may contain an <elcode>xsl:fallback</elcode>
                  element, the effect of this content model is that an <elcode>xsl:fallback</elcode>
                  instruction may appear as a child of <elcode>xsl:try</elcode> in any position.</p>
            </note>
            <?element xsl:catch?>

            <p>An <elcode>xsl:try</elcode> instruction evaluates either the expression contained in
               its <code>select</code> attribute, or its contained <termref def="dt-sequence-constructor">sequence constructor</termref>, and returns the
               result of that evaluation if it succeeds without error. If a <termref def="dt-dynamic-error">dynamic error</termref> occurs during the evaluation, the
               processor evaluates the first <elcode>xsl:catch</elcode> child element applicable to
               the error, and returns that result instead.</p>

            <p>If the <elcode>xsl:try</elcode> element has a <code>select</code> attribute, then it
                  <rfc2119>must</rfc2119> have no children other than <elcode>xsl:catch</elcode> and
                  <elcode>xsl:fallback</elcode>. That is, the <code>select</code> attribute and the
               contained sequence constructor are mutually exclusive. If neither is present, the
               result of the <elcode>xsl:try</elcode> is an empty sequence (no dynamic error can
               occur in this case).</p>

            <p>The <code>rollback-output</code> attribute is described in
                  <specref ref="recovery"/>. The default value is <code>yes</code>.</p>

            <p>
               <error spec="XT" type="static" class="SE" code="3140">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the
                        <code>select</code> attribute of the <elcode>xsl:try</elcode> element is
                     present and the element has children other than <elcode>xsl:catch</elcode> and
                        <elcode>xsl:fallback</elcode> elements.</p>
               </error>
            </p>

            <p>Any <elcode>xsl:fallback</elcode> children of the <elcode>xsl:try</elcode> element
               are ignored by an XSLT 3.0 processor, but can be used to define the recovery action
               taken by an XSLT 1.0 or XSLT 2.0 processor operating with <termref def="dt-forwards-compatible-behavior"/>.</p>

            <p>The <elcode>xsl:catch</elcode> element has an optional <code>errors</code> attribute,
               which lists the error conditions that the <elcode>xsl:catch</elcode> element is
               designed to intercept. The default value is <code>errors="*"</code>, which catches
               all errors. The value is a whitespace-separated list of <xnt spec="XP40" ref="prod-xpath40-NameTest">NameTests</xnt>; an <elcode>xsl:catch</elcode> element
               catches an error condition if this list includes a <code>NameTest</code> that matches
               the error code associated with that error condition.</p>

            <note>
               <p>Error codes are QNames. Those defined in this specification and in related
                  specifications are all in the <termref def="dt-standard-error-namespace">standard
                     error namespace</termref>, and may therefore be caught using an
                     <elcode>xsl:catch</elcode> element such as <code>&lt;xsl:catch
                     errors="err:FODC0001 err:FODC0005"&gt;</code> where the namespace prefix
                     <code>err</code> is bound to this namespace. Errors defined by implementers,
                  and errors raised by an explicit call of the <xfunction>error</xfunction> function
                  or by use of the <elcode>xsl:message</elcode>
                  or <elcode>xsl:assert</elcode> instruction, may
                  use error codes in other namespaces.</p>
            </note>

            <p>If more than one <elcode>xsl:catch</elcode> element matches an error, the error is
               processed using the first one that matches, in document order. If no
                  <elcode>xsl:catch</elcode> matches the error, then the error is not caught (that
               is, evaluation of the <elcode>xsl:try</elcode> element fails with the dynamic
               error).</p>

            <p>An <elcode>xsl:catch</elcode> element may have either a <code>select</code>
               attribute, or a contained <termref def="dt-sequence-constructor">sequence
                  constructor</termref>.</p>

            <p>
               <error spec="XT" type="static" class="SE" code="3150">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the
                        <code>select</code> attribute of the <elcode>xsl:catch</elcode> element is
                     present unless the element has empty content.</p>
               </error>
            </p>


            <p>The result of evaluating the <elcode>xsl:catch</elcode> element is the result of
               evaluating the XPath expression in its <code>select</code> attribute or the result of
               evaluating the contained sequence constructor; if neither is present, the result is
               an empty sequence. This result is delivered as the result of the <elcode>xsl:try</elcode>
               instruction.</p>

            <p>If a dynamic error occurs during the evaluation of <elcode>xsl:catch</elcode>, it
               causes the containing <elcode>xsl:try</elcode> to fail with this error. The error is
               not caught by other sibling <elcode>xsl:catch</elcode> elements within the same
                  <elcode>xsl:try</elcode> instruction, but it may be caught by an
                  <elcode>xsl:try</elcode> instruction at an outer level, or by an
                  <elcode>xsl:try</elcode> instruction nested within the <elcode>xsl:catch</elcode>. </p>

            <p>Within the <code>select</code> expression, or within the sequence constructor
               contained by the <elcode>xsl:catch</elcode> element, a number of variables are
               implicitly declared, giving information about the error that occurred. These are
               lexically scoped to the <elcode>xsl:catch</elcode> element. These variables are all in
               the <termref def="dt-standard-error-namespace">standard error namespace</termref>,
               and they are initialized as described in the following table:</p>
            

            <table class="data">
               <caption>Variables Available within <code>xsl:catch</code></caption>
               <thead>
                  <tr>
                     <th rowspan="1" colspan="1">Variable</th>
                     <th rowspan="1" colspan="1">Type</th>
                     <th rowspan="1" colspan="1">Value</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td rowspan="1" colspan="1">err:code</td>
                     <td rowspan="1" colspan="1">xs:QName</td>
                     <td rowspan="1" colspan="1">The error code</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">err:description</td>
                     <td rowspan="1" colspan="1">xs:string?</td>
                     <td rowspan="1" colspan="1">A description of the error condition; an empty sequence if no description is available (for example, if
                           the <xfunction>error</xfunction> function was called with one
                           argument).</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">err:value</td>
                     <td rowspan="1" colspan="1">item()*</td>
                     <td rowspan="1" colspan="1">Value associated with the error. For an error raised by
                        calling the <xfunction>error</xfunction> function, this is the value of the
                        third argument (if supplied). For an error raised by evaluating
                           <elcode>xsl:message</elcode> with <code>terminate="yes"</code>, or a failing <elcode>xsl:assert</elcode>, this
                        is the document node at the root of the tree containing the XML message
                        body.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">err:module</td>
                     <td rowspan="1" colspan="1">xs:string?</td>
                     <td rowspan="1" colspan="1">The URI (or system ID) of the stylesheet module containing the
                        instruction where the error occurred; an empty sequence if the information
                        is not available.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">err:line-number</td>
                     <td rowspan="1" colspan="1">xs:integer?</td>
                     <td rowspan="1" colspan="1">The line number within the stylesheet module of the
                        instruction where the error occurred; an empty sequence if the information
                        is not available. The value <rfc2119>may</rfc2119> be approximate.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">err:column-number</td>
                     <td rowspan="1" colspan="1">xs:integer?</td>
                     <td rowspan="1" colspan="1">The column number within the stylesheet module of the
                        instruction where the error occurred; an empty sequence if the information
                        is not available. The value <rfc2119>may</rfc2119> be approximate.</td>
                  </tr>
               </tbody>
            </table>

            <p>Variables declared within the sequence constructor of the <elcode>xsl:try</elcode>
               element (and not within an <elcode>xsl:catch</elcode>) are not visible within the
                  <elcode>xsl:catch</elcode> element.</p>

            <note>
               <p>Within an <elcode>xsl:catch</elcode> it is possible to re-throw the error using
                  the function call <code>error($err:code, $err:description, $err:value)</code>.</p>
            </note>

            <p>The following additional rules apply to the catching of errors:</p>

            <olist>
               <item>
                  <p>All dynamic errors occurring during the evaluation of the
                        <elcode>xsl:try</elcode> sequence constructor or <code>select</code>
                     expression are caught (provided they match one of the
                        <elcode>xsl:catch</elcode> elements). </p>

                  <note>
                     <ulist>
                        <item>
                           <p>This includes errors occurring in functions or templates invoked in
                              the course of this evaluation, unless already caught by a nested
                                 <elcode>xsl:try</elcode>.</p>
                        </item>
                        <item>
                           <p>It also includes (for
                                 example) errors caused by calling the
                                 <xfunction>error</xfunction> function, or the
                                 <elcode>xsl:message</elcode> instruction with
                                 <code>terminate="yes"</code>, or the 
                                 <elcode>xsl:assert</elcode> instruction, or the <code>xs:error</code> constructor
                                 function. </p>
                        </item>
                        <item>
                           <p>It does not include errors that occur while evaluating references to
                              variables whose declaration and initialization is outside the
                                 <elcode>xsl:try</elcode>.</p>
                        </item>
                     </ulist>
                  </note>
               </item>
               
               <item>
                  <p>The existence of an <elcode>xsl:try</elcode> instruction does not affect the
                     obligation of the processor to signal certain errors as static errors, or its
                     right to choose whether to signal some errors (such as <termref def="dt-type-error">type errors</termref>) statically or dynamically. Static
                     errors are never caught.</p>
               </item>
               <item>
                  <p>Some fatal errors arising in the processing environment, such as running out of
                     memory, may cause termination of the transformation despite the presence of an
                        <elcode>xsl:try</elcode> instruction. This is <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p>
               </item>

               <item>
                  <p>If the sequence constructor or <code>select</code> expression of the
                        <elcode>xsl:try</elcode> causes execution of
                        <elcode>xsl:result-document</elcode>, <elcode>xsl:message</elcode>, or <elcode>xsl:assert</elcode> instructions and
                     fails with a dynamic error that is caught, it is implementation-dependent
                     whether these instructions have any externally visible effect. The processor is
                        <rfc2119>not required</rfc2119> to roll back any changes made by these
                     instructions. The same applies to any side effects caused by extension
                     functions or extension instructions.</p>
               </item>
               <item>
                  
                  <p>A serialization error that occurs during the serialization of
                     a <termref def="dt-secondary-result"/> produced
                     using <elcode>xsl:result-document</elcode> is treated as a dynamic error in the
                     evaluation of the <elcode>xsl:result-document</elcode> instruction, and may be
                     caught (for example by an <elcode>xsl:try</elcode> instruction that contains
                     the <elcode>xsl:result-document</elcode> instruction). A serialization error
                     that occurs while serializing the <termref def="dt-principal-result"/>
                      is
                     treated as occurring after the transformation has finished, and cannot be
                     caught. </p>
               </item>
               <item>
                  
                  
                  <p>A validation error is treated as occurring in the instruction
                     that requested validation. For example, if the stylesheet is producing XHTML
                     output and requests validation of the entire result document by means of the
                     attribute <code>validation="strict"</code> on the instruction that creates the
                     outermost <code>html</code> element, then a validation failure can be caught
                     only at that level. Although the validation error might be detected, for
                     example, while writing a <code>p</code> element at a location where no
                        <code>p</code> element is allowed, it is not treated as an error in the
                     instruction that writes the <code>p</code> element and cannot be caught at that
                     level.</p>
               </item>
               <item>
                  <p>A type error may be caught if the processor raises it dynamically; this does
                     not affect the processor’s right to raise the error statically if it
                     chooses.</p>

                  <p>The following rules are provided to define which expression is considered to
                     fail when a type error occurs, and therefore where the error can be caught. The
                     general principle is that where the semantics of a construct <var>C</var> place
                     requirements on the type of some subexpression, a type error is an error in the
                     evaluation of <var>C</var>, not in the evaluation of the subexpression.</p>

                  <p>For example, consider the following construct:</p>

                  <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:variable name="v" as="xs:integer"&gt;
  &lt;xsl:sequence select="$foo"/&gt;
&lt;/xsl:variable&gt;</eg>

                  <p>The expected type of the result of the sequence constructor is
                        <code>xs:integer</code>; if the value of variable <code>$foo</code> turns
                     out to be a string, then a type error will occur. It is not possible to catch
                     this by writing:</p>

                  <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:variable name="v" as="xs:integer"&gt;
  &lt;xsl:try&gt;
    &lt;xsl:sequence select="$foo"/&gt;
    &lt;xsl:catch&gt;...&lt;/xsl:catch&gt;
  &lt;/xsl:try&gt;
&lt;/xsl:variable&gt;</eg>

                  <p>This fails to catch the error because the <elcode>xsl:sequence</elcode>
                     instruction is deemed to evaluate successfully; the failure only occurs when
                     the result of this instruction is bound to the variable.</p>

                  <p>A similar rule applies to functions: if the body of a function computes a
                     result which does not conform to the required type of the function result, it
                     is not possible to catch this error within the function body itself; it can
                     only be caught by the caller of the function. Similarly, if an expression used
                     to compute an argument to a function returns a value of the wrong type for the
                     function signature, this is not considered an error in this expression, but an
                     error in evaluating the function call as a whole.</p>

                  <p>A consequence of these rules is that when a type error occurs while
                     initializing a global variable (because the initializer returns a value of the
                     wrong type, given the declared type of the variable), then this error cannot be
                     caught.</p>

                  <note>
                     <p>Because processors are permitted to report type errors during static
                        analysis, it is unwise to attempt to recover from type errors dynamically.
                        The best strategy is generally to prevent their occurrence. For example,
                        rather than writing <code>$p + 1</code> where <code>$p</code> is a parameter
                        of unknown type, and then catching the type error that occurs if
                           <code>$p</code> is not numeric, it is better first to test whether
                           <code>$p</code> is numeric, perhaps by means of an expression such as
                           <code>$p instance of my:numeric</code>, where <code>my:numeric</code> is
                        a union type with <code>xs:double</code>, <code>xs:float</code>, and
                           <code>xs:decimal</code> as its member types.</p>
                  </note>


               </item>
               <item>
                  <p>The fact that the application tries to catch errors does not prevent the
                     processor from organizing the evaluation in such a way as to prevent errors
                     occurring. For example <code>exists(//a[10 div . gt 5])</code> may still do an
                     “early exit”, rather than examining every item in the sequence just to see if
                     it triggers a divide-by-zero error.</p>
               </item>

               <item>
                  <p>Except as specified above, the optimizer must not rearrange the evaluation (at
                     compile time or at run time) so that expressions written to be subject to the
                     try/catch are evaluated outside its scope, or expressions written to be
                     external to the try/catch are evaluated within its scope. This does not prevent
                     expressions being rearranged, but any expression that is so rearranged must
                     carry its try/catch context with it.</p>
               </item>
            </olist>

            

            

            <div3 id="recovery">
               <head>Recovery of Result Trees</head>

               <p>The XSLT language is designed so that a processor that chooses to execute
                  instructions in document order will always append nodes to the result tree in
                  document order, and never needs to update a result tree in situ. As a result, it
                  is normal practice for XSLT processors to stream the result tree directly to its
                  final destination (for example, a serializer) without ever holding the tree in
                  memory. This applies whether or not the processor is streamable, and whether or
                  not source documents are streamed.</p>

               <p>The language specification states (see <specref ref="errors"/>) that when a
                  transformation terminates with a dynamic error, the state of persistent resources
                  affected by the transformation (for example, serialized result documents) is
                     <termref def="dt-implementation-defined"/>, so processors are not required to
                  take any special steps to recover such resources to their pre-transformation
                  state; at the same time, there is no guarantee that secondary result documents
                  produced before the failure occurs will be in a usable state.</p>

               <p>The situation becomes more complicated when dynamic errors occur while writing to
                  a result tree, and the dynamic error is caught by an
                     <elcode>xsl:try</elcode>/<elcode>xsl:catch</elcode> instruction. The semantics
                  of these instructions requires that when an error occurring during the evaluation
                  of <elcode>xsl:try</elcode> is caught, the result of the <elcode>xsl:try</elcode>
                  instruction is the result of the relevant <elcode>xsl:catch</elcode>. To achieve
                  this, any output written to the result tree during the execution of
                     <elcode>xsl:try</elcode> until the point where the error occurs must
                  effectively be undone. There are two basic strategies for achieving this: either
                  the updates are not committed to persistent storage until the
                     <elcode>xsl:try</elcode> instruction is completed, or the updates are written
                  in such a way that they can be rolled back in the event of a failure.</p>

               <p>Both these strategies are potentially expensive, and both have an adverse effect
                  on streaming, in that they affect the amount of memory needed to transform large
                  amounts of data. XSLT 3.0 therefore provides an option to relax the requirement to
                  recover result trees when failures occur in the course of evaluating an
                     <elcode>xsl:try</elcode> instruction. This option is invoked by specifying
                     <code>rollback-output="no"</code> on the <elcode>xsl:try</elcode>
                  instruction.</p>

               <p>The default value of the attribute is <code>rollback-output="yes"</code>.</p>

               <p>The effect of specifying <code>rollback-output="no"</code> on
                     <elcode>xsl:try</elcode> is as follows: if a dynamic error occurs in the course
                  of evaluating the <elcode>xsl:try</elcode> instruction, and if the failing
                  construct is evaluated in <termref def="dt-final-output-state"/> while writing to
                  some result document, then it is <termref def="dt-implementation-dependent"/>
                  whether an attempt to catch this error using <elcode>xsl:catch</elcode> will be
                  successful. If the attempt is successful, then the <elcode>xsl:try</elcode>
                  instruction succeeds, delivering the result of evaluating the
                     <elcode>xsl:catch</elcode> clause, and the transformation proceeds as normal.
                  If the attempt is unsuccessful (typically, because non-recoverable updates have
                  already been made to the result tree), then the <elcode>xsl:try</elcode>
                  instruction as a whole fails with a dynamic error. The state of this result
                  document will then be undefined, but the transformation can ignore the failure and
                  continue to produce other result documents, for example by wrapping the
                     <elcode>xsl:result-document</elcode> instruction in an <elcode>xsl:try</elcode>
                  instruction that catches the relevant error.</p>

               <p>
                  <error spec="XT" class="DE" code="3530" type="dynamic">
                     <p>It is a <termref def="dt-dynamic-error"/> if an <elcode>xsl:try</elcode>
                        instruction is unable to recover the state of a final result tree because
                        recovery has been disabled by use of the attribute
                           <code>rollback-output="no"</code>.</p>
                  </error>
               </p>

               <p>For example, consider the following:</p>

               <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:result-document href="out.xml"&gt;     
  &lt;xsl:try rollback-output="no"&gt;
    &lt;xsl:source-document streamable="yes" href="in.xml"&gt;
      &lt;xsl:copy-of select="."/&gt;
    &lt;/xsl:source-document&gt;
    &lt;xsl:catch errors="*"&gt;
       &lt;error code="{$err:code}" message="{$err:description}" file="in.xml"/&gt;
    &lt;/xsl:catch&gt;
  &lt;/xsl:try&gt;
&lt;/xsl:result-document&gt;</eg>

               <p>The most likely failure to occur here is a failure to read the streamed input file
                     <code>in.xml</code>. In the common case where this failure is detected
                  immediately, for example if the file does not exist or the network connection is
                  down, no output will have been written to the result document, and the attempt to
                  catch the error is likely to be successful. If however a failure is detected after
                  several megabytes of data have been copied to <code>out.xml</code>, for example an
                  XML well-formedness error in the input file, or a network failure that occurs
                  while reading the file, recovery of the output file may be impossible. In this
                  situation the <elcode>xsl:result-document</elcode> instruction will fail with a
                  dynamic error. It is possible to catch this error, but the state of the file
                     <code>out.xml</code> will be unpredictable.</p>

               <p>Note that adding an <elcode>xsl:try</elcode> instruction as a child of
                     <elcode>xsl:source-document</elcode> does not help. Any error reading the input file
                  (such as a well-formedness error) is an error in the <elcode>xsl:source-document</elcode>
                  instruction and can only be caught at that level.</p>

               <p>When <code>rollback-output="no"</code> is specified, it is still possible to
                  ensure recovery of errors happens predictably by evaluating the
                  potentially failing code in <termref def="dt-temporary-output-state"/>: typically,
                  within an <elcode>xsl:variable</elcode>. In effect the variable acts as an
                  explicit buffer for temporary results, which is only copied to the final output if
                  evaluation succeeds.</p>

               <note>
                  <p>An application might wish to ensure that when a fatal error occurs while
                     reading an input stream, data written to persistent storage up to the point of
                     failure is available after the transformation terminates. Setting
                        <code>rollback-output="no"</code> does not guarantee this, but a processor
                     might choose to interpret this as the intent.</p>
               </note>

               <p>Changing the attribute to <code>rollback-output="yes"</code> makes the stylesheet
                  more robust and able to handle error conditions predictably, but the cost may be
                  substantial; for example it may be necessary to buffer the whole of the result
                  document in memory.</p>
            </div3>


            <div3 id="try-catch-examples">
               <head>Try/Catch Examples</head>

               <example>
                  <head>Catching a Divide-by-Zero Error</head>

                  <p>The following example divides an employee’s salary by the number of
                     years they have served, catching the divide-by-zero error if the latter is
                     zero.</p>
                  <eg role="xslt-instruction xmlns:err='http://www.w3.org/2005/xqt-errors'" xml:space="preserve">&lt;xsl:try select="salary div length-of-service"&gt;
  &lt;xsl:catch errors="err:FOAR0001" select="()"/&gt;
&lt;/xsl:try&gt;</eg>
               </example>

               <example>
                  <head>Catching an Error during Result-tree Validation</head>

                  <p>The following example generates a result tree and performs schema validation,
                     outputting a warning message and serializing the invalid tree if validation
                     fails.</p>

                  <eg role="xslt-instruction xmlns:err='http://www.w3.org/2005/xqt-errors'" xml:space="preserve">&lt;xsl:result-document href="out.xml"&gt;
  &lt;xsl:variable name="result"&gt;
    &lt;xsl:call-template name="construct-output"/&gt;
  &lt;/xsl:variable&gt;
  &lt;xsl:try&gt;
    &lt;xsl:copy-of select="$result" validation="strict"/&gt;
    &lt;xsl:catch&gt;
      &lt;xsl:message&gt;Warning: validation of result document failed:
          Error code: &lt;xsl:value-of select="$err:code"/&gt;
          Reason: &lt;xsl:value-of select="$err:description"/&gt;
      &lt;/xsl:message&gt;
      &lt;xsl:sequence select="$result"/&gt;
    &lt;/xsl:catch&gt;
  &lt;/xsl:try&gt;
&lt;/xsl:result-document&gt;
</eg>

                  <p>The reason that the result tree is constructed in a variable in this example is
                     so that the unvalidated tree is available to be used within the
                        <elcode>xsl:catch</elcode> element. An alternative approach would be to
                     repeat the logic for constructing the tree:</p>
                  <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:try&gt;
  &lt;xsl:result-document href="out.xml" validation="strict"&gt;  
    &lt;xsl:call-template name="construct-output"/&gt;
  &lt;/xsl:result-document&gt;
  &lt;xsl:catch&gt;
    &lt;xsl:message&gt;Warning: validation of result document failed:
          Error code: &lt;xsl:value-of select="$err:code"/&gt;
          Reason: &lt;xsl:value-of select="$err:description"/&gt;
    &lt;/xsl:message&gt;
    &lt;xsl:call-template name="construct-output"/&gt;
  &lt;/xsl:catch&gt;
&lt;/xsl:try&gt;</eg>
               </example>
            </div3>

         </div2>
         <div2 id="conditional-content-construction">
            <head>Conditional Content Construction</head>

            <p>The facilities described in this section are designed to make it easier to generate
               result trees conditionally depending on what is found in the input, without violating
               the rules for streamability. These facilities are available whether or not streaming
               is in use, but they are introduced to the language specifically to make streaming
               easier.</p>

            <p>The facilities are introduced first by example:</p>

            <example>
               <head>Generating a Wrapper Element for a non-Empty Sequence</head>
               <p>The following example generates an <code>events</code> element if and only if
                  there are one or more <code>event</code> elements. The code could be written like
                  this:</p>
               <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:if test="exists(event)"&gt;
  &lt;events&gt;
    &lt;xsl:copy-of select="event"/&gt;
  &lt;/events&gt;
&lt;/xsl:if&gt;</eg>
               <p>However, the above code would not be <termref def="dt-guaranteed-streamable"/>,
                  because it processes the child <code>event</code> elements more than once. To make
                  it streamable, it can be rewritten as:</p>
               <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:where-populated&gt;
  &lt;events&gt;
    &lt;xsl:copy-of select="event"/&gt;
  &lt;/events&gt;
&lt;/xsl:where-populated&gt;</eg>
               <p>The effect of the <elcode>xsl:where-populated</elcode> instruction, as explained
                  later, is to avoid outputting the <code>events</code> element if it would have no
                  children. A streaming implementation will typically hold the start tag of the
                     <code>events</code> element in a buffer, to be sent to the output destination
                  only if and when a child node is generated.</p>
            </example>
            <example>
               <head>Generating a Header and Footer only if there is Content</head>
               <p>The following example generates an <code>h3</code> element and a summary paragraph
                  only if a list of items is non-empty. The code could be written like this:</p>
               <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:if test="exists(item-for-sale)"&gt;
  &lt;h1&gt;Items for Sale&lt;/h1&gt;
&lt;/xsl:if&gt;  
&lt;xsl:apply-templates select="item-for-sale"/&gt;
&lt;xsl:if test="exists(item-for-sale)"&gt;
  &lt;p&gt;Total value: {accumulator-before('total-value')}&lt;/p&gt;
&lt;/xsl:if&gt;</eg>
               <p>However, the above code would not be <termref def="dt-guaranteed-streamable"/>,
                  because it processes the child <code>item-for-sale</code> elements more than once.
                  To make it streamable, it can be rewritten as:</p>
               <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:sequence&gt;
  &lt;xsl:on-non-empty&gt;
    &lt;h1&gt;Items for Sale&lt;/h1&gt;
  &lt;/xsl:on-non-empty&gt;  
  &lt;xsl:apply-templates select="item-for-sale"/&gt;
  &lt;xsl:on-non-empty&gt;
    &lt;p&gt;Total value: {accumulator-before('total-value')}&lt;/p&gt;
  &lt;/xsl:on-non-empty&gt;  
&lt;/xsl:sequence&gt;</eg>
               <p>The effect of the <elcode>xsl:on-non-empty</elcode> instruction, as explained
                  later, is to output the enclosed content only if the containing sequence
                  constructor also generates “ordinary” content, that is, if there is content
                  generated by instructions other than <elcode>xsl:on-empty</elcode> and
                     <elcode>xsl:on-non-empty</elcode> instructions.</p>
            </example>
            <example>
               <head>Generating Substitute Text when there is no Content</head>
               <p>The following example generates a summary paragraph only if a list of items is
                  empty. The code could be written like this:</p>
               <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:apply-templates select="item-for-sale"/&gt;
&lt;xsl:if test="empty(item-for-sale)"&gt;
  &lt;p&gt;There are no items for sale.&lt;/p&gt;
&lt;/xsl:if&gt;</eg>
               <p>However, the above code would not be <termref def="dt-guaranteed-streamable"/>,
                  because it processes the child <code>item-for-sale</code> elements more than once
                  (the fact that the list is empty is irrelevant, because streamability is
                  determined statically). To make the code streamable, it can be rewritten as:</p>
               <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:sequence&gt;
  &lt;xsl:apply-templates select="item-for-sale"/&gt;
  &lt;xsl:on-empty&gt;
    &lt;p&gt;There are no items for sale.&lt;/p&gt;
  &lt;/xsl:on-empty&gt;
&lt;/xsl:sequence&gt;</eg>
               <p>The effect of the <elcode>xsl:on-empty</elcode> instruction, as explained later,
                  is to output the enclosed content only if the containing sequence constructor
                  generates no “ordinary” content, that is, if there is no content generated by
                  instructions other than <elcode>xsl:on-empty</elcode> and
                     <elcode>xsl:on-non-empty</elcode> instructions.</p>
            </example>
            <note>
               <p>In some cases, similar effects can be achieved by using the
                     <xfunction>has-children</xfunction> function, which tests whether an element
                  has child nodes without consuming the children. However, use of
                     <xfunction>has-children</xfunction> has the drawback that the function is
                  unselective: it cannot be used to test whether there are any children of relevance
                  to the application. In particular, it returns <code>true</code> if an element contains comments
                  or whitespace text nodes that the application might consider to be
                  insignificant.</p>
            </note>
            <note>
               <p>There are no special streamability rules for the three instructions
                     <elcode>xsl:where-populated</elcode>, <elcode>xsl:on-empty</elcode>, or
                     <elcode>xsl:on-non-empty</elcode>. The <termref def="dt-general-streamability-rules"/> apply. In many cases the
                     <elcode>xsl:on-empty</elcode> and <elcode>xsl:on-non-empty</elcode>
                  instructions will generate content that does not depend on the source document,
                  and they will therefore be <termref def="dt-motionless"/>, but this is not
                  required.</p>
            </note>
            <div3 id="where-populated">
               <head>The <code>xsl:where-populated</code> instruction</head>
               <?element xsl:where-populated?>
               <p>The <elcode>xsl:where-populated</elcode> instruction encloses a <termref def="dt-sequence-constructor"/>. The result of the instruction is established
                  as follows:</p>
               <olist>
                  <item>
                     <p>The sequence constructor is evaluated in the usual way (taking into account
                        any <elcode>xsl:on-empty</elcode> and <elcode>xsl:on-non-empty</elcode>
                        instructions) to produce a result <var>$R</var>.</p>
                  </item>
                  <item>
                     <p>The result of the instruction is the value of the expression
                           <code>$R[not(deemed-empty(.))]</code> where the function
                           <code>deemed-empty($item as item())</code> returns <code>true</code> if and only if
                           <code>$item</code> is one of the following:</p>

                     <ulist>
                        <item>
                           <p>A document or element node that has no children.</p>
                           <note>
                              <p>If an element has attributes or namespaces, these do not prevent
                                 the element being deemed empty.</p>
                              <p>If a document or element node has children, the node is not deemed
                                 empty, even if the children are empty. For example, a document node
                                 created using an <elcode>xsl:variable</elcode> instruction in the
                                 form
                                    <code>&lt;xsl:variable name="temp"&gt;&lt;a/&gt;&lt;/xsl:variable&gt;</code>
                                 is not deemed empty, even though the contained &lt;a/&gt;
                                 element is empty.</p>
                           </note>
                        </item>
                        <item>
                           <p>A node, other than a document or element node, whose string value is
                              zero-length.</p>
                           <note>
                              <p>A whitespace-only text node is not deemed empty.</p>
                           </note>
                        </item>
                        <item>
                           <p>An atomic value such that the result of casting the atomic value to a
                              string is zero-length.</p>
                           <note>
                              <p>This can happen only when the atomic value is of type
                                    <code>xs:string</code>, <code>xs:anyURI</code>,
                                    <code>xs:untypedAtomic</code>, <code>xs:hexBinary</code>, or
                                    <code>xs:base64Binary</code>.</p>
                           </note>
                        </item>
                        <item>
                           <p>A map whose size (number of key/value
                              pairs) is zero.</p>
                        </item>
                        <item>
                           <p>An array (see <specref ref="arrays"/>) where the result 
                              of flattening the array using the <xfunction spec="FO40">array:flatten</xfunction> function is 
                              either an empty sequence, or a sequence in which every item is deemed empty 
                              (applying these rules recursively).</p>
                        </item>
                     </ulist>
                  </item>
               </olist>

               <example>
                  <head>Generating an HTML list</head>
                  <p>The following example generates an HTML unnumbered list, if and only if the
                     list is non-empty. Note that the presence of the <code>class</code> attribute
                     does not make the list non-empty. The code is written to be streamable.</p>
                  <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:where-populated&gt;
  &lt;ul class="my-list"&gt;
    &lt;xsl:for-each select="source-item"&gt;
       &lt;li&gt;&lt;xsl:value-of select="."/&gt;&lt;/li&gt;
    &lt;/xsl:for-each&gt;
  &lt;/ul&gt;
&lt;/xsl:where-populated&gt;</eg>
               </example>
            </div3>
            <div3 id="on-empty">
               <head>The <code>xsl:on-empty</code> instruction</head>
               <?element xsl:on-empty?>
               <p>The <elcode>xsl:on-empty</elcode> instruction has the same content model as
                     <elcode>xsl:sequence</elcode>, and when it is evaluated, the same rules apply.
                  In particular, the <code>select</code> attribute and the contained sequence
                  constructor are mutually exclusive <errorref spec="XT" class="SE" code="3185"/>.</p>
               <p>When an <elcode>xsl:on-empty</elcode> instruction
                  appears in a sequence constructor, then:</p>
               <olist>
                  <item>
                     <p>It must be the only <elcode>xsl:on-empty</elcode> instruction in the
                        sequence constructor, and</p>
                  </item>
                  <item>
                     <p>It must not be followed in the sequence constructor by any other <termref def="dt-instruction"/>, other than <elcode>xsl:fallback</elcode>, or by a
                        significant text node (that is, a text node that has not been discarded
                        under the provisions of <specref ref="stylesheet-stripping"/>), or by a
                           <termref def="dt-literal-result-element"/>. It may, however, be followed
                        by non-instructions such as <elcode>xsl:catch</elcode> where
                        appropriate.</p>
                  </item>
               </olist>
               
               <p><termdef id="dt-vacuous" term="vacuous">An item is <term>vacuous</term> if
               it is one of the following: a zero-length text node; a document node with no children; an atomic value which, 
               on casting to <code>xs:string</code>, produces a zero-length string; or <phrase diff="del" at="2022-01-01">(when XPath 3.1 is supported)</phrase> an array 
                  which on flattening using the <xfunction spec="FO40">array:flatten</xfunction> function produces either an empty sequence 
                  or a sequence consisting entirely of <termref def="dt-vacuous"/> items.</termdef></p>
                                
               <p>An <elcode>xsl:on-empty</elcode> instruction is triggered only if every 
                  preceding sibling instruction, text node, and literal result element in the same <termref def="dt-sequence-constructor"/> 
                  returns either an empty sequence, or a sequence consisting entirely of <termref def="dt-vacuous"/> items.
               </p>
                  
               <p>If an <elcode>xsl:on-empty</elcode> instruction is triggered, then the result 
                  of the containing <termref def="dt-sequence-constructor"/> is the result of the <elcode>xsl:on-empty</elcode> instruction.
               </p>
               
               <note><p>This means that the (vacuous) results produced by other instructions in the 
                  sequence constructor are discarded. This is relevant mainly when the result of the sequence constructor 
                  is used for something other than constructing a node: for example if it forms the result of a function, 
                  or the value of a variable, and the function or variable specifies a required type.</p>
                  <p>When streaming, it may be necessary to buffer vacuous items in the result sequence until it is 
                     known whether the result will contain items that are non-vacuous. In many common situations, however
                     — in particular, when the sequence constructor is being used to create the content of a node — 
                     vacuous items can be discarded immediately because they do not affect the content of the node being constructed.
                  </p>
               </note>
                  
               <note><p>In nearly all cases, the rules for <elcode>xsl:on-empty</elcode> are aligned 
                  with the rules for constructing complex content. If the sequence constructor within a literal result element 
                  or an <elcode>xsl:element</elcode> instruction includes an <elcode>xsl:on-empty</elcode> instruction, 
                  then the content of the element will be the value delivered by the <elcode>xsl:on-empty</elcode> instruction 
                  if and only if the content would otherwise be empty.</p>
                  <p>There is one minor exception to this rule: if the sequence constructor delivers multiple zero-length strings, 
                     then in the absence of the <elcode>xsl:on-empty</elcode> instruction the new element would contain whitespace, 
                     made up of the separators between these zero-length strings; but <elcode>xsl:on-empty</elcode> takes no account 
                     of these separators.</p></note>
                  
               <note><p>Attribute and namespace nodes created by the sequence constructor 
                  are significant; the <elcode>xsl:on-empty</elcode> instruction will not be triggered if such nodes are present. 
                  If this is not the desired effect, it is possible to partition the sequence constructor to change the scope of 
                  <elcode>xsl:on-empty</elcode>, for example:</p>
                     
                     <eg role="xslt-instruction" xml:space="preserve">&lt;ol&gt;
  &lt;xsl:attribute name="class" select="numbered-list"/&gt;
  &lt;xsl:sequence&gt;
    &lt;xsl:value-of select="xyz"/&gt;
    &lt;xsl:on-empty select="'The list is empty'"/&gt;
  &lt;/xsl:sequence&gt;
&lt;/ol&gt;</eg>
                     
                  </note>
                  
               <note><p>Where the sequence constructor is a child of an instruction with
               an <code>[xsl:]use-attribute-sets</code> attribute, any attribute nodes created by expanding the referenced
               attribute set(s) are not part of the result of the sequence constructor and therefore play no role in determining
               whether an <elcode>xsl:on-empty</elcode> or <elcode>xsl:on-non-empty</elcode> instruction is triggered. 
                  Equally, when the sequence constructor is a child
               of a <termref def="dt-literal-result-element"/>, attribute nodes generated by expanding the attributes
               of the literal result element are not taken into account.</p></note>
                  


               <note>
   
                  <p>If <elcode>xsl:on-empty</elcode> is the only instruction in a sequence
                     constructor then it is always evaluated.</p>
                  <p>If <elcode>xsl:on-empty</elcode> and <elcode>xsl:on-non-empty</elcode> appear
                     in the same sequence constructor, then the rules ensure that only one of them
                     will be evaluated.</p>
               </note>




            </div3>
            <div3 id="on-non-empty">
               <head>The <elcode>xsl:on-non-empty</elcode> instruction</head>
               <?element xsl:on-non-empty?>
               <p>The <elcode>xsl:on-non-empty</elcode> instruction has the same content model as
                     <elcode>xsl:sequence</elcode>, and when it is evaluated, the same rules apply.
                  In particular, the <code>select</code> attribute and the contained sequence
                  constructor are mutually exclusive <errorref spec="XT" class="SE" code="3185"/>.</p>
               
               <p>An <elcode>xsl:on-non-empty</elcode> instruction is evaluated only 
                  if there is at least one sibling node in the same <termref def="dt-sequence-constructor"/>, 
                  excluding <elcode>xsl:on-empty</elcode> and <elcode>xsl:on-non-empty</elcode> instructions, 
                  whose evaluation yields a sequence containing an item that is not <termref def="dt-vacuous"/>. 
                  If this condition applies, then all <elcode>xsl:on-non-empty</elcode> instructions in the 
                  containing sequence constructor are evaluated, and their results are included in the result 
                  of the containing sequence constructor in their proper positions.
               </p>
               <note>
                  <p>The <elcode>xsl:on-non-empty</elcode> instruction is typically used to generate headers or 
                     footers appearing before or after a list of items, where the header or footer is to be 
                     omitted if there are no items in the list.
              </p> </note>
               

               <note>
                  <p>Unlike <elcode>xsl:on-empty</elcode>, the <elcode>xsl:on-non-empty</elcode>
                     instruction can appear anywhere in a sequence constructor, and can appear more
                     than once.</p>
               </note>

            </div3>
            <div3 id="evaluating-on-empty">
               <head>Evaluating <elcode>xsl:on-empty</elcode> and <elcode>xsl:on-non-empty</elcode>
                  Instructions</head>
               <p>The following non-normative algorithm explains one possible strategy for streamed
                  evaluation of a <termref def="dt-sequence-constructor"/> containing
                     <elcode>xsl:on-empty</elcode> and/or <elcode>xsl:on-non-empty</elcode>
                  instructions.</p>
               <p>The algorithm makes use of the following mutable variables:</p>
               <ulist>
                  <item>
                     <p><var>L</var> : a list of instructions awaiting evaluation. Initially
                        empty.</p>
                  </item>
                  <item>
                     <p><var>R</var> : a list of items to act as the result of the evaluation.
                        Initially empty.</p>
                  </item>
                  <item>
                     <p><var>F</var> : a boolean flag, initially <code>false</code>, to indicate whether any
                           <termref def="dt-vacuous">non-vacuous</termref> items have been written to <var>R</var> by
                           <term>ordinary instructions</term>. The term <term>ordinary instruction</term>
                        means any node in the sequence constructor other than an
                           <elcode>xsl:on-empty</elcode> or <elcode>xsl:on-non-empty</elcode>
                        instruction.</p>
                  </item>
               </ulist>
               <p>The algorithm is as follows:</p>
               <olist>
                  <item>
                     <p>The nodes in the sequence constructor are evaluated in document order.</p>
                  </item>
                  <item>
                     <p>When an <elcode>xsl:on-non-empty</elcode> instruction is encountered,
                        then:</p>
                     <olist>
                        <item>
                           <p>If <var>F</var> is true, the instruction is evaluated and the result
                              is appended to <var>R</var>.</p>
                        </item>
                        <item>
                           <p>Otherwise, the instruction is appended to <var>L</var>.</p>
                        </item>
                     </olist>
                  </item>
                  <item>
                     <p>When an <term>ordinary instruction</term> is evaluated:</p>
                     <olist>
                        <item>
                           <p>The results of the evaluation are appended to <var>R</var>, in
                              order.</p>
                        </item>
                        <item>
                           <p>When a <termref def="dt-vacuous">non-vacuous</termref> item is about to be appended to
                                 <var>R</var>, and <var>F</var> is false, then before appending the
                              item to <var>R</var>, the following actions are taken:</p>
                           <olist>
                              <item>
                                 <p>Any <elcode>xsl:on-non-empty</elcode> instructions in
                                       <var>L</var> are evaluated, in order, and their results are
                                    appended to <var>R</var>.</p>
                              </item>
                              <item>
                                 <p><var>F</var> is set to <code>true</code>.</p>
                              </item>
                           </olist>
                        </item>
                     </olist>
                  </item>
                  <item>
                     <p>When an <elcode>xsl:on-empty</elcode> instruction is encountered, then:</p>
                     <olist>
                        <item>
                           <p>If <var>F</var> is true, the instruction is ignored.</p>
                        </item>
                        <item>
                           <p>Otherwise, the existing contents of <var>R</var> are discarded, 
                              the instruction is evaluated, and its results are appended to <var>R</var>.</p> 
                           
                           <note><p>The need to discard items from <var>R</var> 
                              arises only when all the items in <var>R</var> are <termref def="dt-vacuous"/>. 
                              Streaming implementations may therefore need a limited amount of buffering to retain 
                              insignificant items until it is known whether they will be needed. 
                              However, in many common cases an optimized implementation will be able 
                              to discard <termref def="dt-vacuous"/> items such as empty text nodes immediately, 
                              because when a node is being constructed using the rules in 
                              <specref ref="constructing-complex-content"/> or <specref ref="constructing-simple-content"/>, 
                              such items have no effect on the final outcome.</p></note>
                                                     
                           <p>Otherwise, the instruction is evaluated and its results are appended
                              to <var>R</var>.</p>
                        </item>
                     </olist>
                  </item>
                  <item>
                     <p>The result of the sequence constructor is the list of items in
                        <var>R</var>.</p>
                  </item>
               </olist>

            </div3>
            <div3 id="where-populated-example">
               <head>A More Complex Example</head>
               <p>This example shows how the three instructions
                  <elcode>xsl:where-populated</elcode>, <elcode>xsl:on-empty</elcode>, and
                     <elcode>xsl:on-non-empty</elcode> may be combined.</p>
               <example>
                  <head>Generating a Table only if there is Content</head>
                  <p>The following example generates a table containing the names and ages of a set
                     of students; if there are no students, it substitutes a paragraph explaining
                     this.</p>
                  <eg role="xslt-fragment" xml:space="preserve">&lt;div id="students"&gt;
&lt;xsl:where-populated&gt;
   &lt;table&gt;
      &lt;xsl:on-non-empty&gt;
         &lt;thead&gt;
            &lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Age&lt;/th&gt;&lt;/tr&gt;
         &lt;/thead&gt;
      &lt;/xsl:on-non-empty&gt;
      &lt;xsl:where-populated&gt;
         &lt;tbody&gt;
            &lt;xsl:for-each select="student/copy-of()"&gt;
               &lt;tr&gt;
                  &lt;td&gt;&lt;xsl:value-of select="name"/&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;xsl:value-of select="age"/&gt;&lt;/td&gt;
               &lt;/tr&gt;
            &lt;/xsl:for-each&gt;
         &lt;/tbody&gt;
      &lt;/xsl:where-populated&gt;
   &lt;/table&gt;
&lt;/xsl:where-populated&gt;
&lt;xsl:on-empty&gt;
   &lt;p&gt;There are no students&lt;/p&gt;
&lt;/xsl:on-empty&gt;
&lt;/div&gt;</eg>
                  <p>Explanation:</p>
                  <ulist>
                     <item>
                        <p>The <elcode>xsl:where-populated</elcode> around the <code>table</code>
                           element ensures that if there is no <code>thead</code> and no
                              <code>tbody</code>, then there will be no <code>table</code>. </p>
                     </item>
                     <item>
                        <p>The <elcode>xsl:on-non-empty</elcode> surrounding the <code>thead</code>
                           element ensures that the <code>thead</code> element is not output unless
                           the <code>tbody</code> element is output. </p>
                     </item>
                     <item>
                        <p>The <elcode>xsl:where-populated</elcode> around the <code>tbody</code>
                           element ensures that the <code>tbody</code> element is not output unless
                           there is at least one table row (<code>tr</code>). </p>
                     </item>
                     <item>
                        <p>The <elcode>xsl:on-empty</elcode> around the <code>p</code> element
                           ensures that if no <code>table</code> is output, then the paragraph
                           <code>There are no students</code> is output instead. </p>
                     </item>
                  </ulist>
               </example>
            </div3>
         </div2>
      </div1>


      <div1 id="add-func">
         <head>Additional Functions</head>
         <p>This section describes XSLT-specific additions to the XPath function library. Some of these 
            additional functions also make use of
            information specified by <termref def="dt-declaration">declarations</termref> in the
            stylesheet; this section also describes these declarations.</p>

         <div2 id="func-document">
            <head><?function fn:document?></head>
         </div2>


         <div2 id="key">
            <head>Keys</head>
            <p>Keys provide a way to work with documents that contain an implicit cross-reference
               structure. They make it easier to locate the nodes within a document that have a
               given value for a given attribute or child element, and they provide a hint to the
               implementation that certain access paths in the document need to be efficient.</p>
            <div3 id="xsl-key">
               <head>The <elcode>xsl:key</elcode> Declaration</head>
               <?element xsl:key?>
               <p>The <elcode>xsl:key</elcode>
                  <termref def="dt-declaration">declaration</termref> is used to declare <termref def="dt-key">keys</termref>. The <code>name</code> attribute specifies the name
                  of the key. The value of the <code>name</code> attribute is an <termref def="dt-eqname">EQName</termref>, which is expanded as
                  described in <specref ref="qname"/>. The <code>match</code> attribute is a <nt def="Pattern40">Pattern</nt>; an <elcode>xsl:key</elcode> element applies to
                  all nodes that match the pattern specified in the <code>match</code>
                  attribute.</p>
               <p>
                  <termdef id="dt-key" term="key">A <term>key</term> is defined as a set of
                        <elcode>xsl:key</elcode> declarations in the same
                           <termref def="dt-package">package</termref> that share the same
                     name.</termdef>
               </p>
               <p>The key name is scoped to the containing <termref def="dt-package">package</termref>, and is available for use in calls to the
                     <function>key</function> function within that package.</p>
               <p>The value of the key may be specified either using the <code>use</code> attribute
                  or by means of the contained <termref def="dt-sequence-constructor">sequence
                     constructor</termref>.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="1205">
                     <p>It is a <termref def="dt-static-error">static error</termref> if an
                           <elcode>xsl:key</elcode> declaration has a <code>use</code> attribute and
                        has non-empty content, or if it has empty content and no <code>use</code>
                        attribute.</p>
                  </error>
               </p>
               <p>If the <code>use</code> attribute is present, its value is an <termref def="dt-expression">expression</termref> specifying the values of the key. The
                  expression will be evaluated with a <termref def="dt-singleton-focus">singleton focus</termref> based on the node that
                     matches the pattern. The result of evaluating the expression is
                     <termref def="dt-atomization">atomized</termref>. </p>
               <p>Similarly, if a <termref def="dt-sequence-constructor">sequence
                     constructor</termref> is present, it is used to determine the values of the
                  key. The sequence constructor will be evaluated with the node that matches the
                  pattern as the context node. The result of evaluating the sequence constructor is
                     <termref def="dt-atomization">atomized</termref>.</p>
               <p>
                  <termdef id="dt-key-specifier" term="key specifier">The expression in the
                        <code>use</code> attribute and the <termref def="dt-sequence-constructor">sequence constructor</termref> within an <elcode>xsl:key</elcode>
                     declaration are referred to collectively as the <term>key specifier</term>. The
                     key specifier determines the values that may be used to find a node using this
                        <termref def="dt-key">key</termref>.</termdef>
               </p>
               <p>When evaluation of the <termref def="dt-key-specifier">key
                     specifier</termref> results in a sequence (after atomization) containing more
                  than one atomic value, the effect depends on the value of the
                     <code>composite</code> attribute:</p>
               <ulist>
                  <item>
                     <p>When the attribute is absent or has the value <code>no</code>, each atomic
                        value in the sequence acts as an individual key. For example, if
                           <code>match="book" use="author" composite="no"</code> is specified, then
                        a <code>book</code> element may be located using the value of any
                           <code>author</code> element.</p>
                  </item>
                  <item>
                     <p>When the attribute is present and has the value <code>yes</code>, the
                        sequence of atomic values is treated as a composite key that must be matched
                        in its entirety. For example, if <code>match="book" use="author"
                           composite="yes"</code> is specified, then a <code>book</code> element may
                        be located using the value of all its <code>author</code> elements, supplied
                        in the correct order.</p>
                  </item>
               </ulist>

               <p>If there are several <elcode>xsl:key</elcode> declarations in
                  the same package with the same key name, then
                  they must all have the same <termref def="dt-effective-value"/> for their <code>composite</code>
                  attribute. The <termref def="dt-effective-value"/> is the actual value of the attribute if present, or
                  <code>"no"</code> if the attribute is absent.</p>
               <note>
                  <p>There is no requirement that all the values of a key should have the same
                     type.</p>
               </note>
               <p>The presence of an <elcode>xsl:key</elcode> declaration makes it easy to find a
                  node that matches the <code>match</code> pattern if  the values of the <termref def="dt-key-specifier">key
                     specifier</termref> (when applied to that node) are known. It also provides a
                  hint to the implementation that access to the nodes by means of these values needs
                  to be efficient (many implementations are likely to construct an index or hash
                  table to achieve this). </p>
               <note>
                  <p>An <elcode>xsl:key</elcode> declaration is not bound to a specific source
                     document. The source document to which it applies is determined only when the
                        <function>key</function> function is used to locate nodes using the key.
                     Keys can be used to locate nodes within any source document (including
                     temporary trees), but each use of the <function>key</function> function
                     searches one document only.</p>
                  <p>Keys can only be used to search within a tree 
                     that is rooted at a document node.</p>
               </note>
               <p>The optional <code>collation</code> attribute is used only when deciding whether
                  two strings are equal for the purposes of key matching. Specifically, two key
                  values <code>$a</code> and <code>$b</code> are considered equal if the result of
                  the function call <code>deep-equal($a, $b,
                        $collation)</code> returns <code>true</code>. The effective collation for an
                     <elcode>xsl:key</elcode> declaration is the collation specified in its
                     <code>collation</code> attribute if present, resolved against the base URI of
                  the <elcode>xsl:key</elcode> element, or the <termref def="dt-default-collation">default collation</termref> that is in scope for the <elcode>xsl:key</elcode>
                  declaration otherwise; the effective collation must be the same for all the
                     <elcode>xsl:key</elcode> declarations making up a <termref def="dt-key">key</termref>.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="1210">
                     <p>It is a <termref def="dt-static-error">static error</termref> if the
                           <elcode>xsl:key</elcode> declaration has a <code>collation</code>
                        attribute whose value (after resolving against the base URI) is not a URI
                        recognized by the implementation as referring to a collation.</p>
                  </error>
               </p>
               <p>
                  <error spec="XT" type="static" class="SE" code="1220">
                     <p>It is a <termref def="dt-static-error">static error</termref> if there are
                        several <elcode>xsl:key</elcode> declarations in the same <termref def="dt-package">package</termref> with the
                        same key name and different effective collations. Two collations are the
                        same if their URIs are equal under the rules for comparing
                           <code>xs:anyURI</code> values, or if the implementation can determine
                        that they are different URIs referring to the same collation.</p>
                  </error>
               </p>
               <p>
                  <error spec="XT" type="static" class="SE" code="1222">
                     <p>It is a <termref def="dt-static-error">static error</termref> if there are
                        several <elcode>xsl:key</elcode> declarations in a <termref def="dt-package">package</termref> with the same key name and
                        different <termref def="dt-effective-value">effective values</termref> for the <code>composite</code> attribute.</p>
                  </error>
               </p>
               <p>It is possible to have:</p>
               <ulist>
                  <item>
                     <p>multiple <elcode>xsl:key</elcode> declarations with the same name;</p>
                  </item>
                  <item>
                     <p>a node that matches the <code>match</code> patterns of several different
                           <elcode>xsl:key</elcode> declarations, whether these have the same key
                        name or different key names;</p>
                  </item>
                  <item>
                     <p>a node that returns more than one value from its <termref def="dt-key-specifier">key specifier</termref>
                        (which can be treated either as separate
                           individual key values, or as a single composite key value);</p>
                  </item>
                  <item>
                     <p>a key value that identifies more than one node (the key values for different
                        nodes do not need to be unique).</p>
                  </item>
               </ulist>
               <p>An <elcode>xsl:key</elcode> declaration with higher <termref def="dt-import-precedence">import precedence</termref> does not override
                  another of lower import precedence; all the <elcode>xsl:key</elcode> declarations
                  in the stylesheet are effective regardless of their import precedence.</p>
            </div3>
            <div3 id="func-key">
               <head><?function fn:key?></head>

            </div3>
         </div2>
         <div2 id="keys-and-streaming">
            <head>Keys and Streaming</head>
            <p>Keys are not applicable to streamed documents.</p>
            <p>This is ensured by the rules for the streamability of the <function>key</function> function 
               (see <specref ref="classifying-built-in-functions"/>). These rules make the <termref def="dt-operand-usage"/> of the
               third argument <termref def="dt-navigation"/>, which has the consequence that when the <function>key</function> function
            is applied to a streamed input document, the call is <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>, which effectively makes
            the containing construct non-streamable.</p>
         </div2>


         <div2 id="misc-func">
            <head>Miscellaneous Additional Functions</head>
            <div3 id="func-current">
               <head><?function fn:current?></head>
            </div3>
            <div3 id="func-unparsed-entity-uri">
               <head><?function fn:unparsed-entity-uri?></head>
            </div3>
            <div3 id="func-unparsed-entity-public-id">
               <head><?function fn:unparsed-entity-public-id?></head>
            </div3>

            <div3 id="func-system-property">
               <head><?function fn:system-property?></head>
            </div3>
            <div3 id="func-available-system-properties">
               <head><?function fn:available-system-properties?></head>
            </div3>

         </div2>

      </div1>



      <div1 id="map">
         <head>Maps</head>
         
         <p diff="chg" at="2022-01-01">Maps are defined in the XDM Data Model.</p>
         <div2 id="map-type" diff="del" at="2022-01-01">
            <head>The Type of a Map</head>


            <p>The syntax of <xnt ref="prod-xpath40-ItemType" spec="XP40">ItemType</xnt> as defined
               in XPath is extended as follows:</p>
            <scrap headstyle="show" id="MapType-scrap">
               <head>MapType</head>
               <prodgroup>
                  <prod num="69" id="NT-ItemType-2">
                     <lhs>ItemType</lhs>
                     <rhs>KindTest | ("item" "(" ")") | FunctionTest | AtomicOrUnionType |
                        ParenthesizedItemType<br/> | MapType</rhs>
                  </prod>
                  <prod num="201" id="NT-MapType">
                     <lhs>MapType</lhs>
                     <rhs>'map' '(' ( '*' | (<xnt ref="doc-xpath40-AtomicOrUnionType" spec="XP40">AtomicOrUnionType</xnt> ',' <xnt ref="prod-xpath40-SequenceType" spec="XP40">SequenceType</xnt>) ')'</rhs>
                  </prod>
               </prodgroup>
            </scrap>

            <p>The following rules express the matching rules for a map item type
               and a map, and extend the set of rules given in <xspecref spec="XP40" ref="id-matching-item"/>:</p>

            <ulist>
               <item>
                  <p>The <code>ItemType</code>
                     <code>map(K, V)</code> matches an item <var>M</var> if (a) <var>M</var> is a
                        map, and (b) every entry in <var>M</var> has
                     a key that matches <var>K</var> and an associated value that matches
                        <var>V</var>. For example, <code>map(xs:integer, element(employee))</code>
                     matches a map if all the keys in the map are integers, and all the associated
                     values are <code>employee</code> elements. Note that a map (like a sequence)
                     carries no intrinsic type information separate from the types of its entries,
                     and the type of existing entries in a map does not constrain the type of new
                     entries that can be added to the map.</p>
                  <note>
                     <p>In consequence, <code>map(K, V)</code> matches an empty
                        map, whatever the types <var>K</var> and <var>V</var> might be.</p>
                  </note>
               </item>
               <item>
                  <p>The <code>ItemType</code>
                     <code>map(*)</code> matches any map regardless of its contents. It is
                     equivalent to <code>map(xs:anyAtomicType, item()*)</code>.</p>
               </item>
            </ulist>

            <p>A map also acts as a function. This means that maps match certain
               function item types. Specifically, the following rule extends the list of rules in
                  <xspecref spec="XP40" ref="id-function-test"/>:</p>

            <ulist>
               <item>
                  <p><code>function(*)</code> matches any map.</p>
               </item>
               <item>
                  <p><code>function(xs:anyAtomicType) as item()*</code> matches any map.</p>
               </item>
            </ulist>

            <p>Because of the rules for subtyping of function types according to
               their signature, it follows that the item type <code>function(A) as item()*</code>,
               where A is an atomic type, also matches any map, regardless of the type of the keys
               actually found in the map. For example, a map whose keys are all strings can be
               supplied where the required type is <code>function(xs:integer) as item()*</code>; a
               call on the map that treats it as a function with an integer argument will always
               succeed, and will always return an empty sequence.</p>

            <p>The function signature of the map, treated as a function, is always
                  <code>function(xs:anyAtomicType) as item()*</code>, regardless of the actual types
               of the keys and values in the map. This means that a function item type with a more
               specific return type, such as <code>function(xs:anyAtomicType) as xs:integer</code>,
               does not match a map in the sense required to satisfy the <code>instance of</code>
               operator. However, the rules for function coercion mean that any map can be supplied
               as a value in a context where such a type is the required type, and a type error will
               only occur if an actual call on the map (treated as a function) returns a value that
               is not an instance of the required return type.</p>

            <note>
               <p>So, given a map <code>$M</code> whose keys are integers and whose results are
                  strings, such as <code>map{0:"no", 1:"yes"}</code>, the following relations hold,
                  among others:</p>
               <ulist>
                  <item>
                     <p><code>$M instance of map(*)</code></p>
                  </item>
                  <item>
                     <p><code>$M instance of map(xs:integer, xs:string)</code></p>
                  </item>
                  <item>
                     <p><code>$M instance of map(xs:decimal, xs:anyAtomicType)</code></p>
                  </item>
                  <item>
                     <p><code>not($M instance of map(xs:int, xs:string))</code></p>
                  </item>
                  <item>
                     <p><code>not($M instance of map(xs:integer, xs:token))</code></p>
                  </item>
                  <item>
                     <p><code>$M instance of function(*)</code></p>
                  </item>
                  <item>
                     <p><code>$M instance of function(xs:anyAtomicType) as item()*</code></p>
                  </item>
                  <item>
                     <p><code>$M instance of function(xs:integer) as item()*</code></p>
                  </item>
                  <item>
                     <p><code>$M instance of function(xs:int) as item()*</code></p>
                  </item>
                  <item>
                     <p><code>$M instance of function(xs:string) as item()*</code></p>
                  </item>
                  <item>
                     <p><code>not($M instance of function(xs:integer) as xs:string)</code></p>
                  </item>
               </ulist>
               <p>The last case might seem surprising; however, function coercion ensures that
                     <code>$M</code> can be used successfully anywhere that the required type is
                     <code>function(xs:integer) as xs:string</code>.</p>
            </note>

            <p>The rules for judging whether one item type is a subtype of
               another, given in <xspecref spec="XP40" ref="id-itemtype-subtype"/>, are extended
               with some additional rules. The judgement <code>subtype-itemtype(Ai, Bi)</code> is
               true if:</p>

            <ulist>
               <item>
                  <p><code>Ai</code> is <code>map(K, V)</code> and <code>Bi</code> is
                        <code>map(*)</code>, for any <code>K</code> and <code>V</code>.</p>
               </item>
               <item>
                  <p><code>Ai</code> is <code>map(Ka, Va)</code> and <code>Bi</code> is
                        <code>map(Kb, Vb)</code>, where <code>subtype-itemtype(Ka, Kb)</code> and
                        <code>subtype(Va, Vb)</code>.</p>
               </item>
               <item>
                  <p><code>Ai</code> is <code>map(*)</code> (or, because of the transitivity rules,
                     any other map type) and <code>Bi</code> is <code>function(*)</code>.</p>
               </item>
               <item>
                  <p><code>Ai</code> is <code>map(*)</code>, (or, because of the transitivity rules,
                     any other map type) and <code>Bi</code> is <code>function(xs:anyAtomicType) as
                        item()*</code>.</p>
               </item>
            </ulist>



         </div2>
         
         <div2 id="map-instructions">
            <head>Map Instructions</head>
            <p>Two instructions are added to XSLT to facilitate the construction of maps.</p>

            <?element xsl:map?>


            <p>The instruction <elcode>xsl:map</elcode> constructs and returns a new map.</p>

            

            <p>The contained sequence constructor <rfc2119>must</rfc2119> evaluate to a sequence of
               maps: call this <code>$maps</code>.</p>

            <p><phrase diff="chg" at="2022-01-01">In the absense of duplicate keys,</phrase> the result of the instruction  
               is then given by the XPath 3.1 expression:</p>
            <eg role="non-xml" xml:space="preserve">map:merge($maps)</eg>

            <note>
               <p>Informally: <phrase diff="chg" at="2022-01-01">in the absence of duplicate keys</phrase> the resulting map contains
                  the union of the map entries from the supplied sequence of maps.</p>
            </note>
            
            <p>The handling of duplicate keys is described in <specref ref="duplicate-keys"/> below.</p>

  


            <p>There is no requirement that the supplied input maps should have the same or
               compatible types. The type of a map (for example <code>map(xs:integer,
                  xs:string)</code>) is descriptive of the entries it currently contains, but is not
               a constraint on how the map may be combined with other maps.</p>

            <note diff="add" at="2023-04-04">
               <p>A common coding pattern is to supply the input as a set of singleton maps, that is,
               maps containing a single entry. Moreover, it is often convenient to construct these
               using the <elcode>xsl:map-entry</elcode> instruction. However, it is not required that
               the input maps should be singletons, nor is it required that they should be constructed
               using this instruction.</p>
            </note>

            <p><error spec="XT" class="TE" code="3375" type="type">
                  <p>A type error occurs if the result of evaluating the sequence constructor
                        <error.extra>within an <elcode>xsl:map</elcode> instruction</error.extra> is
                     not an instance of the required type <code>map(*)*</code>.</p>
               </error></p>



            <note>
               <p>In practice, the effect of this rule is that the sequence
                  constructor contained in the <elcode>xsl:map</elcode> instruction is severely
                  constrained: it doesn’t make sense, for example, for it to contain
                  instructions such as <elcode>xsl:element</elcode> that create new nodes. As with
                  other type errors, processors are free to signal the error statically if they are
                  able to determine that the sequence constructor would always fail when
                  evaluated.</p>
            </note>

            <?element xsl:map-entry?>

            <p>The instruction <elcode>xsl:map-entry</elcode> constructs and returns a singleton
               map: that is, a map which  contains one
               key and one value. Such a map is primarily used as a building block when constructing
               maps using the <elcode>xsl:map</elcode> instruction.</p>

            <p>The <code>select</code> attribute and the contained sequence constructor are mutually
               exclusive: if a <code>select</code> attribute is present, then the content
                  <rfc2119>must</rfc2119> be empty except optionally for
                  <elcode>xsl:fallback</elcode> instructions.</p>

            <p>
               <error spec="XT" type="static" class="SE" code="3280">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the
                        <code>select</code> attribute of the <elcode>xsl:map-entry</elcode> element
                     is present unless the element has no children other than
                        <elcode>xsl:fallback</elcode> elements.</p>
               </error>
            </p>

            

            <p>The key of the entry in the new map is the value obtained by evaluating the
               expression in the <code>key</code> attribute, converted to the required type
                  <code>xs:anyAtomicType</code> by applying the <termref def="dt-coercion-rules"/>. If the supplied key (after conversion) is of
               type <code>xs:untypedAtomic</code>, it is cast to <code>xs:string</code>.</p>

            <p>The associated value is the value obtained by evaluating the expression in the
                  <code>select</code> attribute, or the contained sequence constructor, with no
               conversion. If there is no <code>select</code> attribute and the sequence constructor
               is empty, the associated value is the empty sequence.</p>

            

            <example>
               <head>Using XSLT instructions to create a fixed map</head>
               <p>The following example binds a variable to a map whose content is statically
                  known:</p>
               <eg role="xslt-declaration" xml:space="preserve">
&lt;xsl:variable name="week" as="map(xs:string, xs:string)"&gt;
  &lt;xsl:map&gt;
    &lt;xsl:map-entry key="'Mo'" select="'Monday'"/&gt;
    &lt;xsl:map-entry key="'Tu'" select="'Tuesday'"/&gt;
    &lt;xsl:map-entry key="'We'" select="'Wednesday'"/&gt;
    &lt;xsl:map-entry key="'Th'" select="'Thursday'"/&gt;
    &lt;xsl:map-entry key="'Fr'" select="'Friday'"/&gt;
    &lt;xsl:map-entry key="'Sa'" select="'Saturday'"/&gt;
    &lt;xsl:map-entry key="'Su'" select="'Sunday'"/&gt;
  &lt;/xsl:map&gt;
&lt;/xsl:variable&gt;  
</eg>
            </example>
            <example>
               <head>Using XSLT instructions to create a computed map</head>
               <p>The following example binds a variable to a map acting as an index into a source
                  document:</p>
               <eg role="xslt-declaration" xml:space="preserve">
&lt;xsl:variable name="index" as="map(xs:string, element(employee))"&gt;
  &lt;xsl:map&gt;
    &lt;xsl:for-each select="//employee"&gt;
      &lt;xsl:map-entry key="@empNr" select="."/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:map&gt;
&lt;/xsl:variable&gt;  
</eg>
            </example>
            
            <example diff="add" at="2023-04-04">
               <head>Modifying the keys in a map</head>
               <p>The following example modifies a supplied map <code>$input</code> by changing
                  all the keys to upper case. A dynamic error occurs if this results in duplicate
                  keys:</p>
               <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:map&gt;
  &lt;xsl:for-each select="map:key-value-pairs($map)"&gt;
    &lt;xsl:map-entry key="upper-case(?key)" select="?value"/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:map&gt; 
</eg>
            </example>
            
            <example diff="add" at="2023-04-04">
               <head>Modifying the values in a map</head>
               <p>The following example modifies a supplied map <code>$input</code> by wrapping
                  each of the values in an array:</p>
               <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:map&gt;
  &lt;xsl:for-each select="map:key-value-pairs($map)"&gt;
    &lt;xsl:map-entry key="?key"&gt;
       &lt;xsl:array select="?value"/&gt;
    &lt;/xsl:map-entry>
  &lt;/xsl:for-each&gt;
&lt;/xsl:map&gt; 
</eg>
            </example>
            
            <div3 id="duplicate-keys" diff="add" at="2022-01-01">
               <head>Handling of duplicate keys</head>
               
               <p>This section describes what happens when two or more maps returned by the sequence constructor
               within an <elcode>xsl:map</elcode> instruction contain duplicate keys: that is, when one of these
               maps contains an entry with key <var>K</var>, and another contains an entry with key <var>L</var>,
                  and <code diff="chg" at="2023-01-25">fn:atomic-equal(K, L)</code> returns <code>true</code>.</p>
               
               <p><error spec="XT" class="DE" code="3365" type="dynamic">
                  <p>In the absence of the <code>on-duplicates</code> attribute, 
                     a <termref def="dt-dynamic-error">dynamic error</termref> occurs if the set of
                     keys in the maps resulting from evaluating the sequence constructor
                     <error.extra>within an <elcode>xsl:map</elcode> instruction</error.extra>
                     contains duplicates.</p>
               </error></p>
               
               <p>The result of evaluating the <code>on-duplicates</code> attribute, if present, <rfc2119>must</rfc2119>
               be a function with arity 2. When the <elcode>xsl:map</elcode> instruction encounters two
               map entries having the same key, the two values associated with this key are passed as
               arguments to this function, and the function returns the value that should be associated
               with this key in the final map.</p>
               
               <p>The order of the arguments passed to the function reflects the order of the maps in which
               the duplicate entries appear: if map <var>M</var> and map <var>N</var> contain values <var>V/M</var>
               and <var>V/N</var> for the same key, and <var>M</var> precedes <var>N</var> in the sequence
                  of maps returned by the sequence constructor, then the callback function is called with arguments
                  <var>V/M</var> and <var>V/N</var> in that order.
               </p>
               
               <p>If more than two maps contain values for the same key, then the callback function is invoked repeatedly.
                  Let <var>F</var> be the callback function.
               Then if (for example) four maps supply the values <var>A</var>, <var>B</var>, <var>C</var>, and <var>D</var>
               for a given key <var>K</var>, in that order, the evaluation is as follows:</p>
               <olist>
                  <item><p><code>F(A, B)</code> is called; let its return value be <var>X</var>.</p></item>
                  <item><p><code>F(X, C)</code> is called; let its return value be <var>Y</var>.</p></item>
                  <item><p><code>F(Y, D)</code> is called; let its return value be <var>Z</var>.</p></item>
                  <item><p>The value that is associated with key <var>K</var> in the final map
                  will be <var>Z</var>.</p></item>
               </olist>
               
               <p>Thus, if the values are all singleton items (which is not necessarily the case), and if the sequence
               of values is <var>S</var>, then the final result is <code>fold-left(tail(S), head(S), F)</code>.</p>
               
               <p>For example, the following table shows some useful callback functions that might be supplied,
                  and explains their effect:</p>
               
               <table>
                  <thead>
                     <tr>
                        <th>Function</th>
                        <th>Effect</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td><code>function($a, $b){$a}</code></td>
                        <td>The first of the duplicate values is used.</td>
                     </tr>
                     <tr>
                        <td><code>function($a, $b){$b}</code></td>
                        <td>The last of the duplicate values is used.</td>
                     </tr>
                     <tr>
                        <td><code>function($a, $b){$a, $b}</code></td>
                        <td>The sequence-concatenation of the duplicate values is used. 
                           <phrase diff="add" at="2023-04-04">This could
                        also be expressed as <code>on-duplicates="op(',')"</code>.</phrase></td>
                     </tr>
                     <tr>
                        <td><code>function($a, $b){max(($a, $b))}</code></td>
                        <td>The highest of the duplicate values is used.</td>
                     </tr>
                     <tr>
                        <td><code>function($a, $b){min(($a, $b))}</code></td>
                        <td>The lowest of the duplicate values is used.</td>
                     </tr>
                     <tr>
                        <td><code>function($a, $b){string-join(($a, $b), ', ')}</code></td>
                        <td>The comma-separated string concatenation of the duplicate values is used.</td>
                     </tr>
                     <tr diff="add" at="2023-04-04">
                        <td><code>function($a, $b){$a + $b)}</code></td>
                        <td>The sum of the duplicate values is used.
                           This could also be expressed as <code>on-duplicates="op('+')"</code>
                        </td>
                     </tr>
                     <tr>
                        <td><code>function($a, $b){error()}</code></td>
                        <td>Duplicates are rejected as an error (this is the default in the absence of a
                           callback function).</td>
                     </tr>
                  </tbody>
               </table>
               
               <example id="map-with-duplicates-into-array">
                  <head>Combining Duplicates into an Array</head>
                  <p>This example takes as input an XML document such as:</p>
                  <eg><![CDATA[<data>
   <event id="A23" value="12"/>
   <event id="A24" value="5"/>
   <event id="A25" value="9"/>
   <event id="A23" value="2"/>
 </data>]]></eg>
                  <p>and constructs a map whose JSON representation is:</p>
                  <eg><![CDATA[{"A23": [12, 2], "A24": [5], "A23": [9]}]]></eg>
                  <p>The logic is:</p>
                  <eg><![CDATA[<xsl:template match="data">
   <xsl:map on-duplicates="function($a, $b){array:join(($a, $b))}">
     <xsl:for-each select="event">
        <xsl:map-entry key="@id" select="[xs:integer(@value)]"/>
     </xsl:for-each>
   </xsl:map>
   </xsl:template>]]></eg>
               </example>
               
               
            </div3>
         </div2>

         <div2 id="map-constructors" diff="del" at="2022-01-01">
            <head>Map Constructors</head>
            <p>A Map Constructor is a new kind of expression added to the syntax of XPath.</p>
            <note>
               <p>Map Constructors are defined in XPath 3.1. They are available in XSLT 3.0 whether
                  or not XPath 3.1 is supported. The specification given here is intended to be
                  identical to the specification in XPath 3.1.</p>
            </note>
            <p>The syntax of <xnt spec="XP40" ref="doc-xpath40-PrimaryExpr">PrimaryExpr</xnt> is
               extended to permit <code>MapConstructor</code> as an additional alternative.</p>

            <scrap headstyle="show" id="MapConstructor-scrap">
               <head>MapConstructor</head>
               <prodgroup>
                  <prod num="52" id="NT-PrimaryExpr">
                     <lhs>PrimaryExpr</lhs>
                     <rhs>Literal | VarRef | ParenthesizedExpr | ContextItemExpr | FunctionCall |
                        FunctionItemExpr<br/> | MapConstructor</rhs>
                  </prod>

                  <prod num="202" id="NT-MapConstructor">
                     <lhs>MapConstructor</lhs>
                     <rhs>"map" "{" (MapConstructorEntry ("," MapConstructorEntry )*)? "}" </rhs>
                  </prod>
                  <prod num="203" id="NT-MapConstructorEntry">
                     <lhs>MapConstructorEntry</lhs>
                     <rhs>MapKeyExpr ":" MapValueExpr </rhs>
                  </prod>
                  <prod num="204" id="NT-MapKeyExpr">
                     <lhs>MapKeyExpr</lhs>
                     <rhs><xnt ref="doc-xpath40-ExprSingle" spec="XP40">ExprSingle</xnt></rhs>
                  </prod>
                  <prod num="205" id="NT-MapValueExpr">
                     <lhs>MapValueExpr</lhs>
                     <rhs><xnt ref="doc-xpath40-ExprSingle" spec="XP40">ExprSingle</xnt></rhs>
                  </prod>
               </prodgroup>
            </scrap>



            <note>
               <p>In some circumstances, it is necessary to include whitespace
                  before or after the colon to ensure that this grammar is correctly parsed; this
                  arises for example when the <code>KeyExpr</code> ends with a name and the
                     <code>ValueExpr</code> starts with a name. </p>
            </note>

            <p>The value of the expression is a map whose entries correspond to the key-value pairs
               obtained by evaluating the successive <code>KeyExpr</code> and <code>ValueExpr</code>
               expressions.</p>
            <p>Each <code>KeyExpr</code> expression is evaluated and atomized; a type error <xerrorref spec="XP40" class="TY" code="0004"/> occurs if the result is not a single atomic value. If the key is of
               type <code>xs:untypedAtomic</code> it is converted to <code>xs:string</code>. The
               associated value is the result of evaluating the corresponding
                  <code>ValueExpr</code>. If two or more entries have the <term>same key</term> then 
               a dynamic error occurs <errorref spec="XT" class="DE" code="3365"/>.</p>
            <p>For example, the following expression constructs a map with seven entries:</p>
            <eg role="non-xml" xml:space="preserve">
map {
  "Su" : "Sunday",
  "Mo" : "Monday",
  "Tu" : "Tuesday",
  "We" : "Wednesday",
  "Th" : "Thursday",
  "Fr" : "Friday",
  "Sa" : "Saturday"
}</eg>
            <note>
               <p>Unlike the <function>map:merge</function> function, the number of entries in a map
                  that is constructed using a map expression is known statically.</p>
            </note>

         </div2>
         
         <div2 id="maps-streaming">
            <head>Maps and Streaming</head>

            <p>Maps have many uses, but their introduction to XSLT 3.0 was strongly motivated by
               streaming use cases. In essence, when a source document is processed in streaming
               mode, data that is encountered in the course of processing may need to be retained in
               variables for subsequent use, because the nodes cannot be revisited. This creates a
               need for a flexible data structure to accommodate such temporary data, and maps were
               designed to fulfil this need.</p>
            
            <p>The entries in a map are not allowed to contain references to 
               <termref def="dt-streamed-node">streamed nodes</termref>. This is achieved by ensuring that for all constructs
            that supply content to be included in a map (for example the third argument of <function>map:put</function>, and
               the <code>select</code> attribute of <elcode>xsl:map-entry</elcode>),
            the relevant operand is defined to have operand usage <termref def="dt-navigation"/>. Because maps cannot
               contain references to streamed nodes, they are effectively <termref def="dt-grounded"/>, and can therefore
               be used freely in contexts (such as parameters to functions or templates) where only grounded operands
               are permitted.</p>

            <p>The <elcode>xsl:map</elcode> instruction, and the XPath <code>MapConstructor</code>
               construct, are exceptions to the general rule that during streaming, only one
               downward selection (one consuming subexpression) is permitted. They share this
               characteristic with <elcode>xsl:fork</elcode>. As with <elcode>xsl:fork</elcode>, a
               streaming processor is expected to be able to construct the map during a single pass
               of the streamed input document, which may require multiple expressions to be
               evaluated in parallel.</p>

            <p>In the case of the <elcode>xsl:map</elcode> instruction, this exemption applies only in the
               case where the instruction consists exclusively of <elcode>xsl:map-entry</elcode>
               (and <elcode>xsl:fallback</elcode>) children, and not in more complex cases where the
               map entries are constructed dynamically (for example using a control flow implemented
               using <elcode>xsl:choose</elcode>, <elcode>xsl:for-each</elcode>, or
                  <elcode>xsl:call-template</elcode>). Such cases may, of course, be streamable
               if they only have a single consuming subexpression.</p>

            <p>For example, the following XPath expression is streamable, despite making two
               downward selections:</p>

            <eg role="non-xml" xml:space="preserve">
let $m := map{'price':xs:decimal(price), 'discount':xs:decimal(discount)} 
return ($m?price - $m?discount)</eg>

            <p>Analysis:</p>
            <olist>
               <item>
                  <p>Because the <code>return</code> clause is motionless, the <termref def="dt-sweep"/> of the <code>let</code> expression is the sweep of the map
                     expression (the expression in curly brackets).</p>
               </item>
               <item>
                  <p>The sweep of a map expression is the maximum sweep of its key/value pairs.</p>
               </item>
               <item>
                  <p>For both key/value pairs, the key is <termref def="dt-motionless"/> and the
                     value is <termref def="dt-consuming"/>.</p>
               </item>
               <item>
                  <p>The expression carefully atomizes both values, because
                     retaining references to streamed nodes in a map is not permitted.</p>
               </item>
               <item>
                  <p>Therefore the map expression, and hence the expression as a whole, is <termref def="dt-grounded"/> and <termref def="dt-consuming"/>.</p>
               </item>
            </olist>

            <p>See also: <specref ref="streamability-of-map-constructors"/>, <specref ref="streamability-xsl-map"/>, <specref ref="streamability-xsl-map-entry"/></p>

         </div2>
         <div2 id="map-examples">
            <head>Examples using Maps</head>
            <p>This section gives some examples of where maps can be useful.</p>

            <example id="maps-with-iterate">
               <head>Using Maps with xsl:iterate</head>
               <p>This example uses maps in conjunction with the <elcode>xsl:iterate</elcode>
                  instruction to find the highest-earning employee in each department, in a single
                  streaming pass of an input document containing employee records.</p>
               <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:source-document streamable="yes" href="employees.xml"&gt;
  &lt;xsl:iterate select="*/employee"&gt;
    &lt;xsl:param name="highest-earners" 
               as="map(xs:string, element(employee))" 
               select="map{}"/&gt;
    &lt;xsl:on-completion&gt;
      &lt;xsl:for-each select="map:keys($highest-earners)"&gt;
        &lt;department name="{.}"&gt;
          &lt;xsl:copy-of select="$highest-earners(.)"/&gt;
        &lt;/department&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:on-completion&gt;           
    &lt;xsl:variable name="this" select="copy-of(.)" as="element(employee)"/&gt; 
    &lt;xsl:next-iteration&gt;
      &lt;xsl:with-param name="highest-earners"
          select="let $existing := $highest-earners($this/department)
                  return if ($existing/salary gt $this/salary)
                         then $highest-earners
                         else map:put($highest-earners, $this/department, $this)"/&gt;
    &lt;/xsl:next-iteration&gt;
  &lt;/xsl:iterate&gt;
&lt;/xsl:source-document&gt;
</eg>
            </example>
            <example id="example-complex-numbers">
               <head>Using Maps to Implement Complex Numbers</head>
               <p>A complex number might be represented as a map with two entries, the keys being
                  the <code>xs:boolean</code> value <code>true</code> for the real part, and the
                     <code>xs:boolean</code> value <code>false</code> for the imaginary part. A
                  library for manipulation of complex numbers might include functions such as the
                  following:</p>
               <eg role="xslt-declaration xmlns:i='i'" xml:space="preserve">

&lt;xsl:variable name="REAL" static="yes" as="xs:int" select="0"/&gt; 
&lt;xsl:variable name="IMAG" static="yes" as="xs:int" select="1"/&gt; 
                     
&lt;xsl:function name="i:complex" as="map(xs:int, xs:double)"&gt;
  &lt;xsl:param name="real" as="xs:double"/&gt;
  &lt;xsl:param name="imaginary" as="xs:double"/&gt;
  &lt;xsl:sequence select="map{ $REAL : $real, $IMAG : $imaginary }"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:real" as="xs:double"&gt;
  &lt;xsl:param name="complex" as="map(xs:int, xs:double)"/&gt;
  &lt;xsl:sequence select="$complex($REAL)"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:imaginary" as="xs:double"&gt;
  &lt;xsl:param name="complex" as="map(xs:int, xs:double)"/&gt;
  &lt;xsl:sequence select="$complex($IMAG)"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:add" as="map(xs:int, xs:double)"&gt;
  &lt;xsl:param name="arg1" as="map(xs:int, xs:double)"/&gt;
  &lt;xsl:param name="arg2" as="map(xs:int, xs:double)"/&gt;
  &lt;xsl:sequence select="i:complex(i:real($arg1)+i:real($arg2), 
                                  i:imaginary($arg1)+i:imaginary($arg2)"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:multiply" as="map(xs:boolean, xs:double)"&gt;
  &lt;xsl:param name="arg1" as="map(xs:boolean, xs:double)"/&gt;
  &lt;xsl:param name="arg2" as="map(xs:boolean, xs:double)"/&gt;
  &lt;xsl:sequence select="i:complex(
      i:real($arg1)*i:real($arg2) - i:imaginary($arg1)*i:imaginary($arg2),
      i:real($arg1)*i:imaginary($arg2) + i:imaginary($arg1)*i:real($arg2))"/&gt;
&lt;/xsl:function&gt;
</eg>
            </example>
            <example id="map-as-index">
               <head>Using a Map as an Index</head>
               <p>Given a set of <code>book</code> elements, it is possible to construct an index in
                  the form of a map allowing the books to be retrieved by ISBN number.</p>
               <p>Assume the book elements have the form:</p>
               <eg role="xml" xml:space="preserve">
&lt;book&gt;
  &lt;isbn&gt;0470192747&lt;/isbn&gt;
  &lt;author&gt;Michael H. Kay&lt;/author&gt;
  &lt;publisher&gt;Wiley&lt;/publisher&gt;
  &lt;title&gt;XSLT 2.0 and XPath 2.0 Programmer's Reference&lt;/title&gt;
&lt;/book&gt;</eg>
               <p>An index may be constructed as follows: </p>
               <eg role="xslt-declaration xmlns:map='http://www.w3.org/2005/xpath-functions/map" xml:space="preserve">
&lt;xsl:variable name="isbn-index" as="map(xs:string, element(book))"
    select="map:merge(for $b in //book return map{$b/isbn : $b})"/&gt;</eg>
               <p>This index may then be used to retrieve the book for a given ISBN using either of
                  the expressions <code>map:get($isbn-index, "0470192747")</code> or
                     <code>$isbn-index("0470192747")</code>.</p>
               <p>In this simple form, this replicates the functionality available using
                     <elcode>xsl:key</elcode> and the <function>key</function> function. However, it
                  also provides capabilities not directly available using the
                     <function>key</function> function: for example, the index can include
                     <code>book</code> elements in multiple source documents. It also allows
                  processing of all the books using a construct such as <code>&lt;xsl:for-each
                     select="map:keys($isbn-index)"&gt;</code></p>
            </example>
            <example id="map-as-class">
               <head>A Map containing Named Functions</head>
               <p>As in JavaScript, a map whose keys are strings and whose associated values are
                  function items can be used in a similar way to a class in object-oriented
                  programming languages.</p>
               <p>Suppose an application needs to handle customer order information that may arrive
                  in three different formats, with different hierarchic arrangements:</p>
               <olist>

                  <item>
                     <p>Flat structure:</p>
                     <eg role="xml" xml:space="preserve">
&lt;customer id="c123"&gt;...&lt;/customer&gt;
&lt;product id="p789"&gt;...&lt;/product&gt;
&lt;order customer="c123" product="p789"&gt;...&lt;/order&gt;</eg>
                  </item>
                  <item>
                     <p>Orders within customer elements:</p>
                     <eg role="xml" xml:space="preserve">
&lt;customer id="c123"&gt;
   &lt;order product="p789"&gt;...&lt;/order&gt;
&lt;/customer&gt;
&lt;product id="p789"&gt;...&lt;/product&gt;</eg>
                  </item>
                  <item>
                     <p>Orders within product elements:</p>
                     <eg role="xml" xml:space="preserve">
&lt;customer id="c123"&gt;...&lt;/customer&gt;
&lt;product id="p789"&gt;
  &lt;order customer="c123"&gt;...&lt;/order&gt;
&lt;/product&gt;</eg>
                  </item>
               </olist>

               <p>An application can isolate itself from these differences by defining a set of
                  functions to navigate the relationships between customers, orders, and products:
                     <code>orders-for-customer</code>, <code>orders-for-product</code>,
                     <code>customer-for-order</code>, <code>product-for-order</code>. These
                  functions can be implemented in different ways for the three different input
                  formats. For example, with the first format the implementation might be:</p>
               <eg role="xslt-declaration" xml:space="preserve">
&lt;xsl:variable name="flat-input-functions" as="map(xs:string, function(*))*"
  select="map{
            'orders-for-customer' : 
                 function($c as element(customer)) as element(order)* 
                    {$c/../order[@customer=$c/@id]},
            'orders-for-product' : 
                 function($p as element(product)) as element(order)* 
                    {$p/../order[@product=$p/@id]},
            'customer-for-order' : 
                 function($o as element(order)) as element(customer) 
                    {$o/../customer[@id=$o/@customer]},
            'product-for-order' : 
                 function($o as element(order)) as element(product) 
                    {$o/../product[@id=$o/@product]} }                    
         "/&gt;</eg>
               <p>Having established which input format is in use, the application can bind the
                  appropriate implementation of these functions to a variable such as
                     <code>$input-navigator</code>, and can then process the input using XPath
                  expressions such as the following, which selects all products for which there is
                  no order: <code>//product[empty($input-navigator("orders-for-product")(.))]</code>
               </p>

            </example>
         </div2>
      </div1>
      
      <div1 id="arrays" diff="add" at="2022-01-01">
         <head>Arrays</head>
         
         <p>Arrays are defined in the XDM Data Model.</p>
         <div2 id="array-construction">
            <head>Array Construction</head>
            <p>The instruction <elcode>xsl:array</elcode> constructs and returns a new array.</p>
            <?element xsl:array?>
            <p diff="chg" at="2023-03-22">If the <code>use</code> attribute is omitted, the resulting
            array has one singleton member for each item returned by the <code>select</code> attribute or
            sequence constructor. For example <code>&lt;xsl:array select="1 to 5"/></code> returns
            an array with five members: <code>[1, 2, 3, 4, 5]</code>.</p>
            <p diff="chg" at="2023-03-22">If the <code>use</code> attribute is present then it is evaluated
               once for each item in the sequence returned by the <code>select</code> attribute or
               sequence constructor, with a <termref def="dt-singleton-focus"/> based on that item,
               to produce the value of the corresponding array member.</p>
            <p diff="chg" at="2023-03-22">For example, <code>&lt;xsl:array select="'red', 'green', 'blue'" use="characters(.)"/></code>
               returns an array with three members: <code>[("r", "e", "d"), ("g", "r", "e", "e", "n"), ("b", "l", "u", "e")] </code>.</p>
            <p diff="chg" at="2023-03-22">A useful convention is to construct each array member as a <term>value record</term>
               (a singleton map whose single entry has the key <code>"value"</code>): 
               <code>&lt;xsl:array select="map:entry('value', 1 to 3), map:entry('value': 8 to 10)" use="?value"/></code>
            returns an array with two members: <code>[(1,2,3), (8,9,10)]</code>. This is essentially equivalent to
            the effect of the <function>array:of-members</function> function.</p>
            <p>The <code>select</code> attribute and the contained sequence constructor are mutually
            exclusive: if the <code>select</code> attribute is present, then the only permitted child
            element is <elcode>xsl:fallback</elcode>.</p>
            <p diff="del" at="2023-03-22">For convenience and readability, the instruction <code>xsl:array-member</code>
            can be used to construct a zero-arity function suitable for use with <elcode>xsl:array</elcode>.</p>
            
            
            
            <example>
               <head>Constructing an array whose members are single items</head>
               <p>The following example constructs an array by tokenizing a string:</p>
               <eg><![CDATA[<xsl:array select="tokenize('The cat sat on the mat')"/>]]></eg>
               <p>The result is the array <code>["The", "cat", "sat", "on", "the", "mat"]</code>.</p>
               <p>The following example constructs an array containing items computed using nested instructions:</p>
               <eg><![CDATA[<xsl:array>
   <xsl:for-each-group select="0 to 19" group-adjacent=". idiv 4">
     <xsl:sequence select="string-join(current-group(), '-')"/>
   </xsl:for-each-group>
</xsl:array>]]></eg>
               <p>The result is the array <code>["0-1-2-3", "4-5-6-7", "8-9-10-11", "12-13-14-15", "16-17-18-19"]</code>.</p>
            </example>
            
            <example>
               <head>Constructing an array whose members are arbitrary sequences</head>
               <p>The following example constructs an array whose members are sequences:</p>
               <eg><![CDATA[<xsl:array use="?value">
   <xsl:for-each-group select="0 to 19" group-adjacent=". idiv 4">
     <xsl:map-entry key="'value'" select="current-group()"/>
   </xsl:for-each-group>
</xsl:array>]]></eg>
               <p>The result is the array <code>[(0,1,2,3), (4,5,6,7), (8,9,10,11), (12,13,14,15), (16,17,18,19)]</code>.</p>
               <p>The technique used here is to capture each member sequence in a singleton map (known as a <term>value record</term>)
               with the conventional key <code>"value"</code>.</p> 
               <p>The following example delivers the same result in a different way:</p>
               <eg><![CDATA[<xsl:array use=".()">
   <xsl:for-each-group select="0 to 19" group-adjacent=". idiv 4">
     <xsl:sequence select="current-group#0"/>
   </xsl:for-each-group>
</xsl:array>]]></eg>
               <p>In this approach, the member sequence is captured in the value of the zero-arity function
                  <code>current-group#0</code>, which is then applied using the expression <code>.()</code> 
                  to yield the actual value.
               </p>
               <note><p>TODO: this example only works if we fix issue #407. Without that fix, calling <code>current-group#0</code> 
                  raises XTDE1061.</p></note>
               <p>A third approach would be to capture the member sequences as arrays:</p>
               <eg><![CDATA[<xsl:array use="?*">
   <xsl:for-each-group select="0 to 19" group-adjacent=". idiv 4">
     <xsl:array select="current-group()"/>
   </xsl:for-each-group>
</xsl:array>]]></eg>               
            </example>
            <example>
               <head>Constructing an array based on an existing array</head>
               <p>The <elcode>xsl:array</elcode> instruction can be used in conjunction with
               the <xfunction>array:members</xfunction> function to construct an array from the members
               of an existing array. For example, the following code combines two arrays and sorts the result:</p>
               <eg><![CDATA[<xsl:array use="?value">
   <xsl:perform-sort select="array:members($input-1), array:members($input-2)">
      <xsl:sort select="count(?value)"/>
   </xsl:perform-sort>
</xsl:array>]]></eg>
               <p>The following code inverts a nested array (such as <code>[[1,2,3], [4,5,6], [7,8,9]]</code>)
               so the result is organized by columns rather than rows (<code>[[1,4,7], [2,5,8], [3,6,9]]</code>):</p>
               <eg><![CDATA[<xsl:array>
   <xsl:for-each select="1 to array:size($input?1)">
      <xsl:variable name="index" select="."/>
      <xsl:array select="array:members($input)?value?($index)"/>
   </xsl:for-each>
</xsl:array>]]></eg>
            </example>
            
            
            
         </div2>
         
         <!--<div2 id="array-iteration">
            <head>Iterating over the Members of an Array</head>
            <p>The instruction <elcode>for-each-member</elcode> is available to iterate over the members of an
            array.</p>
            <?element xsl:for-each-member?>
         
            <p>The <code>select</code> attribute is <rfc2119>required</rfc2119>, and its value <rfc2119>must</rfc2119>
            be a single array item. The contained sequence constructor is evaluated once for each member in the array.</p>
            <p>If the <code>composite</code> attribute is absent or has the value <code>no</code>, then each member of the array
               must be a single item. In this case the sequence constructor is evaluated (once for each member) with 
               the context item being the single item comprising the array member, the context position being the
               position of the member within the array, and the context size being the number of members in the array.</p>
            
            <p>It is a <termref def="dt-type-error"/> [TBA] if the <elcode>xsl:for-each-member</elcode> instruction is evaluated
            for an array that has a member which is not a singleton item.</p>
            
            <p>If the <code>composite</code> attribute is present with the value <code>yes</code>, then the sequence
               constructor is evaluated (once for each member) with the context item being an anonymous zero-arity 
               function that wraps the actual
               value of the array member. The context position is again the
               position of the member within the array, and the context size is the number of members in the array.</p>
            
            <example>
               <head>Processing an array of singleton items</head>
               <p>Given an array <code>$in</code> containing <code>[1, 5, 6, 10]</code> the following example might output the sequence
               <code>('i', 'v', 'vi', 'x')</code>:</p>
               <eg><![CDATA[
<xsl:for-each-member select="$in">
  <xsl:sequence select="format-integer(., 'i')"/>
</xsl:for-each-member>  
]]></eg>
               <p>To obtain the output as an array, <code>('i', 'v', 'vi', 'x')</code>, the iteration can be combined with
               array construction:</p>
               <eg><![CDATA[
<xsl:array>
  <xsl:for-each-member select="$in">
    <xsl:array-item select="format-integer(., 'i')"/>
  </xsl:for-each-member>
</xsl:array>  
]]></eg>
               
            </example>
            <example>
               <head>Processing an array of sequence-valued items</head>
               <p>Given an array <code>$in</code> containing <code>[(1,2), (), (3,4,5)]</code>, the following example
               outputs the sum of the integers in each member, that is, <code>(3, 0, 12)</code>.</p>
               <eg><![CDATA[
<xsl:for-each-member select="$in" composite="yes">
  <xsl:sequence select="sum(.())"/>
</xsl:for-each-member>  
]]></eg>
               <p>The sequence constructor is evaluated three times, with the context item being set successively
               to a function that delivers <code>(1,2)</code>, a function that delivers the empty sequence 
                  <code>()</code>, and finally a function that delivers the sequence <code>(3,4,5)</code>.</p>
               <p>Because <elcode>xsl:for-each-member</elcode> represents array members in the same way that
               <elcode>xsl:array</elcode> expects them, array iteration and array construction can conveniently
               be combined. The following example copies selected items of an array into a new array:</p>
               <eg><![CDATA[
<xsl:variable name="items-to-copy" select="1, 5, 8"/>
<xsl:array>
  <xsl:for-each-member select="$in" composite="yes">
    <xsl:if test="position() = $items-to-copy" then="."/>
  </xsl:for-each-member>
</xsl:array>  
]]></eg>
            </example>
            
 
         </div2>-->
         
      </div1>

      <div1 id="json">
         <head>Processing JSON Data</head>
         <p>JSON is a popular format for exchange of structured data on the web: it is specified in
               <bibref ref="rfc7159"/>. This section
            describes facilities allowing JSON data to be processed using XSLT.</p>

         <note>
            <p>RFC7159 is taken as the definitive specification of JSON for the purposes of this
               document. The RFC explains its relationship with other JSON specifications such as
                  <bibref ref="ECMA-404"/>.</p>
         </note>

         <note>
            <p>XPath 3.1 incorporates the functions defined in this
               section. It also provides additional JSON capability, in the form of functions
                  <code>parse-json</code>, <code>json-doc</code>, and extensions to the
                  <xfunction>serialize</xfunction> function. These facilities are incorporated in XSLT
               3.0 only if the XPath 3.1 feature is supported. They depend on support for
               arrays.</p>
         </note>

         <div2 id="json-to-xml-mapping" diff="del" at="2022-01-01">
            <head>XML Representation of JSON</head>


            <p>This specification defines a mapping from JSON data to XML (specifically, to XDM
               instances). A function <function>json-to-xml</function> is provided to take a JSON
               string as input and convert it to the XML representation. Two stylesheet modules are
               provided to perform the reverse transformation: one produces JSON in compact linear
               form, the other in indented form suitable for display, editing, or printing.</p>

            <p>The XML representation is designed to be capable of representing any valid JSON text
               other than one that uses characters which are not valid in XML. The transformation is
               lossless: that is, distinct JSON texts convert to distinct XML representations. When
               converting JSON to XML, options are provided to reject unsupported characters, to
               replace them with a substitute character, or to leave them in backslash-escaped
               form.</p>

            <p>The following example demonstrates the correspondence of a JSON text and the
               corresponding XML representation. </p>

            <example>
               <head>A JSON Text and its XML Representation</head>
               <p>Consider the following JSON text:</p>
               <eg role="json" xml:space="preserve">
{
  "desc"    : "Distances between several cities, in kilometers.",
  "updated" : "2014-02-04T18:50:45",
  "uptodate": true,
  "author"  : null,
  "cities"  : {
    "Brussels": [
      {"to": "London",    "distance": 322},
      {"to": "Paris",     "distance": 265},
      {"to": "Amsterdam", "distance": 173}
    ],
    "London": [
      {"to": "Brussels",  "distance": 322},
      {"to": "Paris",     "distance": 344},
      {"to": "Amsterdam", "distance": 358}
    ],
    "Paris": [
      {"to": "Brussels",  "distance": 265},
      {"to": "London",    "distance": 344},
      {"to": "Amsterdam", "distance": 431}
    ],
    "Amsterdam": [
      {"to": "Brussels",  "distance": 173},
      {"to": "London",    "distance": 358},
      {"to": "Paris",     "distance": 431}
    ]
  }
}
               </eg>
               <p>The XML representation of this text is as follows. Whitespace is included in the
                  XML representation for purposes of illustration, and is ignored by the stylesheets
                  that convert XML to JSON, but it will not be present in the output of the
                     <function>json-to-xml</function> function.</p>
               <eg role="xml" xml:space="preserve">
  &lt;map xmlns="http://www.w3.org/2005/xpath-functions"&gt;
    &lt;string key='desc'&gt;Distances between several cities, in kilometers.&lt;/string&gt;
    &lt;string key='updated'&gt;2014-02-04T18:50:45&lt;/string&gt;
    &lt;boolean key="uptodate"&gt;true&lt;/boolean&gt;
    &lt;null key="author"/&gt;
    &lt;map key='cities'&gt;
      &lt;array key="Brussels"&gt;
        &lt;map&gt;
            &lt;string key="to"&gt;London&lt;/string&gt;
            &lt;number key="distance"&gt;322&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;Paris&lt;/string&gt;
            &lt;number key="distance"&gt;265&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;Amsterdam&lt;/string&gt;
            &lt;number key="distance"&gt;173&lt;/number&gt;
        &lt;/map&gt; 
      &lt;/array&gt;
      &lt;array key="London"&gt;
        &lt;map&gt;
            &lt;string key="to"&gt;Brussels&lt;/string&gt;
            &lt;number key="distance"&gt;322&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;Paris&lt;/string&gt;
            &lt;number key="distance"&gt;344&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;Amsterdam&lt;/string&gt;
            &lt;number key="distance"&gt;358&lt;/number&gt;
        &lt;/map&gt; 
      &lt;/array&gt;
      &lt;array key="Paris"&gt;
        &lt;map&gt;
            &lt;string key="to"&gt;Brussels&lt;/string&gt;
            &lt;number key="distance"&gt;265&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;London&lt;/string&gt;
            &lt;number key="distance"&gt;344&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;Amsterdam&lt;/string&gt;
            &lt;number key="distance"&gt;431&lt;/number&gt;
        &lt;/map&gt;  
      &lt;/array&gt;
      &lt;array key="Amsterdam"&gt;
        &lt;map&gt;
            &lt;string key="to"&gt;Brussels&lt;/string&gt;
            &lt;number key="distance"&gt;173&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;London&lt;/string&gt;
            &lt;number key="distance"&gt;358&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;Paris&lt;/string&gt;
            &lt;number key="distance"&gt;431&lt;/number&gt;
        &lt;/map&gt;
      &lt;/array&gt;
    &lt;/map&gt;  
  &lt;/map&gt;</eg>
            </example>

            <p>An XSD 1.0 schema for the XML representation is provided in <specref ref="schema-for-json"/>. It is not necessary to import this schema (using
                  <elcode>xsl:import-schema</elcode>) unless the stylesheet makes explicit reference
               to the components defined in the schema. If the stylesheet does import a schema for
               the namespace <code>http://www.w3.org/2005/xpath-functions</code>, then:</p>

            <olist>
               <item>
                  <p>The processor (if it is schema-aware) <rfc2119>must</rfc2119> recognize an
                        <elcode>xsl:import-schema</elcode> declaration for this namespace, whether
                     or not the <code>schema-location</code> is supplied.</p>
               </item>
               <item>
                  <p>If a <code>schema-location</code> is provided, then the schema document at that
                     location <rfc2119>must</rfc2119> be equivalent to the schema document at
                        <specref ref="schema-for-json"/>; the effect if it is not is <termref def="dt-implementation-dependent"/></p>
               </item>
            </olist>

            <p>The rules governing the mapping from JSON to XML are as follows. In these rules, the
               phrase “an element named N” is to be interpreted as meaning “an element node whose
               local name is N and whose namespace URI is
               <code>http://www.w3.org/2005/xpath-functions</code>”.</p>

            <olist>
               <item>
                  <p>The JSON value <code>null</code> is represented by an element named
                        <code>null</code>, with empty content.</p>
               </item>
               <item>
                  <p>The JSON values <code>true</code> and <code>false</code> are represented by an
                     element named <code>boolean</code>, with content conforming to the type
                        <code>xs:boolean</code>.</p>
               </item>
               <item>
                  <p>A JSON number is represented by an element named <code>number</code>, with
                     content conforming to the type <code>xs:double</code>, with the additional
                     restriction that the value must not be positive or negative infinity, nor
                        <code>NaN</code>.</p>
               </item>
               <item>
                  <p>A JSON string is represented by an element named <code>string</code>, with
                     content conforming to the type <code>xs:string</code>.</p>
               </item>
               <item>
                  <p>A JSON array is represented by an element named <code>array</code>. The content
                     is a sequence of child elements representing the members of the array in order,
                     each such element being the representation of the array member obtained by
                     applying these rules recursively.</p>
               </item>
               <item>
                  <p>A JSON object is represented by an element named <code>map</code>. The content
                     is a sequence of child elements each of which represents one of the name/value
                     pairs in the object. The representation of the name/value pair <var>N:V</var>
                     is obtained by taking the element that represents the value <var>V</var> (by
                     applying these rules recursively) and adding an attribute with name
                        <code>key</code> (in no namespace), whose value is <var>N</var> as an
                     instance of <code>xs:string</code>.</p>
               </item>

            </olist>

            <p>The attribute <code>escaped="true"</code> may be specified on a <code>string</code>
               element to indicate that the string value contains backslash-escaped characters that
               are to be interpreted according to the JSON rules. The attribute
                  <code>escaped-key="true"</code> may be specified on any element with a
                  <code>key</code> attribute to indicate that the key contains backslash-escaped
               characters that are to be interpreted according to the JSON rules. Both attributes
               have the default value <code>false</code>.</p>

            <p>The JSON grammar for <code>number</code> is a subset of
               the lexical space of the XSD type <code>xs:double</code>. The mapping from JSON
                  <code>number</code> values to <code>xs:double</code> values is defined by the
               XPath rules for casting from <code>xs:string</code> to <code>xs:double</code>. Note
               that these rules will never generate an error for out-of-range values; instead very
               large or very small values will be converted to <code>+INF</code> or
                  <code>-INF</code>. Since JSON does not impose limits on the range or precision of
               numbers, the conversion is not guaranteed to be lossless.</p>

            <p>Although the order of entries in a JSON object is generally considered to have no
               significance, the function <code>json-to-xml</code> and the stylesheets that perform
               the reverse transformation both retain order.</p>

            <p>The XDM representation of a JSON value may either be untyped (all elements annotated
               as <code>xs:untyped</code>, attributes as <code>xs:untypedAtomic</code>), or it may
               be typed. If it is typed, then it <rfc2119>must</rfc2119> have the type annotations
               obtained by validating the untyped representation against the schema given in
                  <specref ref="schema-for-json"/>. If it is untyped, then it
                  <rfc2119>must</rfc2119> be an XDM instance such that validation against this
               schema would succeed.</p>
         </div2>
         
         <div2 id="options"  diff="del" at="2022-01-01">
            <head>Option Parameter Conventions</head>
            <p><emph>This section describes conventions which in principle can be adopted by the specification
            of any function. At the time of writing, the function which invoke these conventions are 
               <function>xml-to-json</function> and <function>json-to-xml</function>.</emph></p>
            <p>As a matter of convention, a number of functions defined in this document take
               a parameter whose value is a map, defining options controlling the detail of how
               the function is evaluated. Maps are a new data type introduced in XSLT 3.0.</p>
            <p>For example, the function <code>fn:xml-to-json</code> has an options parameter
               allowing specification of whether the output is to be indented. A call might be written:</p>
            <eg role="xpath" xml:space="preserve">xml-to-json($input, map{'indent':true()})</eg>
            <p><termdef id="option-parameter-conventions" term="option parameter conventions">Functions
               that take an options parameter adopt common conventions on how the
               options are used. These are referred to as the <term>option parameter conventions</term>. These
               rules apply only to functions that explicitly refer to them.</termdef></p>
            <p>Where a function adopts the <termref def="option-parameter-conventions"/>, the following rules
               apply:</p>
            <olist>
               <item><p>The value of the relevant argument must be a map. The entries in the map are
                  referred to as options: the key of the entry is called the option name, and the
                  associated value is the option value. Option names defined in this specification
                  are always strings (single <code>xs:string</code> values). Option values may
                  be of any type.</p></item>
               <item><p>The type of the options parameter in the function signature is always
                  given as <code>map(*)</code>.</p></item>
               <item><p>Although option names are described above as strings, the actual key may be
                  any value that compares equal to the required string (using the <code>eq</code> operator
                  with Unicode codepoint collation). For example, instances of <code>xs:untypedAtomic</code>
                  or <code>xs:anyURI</code> are equally acceptable.</p>
                  <note><p>This means that the implementation of the function can check for the
                     presence and value of particular options using the functions <code>map:contains</code>
                     and/or <code>map:get</code>.</p></note></item>
               <item><p>It is not an error if the options map contains options with names other than those
                  described in this specification. Implementations <rfc2119>may</rfc2119> attach an 
                  <termref def="dt-implementation-defined">implementation-defined</termref> meaning to such entries,
                  and <rfc2119>may</rfc2119> define errors that arise if such entries are present with invalid values.
                  Implementations <rfc2119>must</rfc2119> ignore such entries unless they have a specific 
                  <termref def="dt-implementation-defined">implementation-defined</termref> meaning.
                  Implementations that define additional options in this way <rfc2119>should</rfc2119>
                  use values of type <code>xs:QName</code> as the option names, using an appropriate namespace.</p></item>
               <item><p>All entries in the options map are optional, and supplying an empty map has the same
                  effect as omitting the relevant argument in the function call, assuming this is permitted.</p></item>
               <item><p>For each named option, the function
                  specification defines a required type for the option value. The value that is actually
                  supplied in the map is converted to this required type using the 
                  <termref def="dt-coercion-rules"/>. 
                  A type error <xerrorref spec="XP40" class="TY" code="0004" type="type"/> occurs
                     if conversion of the supplied value to the required type is not possible, or if this conversion
                     delivers a coerced function whose invocation fails with a type error.
                  A dynamic error occurs if the supplied value 
                  after conversion is not one of the permitted values for the option in question: the error codes
                  for this error are defined in the specification of each function.</p>
                  <note><p>It is the responsibility of each function implementation to invoke this conversion; it
                     does not happen automatically as a consequence of the function calling rules.</p></note></item>
               <item><p>In cases where an option is list-valued, by convention the value may be supplied
                  either as a sequence or as an array. Accepting a sequence is convenient if the
                  value is generated programmatically using an XPath expression; while accepting an array 
                  allows the options to be held in an external file in JSON format, to be read using
                  a call on the <code>fn:json-doc</code> function.</p></item>
               <item><p>In cases where the value of an option is itself a map, the specification
                  of the particular function must indicate whether or not these rules apply recursively 
                  to the contents of that map.</p></item>
            </olist>
         </div2>


         <div2 id="xml-to-json-transformation">
            <head>Transforming XML to JSON</head>
            <p>Given an XML structure that does not use the XML representation of JSON defined in
                  <specref ref="json-to-xml-mapping"/>, there are two practical ways to convert it
               to JSON: either perform a transformation to the XML representation of JSON and then
               call the <function>xml-to-json</function> function; or transform it to JSON directly
               by using custom template rules.</p>

            <p>To assist with the second approach, a stylesheet is provided in <specref ref="xml-to-json-stylesheet"/>. This stylesheet includes a function
                  <code>j:xml-to-json</code> which, apart from being in a different namespace, is
               functionally very similar to the <function>xml-to-json</function> function described in
               the previous section. (It differs in doing less validation
                  of the input than the function specification requires, and in the details of how
                  special characters are escaped.)
               The implementation of the function is exposed, using template
               rules to perform a recursive descent of the supplied input, and the behavior of the
               function can therefore be customized (typically by importing the stylesheet and
               adding additional template rules) to handle arbitrary XML input.</p>

            <p>The stylesheet is provided under the W3C software license for the convenience of
               users. There is no requirement for any conformant XSLT processor to make this
               stylesheet available. Processors <rfc2119>may</rfc2119> implement the
               <function>xml-to-json</function> function by invoking this stylesheet (adapted
               to achieve full conformance), but there is no requirement to do so.</p>
         </div2>
      </div1>

     

      <div1 id="diagnostics">
         <head>Diagnostics</head>

         <div2 id="message">
            <head>Messages</head>
            <?element xsl:message?>
            <p>The <elcode>xsl:message</elcode> instruction sends a message in an <termref def="dt-implementation-defined">implementation-defined</termref> way. The
                  <elcode>xsl:message</elcode> instruction causes the creation of a new document,
               which is typically serialized and output to an <termref def="dt-implementation-defined">implementation-defined</termref> destination. The
               result of the <elcode>xsl:message</elcode> instruction is an empty sequence.</p>
            <p>The content of the message may be specified by using either or both of the optional
                  <code>select</code> attribute and the <termref def="dt-sequence-constructor">sequence constructor</termref> that forms the content of the
                  <elcode>xsl:message</elcode> instruction.</p>
            <p>If the <elcode>xsl:message</elcode> instruction contains a <termref def="dt-sequence-constructor">sequence constructor</termref>, then the sequence
               obtained by evaluating this sequence constructor is used to construct the content of
               the new document node, as described in <specref ref="constructing-complex-content"/>.</p>
            <p>If the <elcode>xsl:message</elcode> instruction has a <code>select</code> attribute,
               then the value of the attribute <rfc2119>must</rfc2119> be an XPath expression. The
               effect of the <elcode>xsl:message</elcode> instruction is then the same as if a
               single <elcode>xsl:copy-of</elcode> instruction with this <code>select</code>
               attribute were added to the start of the <termref def="dt-sequence-constructor">sequence constructor</termref>.</p>
            <p>If the <elcode>xsl:message</elcode> instruction has no content and no
                  <code>select</code> attribute, then an empty message is produced.</p>
            <imp-def-feature id="idf-err-messageformat">The destination and formatting of messages
               written using the <elcode>xsl:message</elcode> instruction are <termref def="dt-implementation-defined"/>.</imp-def-feature>
            <p>The tree produced by the <elcode>xsl:message</elcode> instruction is not technically
               a <termref def="dt-final-result-tree">final result tree</termref>. The tree has no
               URI and processors are not <rfc2119>required</rfc2119> to make the tree accessible to
               applications.</p>
            <note>
               <p>In many cases, the XML document produced using <elcode>xsl:message</elcode> will
                  consist of a document node owning a single text node. However, it may contain a
                  more complex structure.</p>
            </note>
            <note>
               <p>An implementation might implement <elcode>xsl:message</elcode> by popping up an
                  alert box or by writing to a log file. Because the order of execution of
                  instructions is implementation-defined, the order in which such messages appear is
                  not predictable.</p>
            </note>
            <p>The <code>terminate</code> attribute is interpreted as an <termref def="dt-attribute-value-template">attribute value template</termref>.</p>
            <p>If the <termref def="dt-effective-value"/> of the
                  <code>terminate</code> attribute is <code>yes</code>, then the <termref def="dt-processor">processor</termref>
               <rfc2119>must</rfc2119>
               signal a <termref def="dt-dynamic-error"> dynamic error</termref> after
               sending the message. This error may be caught in the same
                  way as any other dynamic error using <elcode>xsl:catch</elcode>. The
               default value is <code>no</code>. Note that because the order of evaluation of
               instructions is <termref def="dt-implementation-dependent">implementation-dependent</termref>, this gives no guarantee that any particular
               instruction will or will not be evaluated before processing terminates.</p>
            <p>The optional <code>error-code</code> attribute 
               (also interpreted as an <termref def="dt-attribute-value-template"/>)
               may be used to indicate the error code
               associated with the message. This may be used irrespective of the value of
                  <code>terminate</code>. The 
               <termref def="dt-effective-value"/> of the 
               error code attribute is expected to be an <termref def="dt-eqname">EQName</termref>. If no error code is specified, or if
               the <termref def="dt-effective-value"/> is not a valid EQName, the error code will have local part
                  <code>XTMM9000</code> and namespace URI
                  <code>http://www.w3.org/2005/xqt-errors</code>. User-defined error codes
                  <rfc2119>should</rfc2119> be in a namespace other than
                  <code>http://www.w3.org/2005/xqt-errors</code>. When the value of
                  <code>terminate</code> is <code>yes</code>, the error code may be matched in an
                  <elcode>xsl:catch</elcode> element to catch the error and cause processing to
               continue normally.</p>
            <p>
               <error spec="XT" type="dynamic" class="MM" code="9000">
                  <p>When a transformation is terminated by use of <code>&lt;xsl:message
                        terminate="yes"/&gt;</code>, the effect is the same as when a <termref def="dt-dynamic-error">
                        dynamic error</termref> occurs during the transformation. The default error code is <code>XTMM9000</code>; this may be
                        overridden using the <code>error-code</code> attribute of the
                           <elcode>xsl:message</elcode> instruction.</p>
               </error>
            </p>
            <example>
               <head>Localizing Messages</head>
               <p>One convenient way to do localization is to put the localized information (message
                  text, etc.) in an XML document, which becomes an additional input file to the
                     <termref def="dt-stylesheet">stylesheet</termref>. For example, suppose
                  messages for a language <code>
                     <var>L</var>
                  </code> are stored in an XML file <code>resources/<var>L</var>.xml</code> in the
                  form:</p>
               <eg role="xml" xml:space="preserve">&lt;messages&gt;
  &lt;message name="problem"&gt;A problem was detected.&lt;/message&gt;
  &lt;message name="error"&gt;An error was detected.&lt;/message&gt;
&lt;/messages&gt;
</eg>
               <p>Then a stylesheet could use the following approach to localize messages:</p>
               <eg role="xslt-declarations" xml:space="preserve">&lt;xsl:param name="lang" select="'en'"/&gt;
&lt;xsl:variable name="messages"
  select="document(concat('resources/', $lang, '.xml'))/messages"/&gt;

&lt;xsl:template name="localized-message"&gt;
  &lt;xsl:param name="name"/&gt;
  &lt;xsl:message select="string($messages/message[@name=$name])"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template name="problem"&gt;
  &lt;xsl:call-template name="localized-message"&gt;
    &lt;xsl:with-param name="name"&gt;problem&lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <!--Text inserted by erratum E20 change 1" Amended because we no longer have recoverable errors-->
            <p>Any <termref def="dt-dynamic-error">dynamic error</termref> that occurs while
               evaluating the <code>select</code> expression or the contained <termref def="dt-sequence-constructor">sequence constructor</termref>, and any <termref def="dt-serialization-error">serialization error</termref> that occurs while
               processing the result, does not cause the transformation to
                  fail; at worst, it means that no message is output, or that the only message that
                  is output is one that relates to the error that occurred.</p>
            <note>
               <p>An example of such an error is the serialization error that occurs when processing
                  the instruction <code>&lt;xsl:message select="@code"/&gt;</code> (on the grounds
                  that free-standing attributes cannot be serialized). Making such errors
                  recoverable means that it is implementation-defined whether or not they are
                  signaled to the user and whether they cause termination of the transformation. If
                  the processor chooses to recover from the error, the content of any resulting
                  message is implementation-dependent.</p>
               <p>One possible recovery action is to include a description of the error in the
                  generated message text.</p>
            </note>
            <!--End of text inserted by erratum E20-->
         </div2>
         <div2 id="assertions">
            <head>Assertions</head>

            <p>The <elcode>xsl:assert</elcode> instruction is used to assert that the value of a
               particular expression is <code>true</code>; if the value of the expression is <code>false</code>, and
               assertions are enabled, then a dynamic error occurs.</p>

            <?element xsl:assert?>

            <p>By default, assertions are disabled.</p>

            <p>An implementation <rfc2119>must</rfc2119> provide an external mechanism to enable or
               disable assertion checking. This may work either statically or dynamically, and may
               be at the level of the stylesheet as a whole, or at the level of an individual
               package, or otherwise. The detail of such mechanisms is <termref def="dt-implementation-defined"/>.</p>

            <!--<olist>          
            <item><p>As with any other instruction, assertions may be disabled by use of the <code>use-when</code>
            attribute: see <specref ref="conditional-inclusion"/>.</p></item>
            <item></item>
       
            <item><p diff="del" at="M">The optional <code>enabled</code> attribute contains an expression which is evaluated
               to determine whether assertion checking is enabled. Checking is disabled if the attribute is present
               and the effective boolean value
               of the expression is <code>false</code>. This mechanism can be used, for example, to enable or disable a group of assertions
               by the setting of a <termref def="dt-stylesheet-parameter"/>.</p></item>
         </olist>-->

            <imp-def-feature id="idf-api-enablingassertions">The detail of any external mechanism
               allowing a processor to enable or disable checking of assertions is <termref def="dt-implementation-defined"/>.</imp-def-feature>

            <p>If assertion checking is enabled, the instruction is evaluated as follows:</p>

            <olist>
               <item>
                  <p>The expression in the <code>test</code> attribute is evaluated. If the
                     effective boolean value of the result is <code>true</code>, the assertion
                     succeeds, and no further action is taken. If the effective boolean value is
                     <code>false</code>, or if a dynamic error occurs during evaluation of the expression, then
                     the assertion fails.</p>
               </item>

               <item>
                  <p>If the assertion fails, then the effect of the instruction is governed by the
                     rules for evaluation of an <elcode>xsl:message</elcode> instruction with the
                     same <code>select</code> attribute, <code>error-code</code> attribute, and
                     contained <termref def="dt-sequence-constructor"/>, and with the value
                        <code>terminate="yes"</code>. However, the default error code if the
                        <code>error-code</code> attribute is omitted is <code>XTMM9001</code> rather
                     than <code>XTMM9000</code>.</p>

                  <note>
                     <p>To the extent that the behavior of <elcode>xsl:message</elcode> is <termref def="dt-implementation-defined"/>, this rule does not prevent an
                        implementation treating <elcode>xsl:assert</elcode> and
                           <elcode>xsl:message</elcode> differently.</p>
                  </note>

                  <note>
                     <p>If evaluation of the <code>test</code> expression
                        fails with a dynamic error, the effect is exactly the same as if the
                        evaluation returns <code>false</code>, including the fact that the
                        instruction fails with error code <code>XTMM9001</code>.</p>
                  </note>
               </item>

               <item>
                  <p>If an assertion fails, then the following sibling
                     instructions of the <elcode>xsl:assert</elcode> instruction are not
                     evaluated.</p>

                  <note>
                     <p>This means that <elcode>xsl:assert</elcode> can
                        be used (rather like <elcode>xsl:if</elcode> and
                        <elcode>xsl:choose</elcode>) to prevent subsequent instructions from
                        executing if a particular precondition is not true, which might be useful if
                        the subsequent instructions have side-effects (for example, by calling
                        extension functions) or if they can fail in uncatchable ways (for example,
                        non-terminating recursion). It is worth noting that there are limits to this
                        guarantee. It does not ensure, for example, that when an assertion within a
                        template fails, the following siblings of the
                           <elcode>xsl:call-template</elcode> instruction that invokes that template
                        will not be evaluated; nor does it ensure that if an assertion fails while
                        processing the first item of a sequence using <elcode>xsl:for-each</elcode>,
                        then subsequent items in the sequence will not be processed. </p>
                  </note>
               </item>
            </olist>

            <p>
               <error spec="XT" type="dynamic" class="MM" code="9001">
                  <p>When a transformation is terminated by use of <elcode>xsl:assert</elcode>, the
                     effect is the same as when a <termref def="dt-dynamic-error"> dynamic error</termref> occurs during the
                     transformation. The default error code is <code>XTMM9001</code>; this may be
                     overridden using the <code>error-code</code> attribute of the
                        <elcode>xsl:assert</elcode> instruction.</p>
               </error>
            </p>

            <p>As with any other dynamic error, an error caused by an assertion failing may be
               trapped using <elcode>xsl:try</elcode>: see <specref ref="try-catch"/>.</p>

            <p>The result of the <elcode>xsl:assert</elcode> instruction is an empty sequence.</p>

            <example>
               <head>Using Assertions with Static Parameters</head>
               <p>The following example shows a stylesheet function that checks that the value of
                  its supplied argument is in range. The check is performed only if the <termref def="dt-static-parameter"/>
                  <code>$DEBUG</code> is set to <code>true</code>.</p>
               <eg role="xslt-declarations" xml:space="preserve">
&lt;xsl:param name="DEBUG" as="xs:boolean" select="false()" 
           static="yes" required="no"/&gt;
&lt;xsl:function name="f:days-elapsed" as="xs:integer"&gt;
  &lt;xsl:param name="date" as="xs:date"/&gt;
  &lt;xsl:assert use-when="$DEBUG" test="$date lt current-date()"/&gt;
  &lt;xsl:sequence select="(current-date() - $since) 
                            div xs:dayTimeDuration('PT1D')"/&gt;
&lt;/xsl:function&gt;</eg>
            </example>

            <note>
               <p>Implementations should avoid optimizing <elcode>xsl:assert</elcode> instructions
                  away. As a guideline, if the result of a sequence constructor is required by the
                  transformation, the implementation should ensure that all
                     <elcode>xsl:assert</elcode> instructions in that sequence constructor are
                  evaluated. Conversely, if the result of a sequence constructor is not required by
                  the transformation, its <elcode>xsl:assert</elcode> instructions should not be
                  evaluated.</p>

               <p>This guidance is not intended to prevent optimizations such as lazy
                  evaluation, where evaluation of a sequence constructor may finish early, as soon
                  as enough information is available to evaluate the containing instruction.</p>
            </note>

            <p>An implementation <rfc2119>may</rfc2119> provide a user option allowing a processor
               to treat assertions as being true without explicit checking. This option
                  <rfc2119>must not</rfc2119> be enabled by default. If such an option is in force,
               the effect of any assertion not being true is <termref def="dt-implementation-dependent"/>.</p>

            <note>
               <p>For example, given the assertion <code>&lt;xsl:assert
                     test="count(//title)=1"/&gt;</code>, a processor might generate code for the
                  expression <code>&lt;xsl:value-of select="//title"/&gt;</code> that stops searching
                  for <code>title</code> elements after finding the first one. In the event that the
                  source document contains more than one <code>title</code>, execution of the
                  stylesheet may fail in arbitrary ways, or it may produce incorrect output.</p>
            </note>


         </div2>
      </div1>
      <div1 id="extension">
         <head>Extensibility and Fallback</head>
         <p>XSLT allows two kinds of extension, extension instructions and extension functions.</p>
         <p>
            <termdef id="dt-extension-instruction" term="extension instruction">An <term>extension
                  instruction</term> is an element within a <termref def="dt-sequence-constructor">sequence constructor</termref> that is in a namespace (not the <termref def="dt-xslt-namespace">XSLT namespace</termref>) designated as an extension
               namespace.</termdef>
         </p>
         <p>
            <termdef id="dt-extension-function" term="extension function">An <term>extension
               function</term> is a named function introduced to the static or dynamic context 
               by mechanisms outside the scope of this specification.</termdef></p>
         
    
         <p>This specification does not define any mechanism for creating or binding implementations
            of <termref def="dt-extension-instruction">extension instructions</termref> or <termref def="dt-extension-function">extension functions</termref>, and it is not
               <rfc2119>required</rfc2119> that implementations support any such mechanism. Such
            mechanisms, if they exist, are <termref def="dt-implementation-defined">implementation-defined</termref>. Therefore, an XSLT stylesheet that must be
            portable between XSLT implementations cannot rely on particular extensions being
            available. XSLT provides mechanisms that allow an XSLT stylesheet to determine whether
            the implementation makes particular extensions available, and to specify what happens if
            those extensions are not available. If an XSLT stylesheet is careful to make use of
            these mechanisms, it is possible for it to take advantage of extensions and still retain
            portability.</p>
         
         <p>
            <error spec="XT" type="static" class="SE" code="0085">
               <p>It is a <termref def="dt-static-error"/> to use a <termref def="dt-reserved-namespace"/>
                  in the name of any <termref def="dt-extension-function"/> or <termref def="dt-extension-instruction"/>,
                  other than a function or instruction defined in this specification or in a normatively 
                  referenced specification. It is a <termref def="dt-static-error"/> to use a prefix bound 
                  to a reserved namespace in the <code>[xsl:]extension-element-prefixes</code> attribute.
               </p>
            </error>
         </p>

         <div2 id="extension-functions">
            <head>Extension Functions</head>
            <p>The set of functions that can be called from a <xnt spec="XP40" ref="prod-xpath40-FunctionCall">FunctionCall</xnt> within an XPath <termref def="dt-expression">expression</termref> may include one or more <termref def="dt-extension-function">extension functions</termref>. The <termref def="dt-expanded-qname">expanded QName</termref> of an extension function always
               has a non-null namespace URI, which <rfc2119>must not</rfc2119> be the 
                  URI of a <termref def="dt-reserved-namespace"/>.</p>
            
            <note><p>The definition of the term <termref def="dt-extension-function"/> is written to exclude
            user-written <termref def="dt-stylesheet-function">stylesheet functions</termref>,
            constructor functions for built-in and user-defined types, functions in the <code>fn</code>, <code>math</code>,
               <code>map</code>, and <code>array</code> namespaces,
            anonymous XPath inline functions, maps and arrays,
            and partial function applications (including partial applications of extension functions). It also excludes
            functions obtained by invoking XPath-defined functions such as
               <xfunction spec="FO40">load-xquery-module</xfunction>.
            The definition allows extension functions to be discovered at evaluation time (typically using
            <xfunction>function-lookup</xfunction>) rather than necessarily being known statically.
            </p>
            <p>Technically, the definition of extension functions excludes anonymous functions
            obtained by calling or partially applying other extension functions. Since such functions are
            by their nature implementation-defined, they may however share some of the characteristics of
            extension functions.</p></note>
            
  
            <div3 id="func-function-available">
               <head><?function fn:function-available?></head>
            </div3>
            <div3 id="calling-extension-functions">
               <head>Calling Extension Functions</head>
               <p>If the function name used in a <xnt spec="XP40" ref="prod-xpath40-FunctionCall">FunctionCall</xnt> within an XPath <termref def="dt-expression">expression</termref> identifies an extension function, then to evaluate the
                     <xnt spec="XP40" ref="prod-xpath40-FunctionCall">FunctionCall</xnt>, the
                  processor will first evaluate each of the arguments in the <xnt spec="XP40" ref="prod-xpath40-FunctionCall">FunctionCall</xnt>. If the processor has
                  information about the datatypes expected by the extension function, then it
                     <rfc2119>may</rfc2119> perform any necessary type conversions between the XPath
                  datatypes and those defined by the implementation language. If multiple extension
                  functions are available with the same name, the processor <rfc2119>may</rfc2119>
                  decide which one to invoke based on the number of arguments, the types of the
                  arguments, or any other criteria. The result returned by the implementation is
                  returned as the result of the function call, again after any necessary conversions
                  between the datatypes of the implementation language and those of XPath. The
                  details of such type conversions are outside the scope of this specification.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1420">
                     <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the arguments
                        supplied to a call on an extension function do not satisfy the rules defined
                        for that particular extension function, or if the extension function reports
                        an error, or if the result of the extension function cannot be converted to
                        an XPath value.</p>
                  </error>
               </p>
               <note>
                  <p>Implementations may also provide mechanisms allowing extension functions to
                     report recoverable dynamic errors, or to execute within an environment that
                     treats some or all of the errors listed above as recoverable.</p>
               </note>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1425">
                     <p>When the containing element is processed with
                              <termref def="dt-xslt-10-behavior">XSLT 1.0
                           behavior</termref>, it is a <termref def="dt-dynamic-error"> dynamic
                           error</termref> to evaluate an extension function call if no
                        implementation of the extension function is available.</p>
                  </error>
               </p>
               <note>
                  <p>When XSLT 1.0 behavior is not enabled, this
                     is a static error <xerrorref spec="XP40" class="ST" code="0017"/>.</p>
               </note>
               <note>
                  <p>There is no prohibition on calling extension functions that have side-effects
                     (for example, an extension function that writes data to a file). However, the
                     order of execution of XSLT instructions is not defined in this specification,
                     so the effects of such functions are unpredictable.</p>
               </note>
               <p>Implementations are not <rfc2119>required</rfc2119> to perform full validation of
                  values returned by extension functions. It is an error for an extension function
                  to return a string containing characters that are not permitted in XML, but the
                  consequences of this error are <termref def="dt-implementation-defined">implementation-defined</termref>. The implementation <rfc2119>may</rfc2119>
                  raise an error, <rfc2119>may</rfc2119> convert the string to a string containing
                  valid characters only, or <rfc2119>may</rfc2119> treat the invalid characters as
                  if they were permitted characters.</p>
               <imp-def-feature id="idf-ext-nonxmlstring">The effect of an extension function
                  returning a string containing characters that are not permitted in XML is
                  implementation-defined.</imp-def-feature>
               <note>
                  <p>The ability to execute extension functions represents a potential security
                     weakness, since untrusted stylesheets may invoke code that has privileged
                     access to resources on the machine where the <termref def="dt-processor">processor</termref> executes. Implementations may therefore provide
                     mechanisms that restrict the use of extension functions by untrusted
                     stylesheets.</p>
               </note>
               <p>All observations in this section regarding the errors that can occur when invoking
                  extension functions apply equally when invoking <termref def="dt-extension-instruction">extension instructions</termref>.</p>
            </div3>
            <div3 id="external-objects">
               <head>External Objects</head>
               <p>An implementation <rfc2119>may</rfc2119> allow an extension function to return an
                  object that does not have any natural representation in the XDM data model,
                  whether as an atomic value, a node, or a function
                     item. For example, an extension function <code>sql:connect</code>
                  might return an object that represents a connection to a relational database; the
                  resulting connection object might be passed as an argument to calls on other
                  extension functions such as <code>sql:insert</code> and
                  <code>sql:select</code>.</p>
               <p>The way in which such objects are represented in the type system is <termref def="dt-implementation-defined">implementation-defined</termref>. They might be
                  represented by a completely new datatype, or they might be mapped to existing
                  datatypes such as <code>integer</code>, <code>string</code>, or
                     <code>anyURI</code>.</p>
               <imp-def-feature id="idf-ext-externalobjects">The way in which external objects are
                  represented in the type system is implementation-defined.</imp-def-feature>
            </div3>
            <div3 id="func-type-available">
               <head><?function fn:type-available?></head>
            </div3>
         </div2>
         <div2 id="extension-instruction">
            <head>Extension Instructions</head>
            <p>
               <termdef id="dt-extension-namespace" term="extension namespace">The <termref def="dt-extension-instruction">extension instruction</termref> mechanism allows
                  namespaces to be designated as <term>extension namespaces</term>. When a namespace
                  is designated as an extension namespace and an element with a name from that
                  namespace occurs in a <termref def="dt-sequence-constructor">sequence
                     constructor</termref>, then the element is treated as an <termref def="dt-instruction">instruction</termref> rather than as a <termref def="dt-literal-result-element">literal result element</termref>.</termdef> The
               namespace determines the semantics of the instruction.</p>
            <note>
               <p>Since an element that is a child of an <elcode>xsl:stylesheet</elcode> element is
                  not occurring <emph>in a <termref def="dt-sequence-constructor">sequence
                        constructor</termref>
                  </emph>, <termref def="dt-data-element">user-defined data elements</termref> (see
                     <specref ref="user-defined-top-level"/>) are not extension elements as defined
                  here, and nothing in this section applies to them.</p>
            </note>
            <div3 id="designating-extension-namespace">
               <head>Designating an Extension Namespace</head>
               <p>A namespace is designated as an extension namespace by using an
                     <code>[xsl:]extension-element-prefixes</code> attribute on an element in the
                  stylesheet (see <specref ref="standard-attributes"/>). The attribute
                     <rfc2119>must</rfc2119> be in the XSLT namespace only if its parent element is
                     <emph>not</emph> in the XSLT namespace. The value of the attribute is a
                  whitespace-separated list of namespace prefixes. The namespace bound to each of
                  the prefixes is designated as an extension namespace.</p>
               <p>The default namespace (as declared by <code>xmlns</code>) may be designated as an
                  extension namespace by including <code>#default</code> in the list of namespace
                  prefixes.</p>
               <p>A <termref def="dt-reserved-namespace"/> 
                  cannot be designated as an extension namespace: see <errorref spec="XT" class="SE" code="0085"/>.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="1430">
                     <p>It is a <termref def="dt-static-error">static error</termref> if there is no
                        namespace bound to the prefix on the element bearing the
                           <code>[xsl:]extension-element-prefixes</code> attribute or, when
                           <code>#default</code> is specified, if there is no default namespace.</p>
                  </error>
               </p>
               <p>The designation of a namespace as an extension namespace is effective for the
                  element bearing the <code>[xsl:]extension-element-prefixes</code> attribute and
                  for all descendants of that element within the same stylesheet module.</p>
            </div3>
            <div3 id="func-element-available">
               <head><?function fn:element-available?></head>

            </div3>
            <div3 id="fallback">
               <head>Fallback</head>
               <?element xsl:fallback?>
               <p>The content of an <elcode>xsl:fallback</elcode> element is a <termref def="dt-sequence-constructor">sequence constructor</termref>, and when
                  performing fallback, the value returned by the <elcode>xsl:fallback</elcode>
                  element is the result of evaluating this sequence constructor.</p>
               <p>When not performing fallback, evaluating an <elcode>xsl:fallback</elcode> element
                  returns an empty sequence: the content of the <elcode>xsl:fallback</elcode>
                  element is not evaluated.</p>
               <p>There are two situations where a <termref def="dt-processor">processor</termref>
                  performs fallback: when an extension instruction that is not available is
                  evaluated, and when an instruction in the XSLT namespace, that is not defined in
                  XSLT 3.0, is evaluated within a region of the
                  stylesheet for which <termref def="dt-forwards-compatible-behavior"/> is
                  enabled.</p>
               <note>
                  <p>Fallback processing is not invoked in other situations, for example it is not
                     invoked when an XPath expression uses unrecognized syntax or contains a call to
                     an unknown function. To handle such situations dynamically, the stylesheet
                     should call functions such as <function>system-property</function> and
                        <function>function-available</function> to decide what capabilities are
                     available.</p>
               </note>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1450">
                     <p>When a <termref def="dt-processor">processor</termref> performs fallback for
                        an <termref def="dt-extension-instruction">extension instruction</termref>
                        that is not recognized, if the instruction element has one or more
                           <elcode>xsl:fallback</elcode> children, then the content of each of the
                           <elcode>xsl:fallback</elcode> children <rfc2119>must</rfc2119> be
                        evaluated; it is a <termref def="dt-dynamic-error"> dynamic error</termref> if it has no
                           <elcode>xsl:fallback</elcode> children.</p>
                  </error>
               </p>
               <note>
                  <p>This is different from the situation with unrecognized <termref def="dt-xslt-element">XSLT elements</termref>. As explained in <specref ref="forwards"/>, an unrecognized XSLT element appearing within a <termref def="dt-sequence-constructor">sequence constructor</termref> is a static
                     error unless (a) <termref def="dt-forwards-compatible-behavior"/> is enabled,
                     and (b) the instruction has an <elcode>xsl:fallback</elcode> child.</p>
               </note>
            </div3>
         </div2>
      </div1>
      <div1 id="result-trees">
         <head>Transformation Results</head>
         <p>The output of a transformation includes a <termref def="dt-principal-result"/> and zero or more <termref def="dt-secondary-result">secondary results</termref>.</p>
         
         
         <p>The way in which these results are
             delivered to an application is <termref def="dt-implementation-defined">implementation-defined</termref>.</p>
         <imp-def-feature id="idf-api-results">The way in which the results of the transformation
            are delivered to an application is implementation-defined.</imp-def-feature>
         <p>Serialization of results
             is described further in <specref ref="serialization"/>
         </p>
         <div2 id="creating-result-trees">
            <head>Creating Secondary Results</head>
            <?element xsl:result-document?>
            <p>The <elcode>xsl:result-document</elcode> instruction is
               used to create a <termref def="dt-secondary-result"/>. The content of the
                  <elcode>xsl:result-document</elcode> element is a <termref def="dt-sequence-constructor">sequence constructor</termref>, 
               and the value of the
                  <termref def="dt-secondary-result"/> (known as the <termref def="dt-raw-result"/>)
               is the <termref def="dt-immediate-result"/> of this
               sequence constructor. </p>
            
            <p>As with the <termref def="dt-principal-result"/> of the
            transformation, a <termref def="dt-secondary-result"/> may be delivered to the calling
            application in three ways (see <specref ref="post-processing"/>):</p>
            
            <olist>
               <item><p>The <termref def="dt-raw-result"/> may be delivered <emph>as is</emph>.</p></item>
               <item><p>The <termref def="dt-raw-result"/> may be used to construct a <termref def="dt-final-result-tree"/>
               by invoking the process of <xtermref spec="SER30" ref="sequence-normalization"/>.</p></item>
               <item><p>The <termref def="dt-raw-result"/> may be serialized to a sequence of octets (which
               may then, optionally, be saved to a persistent storage location).</p></item>
            </olist>
            
            <p>The decision whether or not to serialize the raw result depends on the 
               <termref def="dt-processor">processor</termref> and on the way it is invoked. This
               is <termref def="dt-implementation-defined"/>, and it is not controlled by anything
               in the stylesheet.</p>
            
            <p>If the result is not serialized, then the decision whether to
               return the <termref def="dt-raw-result"/> or to construct a tree depends on the effective
               value of the <code>build-tree</code> attribute. If the <termref def="dt-effective-value"/> of
               the <code>build-tree</code> attribute is <code>yes</code>, then 
                  a <termref def="dt-final-result-tree"/> is created
               by invoking the process of <xtermref spec="SER30" ref="sequence-normalization"/>. <phrase diff="del" at="2022-01-01">The default for the
                  <code>build-tree</code> attribute depends on the serialization method. For the
                  <code>xml</code>, <code>html</code>, <code>xhtml</code>, and <code>text</code>
               methods the default value is <code>yes</code>. For
                  the <code>json</code> and <code>adaptive</code> methods the default value is <code>no</code>.</phrase>
               <phrase diff="add" at="2022-01-01">Conversely, if the result <emph>is</emph> serialized, then 
                  the decision whether or not to construct a tree depends on the choice of 
                  serialization method, and the <code>build-tree</code> attribute is then ignored. 
                  For example, with <code>method="xml"</code> a tree is always constructed, whereas 
                  with <code>method="json"</code> a tree is never constructed. [XSLT 3.0 Erratum E14, bug 30208].
               </phrase></p>

            
            <p>The <elcode>xsl:result-document</elcode> instruction
               defines a URI that may be used to identify the <termref def="dt-secondary-result"/>.
               The instruction may optionally specify the output format to be used for serializing the result.</p>
            
            <p>Technically, the result of evaluating the <elcode>xsl:result-document</elcode>
               instruction is an empty sequence. This means it does not contribute anything to the
               result of the sequence constructor it is part of.</p>
            <p>The <termref def="dt-effective-value"/> of the
                  <code>format</code> attribute, if specified, <rfc2119>must</rfc2119> be an <termref def="dt-eqname">EQName</termref>. The value is
               expanded using the namespace declarations in scope for the
                  <elcode>xsl:result-document</elcode> element. The resulting <termref def="dt-expanded-qname">expanded QName</termref>
               <rfc2119>must</rfc2119> match the expanded QName of a named <termref def="dt-output-definition">output definition</termref> in the <termref def="dt-stylesheet">stylesheet</termref>. This identifies the
                  <elcode>xsl:output</elcode> declaration that will control the serialization of the
                  <termref def="dt-final-result-tree">final result tree</termref> (see <specref ref="serialization"/>), if the result tree is serialized. If the
                  <code>format</code> attribute is omitted, the unnamed <termref def="dt-output-definition">output definition</termref> is used to control
               serialization of the result tree.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="1460">
                  <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the <termref def="dt-effective-value"/> of the
                        <code>format</code> attribute <error.extra>of an
                           <elcode>xsl:result-document</elcode> element</error.extra> is not a valid
                        <termref def="dt-eqname">EQName</termref>, or if it does not match the
                        <termref def="dt-expanded-qname">expanded QName</termref> of an <termref def="dt-output-definition">output definition</termref> in the containing <termref def="dt-package">package</termref>. If the processor is able to detect
                     the error statically (for example, when the <code>format</code> attribute
                     contains no curly brackets), then the processor <rfc2119>may</rfc2119>
                     optionally signal this as a <termref def="dt-static-error">static
                        error</termref>.</p>
               </error>
            </p>
            <note>
               <p>The only way to select the unnamed <termref def="dt-output-definition">output
                     definition</termref> is to omit the <code>format</code> attribute.</p>
            </note>
            <p>The <code>parameter-document</code> attribute allows serialization
               parameters to be supplied in an external document. The external document must contain
               an <code>output:serialization-parameters</code> element with the format described in
                  <xspecref spec="SER30" ref="serparams-in-xdm-instance"/>, and the parameters are
               interpreted as described in that specification.</p>
            <p>If present, the <termref def="dt-effective-value"/> of the URI supplied in the
                  <code>parameter-document</code> attribute is dereferenced, after resolution
               against the base URI of the <elcode>xsl:result-document</elcode> element if it is a
               relative reference. 
               The parameter document <rfc2119>should</rfc2119> be read during run-time evaluation of the stylesheet. 
               If the location of the stylesheet at development time is
               different from the deployed location, any relative reference should be resolved
               against the deployed location. A serialization error occurs if the result of
               dereferencing the URI is ill-formed or invalid; but if no document can be found at
               the specified location, the attribute <code>should</code> be ignored.</p>
            <p>A serialization parameter specified in the
                  <code>parameter-document</code> takes precedence over a value supplied directly as
               an attribute of <elcode>xsl:result-document</elcode>, which in turn takes precedence
               over a value supplied in the selected output definition, except that the values of
               the <code>cdata-section-elements</code> and <code>suppress-indentation</code>
               attributes are merged in the same way as when multiple <elcode>xsl:output</elcode>
               declarations are merged.</p>
            <p>The attributes <code>method</code>, <code>allow-duplicate-names</code>, <code>build-tree</code>, <code>byte-order-mark</code>
               <code>cdata-section-elements</code>, <code>doctype-public</code>,
                  <code>doctype-system</code>, <code>encoding</code>,
               <code diff="add" at="2023-03-31">escape-solidus</code>
                  <code>escape-uri-attributes</code>, <code>html-version</code>, <code>indent</code>, <code>item-separator</code>,
               <code>json-node-output-method</code>,
                  <code>media-type</code>, <code>normalization-form</code>,
                  <code>omit-xml-declaration</code>, <code>standalone</code>, <code>suppress-indentation</code>,
               <!-- see bug 6535 -->
               <code>undeclare-prefixes</code>, <code>use-character-maps</code>, and
                  <code>output-version</code> may be used to override attributes defined in the
               selected <termref def="dt-output-definition">output definition</termref>.</p>
            <p>With the exception of <code>use-character-maps</code>, these attributes are all
               defined as <termref def="dt-attribute-value-template">attribute value
                  templates</termref>, so their values may be set dynamically. For any of these
               attributes that is present on the <elcode>xsl:result-document</elcode> instruction,
               the <termref def="dt-effective-value"/> of the attribute
               overrides or supplements the corresponding value from the output definition. This
               works in the same way as when one <elcode>xsl:output</elcode> declaration overrides
               another. Some of the attributes have more specific
                  rules:</p>
            <ulist>
               <item>
                  <p>In the case of <code>cdata-section-elements</code>
                     and <code>suppress-indentation</code>, the
                     value of the serialization parameter is the union of the expanded names of the
                     elements named in this instruction and the elements named in the selected
                     output definition.</p>
               </item>
               <item>
                  <p>In the case of <code>use-character-maps</code>, the character maps referenced
                     in this instruction supplement and take precedence over those defined in the
                     selected output definition.</p>
               </item>
               <item>
                  <p>In the case of <code>doctype-public</code> and <code>doctype-system</code>,
                     setting the <termref def="dt-effective-value"/> of the attribute to a zero-length string has the
                     effect of overriding any value for these attributes obtained from the output
                     definition. The corresponding serialization parameter is not set (is
                     “absent”).</p>
               </item>
               <item>
                  <p>In the case of <code>item-separator</code>, setting the <termref def="dt-effective-value"/> of the
                     attribute to the special value <code>"#absent"</code> has the effect of
                     overriding any value for this attribute obtained from the output definition.
                     The corresponding serialization parameter is not set (is “absent”). It is not
                     possible to set the value of the serialization parameter to the literal
                     7-character string <code>"#absent"</code>. </p>
               </item>
               <item>
                  <p>In all other cases, the <termref def="dt-effective-value"/> of an attribute actually present on
                     this instruction takes precedence over the value defined in the selected output
                     definition.</p>
               </item>
            </ulist>
            <note>
               <p>In the case of the attributes <code>method</code>,
                     <code>cdata-section-elements</code>, <code>suppress-indentation</code>, and
                     <code>use-character-maps</code>, the <termref def="dt-effective-value"/> of the attribute contains a space-separated list of
                     <termref def="dt-eqname">EQNames</termref>. If any of these is a <termref def="dt-lexical-qname">lexical QName</termref> with a prefix, the prefix is
                  expanded using the in-scope namespaces for the
                     <elcode>xsl:result-document</elcode> element. In the case of
                     <code>cdata-section-elements</code>
                  and <code>suppress-indentation</code>, an
                  unprefixed element name is expanded using the default namespace. In the case of
                  the <code>method</code> attribute, if the method is not one of the system-defined
                  methods (xml, html, xhtml, text) then the expanded name must have a non-absent
                  namespace.</p>
            </note>
            <p diff="del" at="2022-01-01">Unless the processor implements the XPath 3.1 feature, the 
               <code>method</code> values <code>json</code> and
                  <code>adaptive</code>
               <rfc2119>must</rfc2119> be rejected as invalid, and the attributes
                  <code>allow-duplicate-names</code> and <code>json-node-output-method</code>
               <rfc2119>must</rfc2119> be ignored. The meaning of these output methods and
               serialization parameters is defined in <bibref ref="xslt-xquery-serialization-31"/>.</p>
            <p>The <code>output-version</code> attribute on the <elcode>xsl:result-document</elcode>
               instruction overrides the <code>version</code> attribute on
                  <elcode>xsl:output</elcode> (it has been renamed because <code>version</code> is
               available with a different meaning as a standard attribute: see <specref ref="standard-attributes"/>). In all other cases, attributes correspond if they
               have the same name.</p>
            <p>There are some serialization parameters that apply to some output methods but not to
               others. For example, the <code>indent</code> attribute has no effect on the
                  <code>text</code> output method. If a value is supplied for an attribute that is
               inapplicable to the output method, its value is not passed to the serializer. The
               processor <rfc2119>may</rfc2119> validate the value of such an attribute, but is not
                  <rfc2119>required</rfc2119> to do so.</p>
            
            <p>The <code>item-separator</code> serialization parameter
               is used when the <termref def="dt-raw-result"/> is used to construct a result tree
               by applying sequence normalization, and it is also used when the result tree is
               serialized. For example, if the sequence constructor delivers a sequence of
               integers, and the <code>text</code> serialization method is used, then the result of serialization
               will be a string obtained by converting each integer to a string, and separating the
               strings using the defined <code>item-separator</code>.</p>
            
            
            <p>The <code>href</code> attribute is optional. The default value is the zero-length
               string. The <termref def="dt-effective-value"/> of the
               attribute <rfc2119>must</rfc2119> be a <termref def="dt-uri-reference">URI
                  Reference</termref>, which may be absolute or relative. If it is relative, then it is resolved against the <termref def="dt-base-output-uri"/>. There <rfc2119>may</rfc2119> be <termref def="dt-implementation-defined">implementation-defined</termref> restrictions on
               the form of absolute URI that may be used, but the implementation is not
                  <rfc2119>required</rfc2119> to enforce any restrictions. Any valid relative URI
                  reference
               <rfc2119>must</rfc2119> be accepted. Note that the zero-length string is a valid
               relative URI reference.</p>
            <imp-def-feature id="idf-api-resultdocumenthref"> It is <termref def="dt-implementation-defined"/> how the URI appearing in the <code>href</code>
               attribute of <elcode>xsl:result-document</elcode> affects the way in which the result
               tree is delivered to the application. There <rfc2119>may</rfc2119> be restrictions on
               the form of this URI. </imp-def-feature>
            <p>If the implementation provides an API to access <termref def="dt-secondary-result">secondary results</termref>, then it
                  <rfc2119>must</rfc2119> allow a secondary result to be identified by means of the
               absolutized value of the <code>href</code> attribute. In addition, if a <termref def="dt-final-result-tree"/> is constructed
               (that is, if the <termref def="dt-effective-value"/> of
                  <code>build-tree</code> is <code>yes</code>), then this value is used as the base
               URI of the document node at the root of the <termref def="dt-final-result-tree">final
                  result tree</termref>. </p>



            <note>
               <p>The base URI of the <termref def="dt-final-result-tree">final result
                     tree</termref> is not necessarily the same thing as the URI of its serialized
                  representation on disk, if any. For example, a server (or browser client) might
                  store final result trees only in memory, or in an internal disk cache. As long as
                  the processor satisfies requests for those URIs, it is irrelevant where they are
                  actually written on disk, if at all.</p>
            </note>
            <note>
               <p>It will often be the case that one <termref def="dt-final-result-tree">final
                     result tree</termref> contains links to another final result tree produced
                  during the same transformation, in the form of a relative URI reference. The mechanism of associating a URI with a final
                  result tree has been chosen to allow the integrity of such links to be preserved
                  when the trees are serialized.</p>
               <p>As well as being potentially significant in any API that provides access to final
                  result trees, the base URI of the new document node is relevant if the final
                  result tree, rather than being serialized, is supplied as input to a further
                  transformation.</p>
            </note>
            <p>The optional attributes <code>type</code> and <code>validation</code> may be used on
               the <elcode>xsl:result-document</elcode> instruction to validate the contents of
                  a <termref def="dt-final-result-tree"/>, and to determine the <termref def="dt-type-annotation">type
                  annotation</termref> that elements and attributes within the <termref def="dt-final-result-tree">final result tree</termref> will carry. The permitted
               values and their semantics are described in <specref ref="validating-document-nodes"/>. Any such validation is applied to the
               document node produced as the result of <xtermref spec="SER30" ref="sequence-normalization"/>.
               If sequence normalization does not take place (typically because the <termref def="dt-raw-result"/>
               is delivered to the application directly, or because the selected serialization method
               does not involve sequence normalization) then the <code>validation</code> and
               <code>type</code> attributes are ignored.</p>
            
            <note><p>Validation applies after inserting item separators as determined by the
            <code>item-separator</code> serialization parameter, and an inappropriate choice
            of <code>item-separator</code> may cause the result to become invalid.</p></note>
            
            <p>A <termref def="dt-processor">processor</termref>
               <rfc2119>may</rfc2119> allow a <termref def="dt-final-result-tree">final result
                  tree</termref> to be serialized. Serialization is described in <specref ref="serialization"/>. However, an implementation (for example, a <termref def="dt-processor">processor</termref> running in an environment with no access to
               writable filestore) is not <rfc2119>required</rfc2119> to support the serialization
               of <termref def="dt-final-result-tree">final result trees</termref>. An
               implementation that does not support the serialization of final result trees
                  <rfc2119>may</rfc2119> ignore the <code>format</code> attribute and the
               serialization attributes. Such an implementation <rfc2119>must</rfc2119> provide the
               application with some means of access to the (un-serialized) result tree, using its
               URI to identify it.</p>
            <p>Implementations may provide additional mechanisms, outside the scope of this
               specification, for defining the way in which <termref def="dt-final-result-tree">final result trees</termref> are processed. Such mechanisms
                  <rfc2119>may</rfc2119> make use of the XSLT-defined attributes on the
                  <elcode>xsl:result-document</elcode> and/or <elcode>xsl:output</elcode> elements,
               or they <rfc2119>may</rfc2119> use additional elements or attributes in an <termref def="dt-implementation-defined">implementation-defined</termref> namespace.</p>

            <example>
               <head>Multiple Result Documents</head>
               <p> The following example takes an XHTML document as input, and breaks it up so that
                  the text following each &lt;h1&gt; element is included in a separate document. A
                  new document <code>toc.html</code> is constructed to act as an index:</p>
               <eg role="xslt-document" xml:space="preserve">&lt;xsl:stylesheet
	version="3.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:xhtml="http://www.w3.org/1999/xhtml"&gt;
	
&lt;xsl:output name="toc-format" method="xhtml" indent="yes"
     doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
     doctype-public="-//W3C//DTD XHTML 1.0 Strict//EN"/&gt;
            
&lt;xsl:output name="section-format" method="xhtml" indent="no"
     doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
     doctype-public="-//W3C//DTD XHTML 1.0 Transitional//EN"/&gt;	
	 
&lt;xsl:template match="/"&gt;
  &lt;xsl:result-document href="toc.html" 
                       format="toc-format" 
                       validation="strict"&gt;
    &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
      &lt;head&gt;&lt;title&gt;Table of Contents&lt;/title&gt;&lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;Table of Contents&lt;/h1&gt;
        &lt;xsl:for-each select="/*/xhtml:body/(*[1] | xhtml:h1)"&gt;
          &lt;p&gt;
            &lt;a href="section{position()}.html"&gt;
              &lt;xsl:value-of select="."/&gt;
            &lt;/a&gt;
          &lt;/p&gt;
        &lt;/xsl:for-each&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:result-document&gt;
  &lt;xsl:for-each-group select="/*/xhtml:body/*" group-starting-with="xhtml:h1"&gt;
    &lt;xsl:result-document href="section{position()}.html" 
                         format="section-format" validation="strip"&gt;  	
      &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
        &lt;head&gt;&lt;title&gt;&lt;xsl:value-of select="."/&gt;&lt;/title&gt;&lt;/head&gt;
        &lt;body&gt;
          &lt;xsl:copy-of select="current-group()"/&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    &lt;/xsl:result-document&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg>
            </example>
         </div2>
         <div2 id="result-document-restrictions">
            <head>Restrictions on the use of <elcode>xsl:result-document</elcode></head>
            <p>There are restrictions on the use of the <elcode>xsl:result-document</elcode>
               instruction, designed to ensure that the results are fully interoperable even when
               processors optimize the sequence in which instructions are evaluated. Informally, the
               restriction is that the <elcode>xsl:result-document</elcode> instruction can only be
               used while writing a final result tree, not while writing to a temporary tree or a
               sequence. This restriction is defined formally as follows.</p>
            <p>
               <termdef id="dt-output-state" term="output state">Each instruction in the <termref def="dt-stylesheet">stylesheet</termref> is evaluated in one of two possible
                     <term>output states</term>: <termref def="dt-final-output-state">final output
                     state</termref> or <termref def="dt-temporary-output-state">temporary output
                     state</termref>.</termdef></p>
            <p>
               <termdef id="dt-final-output-state" term="final output state">The first of the two
                     <termref def="dt-output-state">output states</termref> is called <term>final
                     output</term> state. This state applies when instructions are writing to a
                     <termref def="dt-final-result-tree">final result tree</termref>.</termdef>
            </p>
            <p>
               <termdef id="dt-temporary-output-state" term="temporary output state">The second of
                  the two <termref def="dt-output-state">output states</termref> is called
                     <term>temporary output</term> state. This state applies when instructions are
                  writing to a <termref def="dt-temporary-tree">temporary tree</termref> or any
                  other non-final destination.</termdef>
            </p>
            <p>The instructions in the <termref def="dt-initial-named-template"/> are evaluated in
                  <termref def="dt-final-output-state">final output state</termref>. An instruction
               is evaluated in the same <termref def="dt-output-state">output state</termref> as its
               calling instruction, except that <elcode>xsl:variable</elcode>,
                  <elcode>xsl:param</elcode>, <elcode>xsl:with-param</elcode>, 
               <elcode>xsl:function</elcode>, <elcode>xsl:key</elcode>, <elcode>xsl:sort</elcode>,
                  <elcode>xsl:accumulator-rule</elcode>, and
                     <elcode>xsl:merge-key</elcode>
                always evaluate the instructions in their
               contained <termref def="dt-sequence-constructor">sequence constructor</termref> in
                  <termref def="dt-temporary-output-state">temporary output state</termref>.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="1480">
                  <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> to evaluate the
                        <elcode>xsl:result-document</elcode> instruction in <termref def="dt-temporary-output-state">temporary output state</termref>.</p>
               </error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="1490">
                  <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> for a transformation to
                     generate two or more <termref def="dt-final-result-tree">final result
                        trees</termref> with the same URI.</p>
               </error>
            </p>
            <note>
               <p>Note, this means that it is an error to evaluate more than one
                     <elcode>xsl:result-document</elcode> instruction that omits the
                     <code>href</code> attribute, or to evaluate any
                     <elcode>xsl:result-document</elcode> instruction that omits the
                     <code>href</code> attribute if an initial <termref def="dt-final-result-tree">final result tree</termref> is created implicitly.</p>
            </note>
            <p>In addition, an implementation <rfc2119>may</rfc2119> report this
               error if it is able to detect that two or more final result trees are generated with
               different URIs that refer to the same physical resource.</p>


            
            <p>
               <error spec="XT" type="dynamic" class="DE" code="1500">
                  <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> for a <termref def="dt-stylesheet">stylesheet</termref> to write to an external resource
                     and read from the same resource during a single transformation, if the same absolute URI is used to access the resource in
                        both cases. </p>
               </error>
            </p>
            <p>In addition, an implementation <rfc2119>may</rfc2119> report this
               error if it is able to detect that a transformation writes to a resource and reads
               from the same resource using different URIs that refer to the same physical resource.
               Note that if the error is not detected, it is <termref def="dt-implementation-dependent"/> whether the document that is read from the
               resource reflects its state before or after the result tree is written.</p>
         </div2>
         <div2 id="current-output-uri">
            <head>The Current Output URI</head>
            <p><termdef id="dt-current-output-uri" term="current output URI">The <term>current output URI</term> is the URI
                  associated with the <termref def="dt-principal-result"/> or <termref def="dt-secondary-result"/> that is currently being written.</termdef></p>
            <div3 id="func-current-output-uri">
               <head><?function fn:current-output-uri?></head>

            </div3>
         </div2>


         <div2 id="validation">
            <head>Validation</head>
            <p>It is possible to control the <termref def="dt-type-annotation"/> applied to
               individual element and attribute nodes as they are constructed. This is done using
               the <code>type</code> and <code>validation</code> attributes of the
                  <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                  <elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>,
                  <elcode>xsl:document</elcode>, and <elcode>xsl:result-document</elcode>
               instructions, or the <code>xsl:type</code> and <code>xsl:validation</code> attributes
               of a <termref def="dt-literal-result-element">literal result element</termref>.
                  The same attributes are used on
                     <elcode>xsl:source-document</elcode> and <elcode>xsl:merge-source</elcode> to control
                  validation of input documents.</p>
            <p>The <code>[xsl:]type</code> attribute is used to request validation of an element or
               attribute against a specific simple or complex type defined in a schema. The
                  <code>[xsl:]validation</code> attribute is used to request validation against the
               global element or attribute declaration whose name matches the name of the element or
               attribute being validated.</p>
            <p>The <code>[xsl:]type</code> and <code>[xsl:]validation</code> attributes are mutually
               exclusive. Both are optional, but if one is present then the other
                  <rfc2119>must</rfc2119> be omitted. If both attributes are omitted, the effect is
               the same as specifying the <code>validation</code> attribute with the value specified
               in the <code>[xsl:]default-validation</code> attribute of
                  the innermost containing element having such an attribute; if this is not
               specified, the effect is the same as specifying <code>validation="strip"</code>.</p>

            <p>The <code>[xsl:]default-validation</code> attribute defines the
               default value of the <code>validation</code> attribute of all
                  <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                  <elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>,
                  <elcode>xsl:document</elcode>, and <elcode>xsl:result-document</elcode>
               instructions, and of the <code>xsl:validation</code> attribute of all
               <termref def="dt-literal-result-element">literal result elements</termref>,
               appearing <phrase diff="chg" at="2022-01-01">appearing as descendants of the element 
                  on which the attribute appears, unless there is an inner element that defines 
                  a different default</phrase>. <phrase diff="del" at="2022-01-01">It also determines
               the validation applied to the implicit <termref def="dt-final-result-tree">final
                  result tree</termref> created in the absence of an
                  <elcode>xsl:result-document</elcode> instruction.</phrase> This default <phrase diff="del" at="2022-01-01">applies within the
               containing <termref def="dt-stylesheet-module">stylesheet module</termref> or
                  <termref def="dt-package"/>: it</phrase> does not extend to included or imported stylesheet
               modules or used packages. If the attribute is omitted, the default is
                  <code>strip</code>. The permitted values are <code>preserve</code> and
                  <code>strip</code>.</p>
            
            <p diff="add" at="2022-01-01">
               The <code>default-validation</code> attribute on the outermost element of the principal
               stylesheet module of the <termref def="dt-top-level-package"/> also determines the validation 
               applied to the implicit final result tree created in the absence of an 
               <elcode>xsl:result-document</elcode> instruction. [XSLT 3.0 Erratum E15, bug 30211].
            </p>

            <p>The <code>[xsl:]default-validation</code> attribute has no
               effect on the <elcode>xsl:source-document</elcode> and <elcode>xsl:merge-source</elcode>
               elements, which perform no validation unless explicitly requested.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="1505">
                  <p>It is a <termref def="dt-static-error">static error</termref> if both the
                        <code>[xsl:]type</code> and <code>[xsl:]validation</code> attributes are
                     present on the <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                        <elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>,
                        <elcode>xsl:document</elcode>, <elcode>xsl:result-document</elcode>, <elcode>xsl:source-document</elcode>, or
                           <elcode>xsl:merge-source</elcode> elements, or on a <termref def="dt-literal-result-element">literal result element</termref>.</p>
               </error>
            </p>
            <p>The detailed rules for validation vary depending on the kind of node being validated.
               The rules for element and attribute nodes are given in <specref ref="validating-constructed-nodes"/>, while those for document nodes are given in
                  <specref ref="validating-document-nodes"/>.</p>
            <div3 id="validating-constructed-nodes">
               <head>Validating Constructed Elements and Attributes</head>
               <div4 id="validating-using-validation-attribute">
                  <head>Validation using the <code>[xsl:]validation</code> Attribute</head>
                  <p>The <code>[xsl:]validation</code> attribute defines the validation action to be
                     taken. It determines not only the <termref def="dt-type-annotation">type
                        annotation</termref> of the node that is constructed by the relevant
                     instruction itself, but also the type annotations of all element and attribute
                     nodes that have the constructed node as an ancestor. Conceptually, the
                     validation requested for a child element or attribute node is applied before
                     the validation requested for its parent element. For example, if the
                     instruction that constructs a child element specifies
                        <code>validation="strict"</code>, this will cause the child element to be
                     checked against an element declaration, but if the instruction that constructs
                     its parent element specifies <code>validation="strip"</code>, then the final
                     effect will be that the child node is annotated as <code>xs:untyped</code>.</p>
                  <p>In the paragraphs below, the term <emph>contained nodes</emph> means the
                     elements and attributes that have the newly constructed node as an
                     ancestor.</p>
                  <olist>
                     <item>
                        <p>The value <code>strip</code> indicates that the new node and each of the
                           contained nodes will have the <termref def="dt-type-annotation">type
                              annotation</termref>
                           <code>xs:untyped</code> if it is an element, or
                              <code>xs:untypedAtomic</code> if it is an attribute. Any previous type
                           annotation present on a contained element or attribute node (for example,
                           a type annotation that is present on an element copied from a source
                           document) is also replaced by <code>xs:untyped</code> or
                              <code>xs:untypedAtomic</code> as appropriate. The typed value of the
                           node is changed to be the same as its string value, as an instance of
                              <code>xs:untypedAtomic</code>. In the case of elements the
                              <code>nilled</code> property is set to <code>false</code>. The values
                           of the <code>is-id</code> and <code>is-idrefs</code> properties are
                           unchanged. Schema validation is not invoked.</p>
                     </item>
                     <item>
                        <p>The value <code>preserve</code> indicates that nodes that are copied will
                           retain their <termref def="dt-type-annotation">type
                           annotations</termref>, but nodes whose content is newly constructed will
                           be annotated as <code>xs:anyType</code> in the case of elements, or
                              <code>xs:untypedAtomic</code> in the case of attributes. Schema
                           validation is not invoked. The detailed effect depends on the
                           instruction:</p>
                        <olist>
                           <item>
                              <p>In the case of <elcode>xsl:element</elcode> and literal result
                                 elements, the new element has a <termref def="dt-type-annotation">type annotation</termref> of <code>xs:anyType</code>, and the
                                 type annotations of contained nodes are retained unchanged.</p>
                              <p>The <code>nilled</code>,
                                    <code>is-id</code> and <code>is-idrefs</code> properties on the
                                 new element are set to <code>false</code>.</p>
                           </item>
                           <item>
                              <p>In the case of <elcode>xsl:attribute</elcode>, the effect is
                                 exactly the same as specifying <code>validation="strip"</code>:
                                 that is, the new attribute will have the type annotation
                                    <code>xs:untypedAtomic</code>.</p>
                              <p>The <code>is-id</code> and
                                    <code>is-idrefs</code> properties on the new attribute are set
                                 to <code>false</code>.</p>
                           </item>
                           <item>
                              <p>In the case of <elcode>xsl:copy-of</elcode>, all the nodes that are
                                 copied will retain their type annotations unchanged. The values of their
                                       <code>nilled</code>, <code>is-id</code> and
                                       <code>is-idrefs</code> properties are also
                                 unchanged.</p>
                           </item>
                           <item>
                              <p>In the case of <elcode>xsl:copy</elcode>, the effect depends on the
                                 kind of node being copied.</p>
                              <olist>
                                 <item>
                                    <p>Where the node being copied is an attribute, the copied
                                       attribute will retain its <termref def="dt-type-annotation">type annotation</termref>
                                       and the values of its
                                             <code>is-id</code> and <code>is-idrefs</code>
                                          properties.</p>
                                 </item>
                                 <item>
                                    <p>Where the node being copied is an element, the copied element
                                       will have a <termref def="dt-type-annotation">type
                                          annotation</termref> of <code>xs:anyType</code> (because
                                       this instruction does not copy the content of the element, it
                                       would be wrong to assume that the type is unchanged); but any
                                       contained nodes will have their type annotations retained in
                                       the same way as with <elcode>xsl:element</elcode>. The values of the
                                             <code>nilled</code>, <code>is-id</code>, and
                                             <code>is-idrefs</code> properties are handled in the
                                          same way as <elcode>xsl:element</elcode>.
                                    </p>
                                 </item>
                              </olist>
                           </item>
                        </olist>
                     </item>
                     <item>
                        <p>The value <code>strict</code> indicates that <termref def="dt-type-annotation">type annotations</termref> are established by
                           performing strict schema validity assessment on the element or attribute
                           node created by this instruction as follows:</p>
                        <olist>
                           <item>
                              <p>In the case of an element, a top-level element declaration is
                                 identified whose local name and namespace (if any) match the name
                                 of the element, and schema-validity assessment is carried out
                                 according to the rules defined in <bibref ref="xmlschema-1"/>
                                 (section 3.3.4 <quote>Element Declaration Validation Rules</quote>,
                                 validation rule <quote>Schema-Validity Assessment
                                 (Element)</quote>, clauses 1.1 and 2, using the top-level element
                                 declaration as the “declaration stipulated by the processor”, which
                                 is mentioned in clause 1.1.1.1). The element is considered valid if
                                 the result of the schema validity assessment is a PSVI in which the
                                 relevant element node has a <code>validity</code> property whose
                                 value is <code>valid</code>. If there is no matching element
                                 declaration, or if the element is not considered valid, the
                                 transformation fails <errorref class="TE" code="1510"/>, <errorref class="TE" code="1512"/>. In effect this means that the element
                                 being validated <rfc2119>must</rfc2119> be declared using a
                                 top-level declaration in the schema, and <rfc2119>must</rfc2119>
                                 conform to its declaration. The process of validation applies
                                 recursively to contained elements and attributes to the extent
                                 required by the schema definition.</p>
                              <note>
                                 <p>It is not an error if the identified type definition is a simple
                                    type, although <bibref ref="xmlschema-1"/> does not define
                                    explicitly that this case is permitted.</p>
                              </note>
                           </item>
                           <item>
                              <p>In the case of an attribute, a top-level attribute declaration is
                                 identified whose local name and namespace (if any) match the name
                                 of the attribute, and schema-validity assessment is carried out
                                 according to the rules defined in <bibref ref="xmlschema-1"/>
                                 (section 3.2.4 <quote>Attribute Declaration Validation
                                    Rules</quote>, validation rule <quote>Schema-Validity Assessment
                                    (Attribute)</quote>). The attribute is considered valid if the
                                 result of the schema validity assessment is a PSVI in which the
                                 relevant attribute node has a <code>validity</code> property whose
                                 value is <code>valid</code>. If the attribute is not considered
                                 valid, the transformation fails <errorref class="TE" code="1510"/>.
                                 In effect this means that the attribute being validated
                                    <rfc2119>must</rfc2119> be declared using a top-level
                                 declaration in the schema, and <rfc2119>must</rfc2119> conform to
                                 its declaration.</p>
                           </item>
                           <item>
                              <p>The schema components used to validate an element or attribute may
                                 be located in any way described by <bibref ref="xmlschema-1"/> (see
                                 section 4.3.2, <emph>How schema documents are located on the
                                    Web</emph>). The components in the schema constructed from the
                                 synthetic schema document (see <specref ref="import-schema"/>) will
                                 always be available for validating constructed nodes; if additional
                                 schema components are needed, they <rfc2119>may</rfc2119> be
                                 located in other ways, for example implicitly from knowledge of the
                                 namespace in which the elements and attributes appear, or using the
                                    <code>xsi:schemaLocation</code> attribute of elements within the
                                 tree being validated.</p>
                           </item>
                           <item>
                              <p>The type annotations on the resulting
                                 nodes, as well as the values of their <code>is-id</code>,
                                    <code>is-idrefs</code>, and <code>nilled</code> properties, are
                                 defined by the rules in <xspecref ref="const-psvi" spec="DM31"/>.</p>
                           </item>
                           <item>
                              <p>If no validation is performed for a node, which can happen when the
                                 schema specifies <code>lax</code> or <code>skip</code> validation
                                 for that node or for a subtree, then the node is annotated as
                                    <code>xs:anyType</code> in the case of an element, and
                                    <code>xs:untypedAtomic</code> in the case of an attribute.</p>
                           </item>
                        </olist>
                     </item>
                     <item>
                        <p>The value <code>lax</code> has the same effect as the value
                              <code>strict</code>, except that whereas <code>strict</code>
                           validation fails if there is no matching top-level element declaration or
                           if the outcome of validity assessment is a <code>validity</code> property
                           of <code>invalid</code> or <code>notKnown</code>, <code>lax</code>
                           validation fails only if the outcome of validity assessment is a
                              <code>validity</code> property of <code>invalid</code>. That is,
                              <code>lax</code> validation does not cause a <termref def="dt-type-error">type error</termref> when the outcome is
                              <code>notKnown</code>.</p>
                        <p>In practice this means that the element or attribute being validated
                              <rfc2119>must</rfc2119> conform to its declaration if a top-level
                           declaration is available. If no such declaration is available, then the
                           element or attribute is not validated, but its attributes and children
                           are validated, again with lax validation. Any nodes whose validation
                           outcome is a <code>validity</code> property of <code>notKnown</code> are
                           annotated as <code>xs:anyType</code> in the case of an element, and
                              <code>xs:untypedAtomic</code> in the case of an attribute.</p>

                        <p>The type annotations on the resulting nodes,
                           as well as the values of their <code>is-id</code>,
                           <code>is-idrefs</code>, and <code>nilled</code> properties, are defined
                           by the rules in <xspecref ref="const-psvi" spec="DM31"/>.</p>

                        <note>
                           <p>When the parent element lacks a declaration, the XML Schema
                              specification defines the recursive checking of children and
                              attributes as optional. For this specification, this recursive
                              checking is required.</p>
                        </note>
                        <note>
                           <p>If an element that is being validated has an <code>xsi:type</code>
                              attribute, then the value of the <code>xsi:type</code> attribute will
                              be taken into account when performing the validation. However, the
                              presence of an <code>xsi:type</code> attribute will not of itself
                              cause an element to be validated: if validation against a named type
                              is required, as distinct from validation against a top-level element
                              declaration, then it must be requested using the XSLT
                                 <code>[xsl:]type</code> attribute on the instruction that invokes
                              the validation, as described in section <specref ref="validation-xsl-type"/>
                           </p>
                        </note>
                        
                     </item>
                  </olist>
                  <p>
                     <error spec="XT" type="type" class="TE" code="1510">
                        <p>If the <code>validation</code> attribute of an
                              <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                              <elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>, or
                              <elcode>xsl:result-document</elcode> instruction, or the
                              <code>xsl:validation</code> attribute of a literal result element, has
                           the <termref def="dt-effective-value"/> <code>strict</code>, and schema validity assessment
                           concludes that the validity of the element or attribute is invalid or
                           unknown, a <termref def="dt-type-error">type error</termref> occurs. As
                           with other type errors, the error <rfc2119>may</rfc2119> be signaled
                           statically if it can be detected statically. </p>
                     </error>
                  </p>
                  <p>
                     <error spec="XT" type="type" class="TE" code="1512">
                        <p>If the <code>validation</code> attribute of an
                              <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                              <elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>, or
                              <elcode>xsl:result-document</elcode> instruction, or the
                              <code>xsl:validation</code> attribute of a literal result element, has
                           the <termref def="dt-effective-value"/> <code>strict</code>, and there is no matching
                           top-level declaration in the schema, then a <termref def="dt-type-error">type error</termref> occurs. As with other type errors, the error
                              <rfc2119>may</rfc2119> be signaled statically if it can be detected
                           statically. </p>
                     </error>
                  </p>
                  <p>
                     <error spec="XT" type="type" class="TE" code="1515">
                        <p>If the <code>validation</code> attribute of an
                              <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                              <elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>, or
                              <elcode>xsl:result-document</elcode> instruction, or the
                              <code>xsl:validation</code> attribute of a literal result element, has
                           the <termref def="dt-effective-value"/> <code>lax</code>, and schema validity assessment
                           concludes that the element or attribute is invalid, a <termref def="dt-type-error">type error</termref> occurs. As with other type
                           errors, the error <rfc2119>may</rfc2119> be signaled statically if it can
                           be detected statically. </p>
                     </error>
                  </p>
                  <note>
                     <p>No mechanism is provided to validate an element or attribute against a local
                        declaration in a schema. Such validation can usually be achieved by applying
                        validation to a containing element for which a top-level element declaration
                        exists.</p>
                  </note>
               </div4>
               <div4 id="validation-xsl-type">
                  <head>Validation using the <code>[xsl:]type</code> Attribute</head>
                  <p>The <code>[xsl:]type</code> attribute takes as its value an 
                     <phrase diff="chg" at="2022-01-01"><xnt spec="XP40" ref="prod-xpath40-EQName"/></phrase>.
                     If it is a lexical QName with no prefix, it is
                     expanded using the <phrase diff="chg" at="2022-01-01">default namespace for types</phrase>.
                     This <rfc2119>must</rfc2119> be the name of a type definition included in the
                        <termref def="dt-in-scope-schema-component">in-scope schema
                        components</termref> for the stylesheet. </p>
                  <p>If the <code>[xsl:]type</code> attribute is present, then the newly constructed
                     element or attribute is validated against the type definition identified by
                     this attribute.</p>
                  <ulist>
                     <item>
                        <p>In the case of an element, schema-validity assessment is carried out
                           according to the rules defined in <bibref ref="xmlschema-1"/> (section
                           3.3.4 <quote>Element Declaration Validation Rules</quote>, validation
                           rule <quote>Schema-Validity Assessment (Element)</quote>, clauses 1.2 and
                           2), using this type definition as the <quote>processor-stipulated type
                              definition</quote>. The element is considered valid if the result of
                           the schema validity assessment is a PSVI in which the relevant element
                           node has a <code>validity</code> property whose value is
                              <code>valid</code>. </p>
                     </item>
                     <item>
                        <p>In the case of an attribute, the attribute is considered valid if (in the
                           terminology of XML Schema) the attribute’s normalized value is
                           locally valid with respect to that type definition according to the rules
                           for <quote>String Valid</quote> (<bibref ref="xmlschema-1"/>, section
                           3.14.4). (Normalization here refers to the process of normalizing
                           whitespace according to the rules of the <code>whiteSpace</code> facet
                           for the datatype).</p>
                     </item>
                     <item>
                        <p>If the element or attribute is not considered valid, as defined above,
                           the transformation fails <errorref class="TE" code="1540"/>.</p>
                     </item>
                  </ulist>

                  <p>If an element node is validated against the type
                        <code>xs:untyped</code>, the effect is the same as specifying
                        <code>validation="strip"</code>: that is, the elements and attributes in the
                     subtree rooted at the target element are copied with a type annotation of
                        <code>xs:untyped</code> or <code>xs:untypedAtomic</code> respectively.</p>

                  <p>If an element or attribute node is validated against the type
                        <code>xs:untypedAtomic</code>, the effect is the same as specifying
                        <code>[xsl:]type="xs:string"</code> except that when validation succeeds,
                     the returned element or attribute has a type annotation of
                        <code>xs:untypedAtomic</code>. Validation fails in the case of an element
                     with element children.</p>
                  <p>
                     <error spec="XT" type="static" class="SE" code="1520">
                        <p>It is a <termref def="dt-static-error">static error</termref> if the
                           value of the <code>type</code> attribute of an
                              <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                              <elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>,
                              <elcode>xsl:document</elcode>, <elcode>xsl:result-document</elcode>,
                           <phrase diff="add" at="E"><elcode>xsl:source-document</elcode>, or 
                              <elcode>xsl:merge-source</elcode></phrase>
                           instruction, or the <code>xsl:type</code> attribute of a literal result
                           element, is not a valid <code>QName</code>, or if it uses a prefix that
                           is not defined in an in-scope namespace declaration, or if the QName is
                           not the name of a type definition included in the <termref def="dt-in-scope-schema-component">in-scope schema
                              components</termref> for the <termref def="dt-package">package</termref>.
                        <phrase diff="add" at="2022-01-01">[XSLT 3.0 Erratum E20, bug 30234]</phrase></p>
                     </error>
                  </p>
                  <p>
                     <error spec="XT" type="static" class="SE" code="1530">
                        <p>It is a <termref def="dt-static-error">static error</termref> if the
                           value of the <code>type</code> attribute of an
                              <elcode>xsl:attribute</elcode> instruction refers to a complex type
                           definition</p>
                     </error>.</p>
                  <p>
                     <!-- see spec bug 13001 -->
                     <error spec="XT" type="type" class="TE" code="1535">
                        <p>It is a <termref def="dt-type-error">type error</termref> if the value of
                           the <code>type</code> attribute of an <elcode>xsl:copy</elcode> or
                              <elcode>xsl:copy-of</elcode> instruction refers to a complex type
                           definition and one or more of the items being copied is an attribute
                           node.</p>
                     </error></p>
                  <p>
                     <error spec="XT" type="type" class="TE" code="1540">
                        <p>It is a <termref def="dt-type-error">type error</termref> if an
                              <code>[xsl:]type</code> attribute is defined for a constructed element
                           or attribute, and the outcome of schema validity assessment against that
                           type is that the <code>validity</code> property of that element or
                           attribute information item is other than <code>valid</code>.</p>
                     </error>
                  </p>
                  <note>
                     <p>Like other type errors, this error may be signaled statically if it can be
                        detected statically. For example, the instruction <code>&lt;xsl:attribute
                           name="dob" type="xs:date"&gt;1999-02-29&lt;/xsl:attribute&gt;</code> may
                        result in a static error being signaled. If the error is not signaled
                        statically, it will be signaled when the instruction is evaluated.</p>
                  </note>
               </div4>
               <div4 id="validation-process">
                  <head>The Validation Process</head>
                  <p>As well as checking for validity against the schema, the validity assessment
                     process causes <termref def="dt-type-annotation">type annotations</termref> to
                     be associated with element and attribute nodes. If default values for elements
                     or attributes are defined in the schema, the validation process will where
                     necessary create new nodes containing these default values.</p>
                  <p>Validation of an element or attribute node only takes into account constraints
                     on the content of the element or attribute. Validation rules affecting the
                     document as a whole are not applied. Specifically, this means:</p>
                  <ulist>
                     <item>
                        <p>The validation rule <quote>Validation Root Valid (ID/IDREF)</quote> is
                           not applied. This means that validation will not fail if there are
                           non-unique ID values or dangling IDREF values in the subtree being
                           validated.</p>
                     </item>
                     <item>
                        <!--Text replaced by erratum E12 change 1"-->
                        <p>The validation rule <quote>Validation Rule: Identity-constraint
                              Satisfied</quote>
                           <rfc2119>should</rfc2119> be applied.</p>
                        <!--End of text replaced by erratum E12-->
                     </item>
                     <item>
                        <p>There is no check that the document contains unparsed entities whose
                           names match the values of nodes of type <code>xs:ENTITY</code> or
                              <code>xs:ENTITIES</code>. (XSLT 3.0
                           provides no facility to construct unparsed entities within a tree.)</p>
                     </item>
                     
                  </ulist>
                  <p>With these caveats, validating a newly constructed element, using strict or lax
                     validation, is equivalent to the following steps:</p>
                  <olist>
                     <item>
                        <p>The element is serialized to textual XML form, according to the rules
                           defined in <bibref ref="xslt-xquery-serialization-30"/> using the XML
                           output method, with all parameters defaulted. Note that this process
                           discards any existing <termref def="dt-type-annotation">type
                              annotations</termref>.</p>
                     </item>
                     <item>
                        <p>The resulting XML document is parsed to create an XML Information Set
                           (see <bibref ref="xml-infoset"/>.)</p>
                     </item>
                     <item>
                        <p>The Information Set produced in the previous step is validated according
                           to the rules in <bibref ref="xmlschema-1"/>. The result of this step is a
                           Post-Schema Validation Infoset (PSVI). If the validation process is not
                           successful (as defined above), a <termref def="dt-type-error">type
                              error</termref> is raised.</p>
                     </item>
                     <item>
                        <p>The PSVI produced in the previous step is converted back into the XDM
                           data model by the mapping described in <bibref ref="xpath-datamodel-30"/>
                              (<xspecref spec="DM30" ref="PSVI2Types"/>). This process creates nodes
                           with simple or complex <termref def="dt-type-annotation">type
                              annotations</termref> based on the types established during schema
                           validation.</p>
                     </item>
                  </olist>

                  <p> The above process must be done in such a way that
                     the base URI property of every node in the resulting XDM tree is the same as
                     the base URI property of the corresponding node in the input tree. </p>
                  <note>
                     <p> As an alternative to steps 1 and 2, the XDM tree may be converted to an
                        Infoset directly, using the mapping rules given for each kind of node in
                           <bibref ref="xpath-datamodel-30"/> (Section 6). </p>
                  </note>
                  <p>Validating an attribute using strict or lax validation requires a modified
                     version of this procedure. A copy of the attribute is first added to an element
                     node that is created for the purpose, and namespace fixup (see <specref ref="namespace-fixup"/>) is performed on this element node. The name of this
                     element is of no consequence, but it must be the same as the name of a
                     synthesized element declaration of the form:</p>
                  <eg role="xslt-instruction" xml:space="preserve">&lt;xs:element name="E"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:sequence/&gt;
    &lt;xs:attribute ref="A"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</eg>
                  <p>where A is the name of the attribute being validated.</p>
                  <p>This synthetic element is then validated using the procedure given above for
                     validating elements, and if it is found to be valid, a copy of the validated
                     attribute is made, retaining its <termref def="dt-type-annotation">type
                        annotation</termref>, but detaching it from the containing element (and
                     thus, from any namespace nodes).</p>
                  <p>The XDM data model does not permit an attribute node with no parent to have a
                     typed value that includes a namespace-qualified name, that is, a value whose
                     type is derived from <code>xs:QName</code> or <code>xs:NOTATION</code>. This
                     restriction is imposed because these types rely on the namespace nodes of a
                     containing element to resolve namespace prefixes. Therefore, it is an error to
                     validate a parentless attribute against such a type. This affects the
                     instructions <elcode>xsl:attribute</elcode>, <elcode>xsl:copy</elcode>, and
                        <elcode>xsl:copy-of</elcode>.</p>
                  <p>
                     <error spec="XT" type="type" class="TE" code="1545">
                        <p>A <termref def="dt-type-error">type error</termref> occurs if a
                              <code>type</code> or <code>validation</code> attribute is defined
                           (explicitly or implicitly) for an instruction that constructs a new
                           attribute node, if the effect of this is to cause the attribute value to
                           be validated against a type that is derived from, or constructed by list
                           or union from, the primitive types <code>xs:QName</code> or
                              <code>xs:NOTATION</code>.</p>
                     </error>
                  </p>
               </div4>
            </div3>
            <div3 id="validating-document-nodes">
               <head>Validating Document Nodes</head>
               <p>It is possible to apply validation to a document node. This happens when a new
                  document node is constructed by one of the XSLT elements <elcode>xsl:source-document</elcode>, <elcode>xsl:merge-source</elcode>, <elcode>xsl:document</elcode>,
                     <elcode>xsl:result-document</elcode>, <elcode>xsl:copy</elcode>, or
                     <elcode>xsl:copy-of</elcode>, and this element has a <code>type</code>
                  attribute, or a <code>validation</code> attribute with the value
                     <code>strict</code> or <code>lax</code>.</p>
               <p>Document-level validation is not applied to the document node that is created
                  implicitly when a variable-binding element has no <code>select</code> attribute
                  and no <code>as</code> attribute (see <specref ref="temporary-trees"/>). This is
                  equivalent to using <code>validation="preserve"</code> on
                     <elcode>xsl:document</elcode>: nodes within such trees retain their <termref def="dt-type-annotation">type annotation</termref>. Similarly, validation is
                  not applied to document nodes created using <elcode>xsl:message</elcode>
                  or <elcode>xsl:assert</elcode>. </p>
               <p>The values <code>validation="preserve"</code> and <code>validation="strip"</code>
                  do not request validation. In the first case, all element and attribute nodes
                  within the tree rooted at the new document node retain their <termref def="dt-type-annotation">type annotations</termref>. In the second case,
                  elements within the tree have their type annotation set to
                  <code>xs:untyped</code>, while attributes have their type annotation set to
                     <code>xs:untypedAtomic</code>.</p>
               <p>When validation is requested for a document node (that is, when
                     <code>validation</code> is set to <code>strict</code> or <code>lax</code>, or
                  when a <code>type</code> attribute is present), the following processing takes
                  place:</p>
               <ulist>
                  <item>
                     <p>
                        <error spec="XT" type="type" class="TE" code="1550">
                           <p>A <termref def="dt-type-error">type error</termref> occurs
                                 <error.extra>when a document node is validated</error.extra> unless
                              the children of the document node comprise exactly one element node,
                              no text nodes, and zero or more comment and processing instruction
                              nodes, in any order.</p>
                        </error>
                     </p>
                  </item>
                  <item>
                     <p>The single element node child is validated, using the supplied values of the
                           <code>validation</code> and <code>type</code> attributes, as described in
                           <specref ref="validating-constructed-nodes"/>.</p>
                     <note>
                        <p>The <code>type</code> attribute on <elcode>xsl:source-document</elcode>,
                              <elcode>xsl:document</elcode> and
                           <elcode>xsl:result-document</elcode>, and on <elcode>xsl:copy</elcode>
                           and <elcode>xsl:copy-of</elcode> when copying a document node, thus
                           refers to the required type of the element node that is the only element
                           child of the document node. It does not refer to the type of the document
                           node itself.</p>
                     </note>
                  </item>
                  <item>
                     <p>The validation rule <quote>Validation Root Valid (ID/IDREF)</quote> is
                        applied to the single element node child of the document node. This means
                        that validation will fail if there are non-unique ID values or dangling
                        IDREF values in the document tree.</p>
                  </item>
                  <item>
                     <p>Identity constraints, as defined in section 3.11 of <bibref ref="xmlschema-1"/>, are checked. (This refers to constraints defined
                        using <code>xs:unique</code>, <code>xs:key</code>, and
                           <code>xs:keyref</code>.)</p>
                  </item>
                  <item>
                     <p>There is no check that the tree contains unparsed entities whose names match
                        the values of nodes of type <code>xs:ENTITY</code> or
                           <code>xs:ENTITIES</code>. This is because there is no facility in XSLT
                           3.0 to create unparsed entities in a
                           <termref def="dt-result-tree">result tree</termref>. It is possible to
                        add unparsed entity declarations to the result document by referencing a
                        suitable DOCTYPE during serialization.</p>
                  </item>
                  
                  <item>
                     <p>All other children of the document node (comments and processing
                        instructions) are copied unchanged.</p>
                  </item>
               </ulist>
               <p>
                  <error spec="XT" type="type" class="TE" code="1555">
                     <p>It is a <termref def="dt-type-error">type error</termref> if, when
                        validating a document node, document-level constraints (such as ID/IDREF
                        constraints) are not satisfied. <!-- see test bug 935 -->
                        </p>
                  </error>
               </p>
            </div3>
            <div3 id="validating-xml-id">
               <head>Validating <code>xml:id</code> attributes</head>
               <p>This section provides a non-normative summary of the effect of validation on
               attributes named <code>xml:id</code>. The normative rules can be inferred from rules
               given elsewhere in this section.</p>
               <olist>
                  <item><p>When an attribute named <code>xml:id</code> is encountered
                  in the course of validation:</p>
                  <olist>
                     <item><p>A validation error occurs if it the attribute is not lexically valid against type <code>xs:ID</code>.</p></item>
                     <item><p>The typed value of the attribute is whitespace-normalized.</p></item>
                     <item><p>The attribute is labeled with type annotation <code>xs:ID</code>.</p></item>
                     <item><p>The attribute acquires the <code>is-id</code> property.</p></item>
                  </olist></item>
                  <item><p>The previous rule applies whether validation is strict, lax, or by type; 
                     validation will never fail (or be skipped) on the grounds
                  that no global attribute declaration named <code>xsl:id</code> is available.</p></item>
                  <item><p>Checking <code>xml:id</code> attributes for uniqueness happens if and only if
                  validation is applied at the level of a document node.</p></item>
               </olist>
            </div3>
         </div2>
      </div1>
      <div1 id="serialization">
         <head>Serialization</head>
         <p>A <termref def="dt-processor">processor</termref>
            <rfc2119>may</rfc2119> output a <termref def="dt-final-result-tree">final result
               tree</termref> as a sequence of octets, although it is not
               <rfc2119>required</rfc2119> to be able to do so (see <specref ref="conformance"/>).
            Stylesheet authors can use <elcode>xsl:output</elcode> declarations to specify how they
            wish result trees to be serialized. If a processor serializes a final result tree, it
               <rfc2119>must</rfc2119> do so as specified by these declarations.</p>
         <p>The rules governing the output of the serializer are defined in <bibref ref="xslt-xquery-serialization-30"/>. The serialization is controlled using a number
            of serialization parameters. The values of these serialization parameters may be set
            within the <termref def="dt-stylesheet">stylesheet</termref>, using the
               <elcode>xsl:output</elcode>, <elcode>xsl:result-document</elcode>, and
               <elcode>xsl:character-map</elcode> declarations.</p>
         <?element xsl:output?>
         <p>The <elcode>xsl:output</elcode> declaration is optional; if used, it
               <rfc2119>must</rfc2119> always appear as a <termref def="dt-top-level">top-level</termref> element within a stylesheet module.</p>
         <p>A <termref def="dt-stylesheet">stylesheet</termref> may contain multiple
               <elcode>xsl:output</elcode> declarations and may include or import stylesheet modules
            that also contain <elcode>xsl:output</elcode> declarations. The name of an
               <elcode>xsl:output</elcode> declaration is the value of its <code>name</code>
            attribute, if any.</p>
         <p>
            <termdef id="dt-output-definition" term="output definition">All the
                  <elcode>xsl:output</elcode> declarations within a
                     <termref def="dt-package">package</termref> that share the same name
               are grouped into a named <term>output definition</term>; those that have no name are
               grouped into a single unnamed output definition.</termdef>
         </p>
         <p>An output definition is scoped to a package. If this is a <termref def="dt-library-package">library package</termref> the output definition applies only
            to <elcode>xsl:result-document</elcode> instructions within the same package. If it is
            the <termref def="dt-top-level-package">top-level package</termref>, the output
            definition applies to <elcode>xsl:result-document</elcode> instructions within the same
            package and also to the implicit <termref def="dt-final-result-tree">final result
               tree</termref>.</p>
         <p>A stylesheet always includes an unnamed <termref def="dt-output-definition">output
               definition</termref>; in the absence of an unnamed <elcode>xsl:output</elcode>
            declaration, the unnamed output definition is equivalent to the one that would be used
            if the stylesheet contained an <elcode>xsl:output</elcode> declaration having no
            attributes.</p>
         <p>A named <termref def="dt-output-definition">output definition</termref> is used when its
            name matches the <code>format</code> attribute used in an
               <elcode>xsl:result-document</elcode> element. The unnamed output definition is used
            when an <elcode>xsl:result-document</elcode> element omits the <code>format</code>
            attribute. It is also used when serializing the <termref def="dt-principal-result"/>.
            .</p>
         <p>All the <elcode>xsl:output</elcode> elements making up an <termref def="dt-output-definition">output definition</termref> are effectively merged. For
            those attributes whose values are namespace-sensitive, the merging is done after
               <termref def="dt-lexical-qname">lexical QNames</termref> have been converted into
               <termref def="dt-expanded-qname">expanded QNames</termref>. For the
               <code>cdata-section-elements</code>
            and <code>suppress-indentation</code> attributes, the
            output definition uses the union of the values from all the constituent
               <elcode>xsl:output</elcode> declarations. For the <code>use-character-maps</code>
            attribute, the output definition uses the concatenation of the sequences of <termref def="dt-expanded-qname">expanded QNames</termref> values from all the constituent
               <elcode>xsl:output</elcode> declarations, taking them in order of increasing <termref def="dt-import-precedence">import precedence</termref>, or where several have the
            same import precedence, in <termref def="dt-declaration-order">declaration
               order</termref>. For other attributes, the <termref def="dt-output-definition">output
               definition</termref> uses the value of that attribute from the
               <elcode>xsl:output</elcode> declaration with the highest <termref def="dt-import-precedence">import precedence</termref>.</p>
         <p>The <code>parameter-document</code> attribute allows serialization
            parameters to be supplied in an external document. The external document must contain an
               <code>output:serialization-parameters</code> element with the format described in
               <xspecref spec="SER30" ref="serparams-in-xdm-instance"/>, and the parameters are
            interpreted as described in that specification.</p>
         <p>If present, the URI supplied in the <code>parameter-document</code>
            attribute is dereferenced, after resolution against the base URI of the
               <elcode>xsl:output</elcode> element if it is a relative reference. 
            The parameter document <rfc2119>should</rfc2119> be read during static analysis of the stylesheet. 
            A serialization error occurs
            if the result of dereferencing the URI is ill-formed or invalid; but if no document can
            be found at the specified location, the attribute <rfc2119>should</rfc2119> be ignored.</p>
         <p>A serialization parameter specified in the
               <code>parameter-document</code> takes precedence over a value supplied directly in
            the output declaration, except that the values of the
               <code>cdata-section-elements</code> and <code>suppress-indentation</code> attributes
            are merged in the same way as when multiple <elcode>xsl:output</elcode> declarations are
            merged.</p>


         <p>
            <error spec="XT" type="static" class="SE" code="1560">
               <p>It is a <termref def="dt-static-error">static error</termref> if two
                     <elcode>xsl:output</elcode> declarations within an <termref def="dt-output-definition">output definition</termref> specify explicit values
                  for the same attribute (other than <code>cdata-section-elements</code>, <code>suppress-indentation</code>, and
                     <code>use-character-maps</code>), with the values of the attributes being not
                  equal, unless there is another <elcode>xsl:output</elcode> declaration within the
                  same <termref def="dt-output-definition">output definition</termref> that has
                  higher import precedence and that specifies an explicit value for the same
                  attribute. </p>
            </error>
         </p>
         <p diff="del" at="2022-01-01">The <code>build-tree</code> attribute controls whether the
            raw <termref def="dt-principal-result"/> or <termref def="dt-secondary-result"/> is
            converted to a <termref def="dt-final-result-tree"/>. The default depends on the value
            of the <code>method</code> attribute: the default is <code>yes</code> if the
               <code>method</code> attribute specifies <code>xml</code>, <code>html</code>,
               <code>xhtml</code>, or <code>text</code>, or if it is omitted; the default is <code>no</code> if the <code>method</code> attribute
               specifies <code>json</code> or <code>adaptive</code>. A <termref def="dt-final-result-tree"/> may be constructed whether or not it is subsequently
            serialized.</p>
         <p diff="add" at="2022-01-01">
            If the result is not serialized, then the decision whether to return the raw result 
            or to construct a tree depends on the <termref def="dt-effective-value"/> of the <code>build-tree</code> attribute. 
            If the effective value of the <code>build-tree</code> attribute is <code>yes</code>, then a 
            final result tree is created by invoking the process of sequence normalization. Conversely, 
            if the result is serialized, then the decision whether or not to construct a tree depends 
            on the choice of serialization method, and the <code>build-tree</code> attribute is 
            then ignored. For example, with <code>method="xml"</code> a tree is always constructed, 
            whereas with <code>method="json"</code> a tree is never constructed. [XSLT 3.0 Erratum E14, bug 30208].
         </p>
         <note>
            <p>The default for <code>build-tree</code> may differ for user-defined serialization
               methods or for serialization methods introduced in future versions of this
               specification.</p>
         </note>
         <p diff="del" at="2022-01-01">Unless the processor implements the XPath 3.1 feature, the 
            <code>method</code> values <code>json</code> and
               <code>adaptive</code>
            <rfc2119>must</rfc2119> be rejected as invalid, and the attributes
               <code>allow-duplicate-names</code> and <code>json-node-output-method</code>
            <rfc2119>must</rfc2119> be ignored. The meaning of these output methods and
            serialization parameters is defined in <bibref ref="xslt-xquery-serialization-31"/>.</p>
         <p>If none of the <elcode>xsl:output</elcode> declarations within an <termref def="dt-output-definition">output definition</termref> specifies a value for a
            particular attribute, then the corresponding serialization parameter takes a default
            value. The default value depends on the chosen output method.</p>
         <p>There are some serialization parameters that apply to some output methods but not to
            others. For example, the <code>indent</code> attribute has no effect on the
               <code>text</code> output method. If a value is supplied for an attribute that is
            inapplicable to the output method, its value is not passed to the serializer. The
            processor <rfc2119>may</rfc2119> validate the value of such an attribute, but is not
               <rfc2119>required</rfc2119> to do so.</p>
         <p>An implementation <rfc2119>may</rfc2119> allow the attributes of the
               <elcode>xsl:output</elcode> declaration to be overridden, or the default values to be
            changed, using the API that controls the transformation.</p>
         <p>The location to which <termref def="dt-final-result-tree">final result trees</termref>
            are serialized (whether in filestore or elsewhere) is <termref def="dt-implementation-defined">implementation-defined</termref> (which in practice
               <rfc2119>may</rfc2119> mean that it is controlled using an implementation-defined
            API). However, these locations <rfc2119>must</rfc2119> satisfy the constraint that when
            two <termref def="dt-final-result-tree">final result trees</termref> are both created
            (implicitly or explicitly) using relative URI references in the <code>href</code> attribute of the
               <elcode>xsl:result-document</elcode> instruction, then these relative URI references may be used to construct references from one
            tree to the other, and such references <rfc2119>must</rfc2119> remain valid when both
            result trees are serialized. </p>
         <imp-def-feature id="idf-api-serializationlocation">If serialization is supported, then the
            location to which a <termref def="dt-final-result-tree">final result tree</termref> is
            serialized is implementation-defined, subject to the constraint that relative URI
               references used to reference one tree from another
            remain valid.</imp-def-feature>
         <p>The <code>method</code> attribute on the <elcode>xsl:output</elcode> element identifies
            the overall method that is to be used for outputting the <termref def="dt-final-result-tree">final result tree</termref>.</p>
         <p>
            <error spec="XT" type="static" class="SE" code="1570">
               <p>The value <error.extra>of the <code>method</code> attribute on
                        <elcode>xsl:output</elcode>
                  </error.extra>
                  <rfc2119>must</rfc2119> (if present) be a valid <termref def="dt-eqname">EQName</termref>. If it is a <termref def="dt-lexical-qname">lexical
                     QName</termref> with no a prefix, then it identifies a method specified in
                     <bibref ref="xslt-xquery-serialization-30"/> and <rfc2119>must</rfc2119> be one
                  of <code>xml</code>, <code>html</code>, <code>xhtml</code>, or
                  <code>text</code>.</p>
            </error> If it is a <termref def="dt-lexical-qname">lexical QName</termref> with a
            prefix, then the <termref def="dt-lexical-qname">lexical QName</termref> is expanded
            into an <termref def="dt-expanded-qname">expanded QName</termref> as described in
               <specref ref="qname"/>; the <termref def="dt-expanded-qname">expanded QName</termref>
            identifies the output method; the behavior in this case is not specified by this
            document.</p>
         <p>The default for the <code>method</code> attribute depends on the contents of the tree
            being serialized, and is chosen as follows. If the document node of the <termref def="dt-final-result-tree">final result tree</termref> has an element child, and any
            text nodes preceding the first element child of the document node of the result tree
            contain only whitespace characters, then:</p>
         <ulist>
            <item>
               <p>If the <termref def="dt-expanded-qname">expanded QName</termref> of this first
                  element child has local part <code>html</code> (in lower case), and namespace URI
                     <code>http://www.w3.org/1999/xhtml</code>, then the default output method is
                  normally <code>xhtml</code>. However, if the
                        <termref def="dt-effective-version"/> of the outermost element of the
                        <termref def="dt-principal-stylesheet-module">principal stylesheet
                        module</termref> in the <termref def="dt-top-level-package"/> has the value
                        <code>1.0</code>, and if the result tree is generated implicitly
                  (rather than by an explicit <elcode>xsl:result-document</elcode> instruction),
                  then the default output method in this situation is <code>xml</code>.</p>
            </item>
            <item>
               <p>If the <termref def="dt-expanded-qname">expanded QName</termref> of this first
                  element child has local part <code>html</code> (in any combination of upper and
                  lower case) and a null namespace URI, then the default output method is
                     <code>html</code>.</p>
            </item>
         </ulist>
         <p>In all other cases, the default output method is <code>xml</code>.</p>
         <p>The default output method is used if the selected <termref def="dt-output-definition">output definition</termref> does not include a <code>method</code> attribute.</p>
         <p>The other attributes on <elcode>xsl:output</elcode> provide parameters for the output
            method. The following attributes are allowed:</p>
         <ulist>
            <item>
               <p> The value of the <code>encoding</code> attribute provides the value of the
                     <code>encoding</code> parameter to the serialization method. The default value
                  is <termref def="dt-implementation-defined"/>, but in the case of the
                     <code>xml</code> and <code>xhtml</code> methods it <rfc2119>must</rfc2119> be
                  either <code>UTF-8</code> or <code>UTF-16</code>. </p>
               <imp-def-feature id="idf-defaults-serialization">The default value of the
                     <code>encoding</code> attribute of the <elcode>xsl:output</elcode> element is
                  implementation-defined. Where the encoding is UTF-8, the default for the
                     <code>byte-order-mark</code> attribute is
                  implementation-defined.</imp-def-feature>
            </item>
            <item>
               <p>The <code>byte-order-mark</code> attribute defines whether a byte order mark is
                  written at the start of the file. If the value <code>yes</code> is specified, a
                  byte order mark is written; if <code>no</code> is specified, no byte order mark is
                  written. The default value depends on the encoding used. If the encoding is
                     <code>UTF-16</code>, the default is <code>yes</code>; for <code>UTF-8</code> it
                  is <termref def="dt-implementation-defined"/>, and for all other encodings it is
                     <code>no</code>. The value of the byte order mark indicates whether high order
                  bytes are written before or after low order bytes; the actual byte order used is
                     <termref def="dt-implementation-dependent">implementation-dependent</termref>,
                  unless it is defined by the selected encoding. </p>
            </item>
            <item>
               <p> The <code>cdata-section-elements</code> attribute is a whitespace-separated list
                  of QNames. The default value is an empty list. After expansion of these names
                  using the in-scope namespace declarations for the <elcode>xsl:output</elcode>
                  declaration in which they appear, this list of names provides the value of the
                     <code>cdata-section-elements</code> parameter to the serialization method. In
                  the case of an unprefixed name, the default namespace (that is, the namespace
                  declared using <code>xmlns="uri"</code>) is used. </p>
               <note>
                  <p>This differs from the rule for most other QNames used in a stylesheet. The
                     reason is that these names refer to elements in the result document, and
                     therefore follow the same convention as the name of a literal result element or
                     the <code>name</code> attribute of <elcode>xsl:element</elcode>.</p>
               </note>
            </item>
            <item>
               <p> The value of the <code>doctype-system</code> attribute provides the value of the
                     <code>doctype-system</code> parameter to the serialization method. If the attribute is absent or has a zero-length
                     string as its value, then the serialization parameter is not set (is
                     “absent”).
               </p>

            </item>
            <item>
               <p> The value of the <code>doctype-public</code> attribute provides the value of the
                     <code>doctype-public</code> parameter to the serialization method. If the attribute is absent or has a zero-length
                     string as its value, then the serialization parameter is not set (is
                     “absent”).
               </p>
               <!--Text inserted by erratum E3 change 1"-->
               <p>The value of <code>doctype-public</code> must conform to the rules for a <xnt spec="XML" ref="PubidLiteral">PubidLiteral</xnt> (see <bibref ref="REC-xml"/>).</p>
               <!--End of text inserted by erratum E3-->
            </item>
            <item diff="add" at="2023-05-31">
               <p> The value of the <code>escape-solidus</code> attribute provides the value
                  of the <code>escape-solidus</code> parameter to the serialization method.
                  The default value is <code>yes</code>. </p>
            </item>
            <item>
               <p> The value of the <code>escape-uri-attributes</code> attribute provides the value
                  of the <code>escape-uri-attributes</code> parameter to the serialization method.
                  The default value is <code>yes</code>. </p>
            </item>
            <item>
               <p> The value of the <code>html-version</code> attribute provides
                  the value of the <code>html-version</code> parameter to the serialization method.
                  The set of permitted values, and the default value, are <termref def="dt-implementation-defined">implementation-defined</termref>. A <termref def="dt-serialization-error">serialization error</termref> will be reported if
                  the requested version is not supported by the implementation. </p>
               <note>
                  <p>This serialization parameter is new in version 3.0. If it is
                     absent, the html output method uses the value of the <code>version</code>
                     parameter in its place. For XHTML serialization, the <code>html-version</code>
                     parameter indicates the version of XHTML to be used, while the
                        <code>version</code> parameter indicates the version of XML.</p>
               </note>
            </item>
            <item>
               <p> The value of the <code>include-content-type</code> attribute provides the value
                  of the <code>include-content-type</code> parameter to the serialization method.
                  The default value is <code>yes</code>. </p>
            </item>
            <item>
               <p> The value of the <code>indent</code> attribute provides the value of the
                     <code>indent</code> parameter to the serialization method. The default value is
                     <code>yes</code> in the case of the <code>html</code> and <code>xhtml</code>
                  output methods, <code>no</code> in the case of the <code>xml</code> output method.
               </p>
            </item>
            <item>
               <p> The value of the <code>item-separator</code> attribute provides the value of the
                     <code>item-separator</code> parameter to the serialization method. The value of
                  the serialization parameter can be any string (including a zero-length string), or
                  absent. To set the parameter to absent, the <code>item-separator</code> attribute
                  can either be omitted, or set to the special value
                     <code>item-separator="#absent"</code>; it is not possible to set the value of
                  the serialization parameter to the literal 7-character string <code>"#absent"</code>. </p>
               <note>
                  <p>The <code>item-separator</code> attribute has no
                     effect if the sequence being serialized contains only one item<phrase diff="del" at="2022-01-01">, which will
                     always be the case if the <termref def="dt-effective-value"/> of <code>build-tree</code> is
                        <code>yes</code></phrase>. <phrase diff="add" at="2022-01-01">[XSLT 3.0 Erratum E14, bug 30208].</phrase></p>
               </note>
            </item>
            <item>
               <p> The value of the <code>media-type</code> attribute provides the value of the
                     <code>media-type</code> parameter to the serialization method. The default
                  value is <code>text/xml</code> in the case of the <code>xml</code> output method,
                     <code>text/html</code> in the case of the <code>html</code> and
                     <code>xhtml</code> output methods, and <code>text/plain</code> in the case of
                  the <code>text</code> output method. <phrase diff="add" at="2022-01-01">The default for 
                     the <code>json</code> output method is <code>application/json</code>; the default 
                     for the adaptive output method is <termref def="dt-implementation-defined"/>.
                  [XSLT 3.0 Erratum E26, bug 30245].</phrase></p>
            </item>
            <item>
               <p> The value of the <code>normalization-form</code> attribute provides the value of
                  the <code>normalization-form</code> parameter to the serialization method. A value
                  that is an <code>NMTOKEN</code> other than one of those enumerated for the
                     <code>normalization-form</code> attribute specifies an implementation-defined
                  normalization form; the behavior in this case is not specified by this document.
                  The default value is <code>none</code>. </p>
            </item>
            <item>
               <p> The value of the <code>omit-xml-declaration</code> attribute provides the value
                  of the <code>omit-xml-declaration</code> parameter to the serialization method.
                  The default value is <code>no</code>. </p>
            </item>
            <item>
               <p> The value of the <code>standalone</code> attribute provides the value of the
                     <code>standalone</code> parameter to the serialization method. The default
                  value is <code>omit</code>; this means that no <code>standalone</code> attribute
                  is to be included in the XML declaration. </p>
            </item>
            <item>
               <p> The <code>suppress-indentation</code> attribute is a whitespace-separated list of
                  QNames. The default value is an empty list. After expansion of these names using
                  the in-scope namespace declarations for the <elcode>xsl:output</elcode>
                  declaration in which they appear, this list of names provides the value of the
                     <code>suppress-indentation</code> parameter to the serialization method. In the
                  case of an unprefixed name, the default namespace (that is, the namespace declared
                  using <code>xmlns="uri"</code>) is used. </p>
               <note>
                  <p>This differs from the rule for most other QNames used in a stylesheet. The
                     reason is that these names refer to elements in the result document, and
                     therefore follow the same convention as the name of a literal result element or
                     the <code>name</code> attribute of <elcode>xsl:element</elcode>.</p>
               </note>
            </item>
            <item>
               <p> The value of the <code>undeclare-prefixes</code> attribute provides the value of the
                  <code>undeclare-prefixes</code> parameter to the serialization method. The default
                  value is <code>no</code>.</p>
            </item>
            <item>
               <p>The <code>use-character-maps</code> attribute provides a list of named character
                  maps that are used in conjunction with this <termref def="dt-output-definition">output definition</termref>. The way this attribute is used is described in
                     <specref ref="character-maps"/>. The default value is an empty list.</p>
            </item>
            <item>
               <p> The value of the <code>version</code> attribute provides the value of the
                     <code>version</code> parameter to the serialization method. The set of
                  permitted values, and the default value, are <termref def="dt-implementation-defined">implementation-defined</termref>. A <termref def="dt-serialization-error">serialization error</termref> will be reported if
                  the requested version is not supported by the implementation.
                  <!--The default value depends on the output method: it is <code>1.0</code> for <code>xml</code>,
						<code>4.01</code> for <code>html</code>, and <code>1.0</code> for <code>xhtml</code>. The 
						parameter is not used by the text output method.-->
               </p>
            </item>
         </ulist>
         
         <imp-def-feature id="idf-spec-serversions">It is implementation-defined which versions of
            XML, HTML, and XHTML are supported in the <code>version</code> attribute of the
               <elcode>xsl:output</elcode> declaration.</imp-def-feature>

         <p>If the processor performs serialization, then it must signal any  serialization errors that occur. These have the same
            effect as <termref def="dt-dynamic-error"> dynamic errors</termref>: that is, the processor must
            signal the error and must not finish as if the transformation had been successful.</p>
         <div2 id="character-maps">
            <head>Character Maps</head>
            <p>
               <termdef id="dt-character-map" term="character map">A <term>character map</term>
                  allows a specific character appearing in a text or attribute node in the <termref def="dt-final-result-tree">final result tree</termref> to be substituted by a
                  specified string of characters during serialization.</termdef> The effect of
               character maps is defined in <bibref ref="xslt-xquery-serialization-30"/>.</p>
            <p>The character map that is supplied as a parameter to the serializer is determined
               from the <elcode>xsl:character-map</elcode> elements referenced from the
                  <elcode>xsl:output</elcode> declaration for the selected <termref def="dt-output-definition">output definition</termref>.</p>
            <p>The <elcode>xsl:character-map</elcode> element is a declaration that may appear as a
               child of the <elcode>xsl:stylesheet</elcode> element.</p>
            <?element xsl:character-map?>
            <p>The <elcode>xsl:character-map</elcode> declaration declares a character map with a
               name and a set of character mappings. The character mappings are specified by means
               of <elcode>xsl:output-character</elcode> elements contained either directly within
               the <elcode>xsl:character-map</elcode> element, or in further character maps
               referenced in the <code>use-character-maps</code> attribute.</p>
            <p>The <rfc2119>required</rfc2119>
               <code>name</code> attribute provides a name for the character map. When a character
               map is used by an <termref def="dt-output-definition">output definition</termref> or
               another character map, the character map with the highest <termref def="dt-import-precedence">import precedence</termref> is used.</p>
            <p>The name of a character map is local to the <termref def="dt-package">package</termref> in which its declaration appears; it may be
               referenced only from within the same package.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="1580">
                  <p>It is a <termref def="dt-static-error">static error</termref> if a <termref def="dt-package">package</termref> contains two
                     or more character maps with the same name and the same <termref def="dt-import-precedence">import precedence</termref>, unless it also
                     contains another character map with the same name and higher import
                     precedence.</p>
               </error>
            </p>
            <p>The optional <code>use-character-maps</code> attribute lists the names of further
               character maps that are included into this character map.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="1590">
                  <p>It is a <termref def="dt-static-error">static error</termref> if a name in the
                        <code>use-character-maps</code> attribute of the <elcode>xsl:output</elcode>
                     or <elcode>xsl:character-map</elcode> elements does not match the
                        <code>name</code> attribute of any <elcode>xsl:character-map</elcode> in the
                        containing <termref def="dt-package">package</termref>.</p>
               </error>
            </p>
            <p>
               <error spec="XT" type="static" class="SE" code="1600">
                  <p>It is a <termref def="dt-static-error">static error</termref> if a character
                     map references itself, directly or indirectly, via a name in the
                        <code>use-character-maps</code> attribute.</p>
               </error>
            </p>
            <p>It is not an error if the same character map is referenced more than once, directly
               or indirectly.</p>
            <p>An <termref def="dt-output-definition">output definition</termref>, after recursive
               expansion of character maps referenced via its <code>use-character-maps</code>
               attribute, may contain several mappings for the same character. In this situation,
               the last character mapping takes precedence. To establish the ordering, the following
               rules are used:</p>
            <ulist>
               <item>
                  <p>Within a single <elcode>xsl:character-map</elcode> element, the characters
                     defined in character maps referenced in the <code>use-character-maps</code>
                     attribute are considered before the characters defined in the child
                        <elcode>xsl:output-character</elcode> elements.</p>
               </item>
               <item>
                  <p>The character maps referenced in a single <code>use-character-maps</code>
                     attribute are considered in the order in which they are listed in that
                     attribute. The expansion is depth-first: each referenced character map is fully
                     expanded before the next one is considered.</p>
               </item>
               <item>
                  <p>Two <elcode>xsl:output-character</elcode> elements appearing as children of the
                     same <elcode>xsl:character-map</elcode> element are considered in document
                     order.</p>
               </item>
            </ulist>
            <p>The <elcode>xsl:output-character</elcode> element is defined as follows:</p>
            <?element xsl:output-character?>
            <p>The character map that is passed as a parameter to the serializer contains a mapping
               for the character specified in the <code>character</code> attribute to the string
               specified in the <code>string</code> attribute. </p>
            <p>Character mapping is not applied to characters for which output escaping has been
               disabled as described in <specref ref="disable-output-escaping"/>.</p>
            <p>If a character is mapped, then it is not subjected to XML or HTML escaping.</p>
            <example>
               <head>Using Character Maps to Generate Non-XML Output</head>
               <p>Character maps can be useful when producing serialized output in a format that
                  resembles, but is not strictly conformant to, HTML or XML. For example, when the
                  output is a JSP page, there might be a need to generate the output:</p>
               <eg role="non-xml" xml:space="preserve">&lt;jsp:setProperty name="user" property="id" value='&lt;%= "id" + idValue %&gt;'/&gt;</eg>
               <p>Although this output is not well-formed XML or HTML, it is valid in Java Server
                  Pages. This can be achieved by allocating three Unicode characters (which are not
                  needed for any other purpose) to represent the strings <code>&lt;%</code>,
                     <code>%&gt;</code>, and <code>"</code>, for example:</p>
               <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:character-map name="jsp"&gt;
  &lt;xsl:output-character character="«" string="&amp;lt;%"/&gt;   
  &lt;xsl:output-character character="»" string="%&amp;gt;"/&gt;
  &lt;xsl:output-character character="§" string='"'/&gt;
&lt;/xsl:character-map&gt;</eg>
               <p>When this character map is referenced in the <elcode>xsl:output</elcode>
                  declaration, the required output can be produced by writing the following in the
                  stylesheet:</p>
               <eg role="non-xml" xml:space="preserve">&lt;jsp:setProperty name="user" property="id" value='«= §id§ + idValue »'/&gt;</eg>
               <p>This works on the assumption that when an apostrophe or quotation mark is
                  generated as part of an attribute value by the use of character maps, the
                  serializer will (where possible) use the other choice of delimiter around the
                  attribute value.</p>
            </example>
            <example>
               <head>Constructing a Composite Character Map</head>
               <p>The following example illustrates a composite character map constructed in a
                  modular fashion:</p>
               <eg role="xslt-declarations" xml:space="preserve">
&lt;xsl:output name="htmlDoc" use-character-maps="htmlDoc" /&gt;

&lt;xsl:character-map name="htmlDoc"
  use-character-maps="html-chars doc-entities windows-format" /&gt;
  
&lt;xsl:character-map name="html-chars"
  use-character-maps="latin1 ..." /&gt;

&lt;xsl:character-map name="latin1"&gt;
  &lt;xsl:output-character character="&amp;#160;" string="&amp;amp;nbsp;" /&gt;
  &lt;xsl:output-character character="&amp;#161;" string="&amp;amp;iexcl;" /&gt;
  ...
&lt;/xsl:character-map&gt;

&lt;xsl:character-map name="doc-entities"&gt;
  &lt;xsl:output-character character="&amp;#xE400;" string="&amp;amp;t-and-c;" /&gt;
  &lt;xsl:output-character character="&amp;#xE401;" string="&amp;amp;chap1;" /&gt;
  &lt;xsl:output-character character="&amp;#xE402;" string="&amp;amp;chap2;" /&gt;
  ...
&lt;/xsl:character-map&gt;

&lt;xsl:character-map name="windows-format"&gt;
  &lt;!-- newlines as CRLF --&gt;
  &lt;xsl:output-character character="&amp;#xA;" string="&amp;#xD;&amp;#xA;" /&gt;

  &lt;!-- tabs as three spaces --&gt;
  &lt;xsl:output-character character="&amp;#x9;" string="   " /&gt;

  &lt;!-- images for special characters --&gt;
  &lt;xsl:output-character character="&amp;#xF001;"
    string="&amp;lt;img src='special1.gif' /&amp;gt;" /&gt;
  &lt;xsl:output-character character="&amp;#xF002;"
    string="&amp;lt;img src='special2.gif' /&amp;gt;" /&gt;
  ...
&lt;/xsl:character-map&gt;</eg>
            </example>
            <note>
               <p>When character maps are used, there is no guarantee that the serialized output
                  will be well-formed XML (or HTML). Furthermore, the fact that the result tree was
                  validated against a schema gives no guarantee that the serialized output will
                  still be valid against the same schema. Conversely, it is possible to use
                  character maps to produce schema-valid output from a result tree that would fail
                  validation.</p>
            </note>
         </div2>
         <div2 id="disable-output-escaping">
            <head>Disabling Output Escaping</head>
            <p>Normally, when using the XML, HTML, or XHTML output method, the serializer will
               escape special characters such as <code>&amp;</code> and <code>&lt;</code> when
               outputting text nodes. This ensures that the output is well-formed. However, it is
               sometimes convenient to be able to produce output that is almost, but not quite
               well-formed XML; for example, the output may include ill-formed sections which are
               intended to be transformed into well-formed XML by a subsequent non-XML-aware
               process. For this reason, XSLT defines a mechanism for disabling output escaping.</p>
            <p>This feature is <termref def="dt-deprecated">deprecated</termref>.</p>
            <p>This is an optional feature: it is not <rfc2119>required</rfc2119> that an XSLT
               processor that implements the serialization option <rfc2119>should</rfc2119> offer
               the ability to disable output escaping, and there is no conformance level that
               requires this feature.</p>
            <p>This feature requires the serializer (described in <bibref ref="xslt-xquery-serialization-30"/>) 
               to be extended as follows. Conceptually, the <termref def="dt-final-result-tree">final result tree</termref> provides an additional
               boolean property <code>disable-escaping</code> associated with every character in a
               text node. When this property is set, the normal action of the serializer to escape
               special characters such as <code>&amp;</code> and <code>&lt;</code> is
               suppressed.</p>
            <p>An <elcode>xsl:value-of</elcode> or <elcode>xsl:text</elcode> element may have a
                  <code>disable-output-escaping</code> attribute; the allowed values are
                  <code>yes</code> or <code>no</code>. The default is <code>no</code>; if the value
               is <code>yes</code>, then every character in the text node generated by evaluating
               the <elcode>xsl:value-of</elcode> or <elcode>xsl:text</elcode> element
                  <rfc2119>should</rfc2119> have the <code>disable-escaping</code> property set.</p>
            <example>
               <head>Disable Output Escaping</head>
               <p>For example,</p>
               <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:text disable-output-escaping="yes"&gt;&amp;lt;&lt;/xsl:text&gt;</eg>
               <p>should generate the single character <code>&lt;</code>.</p>
            </example>
            <p>If output escaping is disabled for an <elcode>xsl:value-of</elcode> or
                  <elcode>xsl:text</elcode> instruction evaluated when <termref def="dt-temporary-output-state">temporary output state</termref> is in effect, the
               request to disable output escaping is ignored.</p>
            <p>Similarly, if an <elcode>xsl:value-of</elcode> or
                  <elcode>xsl:text</elcode> instruction specifies that output escaping is to be
               disabled when writing to a <termref def="dt-final-result-tree">final result
                  tree</termref> that is not being serialized, the request to disable output
               escaping is ignored.</p>
            <note>
               <p>Furthermore, a request to disable output escaping has no effect when the newly
               constructed text node is used to form the value of an attribute, comment, processing instruction,
               or namespace node. This is because the rules for constructing such nodes (see <specref ref="constructing-simple-content"/>)
               cause the text node to be atomized, and the process of atomizing a text node takes no
               account of the disable-escaping property.</p>
            </note>
            <p>If output escaping is disabled for text within an element that would normally be
               output using a CDATA section, because the element is listed in the
                  <code>cdata-section-elements</code>, then the relevant text will not be included
               in a CDATA section. In effect, CDATA is treated as an alternative escaping mechanism,
               which is disabled by the <code>disable-output-escaping</code> option.</p>
            <example>
               <head>Interaction of Output Escaping and CDATA</head>
               <p>For example, if <code>&lt;xsl:output cdata-section-elements="title"/&gt;</code> is
                  specified, then the following instructions:</p>
               <eg role="xslt-instruction" xml:space="preserve">&lt;title&gt;
  &lt;xsl:text disable-output-escaping="yes"&gt;This is not &amp;lt;hr/&amp;gt; 
                                          good coding practice&lt;/xsl:text&gt;
&lt;/title&gt;</eg>
               <p>should generate the output:</p>
               <eg role="xml" xml:space="preserve">&lt;title&gt;&lt;![CDATA[This is not ]]&gt;&lt;hr/&gt;&lt;![CDATA[ good coding practice]]&gt;&lt;/title&gt;</eg>
            </example>
            <p>The <code>disable-output-escaping</code> attribute may be used with the
                  <code>html</code> output method as well as with the <code>xml</code> output
               method. The <code>text</code> output method ignores the
                  <code>disable-output-escaping</code> attribute, since this method does not perform
               any output escaping.</p>
            <p>A <termref def="dt-processor">processor</termref> will only be able to disable output
               escaping if it controls how the <termref def="dt-final-result-tree">final result
                  tree</termref> is output. This might not always be the case. For example, the
               result tree might be used as a <termref def="dt-source-tree">source tree</termref>
               for another XSLT transformation instead of being output. It is <termref def="dt-implementation-defined">implementation-defined</termref> whether (and
               under what circumstances) disabling output escaping is supported. If disabling output escaping is not supported, any request to disable
                  output escaping is ignored.</p>
            

            
            <imp-def-feature id="idf-feature-doe">It is implementation-defined whether, and under
               what circumstances, disabling output escaping is supported.</imp-def-feature>
            <p>If output escaping is disabled for a character that is not representable in the
               encoding that the <termref def="dt-processor">processor</termref> is using for
               output, the request to disable output escaping is ignored in respect of that
               character.</p>
            <p>Since disabling output escaping might not work with all implementations and can
               result in XML that is not well-formed, it <rfc2119>should</rfc2119> be used only when
               there is no alternative.</p>
            <note>
               <p>When disable-output-escaping is used, there is no guarantee that the serialized
                  output will be well-formed XML (or HTML). Furthermore, the fact that the result
                  tree was validated against a schema gives no guarantee that the serialized output
                  will still be valid against the same schema. Conversely, it is possible to use
                  disable-output-escaping to produce schema-valid output from a result tree that
                  would fail validation.</p>
            </note>
            <note>
               <p>The facility to define character maps for use during serialization, as described
                  in <specref ref="character-maps"/>, has been produced as an alternative mechanism
                  that can be used in many situations where disabling of output escaping was
                  previously necessary, without the same difficulties.</p>
            </note>
         </div2>
      </div1>
      <div1 id="conformance">
         <head>Conformance</head>
         <p>A <termref def="dt-processor">processor</termref> that claims
            conformance with this specification <rfc2119>must</rfc2119> satisfy the conformance
            requirements for a <termref def="dt-basic-xslt-processor">basic XSLT processor</termref>
            and for each of the optional features with which it claims conformance.</p>
         <p>The following optional features are defined:</p>
         <olist>
            <item>
               <p>The schema-awareness feature, defined in <specref ref="schema-aware-conformance"/></p>
            </item>
            <item>
               <p>The serialization feature, defined in <specref ref="serialization-feature"/></p>
            </item>
            <item>
               <p>The backwards compatibility feature, defined in <specref ref="backwards-compatibility-feature"/></p>
            </item>
            <item>
               <p>The streaming feature, defined in <specref ref="streaming-feature"/>.</p>
            </item>
            <item>
               <p>The dynamic evaluation feature, defined in <specref ref="dynamic-evaluation-feature"/>.</p>
            </item>
            <item diff="del" at="2023-01-29">
               <p>The higher-order functions feature, defined in
               <specref ref="hof-feature"/>.</p>
            </item>
            <item diff="del" at="2022-01-01">
               <p>The XPath 3.1 feature, defined in ... .</p>
            </item>
            
         </olist>

         <p>A processor that does not claim conformance with an optional feature
               <rfc2119>must</rfc2119> satisfy the requirements for processors that do not implement
            that feature.</p>

         <note>
            <p>There is no conformance level or feature defined in this specification that requires
               implementation of the static typing features described in <bibref ref="xpath-30"/>.
               An XSLT processor may provide a user option to invoke static typing, but to be
               conformant with this specification it must allow a stylesheet to be processed with
               static typing disabled. The interaction of XSLT stylesheets with the static typing
               feature of XPath 3.0 has not been specified, so
               the results of using static typing, if available, are implementation-defined.</p>
         </note>
         <p>An XSLT processor takes as its inputs a stylesheet and zero or more XDM trees conforming to the data model defined in <bibref ref="xpath-datamodel-30"/>. It is not <rfc2119>required</rfc2119> that the processor
            supports any particular method of constructing XDM trees, but conformance can only be
            tested if it provides a mechanism that enables XDM trees representing the stylesheet and
            primary source document to be constructed and supplied as input to the processor.</p>
         <p>The output of the XSLT processor consists of zero or more <termref def="dt-final-result-tree">final result trees</termref>. It is not
               <rfc2119>required</rfc2119> that the processor supports any particular method of
            accessing a final result tree, but if it does not support the serialization feature, conformance can only be tested if it provides
            some alternative mechanism that enables access to the results of the transformation.</p>
         <p>Certain facilities in this specification are described as producing <termref def="dt-implementation-defined">implementation-defined</termref> results. A claim
            that asserts conformance with this specification <rfc2119>must</rfc2119> be accompanied
            by documentation stating the effect of each implementation-defined feature. For
            convenience, a non-normative checklist of implementation-defined features is provided at
               <specref ref="implementation-defined-features"/>.</p>
         <p>A conforming <termref def="dt-processor">processor</termref>
            <rfc2119>must</rfc2119> signal any <termref def="dt-static-error">static error</termref>
            occurring in the stylesheet, or in any XPath <termref def="dt-expression">expression</termref>, except where specified otherwise either for individual error
            conditions or under the general provisions for <termref def="dt-forwards-compatible-behavior"/> (see <specref ref="forwards"/>). After
            signaling such an error, the processor <rfc2119>may</rfc2119> continue for the purpose
            of signaling additional errors, but <rfc2119>must</rfc2119> terminate abnormally without
            performing any transformation.</p>
         <p>When a <termref def="dt-dynamic-error">dynamic error</termref> occurs during the course
            of a transformation, and is not caught using
                  <elcode>xsl:catch</elcode>,
             the processor
               <rfc2119>must</rfc2119> signal it and <rfc2119>must</rfc2119> eventually terminate
            abnormally. </p>
         <p>Some errors, notably <termref def="dt-type-error">type errors</termref>,
               <rfc2119>may</rfc2119> be treated as <termref def="dt-static-error">static
               errors</termref> or <termref def="dt-dynamic-error">dynamic errors</termref> at the
            discretion of the processor.</p>
         <p>A conforming processor <rfc2119>may</rfc2119> impose limits on the processing resources
            consumed by the processing of a stylesheet.</p>

         <p>The mandatory requirements of this specification are taken to
            include the mandatory requirements of <bibref ref="xpath-30"/>, <bibref ref="xpath-datamodel-30"/>, and <bibref ref="xpath-functions-40"/>. An XSLT 3.0
            processor <rfc2119>must</rfc2119> provide a mode of operation which conforms to the 3.0
            versions of those specifications as extended by <specref ref="map"/> and <specref ref="json"/>.</p>

         <p diff="del" at="2022-01-01">A processor <rfc2119>may</rfc2119> also provide a mode of
            operation which conforms to the 3.1 versions of those specifications; in this case it
            must do so as described in XPath 3.1 feature.</p>

         <p>A processor <rfc2119>may</rfc2119> also provide a mode of
            operation which conforms to versions of those specifications later than the 3.1
            versions; in such cases the detail of how XSLT 3.0 interacts with new features
            introduced by such later versions (for example, extensions to the data model) is
               <termref def="dt-implementation-defined"/>.</p>

         <imp-def-feature id="idf-spec-xpath">It is <termref def="dt-implementation-defined"/>
            whether (and if so how) an XSLT 3.0 processor is able to work with versions of XPath
            later than XPath 3.1.</imp-def-feature>



         <p>A requirement is mandatory unless the specification includes wording (such as the use of
            the words <rfc2119>should</rfc2119> or <rfc2119>may</rfc2119>) that clearly indicates
            that it is optional.</p>
         
         <p>Some of the optional features are defined in such a way that
         if the feature is not provided, the data model is constrained to exclude certain kinds of
         item. For example:</p>
         
         <ulist>
            <item><p>A processor that does not provide the <termref def="dt-schema-aware-xslt-processor">schema-awareness</termref>
            feature restricts the data model so that it does not contain atomic values of types other than the built-in types,
            or nodes with non-trivial type annotations.</p></item>
            <item diff="del" at="2023-01-29"><p>A processor that does not provide the <termref def="dt-hof-feature"/> constrains the data model so that
            it does not contain function items other than maps or arrays.</p></item>
            <item diff="del" at="2022-01-01"><p>A processor that does not provide the XPath 3.1 feature constrains the data model so that
               it does not contain arrays.</p></item>
         </ulist>
         
         <p><error spec="XT" type="dynamic" class="DE" code="1665">
            <p>A <termref def="dt-dynamic-error"/> <rfc2119>may</rfc2119> be raised if the
               input to the processor includes an item that requires availability
               of an optional feature that the processor does not provide.</p></error></p>
         
         <note><p>It is not necessarily possible to trigger this error. A processor that does
         not provide an optional feature might not define or recognize any representation of the items
         that are disallowed. The error code is provided for use in cases where a processor is able
         to interoperate with other software that does not have the same constraints — for example,
         where a package compiled with a non-schema-aware processor is able to invoke functions in a package
         that was compiled with a schema-aware processor. Even in that case,
         processors have the option of filtering or converting the input so that it meets the relevant
         constraints: for example, a non-schema-aware processor when presented with a schema-validated
         document in the form of a PSVI might simply ignore the properties it does not understand.</p>
            
            <p>The dynamic error is optional: for example a processor might report no error
            if the offending item is not actually used.</p>
         
            <p>The phrase <emph>input to the processor</emph> is deliberately wide: it includes (inter alia)
               the <termref def="dt-global-context-item"/>, items present in the <termref def="dt-initial-match-selection"/>, items passed as <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>, items returned by functions such as 
                <function>document</function>, <xfunction>doc</xfunction>, and
               <xfunction>collection</xfunction>, items returned by <termref def="dt-extension-function">extension functions</termref> and <termref def="dt-extension-instruction">extension instructions</termref>,
            items supplied in function or template parameters or results across package boundaries, and nodes
            reachable from any of the above by axis navigation.</p></note>


         <div2 id="basic-conformance">
            <head>Basic XSLT Processor</head>
            <p>
               <termdef id="dt-basic-xslt-processor" term="basic XSLT processor">A <term>basic XSLT
                     processor</term> is an XSLT processor that implements all the mandatory
                  requirements of this specification with the exception of constructs explicitly
                  associated with an optional feature.</termdef> These constructs are listed
               below.</p>

            <!--<p>A <termref def="dt-basic-xslt-processor">basic XSLT processor</termref> 
               <rfc2119>must</rfc2119> enforce the following restrictions. It
                  <rfc2119>must</rfc2119> signal a static or dynamic error when the restriction is
               violated, as described below.</p>-->

         </div2>
         <div2 id="schema-aware-conformance">
            <head>Schema-Awareness Conformance Feature</head>

            <p>A conformant processor <rfc2119>must</rfc2119> either be a conformant <termref def="dt-schema-aware-xslt-processor"/> or a conformant <termref def="dt-non-schema-aware-processor"/>.</p>
            <p>
               <termdef id="dt-schema-aware-xslt-processor" term="schema-aware XSLT processor">A
                     <term>schema-aware XSLT processor</term> is an XSLT processor that implements
                  the mandatory requirements of this specification connected with the
                     <elcode>xsl:import-schema</elcode> declaration, the
                     <code>[xsl:]validation</code> and <code>[xsl:]type attributes</code>, and the
                  ability to handle input documents whose nodes have type annotations other than
                     <code>xs:untyped</code> and <code>xs:untypedAtomic</code>. The mandatory
                  requirements of this specification are taken to include the mandatory requirements
                  of XPath 3.0, as described in <bibref ref="xpath-30"/>. A requirement is mandatory unless the specification includes
                  wording (such as the use of the words <rfc2119>should</rfc2119> or
                     <rfc2119>may</rfc2119>) that clearly indicates that it is optional.</termdef>
            </p>

            <p><termdef id="dt-non-schema-aware-processor" term="non-schema-aware processor">A <term>non-schema-aware processor</term> is a
                  processor that does not claim conformance with the schema-aware conformance
                  feature. Such a processor <rfc2119>must</rfc2119> handle constructs associated
                  with schema-aware processing as described in this section.</termdef></p>


            <p>
               <error spec="XT" type="static" class="SE" code="1650">
                  <p>A <termref def="dt-non-schema-aware-processor">non-schema-aware
                        processor</termref>
                     <rfc2119>must</rfc2119> signal a <termref def="dt-static-error">static
                        error</termref> if a <termref def="dt-package">package</termref> includes an
                        <elcode>xsl:import-schema</elcode> declaration.</p>
               </error>
            </p>
            <note>
               <p>A processor that rejects an <elcode>xsl:import-schema</elcode> declaration will
                  also reject any reference to a user-defined type defined in a schema, or to a
                  user-defined element or attribute declaration; it will not, however, reject
                  references to the built-in types listed in <specref ref="built-in-types"/>.</p>
            </note>
            <p>A <termref def="dt-non-schema-aware-processor">non-schema-aware
                  processor</termref> is not able to validate input documents, and is not able to
               handle input documents containing type annotations other than <code>xs:untyped</code>
               or <code>xs:untypedAtomic</code>. Therefore, such a processor <rfc2119>must</rfc2119>
               treat any <code>[xsl:]validation</code> attribute
                  with a value of <code>preserve</code> or <code>lax</code>, or a
                     <code>[xsl:]default-validation</code> attribute with a value of
                     <code>preserve</code> as if the value were <code>strip</code>.</p>

            <note>
               <p>The values <code>lax</code> and <code>preserve</code> indicate that the validation
                  to be applied depends on the calling application, so it is appropriate for the
                  request to be treated differently by different kinds of processor. By contrast,
                  requesting <code>strict</code> validation, either through the
                     <code>[xsl:]validation</code> attribute or the <code>type</code> attribute,
                  indicates that the stylesheet is expecting to deal with typed data, and therefore
                  cannot be processed without performing the validation.</p>
            </note>
            <p>
               <error spec="XT" type="static" class="SE" code="1660">
                  <p>A <termref def="dt-non-schema-aware-processor">non-schema-aware
                        processor</termref>
                     <rfc2119>must</rfc2119> signal a <termref def="dt-static-error">static
                        error</termref> if a <termref def="dt-package">package</termref> includes an
                        <code>[xsl:]type</code> attribute; or an <code>[xsl:]validation</code> or
                        <code>[xsl:]default-validation</code> attribute with a value other than
                        <code>strip</code>, <code>preserve</code>, or
                           <code>lax</code>; or an
                           <elcode>xsl:mode</elcode> element whose <code>typed</code> attribute is
                        equal to <code>yes</code> or <code>strict</code>; or an <code>as</code>
                              attribute whose value is a 
                              <termref def="dt-sequence-type"/> that can only match
                        nodes with a type annotation other than <code>xs:untyped</code> or
                           <code>xs:untypedAtomic</code> (for example, <code>as="element(*,
                           xs:integer)"</code>).</p>
               </error>
            </p>
            <p>A <termref def="dt-non-schema-aware-processor">non-schema-aware processor</termref>
               constrains the data model as follows, and raises a <termref def="dt-dynamic-error"/> (<errorref spec="XT" class="DE" code="1665"/>) if the
                  constraints are not satisfied:</p>
            <ulist>
               <item>
                  <p>Atomic values <rfc2119>must</rfc2119> belong to one of the atomic types listed
                     in <specref ref="built-in-types"/> (except as noted below).</p>
                  <p>An atomic value may also belong to an implementation-defined type that has been
                     added to the context for use with <termref def="dt-extension-function">extension functions</termref> or <termref def="dt-extension-instruction">extension instructions</termref>.</p>
                  <p>The set of constructor functions available are limited to those that construct
                     values of the above atomic types.</p>
                  <p>The static context, which defines the full set of type names recognized by an
                     XSLT processor and also by the XPath processor, includes these atomic types,
                     plus <code>xs:anyType</code>, <code>xs:anySimpleType</code>,
                        <code>xs:untyped</code>, and <code>xs:anyAtomicType</code>.</p>
               </item>
               <item>
                  <p>Element nodes <rfc2119>must</rfc2119> be annotated with the <termref def="dt-type-annotation">type annotation</termref>
                     <code>xs:untyped</code>, and attribute nodes with the type annotation
                        <code>xs:untypedAtomic</code>.</p>
               </item>
            </ulist>
            

         </div2>
         <div2 id="serialization-feature">
            <head>Serialization Feature</head>
            <p>
               <termdef id="dt-serialization-feature" term="serialization feature">A processor that
                  claims conformance with the <term>serialization feature</term>
                  <rfc2119>must</rfc2119> support the conversion of a <termref def="dt-final-result-tree">final result tree</termref> to a sequence of octets
                  following the rules defined in <specref ref="serialization"/>.</termdef> It
                  <rfc2119>must</rfc2119> respect all the attributes of the
                  <elcode>xsl:output</elcode> and <elcode>xsl:character-map</elcode> declarations,
               and <rfc2119>must</rfc2119> provide all four output methods, <code>xml</code>,
                  <code>xhtml</code>, <code>html</code>, and <code>text</code>. Where the
               specification uses words such as <rfc2119>must</rfc2119> and
                  <rfc2119>required</rfc2119>, then it <rfc2119>must</rfc2119> serialize the result
               tree in precisely the way described; in other cases it <rfc2119>may</rfc2119> use an
               alternative, equivalent representation.</p>
            <p>A processor may claim conformance with the serialization feature whether or not it
               supports the setting <code>disable-output-escaping="yes"</code> on
                  <elcode>xsl:text</elcode>, or <elcode>xsl:value-of</elcode>. </p>
            <p>A processor that does not claim conformance with the serialization feature
                  <rfc2119>must not</rfc2119> signal an error merely because the <termref def="dt-stylesheet">stylesheet</termref> contains <elcode>xsl:output</elcode> or
                  <elcode>xsl:character-map</elcode> declarations, or serialization attributes on
               the <elcode>xsl:result-document</elcode> instruction. Such a processor
                  <rfc2119>may</rfc2119> check that these declarations and attributes have valid
               values, but is not <rfc2119>required</rfc2119> to do so. Apart from optional
               validation, these declarations <rfc2119>should</rfc2119> be ignored.</p>
            
            <note>
               <p>A processor that does not claim conformance with the serialization feature
               <rfc2119>may</rfc2119> offer alternative serialization capabilities, and these
               <rfc2119>may</rfc2119> make use of the serialization parameters defined on
               <elcode>xsl:output</elcode> and/or <elcode>xsl:result-document</elcode>.
                  <phrase diff="add" at="2022-01-01">Such a processor <rfc2119>may</rfc2119> implement 
                     selected parts of the serialization capabilities defined in this specification. 
                     For example, it may implement selected output methods, or selected serialization 
                     properties. It may implement sequence normalization using the <code>item-separator</code> 
                     property even if it has no other serialization capabilities. [XSLT 3.0 Erratum E14, bug 30208].</phrase></p>
            </note>
            
            <p>If the processor claims conformance with 
               the serialization feature then it <rfc2119>must</rfc2119> fully implement the 
               <xfunction>serialize</xfunction> function defined in <phrase diff="chg" at="2022-01-01"><bibref ref="xpath-functions-40"/></phrase>,
               and <rfc2119>must not</rfc2119>
               raise error <xerrorref spec="FO40" code="0010" class="DC"/> as the result of such a call.</p>
            
            <p>If the processor does not claim conformance with
               the serialization feature, then it <rfc2119>may</rfc2119> raise 
               error <xerrorref spec="FO40" code="0010" class="DC"/> in respect of some or
               all calls on the <xfunction>serialize</xfunction> function; it <rfc2119>must not</rfc2119>
               return a result from a call on this function unless the result is conformant with
               the specification, given the parameters actually supplied. 
            </p>

            <p>A processor that claims conformance with the Serialization
               Feature must satisfy the mandatory requirements of <bibref ref="xslt-xquery-serialization-30"/>. It <rfc2119>must</rfc2119> provide a mode of
               operation which conforms to the 3.0 version of that specification. It
                  <rfc2119>may</rfc2119> also provide a mode of operation which conforms to a later
               version of that specification; in such cases the detail of how XSLT 3.0 interacts
               with new features introduced by such a version (for example, support for new
               serialization properties) is <termref def="dt-implementation-defined"/>.</p>

            <imp-def-feature id="idf-spec-serialization">It is <termref def="dt-implementation-defined"/> whether (and if so how) an XSLT 3.0 processor is
               able to work with versions of <bibref ref="xslt-xquery-serialization-30"/> later than
               3.1.</imp-def-feature>
         </div2>
         <div2 id="backwards-compatibility-feature">
            <head>Compatibility Features</head>
            <p>
               <termdef id="dt-1.0-compatibility-feature" term="XSLT 1.0 compatibility feature">A
                  processor that claims conformance with the <term>XSLT 1.0 compatibility
                     feature</term>
                  <rfc2119>must</rfc2119> support the processing of stylesheet instructions and
                  XPath expressions with <termref def="dt-xslt-10-behavior">XSLT
                     1.0 behavior</termref>, as defined in <specref ref="backwards"/>.</termdef>
            </p>
            
            <p>Note that a processor that does not claim conformance with the <termref def="dt-1.0-compatibility-feature"/>
               <rfc2119>must</rfc2119> raise a <termref def="dt-dynamic-error"> dynamic error</termref> if an instruction is
               evaluated whose <termref def="dt-effective-version"/> is 1.0. <errorref spec="XT" class="DE" code="0160"/>.</p>
            <note>
               <p>The reason this is a dynamic error rather than a static error is to allow
                  stylesheets to contain conditional logic, following different paths depending on
                  whether the XSLT processor implements XSLT 1.0, 2.0, or
                     3.0. The selection of which path to use can be controlled by using the
                     <function>system-property</function> function to test the
                     <code>xsl:version</code> system property.</p>
            </note>
            <p>A processor that claims conformance with the <termref def="dt-1.0-compatibility-feature"/>
               <rfc2119>must</rfc2119> permit the use of the namespace axis in XPath expressions
               when backwards compatible behavior is enabled. In all other circumstances, support
               for the namespace axis is optional.</p>
            <note>
               <p>There are no incompatibilities between 3.0 and 2.0 that would
                  justify a 2.0-compatibility mode. When a 3.0 processor encounters a stylesheet
                  that specifies <code>version="2.0"</code>, evaluation therefore proceeds exactly
                  as if it specified <code>version="3.0"</code>. However, a software product may
                  invoke an XSLT 2.0 processor in preference to an XSLT 3.0 processor when the
                  stylesheet specifies <code>version="2.0"</code>, in which case any use of new 3.0
                  constructs will be rejected.</p>
            </note>
         </div2>
         <div2 id="streaming-feature">
            <head>Streaming Feature</head>
            <p>
               <termdef id="dt-streaming-feature" term="streaming feature">A processor that claims
                  conformance with the <term>streaming feature</term>
                  <rfc2119>must</rfc2119> use streamed processing in cases where (a) streaming is
                  requested (for example by using the attribute <code>streamable="yes"</code> on
                  <elcode>xsl:mode</elcode>, or on
                  the <elcode>xsl:source-document</elcode> instruction) and
                  (b) the constructs in question are <termref def="dt-guaranteed-streamable"/>
                  according to this specification.</termdef>
            </p>
            <p>A processor that does not claim conformance with the streaming feature is not
               required to use streamed processing and is not required to determine whether any
               construct is guaranteed streamable. Such a processor must, however, implement the
               semantics of all constructs in the language provided that enough memory is available
               to perform the processing without streaming.</p>
            <p>A processor that conforms with the feature <rfc2119>must</rfc2119>
               return the value <code>"yes"</code> in response to the function call
                  <code>system-property('xsl:supports-streaming')</code>; a processor that does not
               conform with the feature <rfc2119>must</rfc2119> return the value
               <code>"no"</code>.</p>
            <note>
               <p>The term <emph>streamed processing</emph> as used here means the ability to
                  process arbitrarily large input documents without ever-increasing memory
                  requirements.</p>
            </note>


         </div2>
         <div2 id="dynamic-evaluation-feature">
            <head>Dynamic Evaluation Feature</head>
            <p>
               <termdef id="dt-dynamic-evaluation-feature" term="dynamic evaluation feature">A
                  processor that claims conformance with the <term>dynamic evaluation feature</term>
                  <rfc2119>must</rfc2119> evaluate the <elcode>xsl:evaluate</elcode> function as
                  described in this specification.</termdef>
            </p>
            <p>A processor that does not claim conformance with the dynamic evaluation feature
                  <rfc2119>must</rfc2119> report a dynamic error if an <elcode>xsl:evaluate</elcode>
               instruction is evaluated. It <rfc2119>must not</rfc2119> report a static error merely
               because of the presence of an <elcode>xsl:evaluate</elcode> instruction in the
               stylesheet, unless a processor that conforms with the feature would report the same
               static error.</p>

            <p>A processor that conforms with the feature <rfc2119>must</rfc2119> return the value
                  <code>"yes"</code> in response to the function call
                  <code>system-property('xsl:supports-dynamic-evaluation')</code>; a processor that
               does not conform with the feature <rfc2119>must</rfc2119> return the value
                  <code>"no"</code>.</p>

            <p>A processor that conforms with the feature <rfc2119>must</rfc2119> return the value
                  <code>true</code> in response to the function call
                  <code>element-available('xsl:evaluate')</code>; a processor that does not conform
               with the feature <rfc2119>must</rfc2119> return the value <code>false</code>.</p>

            <note>
               <p>A processor may allow dynamic evaluation to be enabled and disabled by means of
                  configuration settings, perhaps for security reasons. In consequence, it may be
                  impossible to tell during static analysis of the stylesheet whether or not the
                  feature will be available during execution. A stylesheet author wanting to check
                  whether the feature is available should therefore make the test using a run-time
                  call on <code>system-property</code>, rather than relying on tests in an
                     <code>[xsl:]use-when</code> attribute.</p>
            </note>
         </div2>
         
 
         <div2 id="hof-feature" diff="del" at="2023-01-29">
            <head>Higher-Order Functions Feature</head>
            <p><termdef id="dt-hof-feature" term="higher-order functions feature">The <term>higher-order functions feature</term>
            contains functionality connected with the use of functions as items in the data model, that can be stored in variables
            and passed to other functions.</termdef></p>
          
            <p><error type="static" spec="XT" class="SE" code="3540"><p>A processor that does not provide the 
               <termref def="dt-hof-feature"/> raises a <termref def="dt-static-error"/> if any of the following
               XPath constructs are found in an <termref def="dt-expression"/>, <termref def="dt-pattern"/>, 
               <termref def="dt-sequence-type"/>, or <code>ItemType</code>: a 
               <xnt spec="XP40" ref="prod-xpath40-TypedFunctionTest">TypedFunctionTest</xnt>, a
               <xnt spec="XP40" ref="prod-xpath40-NamedFunctionRef">NamedFunctionRef</xnt>, an
               <xnt spec="XP40" ref="prod-xpath40-InlineFunctionExpr">InlineFunctionExpr</xnt>, or an
               <xnt spec="XP40" ref="prod-xpath40-ArgumentPlaceholder">ArgumentPlaceholder</xnt></p></error>.</p>
            
            <note><p>The effect is to disallow the three constructs used to create function-valued items: named function references
            such as <code>round#1</code>, inline function expressions such as <code>function($x){$x+1}</code>, and
            partial function application such as <code>starts-with(?, '#')</code>, along with sequence types
            such as <code>function(xs:integer) as xs:string</code> that serve no useful purpose in the absence of such items.</p> 
            
            <p>The item type <code>function(*)</code> is allowed by these rules, and serves as a generic type for maps and arrays.</p></note>
            
            <p>Where a processor does not provide the <termref def="dt-hof-feature"/>, functions whose
            specification in <bibref ref="xpath-functions-31"/> labels them with the <term>higher-order</term>
            property are excluded from the static context of expressions and patterns. An attempt to reference such
            a function therefore fails in the same way as an attempt to call a non-existent function.</p>
            
            <note><p>Examples of functions labeled with this property are <xfunction>filter</xfunction>, <xfunction>for-each</xfunction>,
            <xfunction>fold-left</xfunction>, and <xfunction>fold-right</xfunction>.</p></note>
            
            <p>A processor that does not provide the higher-order functions feature constrains the data model
               by disallowing function items other than maps and arrays, and may raise a <termref def="dt-dynamic-error"/> (<errorref spec="XT" class="DE" code="1665"/>) if this
               constraint is not satisfied.</p>
            
            <p>The same rules apply to a dynamic XPath expression processed using <elcode>xsl:evaluate</elcode>.</p>
            
         </div2>
         
      </div1>
   </body>
   <back>
      <div1 id="references">
         <head>References</head>
         <div2 id="normative-references">
            <head>Normative References</head>

            <blist>
               <bibl id="xpath-datamodel-30" key="XDM 3.0"/>
               <bibl id="xpath-datamodel-31" key="XDM 3.1"/>
               <bibl id="xpath-datamodel-40" key="XDM 4.0"/>
               <bibl id="xpath-functions-30" key="Functions and Operators 3.0"/>
               <bibl id="xpath-functions-31" key="Functions and Operators 3.1"/>
               <bibl id="xpath-functions-40" key="Functions and Operators 4.0">
                 <emph>CITATION: T.B.D.</emph>
               </bibl>

               <!--World Wide Web Consortium. 
<emph>XQuery 1.0 and XPath 2.0 Functions and Operators.</emph>
W3C Working Draft. 
See <loc href="http://www.w3.org/TR/xpath-functions/"/>
					</bibl>-->
               <bibl id="xml-infoset" key="XML Information Set"/>
               <!--World Wide Web Consortium. 
					<emph>XML Information Set.</emph> W3C Recommendation. 
					See <loc href="http://www.w3.org/TR/xml-infoset/"/>
                    </bibl>-->
               <!--<bibl id="ISO3166" key="ISO 3166-1">ISO (International Organization for
                  Standardization) <emph>Codes for the representation of names of countries and
                  their subdivisions - Part 1: Country codes</emph> ISO 3166-1:1997. 
                  Second edition, 2006-11-20. </bibl>-->
               <!--<bibl id="ISO8601" key="ISO 8601">ISO (International Organization for
                  Standardization) <emph>Data elements and interchange formats - Information
                     interchange - Representation of dates and times.</emph> ISO 8601:2004,
                     Third edition, 2004-12-03. </bibl>-->
               <bibl id="ISO15924" key="ISO 15924">ISO (International Organization for
                  Standardization) <emph>Information and documentation — Codes for the
                     representation of names of scripts</emph> ISO 15924:2004, January 2004. See <loc href="https://www.iso.org/obp/ui/#!iso:std:iso:15924:ed-1:v1:en"/>.</bibl>
               <bibl id="ISO15924_register" key="ISO 15924 Register">Unicode Consortium. <emph>Codes
                     for the representation of names of scripts — Alphabetical list of
                     four-letter script codes.</emph> See <loc href="http://www.unicode.org/iso15924/iso15924-codes.html"/>. Retrieved
                  February 2013; continually updated.</bibl>
               <bibl id="xslt-xquery-serialization-30" key="XSLT and XQuery Serialization"/>
               <bibl id="xslt-xquery-serialization-31" key="XSLT and XQuery Serialization 3.1"/>
               <!--<bibl id="UNICODE-NORMALIZATION" key="Unicode Normalization">Unicode Consortium.
					<emph>Unicode Normalization Forms</emph>. Unicode Standard Annex #15.
					See <loc href="http://www.unicode.org/unicode/reports/tr15/"/>
					</bibl>-->
               <!--					<bibl id="XHTML10" key="XHTML 1.0">World Wide Web Consortium. <emph>XHTML
1.0: The Extensible HyperText Markup Language.</emph> W3C Recommendation. 
See <loc href="http://www.w3.org/TR/xhtml1/"/>. Note: a second edition of this
specification is in preparation.</bibl>-->
               <!--					<bibl id="XHTML11" key="XHTML 1.1">World Wide Web Consortium. <emph>XHTML
1.1: Module-Based XHTML.</emph> W3C Recommendation. 
See <loc href="http://www.w3.org/TR/xhtml11/"/>
</bibl>-->
               <bibl id="rfc7159" key="RFC 7159">IETF. <emph>The JavaScript Object Notation (JSON)
                     Data Interchange Format.</emph>
                  March 2014. See <loc href="http://www.ietf.org/rfc/rfc7159.txt">http://www.ietf.org/rfc/rfc7159.txt</loc>
               </bibl>

               <bibl id="UNICODE" key="UNICODE">Unicode Consortium. <emph>The Unicode
                     Standard</emph> as updated from time to time by the publication of new
                  versions. See <loc href="http://www.unicode.org/standard/versions/"/> for the
                  latest version and additional information on versions of the standard and of the
                  Unicode Character Database. The version of Unicode to be used is <termref def="dt-implementation-defined">implementation-defined</termref>, but
                  implementations are recommended to use the latest Unicode version.</bibl>
               <bibl id="UNICODE-TR10" key="UNICODE TR10">Unicode Consortium. <emph>Unicode
                     Technical Standard #10. Unicode Collation Algorithm</emph>. Unicode Technical
                  Report. See <loc href="http://www.unicode.org/reports/tr10/"/>.</bibl>
               <bibl id="UNICODE-TR35" key="UNICODE TR35">Unicode Consortium. <emph>Unicode
                     Technical Standard #35. Unicode Locale Data Markup Language</emph>. Unicode
                  Technical Report. See <loc href="http://www.unicode.org/reports/tr35/"/>.</bibl>
               <bibl id="REC-xml" key="XML 1.0"> World Wide Web Consortium. <emph>Extensible Markup
                     Language (XML) 1.0. W3C Recommendation.</emph> See <loc href="https://www.w3.org/TR/REC-xml">http://www.w3.org/TR/REC-xml/</loc>. The
                  edition of XML 1.0 must be no earlier than the Third Edition; the edition used is
                     <termref def="dt-implementation-defined"/>, but we recommend that
                  implementations use the latest version. </bibl>
               <bibl id="xml11" key="XML 1.1"/>
               <bibl id="xmlbase" key="XML Base"/>
               <bibl id="xml-id" key="xml:id"/>
               <bibl id="xml-names" key="Namespaces in XML"/>
               <bibl id="xml-names11" key="Namespaces in XML 1.1"/>
               <bibl id="xmlschema-1" key="XML Schema Part 1"/>
               <bibl id="xmlschema-2" key="XML Schema Part 2"/>
               <bibl id="xmlschema11-1" key="XML Schema 1.1 Part 1"/>
               <bibl id="xmlschema11-2" key="XML Schema 1.1 Part 2"/>
               <bibl id="xpath-30" key="XPath 3.0"/>
               <bibl id="xpath-31" key="XPath 3.1"/>
               <bibl id="xpath-40" key="XPath 4.0">
                 <emph>CITATION: T.B.D.</emph>
               </bibl>
               <bibl id="XSLT-Mime-Type" key="XSLT Media Type">World Wide Web Consortium.
                     <emph>Registration of MIME Media Type application/xslt+xml</emph>. In <loc href="https://www.w3.org/TR/2007/REC-xslt20-20070123/#media-type-registration">Appendix B.1 of the XSLT 2.0 specification.</loc></bibl>
            </blist>
         </div2>
         <div2 id="other-references">
            <head>Other References</head>
            <blist>
               <bibl id="CLDR" key="Unicode CLDR">CLDR - Unicode Common Locale Data Repository.
                  Available at: <loc href="http://cldr.unicode.org">http://cldr.unicode.org</loc></bibl>

               <bibl id="DOM-Level-2-Core" key="DOM Level 2"/>
               <bibl id="ECMA-404" key="ECMA-404"> ECMA International. <emph>The JSON Data
                     Interchange Format</emph> October 2013. See <loc href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf">http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf</loc>. </bibl>
               <bibl id="ICU" key="ICU">ICU - International Components for Unicode. Available at
                     <loc href="http://site.icu-project.org">http://site.icu-project.org</loc>
               </bibl>
               <bibl id="rfc2119" key="RFC2119">S. Bradner. <emph>Key words for use in RFCs to
                     Indicate Requirement Levels</emph>. IETF RFC 2119. See <loc href="http://www.ietf.org/rfc/rfc2119.txt"/>.</bibl>
               <!--<bibl id="RFC2376" key="RFC2376">E. Whitehead, M. Murata. <emph>XML Media
                     Types</emph>. IETF RFC 2376. See <loc
                     href="http://www.ietf.org/rfc/rfc2376.txt"/>.</bibl>-->

               <bibl id="RFC3986" key="RFC3986"> T. Berners-Lee, R. Fielding, and L. Masinter.
                     <emph>Uniform Resource Identifiers (URI): Generic Syntax</emph>. IETF RFC 3986.
                  See <loc href="http://www.ietf.org/rfc/rfc3986.txt"/>.</bibl>
               <bibl id="RFC3987" key="RFC3987">M. Duerst, M. Suignard. <emph>Internationalized
                     Resource Identifiers (IRIs)</emph>. IETF RFC 3987. See <loc href="http://www.ietf.org/rfc/rfc3987.txt"/>.</bibl>
               
               <bibl id="RFC4647" key="RFC4647">A. Phillips and M. Davis. <emph>Matching of Language Tags</emph>. IETF RFC 4647. See <loc href="http://www.ietf.org/rfc/rfc4647.txt"/>.</bibl>
               

               <bibl id="rfc7303" key="RFC7303">H. Thompson and C. Lilley. <emph>XML Media
                     Types</emph>. IETF RFC 7303. See <loc href="http://www.ietf.org/rfc/rfc7303.txt"/></bibl>

               <bibl id="SemVer" key="SemVer">Tom Preston-Werner, <emph>Semantic Versioning
                     2.0.0</emph>. See <loc href="http://semver.org/"/>. Undated (retrieved 1 August
                  2014).</bibl>
               <bibl id="STX" key="STX">Petr Cimprich <emph>et al</emph>, <emph>Streaming
                     Transformations for XML (STX) Version 1.0</emph>. Working Draft 27 April 2007.
                  See <loc href="http://stx.sourceforge.net/documents/spec-stx-20070427.html"/>
               </bibl>

               <!--<bibl id="xinclude" key="XInclude"/>-->
               <bibl id="xlink" key="XLink"/>
               <bibl id="SCHEMA-AND-XML-1.1" key="XML Schema 1.0 and XML 1.1">World Wide Web
                  Consortium. <emph>Processing XML 1.1 documents with XML Schema 1.0
                     processors</emph>. W3C Working Group Note 11 May 2005. See <loc href="https://www.w3.org/TR/2005/NOTE-xml11schema10-20050511/"/>
               </bibl>
               <bibl id="xml-stylesheet" key="XML Stylesheet"/>
               <bibl id="xptr-framework" key="XPointer Framework"/>
               <bibl id="xsl11" key="XSL-FO"/>
               <bibl id="xslt" key="XSLT 1.0"/>
               <bibl id="xslt20" key="XSLT 2.0"/>
               <bibl id="xslt-30" key="XSLT 3.0"/>
            </blist>
         </div2>
      </div1>
      <div1 id="json-in-xml">
         <head>XML Representation of JSON</head>
         <p>This appendix contains the schema for the XML representation of JSON described in
               <specref ref="json-to-xml-mapping"/>, together with the stylesheets used for
            converting from this XML representation to strings matching the JSON grammar.</p>
         <p>These schema documents and stylesheets are also available as separate resources (links
            are listed at the top of this document).</p>
         <div2 id="schema-for-json">
            <head>Schema for the XML Representation of JSON</head>
            <p>The schema is reproduced below:</p>
            <?doc schema-for-json.xsd?>
         </div2>
         <div2 id="xml-to-json-stylesheet">
            <head>Stylesheet for converting XML to JSON</head>
            <p>This stylesheet contains the implementation of a function very similar to
                  <function>xml-to-json</function>, but implemented in XSLT so that it can be
               customized and extended. This stylesheet is provided for the benefit of users and
               there are no conformance requirements associated with it; there is no requirement
               that processors should make this stylesheet available. The stylesheet is reproduced
               below:</p>
            <?doc xml-to-json.xsl?>
         </div2>
      </div1>
      <inform-div1 id="glossary">
         <head>Glossary</head>
         <?glossary?>
      </inform-div1>
      <inform-div1 id="element-syntax-summary">
         <head>Element Syntax Summary</head>
         <?element-syntax-summary?>
      </inform-div1>
       <inform-div1 id="error-summary">
         <head>Summary of Error Conditions</head>
         <p>This appendix provides a summary of error conditions that a processor
            may signal. This list includes all error codes defined in this specification, but this
            is not an exhaustive list of all errors that can occur. Implementations
               <rfc2119>must</rfc2119> signal errors using these error codes, and applications can
            test for these codes; however, when more than one rule in the specification is violated,
            different processors will not necessarily signal the same error code. Implementations
            are not <rfc2119>required</rfc2119> to signal errors using the descriptive text used
            here.</p>
         <note>
            <p>The appendix is non-normative because the same information is given normatively
               elsewhere.</p>
         </note>
         <?error-summary?>
      </inform-div1>
      <inform-div1 id="implementation-defined-features">
         <head>Checklist of Implementation-Defined Features</head>
         <p>This appendix provides a summary of XSLT language features whose effect is explicitly
               <termref def="dt-implementation-defined"/>. The conformance rules (see <specref ref="conformance"/>) require vendors to provide documentation that explains how these
            choices have been exercised.</p>

         <p>The implementation-defined features are grouped into categories for convenience.</p>

         <div2 id="imp-def-api">
            <head>Application Programming Interfaces</head>

            <p>This category covers interfaces for initiating a transformation, setting its
               parameters, initializing the static and dynamic context, and collecting the results.
               In general terms, it is implementation defined how input is passed to the processor
               and how it returns its output. This includes the interpretation of URIs used to refer
               to stylesheet packages and modules, source documents and collections, collations, and
               result documents.</p>

            <p>More specifically:</p>

            <?implementation-defined-features api?>
         </div2>

         <div2 id="imp-def-ext">
            <head>Vendor and User Extensions</head>

            <p>This category covers extensions and extensibility: mechanisms for providing vendor or
               user extensions to the language without sacrificing interoperability.</p>

            <p>In general terms, it is implementation-defined:</p>

            <ulist>
               <item>
                  <p>whether and under what circumstances the implementation recognizes any
                     extension functions, extension instructions, extension attributes, user-defined
                     data elements, additional types, additional serialization methods or
                     serialization parameters, or additional collations, and if so, what effect they
                     have. </p>
               </item>
               <item>
                  <p>whether, how, and under what circumstances the implementation allows users to
                     define extension functions, extension instructions, extension attributes,
                     user-defined data elements, additional types, additional serialization methods
                     or serialization parameters, or additional collations. If it does allow users
                     to do so, it must follow the rules given elsewhere in this specification. </p>
               </item>
               <item>
                  <p>what information is available to such extensions (for example, whether they
                     have access to the static and dynamic context.) </p>
               </item>
               <item>
                  <p>where such extensions are allowed, the extent to which the processor enforces
                     their correct behavior (for example, checking that strings returned by
                     extension functions contain only valid XML characters) </p>
               </item>
            </ulist>

            <p>More specifically:</p>

            <?implementation-defined-features ext?>
         </div2>

         <div2 id="imp-def-feature">
            <head>Localization</head>
            <p>This specification, and the specifications that it refers to, include facilities for
               adapting the output of a transformation to meet local expectations: examples include
               the formatting of numbers and dates, and the choice of collations for sorted output.
               The general principles are:</p>

            <ulist>
               <item>
                  <p>The specification does not mandate any particular localizations that processors
                     must offer: for example, a conformant processor might choose to provide output
                     in Japanese only.</p>
               </item>
               <item>
                  <p>The specification provides fallback mechanisms so that if a particular
                     localization is requested and is not available, processing does not fail.</p>
               </item>
            </ulist>

            <p>More specifically:</p>

            <?implementation-defined-features local?>
         </div2>

         <div2 id="imp-def-optional-feature">
            <head>Optional Features</head>
            <p>As well as the optional conformance features identified in <specref ref="conformance"/>, some specific features of the specification are defined to be optional.</p>

            <?implementation-defined-features feature?>
         </div2>

         <div2 id="imp-def-dependencies">
            <head>Dependencies</head>
            <p>When this specification refers normatively to other specifications, it generally
               gives implementations freedom to decide (within constraints) which version of the
               referenced specification should be used. Specifically:</p>

            <?implementation-defined-features spec?>
         </div2>

         <div2 id="imp-def-defaults-and-limits">
            <head>Defaults and Limits</head>
            <p>To accommodate variations in the way that the XSLT language is deployed, and the
               constraints of different processing environments, defaults for some options are
               implementation-defined. In addition, limits on the sizes of ranges of values
               permitted are in general implementation-defined:</p>

            <?implementation-defined-features defaults?>
         </div2>
         <div2 id="imp-def-errors">
            <head>Detection and Reporting of Errors</head>
            <p>Some aspects of error handling are implementation-defined:</p>

            <?implementation-defined-features err?>
         </div2>


      </inform-div1>
      <inform-div1 id="summary-list-of-functions">
         <head>Summary of Available Functions</head>
         <div2 id="function-categories">
            <head>Function Classification</head>
            <p>The functions available for use within an XSLT stylesheet can be classified based firstly,
            on where the function is defined, and secondly, on where it can be used. Specifically, the set
            of functions available is slightly different for :</p>
            <ulist>
               <item><p>Regular XPath expressions within the stylesheet, for example those appearing in
                  <code>select</code> or <code>test</code> attributes, or between braces in a <termref def="dt-text-value-template"/> (<var>R</var>)</p></item>
               <item><p><termref def="dt-static-expression">Static expressions</termref> (<var>S</var>)</p></item>
               <item><p>XPath expressions evaluated dynamically using <elcode>xsl:evaluate</elcode> (<var>D</var>)</p></item>
            </ulist>
            
            <p>The categories are listed in the following table:</p>

            <table class="data">
               <caption>Categories of Function, and their Availability</caption>
               <thead>
                  <tr>
                     <th rowspan="1" colspan="1">Category</th>
                     <th rowspan="1" colspan="1">Defined where?</th>
                     <th rowspan="1" colspan="1">Available where?</th>
                     <th rowspan="1" colspan="1">Notes</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td rowspan="1" colspan="1">User-defined functions</td>
                     <td rowspan="1" colspan="1">Defined using <elcode>xsl:function</elcode> declarations in the stylesheet</td>
                     <td rowspan="1" colspan="1"><var>R</var>, <var>D</var></td>
                     <td rowspan="1" colspan="1">Functions are private by default; private functions can be referenced only
                     within the package where they are declared (and not in <elcode>xsl:evaluate</elcode>
                     expressions).</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Constructor functions for built-in types</td>
                     <td rowspan="1" colspan="1"><xspecref spec="FO40" ref="constructor-functions"/></td>
                     <td rowspan="1" colspan="1"><var>R</var>, <var>S</var>, <var>D</var></td>
                     <td rowspan="1" colspan="1">These functions are all in the namespace conventionally associated with the
                     prefix <code>xs</code>. The semantics of a constructor function are identical
                     to the semantics of a <code>cast</code> expression.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Constructor functions for user-defined types</td>
                     <td rowspan="1" colspan="1"><xspecref spec="FO40" ref="constructor-functions"/></td>
                     <td rowspan="1" colspan="1"><var>R</var>, <var>D</var> (if <code>schema-aware="yes"</code>)</td>
                     <td rowspan="1" colspan="1">This category includes a function for every named user-defined simple
                     type in an imported schema; the function allows the conversion of strings
                     and certain other values to instances of the user-defined type.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Functions defined in XPath 4.0</td>
                     <td rowspan="1" colspan="1" diff="add" at="2023-04-18"><bibref ref="xpath-functions-40"/></td>
                     <td rowspan="1" colspan="1"><var>R</var>, <var>S</var>, <var>D</var></td>
                     <td rowspan="1" colspan="1">Includes functions in the namespaces conventionally
                     referred to be the prefixes <code>fn</code> and <code>math</code>.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Functions defined in XSLT 4.0</td>
                     <td rowspan="1" colspan="1">This specification</td>
                     <td rowspan="1" colspan="1"><var>R</var>, <var>S</var> (see note), <var>D</var></td>
                     <td rowspan="1" colspan="1">See <specref ref="XSLT-defined-functions"/>. There is an overlap with
                     the set of functions defined in XPath 4.0. The functions available in static expressions are:
                     <function>element-available</function>, <function>function-available</function>,
                     <function>type-available</function>, <function>available-system-properties</function>,
                     and <function>system-property</function>.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Extension functions</td>
                     <td rowspan="1" colspan="1">Implementation-defined: see <specref ref="extension-functions"/>.</td>
                     <td rowspan="1" colspan="1"><var>R</var>, <var>S</var>, <var>D</var></td>
                     <td rowspan="1" colspan="1">Availability is <termref def="dt-implementation-defined"/></td>
                  </tr>
               </tbody>
            </table>
            
            

         </div2>
      <div2 id="XSLT-defined-functions">
         <head>List of XSLT-defined functions</head>
         <p>This appendix acts as an index of functions defined in this specification, to augment
            the set of functions defined in <bibref ref="xpath-functions-40"/>.</p>
         <?xslt-defined-functions?>
      </div2>
      </inform-div1>
      <inform-div1 id="schema-for-xslt">
         <head>Schemas for XSLT 4.0 Stylesheets</head>
         
         <p diff="add" at="2022-01-01">TODO: the two schemas need to be updated for XSLT 4.0</p>
         
         <p>For convenience, schemas are provided for validation of XSLT 3.0 stylesheets
         using the XSD 1.1 and Relax NG schema languages. These are non-normative. Neither will detect
         every static error that might arise in an XSLT 4.0 stylesheet (for example, there is no attempt
         to check the syntax of XPath expressions); in addition, these schemas may reject some stylesheets
         that are valid, for example because they rely on <code>xsl:use-when</code> to eliminate sections of code
         that would otherwise be invalid.</p>
         <div2 id="xsd11-schema-for-xslt">
            <head>XSD 1.1 Schema for XSLT Stylesheets</head>

         <p>The following XSD 1.1 schema describes the structure of an XSLT stylesheet module. It
            does not define all the constraints that apply to a stylesheet (for example, it does not
            attempt to define a datatype that precisely represents attributes containing XPath
               <termref def="dt-expression">expressions</termref>). However, every valid stylesheet
            module conforms to this schema, unless it contains elements that invoke <termref def="dt-forwards-compatible-behavior"/>.</p>
         <p>A copy of this schema is available at <phrase diff="chg" at="2023-04-18"><loc href="schema-for-xslt40.xsd">schema-for-xslt40.xsd</loc></phrase>
         </p>

         <note>
            <p>The schema as written uses a lax wildcard to permit literal result elements to appear
               in a sequence constructor. This assumes that the schema used for validation will not
               contain any global element declaration that matches the element name of a literal
               result element. The content model for an element such as <code>invoice</code>
               appearing within a stylesheet is not the same as the content model for the same
               element appearing within a source document (it is likely to contain XSLT instructions
               rather than other elements from the target vocabulary): therefore, including such
               declarations in the schema used for validating a stylesheet is inappropriate.</p>
            <p>The reason that lax validation rather than skip validation is used is so that XSLT
               instructions appearing as children of the literal result element will themselves be
               validated, using the appropriate global element declaration.</p>
         </note>

         <note>
            <p>The schema uses XSD 1.1 assertions to represent some of the non-grammatical
               constraints appearing in the specification, for example the rule that some elements
               can have either a <code>select</code> attribute or a contained sequence constructor,
               but not both. At this stage, no attempt has been made to represent every such
               constraint, even where it is not difficult to express the rule. There will always be
               some constraints that cannot be expressed at all, for example those that require
               access to multiple stylesheet modules, those that require access to the in-scope
               schema components, and those that involve parsing a non-regular grammar, such as the
               grammar for patterns.</p>
            <p>Apart from assertions, the only other significant use of XSD 1.1 features is that the
               elements <elcode>xsl:param</elcode> and <elcode>xsl:variable</elcode> are in two
               substitution groups: one containing all instructions, and one containing all
               declarations. If the schema needs to be converted to an XSD 1.0 schema, removing all
               assertions is straightforward; the other change needed is to remove
                  <elcode>xsl:param</elcode> and <elcode>xsl:variable</elcode> from the substitution
               group for declarations, and instead permit them explicitly as children of
                  <elcode>xsl:transform</elcode>.</p>
         </note>
         <?schema-for-xslt?>
         </div2>
         <div2 id="relax-ng-schema-for-xslt">
            <head>Relax-NG Schema for XSLT Stylesheets</head>
            <p>The following Relax-NG schema may be used to validate XSLT 4.0 stylesheet modules. Similar
            caveats apply as for the XSD 1.1 version.</p>
            <p>A copy of this schema is available at <loc href="schema-for-xslt30.rnc">schema-for-xslt30.rnc</loc>
            </p>
            <p diff="add" at="2023-04-18">TODO: Needs updating for 4.0.</p>
            <?rng-schema-for-xslt?>
         </div2>
      </inform-div1>


      <!--<inform-div1 id="acknowledgements">
         <head>Acknowledgements</head>
         <p>This specification was developed and approved for publication by the W3C XSLT Working
            Group (WG).</p>
         <p>The chair of the XSLT WG is Sharon Adler. The active membership of the XSLT WG during the
            final stages of the preparation of this specification included:</p>

         <slist>
            <sitem>Sharon Adler (Chair)</sitem>
            <sitem>Anders Berglund</sitem>
            <sitem>Carine Bournez (W3C team)</sitem>
            <sitem>Abel Braaksma</sitem>
            <sitem>Charles Foster</sitem>
            <sitem>Florent Georges</sitem>
            <sitem>Michael Kay (Editor)</sitem>
            <sitem>Jirka Kosek</sitem>
            <sitem>Luis Ibhiabor</sitem>
            <sitem>Michael Sperberg-McQueen</sitem>
            <sitem>Norm Walsh</sitem>
            <sitem>Mohamed Zergaoui</sitem>
         </slist>

         <p>The Working Group wishes to acknowledge the contribution of those who have participated
            in the work at earlier stages, as well as the pioneering work of the developers of STX
            (see <bibref ref="STX"/>) which formed an important intellectual input to the design
            of XSLT 3.0 and demonstrated the feasibility of creating a streaming transformation
            language based on the core XSLT concept of recursive descent of the source tree using
            rule-based templates.</p>
         
         <p>The Working Group also wishes to thank external reviewers who have provided feedback
         during the development of the specification.</p>

      </inform-div1>-->

      <inform-div1 id="changes-since-3.0" diff="add" at="2022-01-01">
         <head>Changes since XSLT 3.0</head>
         <div2 id="xslt-changes-since-3.0">
            <head>Changes in successive Drafts</head>
            <p>The following sections list changes in successive drafts of this specification.</p>
            <div3 id="changes-in-draft-A">
            <head>Changes in this Specification: draft A (12 April 2021)</head>
            <olist>
               <item><p>Errata agreed against XSLT 3.0 have been applied.</p></item>
               <item><p>Support for XPath 4.0 and Functions and Operators 4.0 is required. This notably
               means that support for XDM arrays is now required.</p></item>
               <item><p>The <elcode>xsl:if</elcode> instruction acquires attributes <code>then</code> and <code>else</code>.</p></item>
               <item><p>The <elcode>xsl:when</elcode> and <elcode>xsl:otherwise</elcode> elements can be evaluated using a
               <code>select</code> expression rather than a contained sequence constructor.</p></item>
               <item><p>A new <elcode>xsl:switch</elcode> instruction is introduced.</p></item>
               <item><p>The <elcode>xsl:item-type</elcode> declaration allows names to be given to item types,
               which can then be referenced by name. This is particularly useful with record types, introduced
               in XPath 4.0.</p></item>
               <item><p>A new <elcode>xsl:function-library</elcode> declaration is introduced, allowing
               functions from multiple different namespaces to be called without using a namespace prefix.</p></item>
               <item><p>The default namespace for element names and the default namespace for types can now be
               different, allowing built-in types to be referenced in unprefixed form (<code>as="integer"</code>).</p></item>
               <item><p>The new instruction <elcode>xsl:array</elcode> allows
               the construction of arrays.</p></item>
               
               
               <item><p>New pattern syntax ( <code>type(T)</code>, <code>record(N, M, N)</code>) 
                  allows matching of items by item type.</p></item>
               <!--<item><p>A new attribute <code>xsl:template/@test</code> allows tunnel parameters to be taken
               into account when deciding which template rules to apply.</p></item>-->
               <item><p>The <elcode>xsl:mode</elcode> declaration acquires an attribute <code>as="sequence-type"</code> which
               declares the return type of all template rules in that mode.</p></item>
               <item><p>The <elcode>xsl:for-each</elcode> and <elcode>xsl:apply-templates</elcode> instructions
               acquire a <code>separator</code> attribute to allow separators to be inserted into the output.</p></item>
               <item><p>The <elcode>xsl:map</elcode> instruction acquires a new attribute <code>on-duplicates</code>.</p></item>
               <item><p>The <elcode>xsl:function</elcode> declaration allows parameters to be declared as optional,
                  so a single <elcode>xsl:function</elcode> declaration can declare functions with multiple arities.</p></item>
               <item><p>Enclosing modes: The <elcode>xsl:mode</elcode> declaration allows contained
                  <elcode>xsl:template</elcode> declarations.</p></item>
               <item><p>Functions that accept a lexical QName as an argument, such as <xfunction>key</xfunction>,
                  <xfunction>function-available</xfunction>, <xfunction>element-available</xfunction>,
                  <xfunction>type-available</xfunction>, <xfunction>system-property</xfunction>,
                  <xfunction>accumulator-before</xfunction>, and <xfunction>accumulator-after</xfunction>,
               now have the option of supplying an <code>xs:QName</code> value instead.</p></item>
               <item><p>A serialization parameter <code>escape-solidus</code> has been added, for use
               in JSON serialization.</p></item>
            </olist>
            </div3>
            <div3 id="changes-in-draft-B">
               <head>Changes in this Specification: draft B (date TBA)</head>
               <olist>
                  <item><p>The proposed <code>array</code> and <code>map</code> attributes of
                     <elcode>xsl:for-each</elcode>, <elcode>xsl:iterate</elcode>, and <elcode>xsl:for-each-group</elcode>
                     have been dropped. Instead, to iterate over the contents of an array or map, use functions
                  such as <code>array:members</code> and <code>map:key-value-pairs</code>.</p></item>
                  <item><p>The descriptions of basic data types for attributes now avoid using the term
                  <emph>lexical space</emph>, since in XSD the lexical space contains values after whitespace
                  normalization whereas these descriptions relate to the values as written.</p></item>
                  <item><p>The rules for <termref def="dt-enclosing-mode">enclosing modes</termref> are corrected:
                  the restriction on referring to the enclosing mode from outside applies to the package, not
                  just to the stylesheet module. In addition, an <elcode>xsl:apply-templates</elcode> instruction
                  within an enclosing mode defaults its <code>mode</code> attribute to the enclosing mode.</p></item>
                  <item><p>Support for higher-order functions is now mandatory (in XSLT 3.0 it was an optional feature).</p></item>
                  <item><p>An <elcode>xsl:note</elcode> element is defined to enable structured documentation. It
                  may appear anywhere.</p></item>
                  <item><p>A new attribute, <code>main-module</code>, is defined on <elcode>xsl:stylesheet</elcode>
                  and <elcode>xsl:transform</elcode>, enabling an XSLT editing tool to identify the top-level module
                  of a stylesheet, and hence the declarations of functions, templates, and global variables available
                  to a module that is being edited.</p></item>
                  <item><p>The <elcode>xsl:matching-substring</elcode> and <elcode>xsl:non-matching-substring</elcode>
                  elements within <elcode>xsl:analyze-string</elcode> may take a <code>select</code> attribute
                  in place of a contained sequence constructor.</p></item>
               </olist>
            </div3>
         </div2>
         <div2 id="xpath-changes-since-3.1">
            <head>Changes in Other Related Specifications</head>

            <p>A number of changes affecting XSLT 4.0 have been made in other related
               specifications. Some of the more significant changes are as follows:</p>
            <olist>
               <item>
                  <p>A number of new kinds of ItemType are introduced, for example union types,
                  record types, and enumeration types.</p>
               </item>

               <item>
                  <p>The coercion rules (previously “function conversion rules”) allow atomic values
                  of primitive types to be supplied where a restricted type is required: for example
                  if the required type is <code>xs:positiveInteger</code>, it is now acceptable to supply the
                  value <code>42</code>.</p>
               </item>
               
               <item>
                  <p>XPath 4.0 introduces abbreviated syntax for <phrase diff="del" at="2023-01-17">conditional expressions
                  (<code>condition ?? action1 !! action2</code>) and for</phrase> inline functions
                  (for example <code>-> ($x, $y) {$x + $y}</code>).</p>
               </item>

 

               
            </olist>
         </div2>
      </inform-div1>
   
      <inform-div1 id="todo-list" diff="add" at="2022-01-01">
         <head>Changes Pending</head>
         <p>Further work is needed in the following areas:</p>
            <olist>
               <item><p>Streamability implications of new constructs</p></item>
               <item><p>Details of error codes</p></item>
               <item><p>Default priorites for new kinds of pattern</p></item>
               <item><p>Add built-in template rules suitable for JSON processing</p></item>
               <item><p>Default namespace for elements: allow matching on local-name only,
               or on “XHTML or nothing”.</p></item>
               <item><p>Completing the XSD and RNG schemas for stylesheet modules.</p></item>
            </olist>
      </inform-div1>

      <inform-div1 id="incompatibilities" diff="add" at="2022-01-01">
         <head>Incompatibilities with XSLT 3.0</head>
         <p>This section lists all known incompatibilities with XSLT 3.0, that is, situations
               where a stylesheet that is error-free
            according to the XSLT 3.0 specification and where all elements have an effective version
            of <code>3.0</code> or less, will produce different results depending on whether it is
            run under an XSLT 3.0 processor or an XSLT 4.0 processor.</p>
         <olist>
            <item>
               <p>The rules for comparing values in <elcode>xsl:for-each-group</elcode> now reference
               the rules for <function>distinct-values</function>, which have themselves changed
               <phrase diff="chg" at="2023-01-25">to be compatible with <function>fn:atomic-equal</function></phrase>. This change eliminates the intransitivity
               in the previous specification, which meant that in edge cases involving rounding of numeric values
               of different types, two items in different groups could compare equal. Any change in behavior
               is confined to this edge case.</p>
            </item>

            
         </olist>
         
         <p>This specification also corrects a number of errors and omissions in XSLT 3.0, in a way that
         might create incompatibilities for some processors, depending on how they interpreted the XSLT 3.0
         specification:</p>
         <olist>
            <item><p>XSLT 3.0 (and earlier releases) did not fully define the evaluation context for the
            default values of template parameters. For example, if the default value of a parameter of a 
            template rule invoked <elcode>xsl:next-match</elcode>, it was not specified whether the
            current template rule should be the calling template or the called template. This omission has
            been corrected.</p></item>
         </olist>


      </inform-div1>
   </back>
</spec>
